/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/next";
exports.ids = ["vendor-chunks/next"];
exports.modules = {

/***/ "(rsc)/./node_modules/next/dist/api/server.js":
/*!**********************************************!*\
  !*** ./node_modules/next/dist/api/server.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _server_web_exports_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../server/web/exports/index */ \"(rsc)/./node_modules/next/dist/server/web/exports/index.js\");\n/* harmony import */ var _server_web_exports_index__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_server_web_exports_index__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _server_web_exports_index__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _server_web_exports_index__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=server.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRDOztBQUU1QyIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGFwaVxcc2VydmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4uL3NlcnZlci93ZWIvZXhwb3J0cy9pbmRleCc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/api/server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/client/components/hooks-server-context.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/hooks-server-context.js ***!
  \**************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DynamicServerError: function() {\n        return DynamicServerError;\n    },\n    isDynamicServerError: function() {\n        return isDynamicServerError;\n    }\n});\nconst DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';\nclass DynamicServerError extends Error {\n    constructor(description){\n        super(\"Dynamic server usage: \" + description), this.description = description, this.digest = DYNAMIC_ERROR_CODE;\n    }\n}\nfunction isDynamicServerError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err) || typeof err.digest !== 'string') {\n        return false;\n    }\n    return err.digest === DYNAMIC_ERROR_CODE;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hooks-server-context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2hvb2tzLXNlcnZlci1jb250ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQUVhQSxrQkFBa0I7ZUFBbEJBOztJQVFHQyxvQkFBb0I7ZUFBcEJBOzs7QUFWaEIsTUFBTUMscUJBQXFCO0FBRXBCLE1BQU1GLDJCQUEyQkc7SUFHdENDLFlBQTRCQyxXQUFtQixDQUFFO1FBQy9DLEtBQUssQ0FBRSwyQkFBd0JBLGNBQUFBLElBQUFBLENBRExBLFdBQUFBLEdBQUFBLGFBQUFBLElBQUFBLENBRjVCQyxNQUFBQSxHQUFvQ0o7SUFJcEM7QUFDRjtBQUVPLFNBQVNELHFCQUFxQk0sR0FBWTtJQUMvQyxJQUNFLE9BQU9BLFFBQVEsWUFDZkEsUUFBUSxRQUNSLENBQUUsYUFBWUEsR0FBQUEsQ0FBRSxJQUNoQixPQUFPQSxJQUFJRCxNQUFNLEtBQUssVUFDdEI7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxPQUFPQyxJQUFJRCxNQUFNLEtBQUtKO0FBQ3hCIiwic291cmNlcyI6WyJFOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXGhvb2tzLXNlcnZlci1jb250ZXh0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IERZTkFNSUNfRVJST1JfQ09ERSA9ICdEWU5BTUlDX1NFUlZFUl9VU0FHRSdcblxuZXhwb3J0IGNsYXNzIER5bmFtaWNTZXJ2ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgZGlnZXN0OiB0eXBlb2YgRFlOQU1JQ19FUlJPUl9DT0RFID0gRFlOQU1JQ19FUlJPUl9DT0RFXG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcbiAgICBzdXBlcihgRHluYW1pYyBzZXJ2ZXIgdXNhZ2U6ICR7ZGVzY3JpcHRpb259YClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljU2VydmVyRXJyb3IoZXJyOiB1bmtub3duKTogZXJyIGlzIER5bmFtaWNTZXJ2ZXJFcnJvciB7XG4gIGlmIChcbiAgICB0eXBlb2YgZXJyICE9PSAnb2JqZWN0JyB8fFxuICAgIGVyciA9PT0gbnVsbCB8fFxuICAgICEoJ2RpZ2VzdCcgaW4gZXJyKSB8fFxuICAgIHR5cGVvZiBlcnIuZGlnZXN0ICE9PSAnc3RyaW5nJ1xuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBlcnIuZGlnZXN0ID09PSBEWU5BTUlDX0VSUk9SX0NPREVcbn1cbiJdLCJuYW1lcyI6WyJEeW5hbWljU2VydmVyRXJyb3IiLCJpc0R5bmFtaWNTZXJ2ZXJFcnJvciIsIkRZTkFNSUNfRVJST1JfQ09ERSIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJkZXNjcmlwdGlvbiIsImRpZ2VzdCIsImVyciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/client/components/hooks-server-context.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/client/components/static-generation-bailout.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/static-generation-bailout.js ***!
  \*******************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    StaticGenBailoutError: function() {\n        return StaticGenBailoutError;\n    },\n    isStaticGenBailoutError: function() {\n        return isStaticGenBailoutError;\n    }\n});\nconst NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';\nclass StaticGenBailoutError extends Error {\n    constructor(...args){\n        super(...args), this.code = NEXT_STATIC_GEN_BAILOUT;\n    }\n}\nfunction isStaticGenBailoutError(error) {\n    if (typeof error !== 'object' || error === null || !('code' in error)) {\n        return false;\n    }\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-bailout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBRWFBLHFCQUFxQjtlQUFyQkE7O0lBSUdDLHVCQUF1QjtlQUF2QkE7OztBQU5oQixNQUFNQywwQkFBMEI7QUFFekIsTUFBTUYsOEJBQThCRzs7UUFBcEMscUJBQ1dDLElBQUFBLEdBQU9GOztBQUN6QjtBQUVPLFNBQVNELHdCQUNkSSxLQUFjO0lBRWQsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSxDQUFFLFdBQVVBLEtBQUFBLENBQUksRUFBSTtRQUNyRSxPQUFPO0lBQ1Q7SUFFQSxPQUFPQSxNQUFNRCxJQUFJLEtBQUtGO0FBQ3hCIiwic291cmNlcyI6WyJFOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHN0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVQgPSAnTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVQnXG5cbmV4cG9ydCBjbGFzcyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBjb2RlID0gTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RhdGljR2VuQmFpbG91dEVycm9yKFxuICBlcnJvcjogdW5rbm93blxuKTogZXJyb3IgaXMgU3RhdGljR2VuQmFpbG91dEVycm9yIHtcbiAgaWYgKHR5cGVvZiBlcnJvciAhPT0gJ29iamVjdCcgfHwgZXJyb3IgPT09IG51bGwgfHwgISgnY29kZScgaW4gZXJyb3IpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZXJyb3IuY29kZSA9PT0gTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVRcbn1cbiJdLCJuYW1lcyI6WyJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJpc1N0YXRpY0dlbkJhaWxvdXRFcnJvciIsIk5FWFRfU1RBVElDX0dFTl9CQUlMT1VUIiwiRXJyb3IiLCJjb2RlIiwiZXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/client/components/static-generation-bailout.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/@edge-runtime/cookies/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/@edge-runtime/cookies/index.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  RequestCookies: () => RequestCookies,\n  ResponseCookies: () => ResponseCookies,\n  parseCookie: () => parseCookie,\n  parseSetCookie: () => parseSetCookie,\n  stringifyCookie: () => stringifyCookie\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/serialize.ts\nfunction stringifyCookie(c) {\n  var _a;\n  const attrs = [\n    \"path\" in c && c.path && `Path=${c.path}`,\n    \"expires\" in c && (c.expires || c.expires === 0) && `Expires=${(typeof c.expires === \"number\" ? new Date(c.expires) : c.expires).toUTCString()}`,\n    \"maxAge\" in c && typeof c.maxAge === \"number\" && `Max-Age=${c.maxAge}`,\n    \"domain\" in c && c.domain && `Domain=${c.domain}`,\n    \"secure\" in c && c.secure && \"Secure\",\n    \"httpOnly\" in c && c.httpOnly && \"HttpOnly\",\n    \"sameSite\" in c && c.sameSite && `SameSite=${c.sameSite}`,\n    \"partitioned\" in c && c.partitioned && \"Partitioned\",\n    \"priority\" in c && c.priority && `Priority=${c.priority}`\n  ].filter(Boolean);\n  const stringified = `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : \"\")}`;\n  return attrs.length === 0 ? stringified : `${stringified}; ${attrs.join(\"; \")}`;\n}\nfunction parseCookie(cookie) {\n  const map = /* @__PURE__ */ new Map();\n  for (const pair of cookie.split(/; */)) {\n    if (!pair)\n      continue;\n    const splitAt = pair.indexOf(\"=\");\n    if (splitAt === -1) {\n      map.set(pair, \"true\");\n      continue;\n    }\n    const [key, value] = [pair.slice(0, splitAt), pair.slice(splitAt + 1)];\n    try {\n      map.set(key, decodeURIComponent(value != null ? value : \"true\"));\n    } catch {\n    }\n  }\n  return map;\n}\nfunction parseSetCookie(setCookie) {\n  if (!setCookie) {\n    return void 0;\n  }\n  const [[name, value], ...attributes] = parseCookie(setCookie);\n  const {\n    domain,\n    expires,\n    httponly,\n    maxage,\n    path,\n    samesite,\n    secure,\n    partitioned,\n    priority\n  } = Object.fromEntries(\n    attributes.map(([key, value2]) => [\n      key.toLowerCase().replace(/-/g, \"\"),\n      value2\n    ])\n  );\n  const cookie = {\n    name,\n    value: decodeURIComponent(value),\n    domain,\n    ...expires && { expires: new Date(expires) },\n    ...httponly && { httpOnly: true },\n    ...typeof maxage === \"string\" && { maxAge: Number(maxage) },\n    path,\n    ...samesite && { sameSite: parseSameSite(samesite) },\n    ...secure && { secure: true },\n    ...priority && { priority: parsePriority(priority) },\n    ...partitioned && { partitioned: true }\n  };\n  return compact(cookie);\n}\nfunction compact(t) {\n  const newT = {};\n  for (const key in t) {\n    if (t[key]) {\n      newT[key] = t[key];\n    }\n  }\n  return newT;\n}\nvar SAME_SITE = [\"strict\", \"lax\", \"none\"];\nfunction parseSameSite(string) {\n  string = string.toLowerCase();\n  return SAME_SITE.includes(string) ? string : void 0;\n}\nvar PRIORITY = [\"low\", \"medium\", \"high\"];\nfunction parsePriority(string) {\n  string = string.toLowerCase();\n  return PRIORITY.includes(string) ? string : void 0;\n}\nfunction splitCookiesString(cookiesString) {\n  if (!cookiesString)\n    return [];\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        lastComma = pos;\n        pos += 1;\n        skipWhitespace();\n        nextStart = pos;\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          cookiesSeparatorFound = true;\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n  return cookiesStrings;\n}\n\n// src/request-cookies.ts\nvar RequestCookies = class {\n  constructor(requestHeaders) {\n    /** @internal */\n    this._parsed = /* @__PURE__ */ new Map();\n    this._headers = requestHeaders;\n    const header = requestHeaders.get(\"cookie\");\n    if (header) {\n      const parsed = parseCookie(header);\n      for (const [name, value] of parsed) {\n        this._parsed.set(name, { name, value });\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this._parsed[Symbol.iterator]();\n  }\n  /**\n   * The amount of cookies received from the client\n   */\n  get size() {\n    return this._parsed.size;\n  }\n  get(...args) {\n    const name = typeof args[0] === \"string\" ? args[0] : args[0].name;\n    return this._parsed.get(name);\n  }\n  getAll(...args) {\n    var _a;\n    const all = Array.from(this._parsed);\n    if (!args.length) {\n      return all.map(([_, value]) => value);\n    }\n    const name = typeof args[0] === \"string\" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;\n    return all.filter(([n]) => n === name).map(([_, value]) => value);\n  }\n  has(name) {\n    return this._parsed.has(name);\n  }\n  set(...args) {\n    const [name, value] = args.length === 1 ? [args[0].name, args[0].value] : args;\n    const map = this._parsed;\n    map.set(name, { name, value });\n    this._headers.set(\n      \"cookie\",\n      Array.from(map).map(([_, value2]) => stringifyCookie(value2)).join(\"; \")\n    );\n    return this;\n  }\n  /**\n   * Delete the cookies matching the passed name or names in the request.\n   */\n  delete(names) {\n    const map = this._parsed;\n    const result = !Array.isArray(names) ? map.delete(names) : names.map((name) => map.delete(name));\n    this._headers.set(\n      \"cookie\",\n      Array.from(map).map(([_, value]) => stringifyCookie(value)).join(\"; \")\n    );\n    return result;\n  }\n  /**\n   * Delete all the cookies in the cookies in the request.\n   */\n  clear() {\n    this.delete(Array.from(this._parsed.keys()));\n    return this;\n  }\n  /**\n   * Format the cookies in the request as a string for logging\n   */\n  [Symbol.for(\"edge-runtime.inspect.custom\")]() {\n    return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;\n  }\n  toString() {\n    return [...this._parsed.values()].map((v) => `${v.name}=${encodeURIComponent(v.value)}`).join(\"; \");\n  }\n};\n\n// src/response-cookies.ts\nvar ResponseCookies = class {\n  constructor(responseHeaders) {\n    /** @internal */\n    this._parsed = /* @__PURE__ */ new Map();\n    var _a, _b, _c;\n    this._headers = responseHeaders;\n    const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? void 0 : _a.call(responseHeaders)) != null ? _b : responseHeaders.get(\"set-cookie\")) != null ? _c : [];\n    const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);\n    for (const cookieString of cookieStrings) {\n      const parsed = parseSetCookie(cookieString);\n      if (parsed)\n        this._parsed.set(parsed.name, parsed);\n    }\n  }\n  /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without the Promise.\n   */\n  get(...args) {\n    const key = typeof args[0] === \"string\" ? args[0] : args[0].name;\n    return this._parsed.get(key);\n  }\n  /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll} without the Promise.\n   */\n  getAll(...args) {\n    var _a;\n    const all = Array.from(this._parsed.values());\n    if (!args.length) {\n      return all;\n    }\n    const key = typeof args[0] === \"string\" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;\n    return all.filter((c) => c.name === key);\n  }\n  has(name) {\n    return this._parsed.has(name);\n  }\n  /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without the Promise.\n   */\n  set(...args) {\n    const [name, value, cookie] = args.length === 1 ? [args[0].name, args[0].value, args[0]] : args;\n    const map = this._parsed;\n    map.set(name, normalizeCookie({ name, value, ...cookie }));\n    replace(map, this._headers);\n    return this;\n  }\n  /**\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete} without the Promise.\n   */\n  delete(...args) {\n    const [name, options] = typeof args[0] === \"string\" ? [args[0]] : [args[0].name, args[0]];\n    return this.set({ ...options, name, value: \"\", expires: /* @__PURE__ */ new Date(0) });\n  }\n  [Symbol.for(\"edge-runtime.inspect.custom\")]() {\n    return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;\n  }\n  toString() {\n    return [...this._parsed.values()].map(stringifyCookie).join(\"; \");\n  }\n};\nfunction replace(bag, headers) {\n  headers.delete(\"set-cookie\");\n  for (const [, value] of bag) {\n    const serialized = stringifyCookie(value);\n    headers.append(\"set-cookie\", serialized);\n  }\n}\nfunction normalizeCookie(cookie = { name: \"\", value: \"\" }) {\n  if (typeof cookie.expires === \"number\") {\n    cookie.expires = new Date(cookie.expires);\n  }\n  if (cookie.maxAge) {\n    cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);\n  }\n  if (cookie.path === null || cookie.path === void 0) {\n    cookie.path = \"/\";\n  }\n  return cookie;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL0BlZGdlLXJ1bnRpbWUvY29va2llcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUMsbUVBQW1FLGdGQUFnRjtBQUNuSixnRUFBZ0UsU0FBUztBQUN6RSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBLHlCQUF5QixPQUFPLEdBQUcscURBQXFEO0FBQ3hGLCtDQUErQyxjQUFjLEVBQUUsY0FBYyxHQUFHO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hELHFCQUFxQixnQkFBZ0I7QUFDckMsdUNBQXVDLHdCQUF3QjtBQUMvRDtBQUNBLHFCQUFxQixtQ0FBbUM7QUFDeEQsbUJBQW1CLGNBQWM7QUFDakMscUJBQXFCLG1DQUFtQztBQUN4RCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlEQUFpRDtBQUM5RTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU8sR0FBRyw0QkFBNEIsV0FBVztBQUNyRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0RUFBNEU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRkFBa0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNEVBQTRFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdCQUF3QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0ZBQWtGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtRUFBbUU7QUFDekY7QUFDQTtBQUNBLDhCQUE4QixpREFBaUQ7QUFDL0U7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FNTCIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGNvbXBpbGVkXFxAZWRnZS1ydW50aW1lXFxjb29raWVzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHNyY19leHBvcnRzID0ge307XG5fX2V4cG9ydChzcmNfZXhwb3J0cywge1xuICBSZXF1ZXN0Q29va2llczogKCkgPT4gUmVxdWVzdENvb2tpZXMsXG4gIFJlc3BvbnNlQ29va2llczogKCkgPT4gUmVzcG9uc2VDb29raWVzLFxuICBwYXJzZUNvb2tpZTogKCkgPT4gcGFyc2VDb29raWUsXG4gIHBhcnNlU2V0Q29va2llOiAoKSA9PiBwYXJzZVNldENvb2tpZSxcbiAgc3RyaW5naWZ5Q29va2llOiAoKSA9PiBzdHJpbmdpZnlDb29raWVcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuXG4vLyBzcmMvc2VyaWFsaXplLnRzXG5mdW5jdGlvbiBzdHJpbmdpZnlDb29raWUoYykge1xuICB2YXIgX2E7XG4gIGNvbnN0IGF0dHJzID0gW1xuICAgIFwicGF0aFwiIGluIGMgJiYgYy5wYXRoICYmIGBQYXRoPSR7Yy5wYXRofWAsXG4gICAgXCJleHBpcmVzXCIgaW4gYyAmJiAoYy5leHBpcmVzIHx8IGMuZXhwaXJlcyA9PT0gMCkgJiYgYEV4cGlyZXM9JHsodHlwZW9mIGMuZXhwaXJlcyA9PT0gXCJudW1iZXJcIiA/IG5ldyBEYXRlKGMuZXhwaXJlcykgOiBjLmV4cGlyZXMpLnRvVVRDU3RyaW5nKCl9YCxcbiAgICBcIm1heEFnZVwiIGluIGMgJiYgdHlwZW9mIGMubWF4QWdlID09PSBcIm51bWJlclwiICYmIGBNYXgtQWdlPSR7Yy5tYXhBZ2V9YCxcbiAgICBcImRvbWFpblwiIGluIGMgJiYgYy5kb21haW4gJiYgYERvbWFpbj0ke2MuZG9tYWlufWAsXG4gICAgXCJzZWN1cmVcIiBpbiBjICYmIGMuc2VjdXJlICYmIFwiU2VjdXJlXCIsXG4gICAgXCJodHRwT25seVwiIGluIGMgJiYgYy5odHRwT25seSAmJiBcIkh0dHBPbmx5XCIsXG4gICAgXCJzYW1lU2l0ZVwiIGluIGMgJiYgYy5zYW1lU2l0ZSAmJiBgU2FtZVNpdGU9JHtjLnNhbWVTaXRlfWAsXG4gICAgXCJwYXJ0aXRpb25lZFwiIGluIGMgJiYgYy5wYXJ0aXRpb25lZCAmJiBcIlBhcnRpdGlvbmVkXCIsXG4gICAgXCJwcmlvcml0eVwiIGluIGMgJiYgYy5wcmlvcml0eSAmJiBgUHJpb3JpdHk9JHtjLnByaW9yaXR5fWBcbiAgXS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHN0cmluZ2lmaWVkID0gYCR7Yy5uYW1lfT0ke2VuY29kZVVSSUNvbXBvbmVudCgoX2EgPSBjLnZhbHVlKSAhPSBudWxsID8gX2EgOiBcIlwiKX1gO1xuICByZXR1cm4gYXR0cnMubGVuZ3RoID09PSAwID8gc3RyaW5naWZpZWQgOiBgJHtzdHJpbmdpZmllZH07ICR7YXR0cnMuam9pbihcIjsgXCIpfWA7XG59XG5mdW5jdGlvbiBwYXJzZUNvb2tpZShjb29raWUpIHtcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBwYWlyIG9mIGNvb2tpZS5zcGxpdCgvOyAqLykpIHtcbiAgICBpZiAoIXBhaXIpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBzcGxpdEF0ID0gcGFpci5pbmRleE9mKFwiPVwiKTtcbiAgICBpZiAoc3BsaXRBdCA9PT0gLTEpIHtcbiAgICAgIG1hcC5zZXQocGFpciwgXCJ0cnVlXCIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IFtwYWlyLnNsaWNlKDAsIHNwbGl0QXQpLCBwYWlyLnNsaWNlKHNwbGl0QXQgKyAxKV07XG4gICAgdHJ5IHtcbiAgICAgIG1hcC5zZXQoa2V5LCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogXCJ0cnVlXCIpKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cbmZ1bmN0aW9uIHBhcnNlU2V0Q29va2llKHNldENvb2tpZSkge1xuICBpZiAoIXNldENvb2tpZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgW1tuYW1lLCB2YWx1ZV0sIC4uLmF0dHJpYnV0ZXNdID0gcGFyc2VDb29raWUoc2V0Q29va2llKTtcbiAgY29uc3Qge1xuICAgIGRvbWFpbixcbiAgICBleHBpcmVzLFxuICAgIGh0dHBvbmx5LFxuICAgIG1heGFnZSxcbiAgICBwYXRoLFxuICAgIHNhbWVzaXRlLFxuICAgIHNlY3VyZSxcbiAgICBwYXJ0aXRpb25lZCxcbiAgICBwcmlvcml0eVxuICB9ID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIGF0dHJpYnV0ZXMubWFwKChba2V5LCB2YWx1ZTJdKSA9PiBbXG4gICAgICBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tL2csIFwiXCIpLFxuICAgICAgdmFsdWUyXG4gICAgXSlcbiAgKTtcbiAgY29uc3QgY29va2llID0ge1xuICAgIG5hbWUsXG4gICAgdmFsdWU6IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSksXG4gICAgZG9tYWluLFxuICAgIC4uLmV4cGlyZXMgJiYgeyBleHBpcmVzOiBuZXcgRGF0ZShleHBpcmVzKSB9LFxuICAgIC4uLmh0dHBvbmx5ICYmIHsgaHR0cE9ubHk6IHRydWUgfSxcbiAgICAuLi50eXBlb2YgbWF4YWdlID09PSBcInN0cmluZ1wiICYmIHsgbWF4QWdlOiBOdW1iZXIobWF4YWdlKSB9LFxuICAgIHBhdGgsXG4gICAgLi4uc2FtZXNpdGUgJiYgeyBzYW1lU2l0ZTogcGFyc2VTYW1lU2l0ZShzYW1lc2l0ZSkgfSxcbiAgICAuLi5zZWN1cmUgJiYgeyBzZWN1cmU6IHRydWUgfSxcbiAgICAuLi5wcmlvcml0eSAmJiB7IHByaW9yaXR5OiBwYXJzZVByaW9yaXR5KHByaW9yaXR5KSB9LFxuICAgIC4uLnBhcnRpdGlvbmVkICYmIHsgcGFydGl0aW9uZWQ6IHRydWUgfVxuICB9O1xuICByZXR1cm4gY29tcGFjdChjb29raWUpO1xufVxuZnVuY3Rpb24gY29tcGFjdCh0KSB7XG4gIGNvbnN0IG5ld1QgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gdCkge1xuICAgIGlmICh0W2tleV0pIHtcbiAgICAgIG5ld1Rba2V5XSA9IHRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1Q7XG59XG52YXIgU0FNRV9TSVRFID0gW1wic3RyaWN0XCIsIFwibGF4XCIsIFwibm9uZVwiXTtcbmZ1bmN0aW9uIHBhcnNlU2FtZVNpdGUoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHN0cmluZy50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gU0FNRV9TSVRFLmluY2x1ZGVzKHN0cmluZykgPyBzdHJpbmcgOiB2b2lkIDA7XG59XG52YXIgUFJJT1JJVFkgPSBbXCJsb3dcIiwgXCJtZWRpdW1cIiwgXCJoaWdoXCJdO1xuZnVuY3Rpb24gcGFyc2VQcmlvcml0eShzdHJpbmcpIHtcbiAgc3RyaW5nID0gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBQUklPUklUWS5pbmNsdWRlcyhzdHJpbmcpID8gc3RyaW5nIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gc3BsaXRDb29raWVzU3RyaW5nKGNvb2tpZXNTdHJpbmcpIHtcbiAgaWYgKCFjb29raWVzU3RyaW5nKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIGNvb2tpZXNTdHJpbmdzID0gW107XG4gIHZhciBwb3MgPSAwO1xuICB2YXIgc3RhcnQ7XG4gIHZhciBjaDtcbiAgdmFyIGxhc3RDb21tYTtcbiAgdmFyIG5leHRTdGFydDtcbiAgdmFyIGNvb2tpZXNTZXBhcmF0b3JGb3VuZDtcbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIC9cXHMvLnRlc3QoY29va2llc1N0cmluZy5jaGFyQXQocG9zKSkpIHtcbiAgICAgIHBvcyArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gcG9zIDwgY29va2llc1N0cmluZy5sZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gbm90U3BlY2lhbENoYXIoKSB7XG4gICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuICAgIHJldHVybiBjaCAhPT0gXCI9XCIgJiYgY2ggIT09IFwiO1wiICYmIGNoICE9PSBcIixcIjtcbiAgfVxuICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICBzdGFydCA9IHBvcztcbiAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSBmYWxzZTtcbiAgICB3aGlsZSAoc2tpcFdoaXRlc3BhY2UoKSkge1xuICAgICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgaWYgKGNoID09PSBcIixcIikge1xuICAgICAgICBsYXN0Q29tbWEgPSBwb3M7XG4gICAgICAgIHBvcyArPSAxO1xuICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICBuZXh0U3RhcnQgPSBwb3M7XG4gICAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBub3RTcGVjaWFsQ2hhcigpKSB7XG4gICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykgPT09IFwiPVwiKSB7XG4gICAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBwb3MgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgbGFzdENvbW1hKSk7XG4gICAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zID0gbGFzdENvbW1hICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY29va2llc1NlcGFyYXRvckZvdW5kIHx8IHBvcyA+PSBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgY29va2llc1N0cmluZy5sZW5ndGgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvb2tpZXNTdHJpbmdzO1xufVxuXG4vLyBzcmMvcmVxdWVzdC1jb29raWVzLnRzXG52YXIgUmVxdWVzdENvb2tpZXMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlcXVlc3RIZWFkZXJzKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3BhcnNlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5faGVhZGVycyA9IHJlcXVlc3RIZWFkZXJzO1xuICAgIGNvbnN0IGhlYWRlciA9IHJlcXVlc3RIZWFkZXJzLmdldChcImNvb2tpZVwiKTtcbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNvb2tpZShoZWFkZXIpO1xuICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIHBhcnNlZCkge1xuICAgICAgICB0aGlzLl9wYXJzZWQuc2V0KG5hbWUsIHsgbmFtZSwgdmFsdWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJzZWRbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIGNvb2tpZXMgcmVjZWl2ZWQgZnJvbSB0aGUgY2xpZW50XG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkLnNpemU7XG4gIH1cbiAgZ2V0KC4uLmFyZ3MpIHtcbiAgICBjb25zdCBuYW1lID0gdHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIgPyBhcmdzWzBdIDogYXJnc1swXS5uYW1lO1xuICAgIHJldHVybiB0aGlzLl9wYXJzZWQuZ2V0KG5hbWUpO1xuICB9XG4gIGdldEFsbCguLi5hcmdzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFsbCA9IEFycmF5LmZyb20odGhpcy5fcGFyc2VkKTtcbiAgICBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYWxsLm1hcCgoW18sIHZhbHVlXSkgPT4gdmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gdHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIgPyBhcmdzWzBdIDogKF9hID0gYXJnc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm5hbWU7XG4gICAgcmV0dXJuIGFsbC5maWx0ZXIoKFtuXSkgPT4gbiA9PT0gbmFtZSkubWFwKChbXywgdmFsdWVdKSA9PiB2YWx1ZSk7XG4gIH1cbiAgaGFzKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkLmhhcyhuYW1lKTtcbiAgfVxuICBzZXQoLi4uYXJncykge1xuICAgIGNvbnN0IFtuYW1lLCB2YWx1ZV0gPSBhcmdzLmxlbmd0aCA9PT0gMSA/IFthcmdzWzBdLm5hbWUsIGFyZ3NbMF0udmFsdWVdIDogYXJncztcbiAgICBjb25zdCBtYXAgPSB0aGlzLl9wYXJzZWQ7XG4gICAgbWFwLnNldChuYW1lLCB7IG5hbWUsIHZhbHVlIH0pO1xuICAgIHRoaXMuX2hlYWRlcnMuc2V0KFxuICAgICAgXCJjb29raWVcIixcbiAgICAgIEFycmF5LmZyb20obWFwKS5tYXAoKFtfLCB2YWx1ZTJdKSA9PiBzdHJpbmdpZnlDb29raWUodmFsdWUyKSkuam9pbihcIjsgXCIpXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIHRoZSBjb29raWVzIG1hdGNoaW5nIHRoZSBwYXNzZWQgbmFtZSBvciBuYW1lcyBpbiB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGRlbGV0ZShuYW1lcykge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuX3BhcnNlZDtcbiAgICBjb25zdCByZXN1bHQgPSAhQXJyYXkuaXNBcnJheShuYW1lcykgPyBtYXAuZGVsZXRlKG5hbWVzKSA6IG5hbWVzLm1hcCgobmFtZSkgPT4gbWFwLmRlbGV0ZShuYW1lKSk7XG4gICAgdGhpcy5faGVhZGVycy5zZXQoXG4gICAgICBcImNvb2tpZVwiLFxuICAgICAgQXJyYXkuZnJvbShtYXApLm1hcCgoW18sIHZhbHVlXSkgPT4gc3RyaW5naWZ5Q29va2llKHZhbHVlKSkuam9pbihcIjsgXCIpXG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYWxsIHRoZSBjb29raWVzIGluIHRoZSBjb29raWVzIGluIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5kZWxldGUoQXJyYXkuZnJvbSh0aGlzLl9wYXJzZWQua2V5cygpKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEZvcm1hdCB0aGUgY29va2llcyBpbiB0aGUgcmVxdWVzdCBhcyBhIHN0cmluZyBmb3IgbG9nZ2luZ1xuICAgKi9cbiAgW1N5bWJvbC5mb3IoXCJlZGdlLXJ1bnRpbWUuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIHJldHVybiBgUmVxdWVzdENvb2tpZXMgJHtKU09OLnN0cmluZ2lmeShPYmplY3QuZnJvbUVudHJpZXModGhpcy5fcGFyc2VkKSl9YDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX3BhcnNlZC52YWx1ZXMoKV0ubWFwKCh2KSA9PiBgJHt2Lm5hbWV9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHYudmFsdWUpfWApLmpvaW4oXCI7IFwiKTtcbiAgfVxufTtcblxuLy8gc3JjL3Jlc3BvbnNlLWNvb2tpZXMudHNcbnZhciBSZXNwb25zZUNvb2tpZXMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlc3BvbnNlSGVhZGVycykge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wYXJzZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHRoaXMuX2hlYWRlcnMgPSByZXNwb25zZUhlYWRlcnM7XG4gICAgY29uc3Qgc2V0Q29va2llID0gKF9jID0gKF9iID0gKF9hID0gcmVzcG9uc2VIZWFkZXJzLmdldFNldENvb2tpZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwocmVzcG9uc2VIZWFkZXJzKSkgIT0gbnVsbCA/IF9iIDogcmVzcG9uc2VIZWFkZXJzLmdldChcInNldC1jb29raWVcIikpICE9IG51bGwgPyBfYyA6IFtdO1xuICAgIGNvbnN0IGNvb2tpZVN0cmluZ3MgPSBBcnJheS5pc0FycmF5KHNldENvb2tpZSkgPyBzZXRDb29raWUgOiBzcGxpdENvb2tpZXNTdHJpbmcoc2V0Q29va2llKTtcbiAgICBmb3IgKGNvbnN0IGNvb2tpZVN0cmluZyBvZiBjb29raWVTdHJpbmdzKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVNldENvb2tpZShjb29raWVTdHJpbmcpO1xuICAgICAgaWYgKHBhcnNlZClcbiAgICAgICAgdGhpcy5fcGFyc2VkLnNldChwYXJzZWQubmFtZSwgcGFyc2VkKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIHtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL2Nvb2tpZS1zdG9yZS8jQ29va2llU3RvcmUtZ2V0IENvb2tpZVN0b3JlI2dldH0gd2l0aG91dCB0aGUgUHJvbWlzZS5cbiAgICovXG4gIGdldCguLi5hcmdzKSB7XG4gICAgY29uc3Qga2V5ID0gdHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIgPyBhcmdzWzBdIDogYXJnc1swXS5uYW1lO1xuICAgIHJldHVybiB0aGlzLl9wYXJzZWQuZ2V0KGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIHtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL2Nvb2tpZS1zdG9yZS8jQ29va2llU3RvcmUtZ2V0QWxsIENvb2tpZVN0b3JlI2dldEFsbH0gd2l0aG91dCB0aGUgUHJvbWlzZS5cbiAgICovXG4gIGdldEFsbCguLi5hcmdzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFsbCA9IEFycmF5LmZyb20odGhpcy5fcGFyc2VkLnZhbHVlcygpKTtcbiAgICBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYWxsO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSB0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIiA/IGFyZ3NbMF0gOiAoX2EgPSBhcmdzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EubmFtZTtcbiAgICByZXR1cm4gYWxsLmZpbHRlcigoYykgPT4gYy5uYW1lID09PSBrZXkpO1xuICB9XG4gIGhhcyhuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZC5oYXMobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIHtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL2Nvb2tpZS1zdG9yZS8jQ29va2llU3RvcmUtc2V0IENvb2tpZVN0b3JlI3NldH0gd2l0aG91dCB0aGUgUHJvbWlzZS5cbiAgICovXG4gIHNldCguLi5hcmdzKSB7XG4gICAgY29uc3QgW25hbWUsIHZhbHVlLCBjb29raWVdID0gYXJncy5sZW5ndGggPT09IDEgPyBbYXJnc1swXS5uYW1lLCBhcmdzWzBdLnZhbHVlLCBhcmdzWzBdXSA6IGFyZ3M7XG4gICAgY29uc3QgbWFwID0gdGhpcy5fcGFyc2VkO1xuICAgIG1hcC5zZXQobmFtZSwgbm9ybWFsaXplQ29va2llKHsgbmFtZSwgdmFsdWUsIC4uLmNvb2tpZSB9KSk7XG4gICAgcmVwbGFjZShtYXAsIHRoaXMuX2hlYWRlcnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI0Nvb2tpZVN0b3JlLWRlbGV0ZSBDb29raWVTdG9yZSNkZWxldGV9IHdpdGhvdXQgdGhlIFByb21pc2UuXG4gICAqL1xuICBkZWxldGUoLi4uYXJncykge1xuICAgIGNvbnN0IFtuYW1lLCBvcHRpb25zXSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiID8gW2FyZ3NbMF1dIDogW2FyZ3NbMF0ubmFtZSwgYXJnc1swXV07XG4gICAgcmV0dXJuIHRoaXMuc2V0KHsgLi4ub3B0aW9ucywgbmFtZSwgdmFsdWU6IFwiXCIsIGV4cGlyZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgwKSB9KTtcbiAgfVxuICBbU3ltYm9sLmZvcihcImVkZ2UtcnVudGltZS5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgcmV0dXJuIGBSZXNwb25zZUNvb2tpZXMgJHtKU09OLnN0cmluZ2lmeShPYmplY3QuZnJvbUVudHJpZXModGhpcy5fcGFyc2VkKSl9YDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX3BhcnNlZC52YWx1ZXMoKV0ubWFwKHN0cmluZ2lmeUNvb2tpZSkuam9pbihcIjsgXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVwbGFjZShiYWcsIGhlYWRlcnMpIHtcbiAgaGVhZGVycy5kZWxldGUoXCJzZXQtY29va2llXCIpO1xuICBmb3IgKGNvbnN0IFssIHZhbHVlXSBvZiBiYWcpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gc3RyaW5naWZ5Q29va2llKHZhbHVlKTtcbiAgICBoZWFkZXJzLmFwcGVuZChcInNldC1jb29raWVcIiwgc2VyaWFsaXplZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvb2tpZShjb29raWUgPSB7IG5hbWU6IFwiXCIsIHZhbHVlOiBcIlwiIH0pIHtcbiAgaWYgKHR5cGVvZiBjb29raWUuZXhwaXJlcyA9PT0gXCJudW1iZXJcIikge1xuICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUoY29va2llLmV4cGlyZXMpO1xuICB9XG4gIGlmIChjb29raWUubWF4QWdlKSB7XG4gICAgY29va2llLmV4cGlyZXMgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgY29va2llLm1heEFnZSAqIDFlMyk7XG4gIH1cbiAgaWYgKGNvb2tpZS5wYXRoID09PSBudWxsIHx8IGNvb2tpZS5wYXRoID09PSB2b2lkIDApIHtcbiAgICBjb29raWUucGF0aCA9IFwiL1wiO1xuICB9XG4gIHJldHVybiBjb29raWU7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgUmVxdWVzdENvb2tpZXMsXG4gIFJlc3BvbnNlQ29va2llcyxcbiAgcGFyc2VDb29raWUsXG4gIHBhcnNlU2V0Q29va2llLFxuICBzdHJpbmdpZnlDb29raWVcbn0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/@edge-runtime/cookies/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/@opentelemetry/api/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/next/dist/compiled/@opentelemetry/api/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("(()=>{\"use strict\";var e={491:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.ContextAPI=void 0;const n=r(223);const a=r(172);const o=r(930);const i=\"context\";const c=new n.NoopContextManager;class ContextAPI{constructor(){}static getInstance(){if(!this._instance){this._instance=new ContextAPI}return this._instance}setGlobalContextManager(e){return(0,a.registerGlobal)(i,e,o.DiagAPI.instance())}active(){return this._getContextManager().active()}with(e,t,r,...n){return this._getContextManager().with(e,t,r,...n)}bind(e,t){return this._getContextManager().bind(e,t)}_getContextManager(){return(0,a.getGlobal)(i)||c}disable(){this._getContextManager().disable();(0,a.unregisterGlobal)(i,o.DiagAPI.instance())}}t.ContextAPI=ContextAPI},930:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.DiagAPI=void 0;const n=r(56);const a=r(912);const o=r(957);const i=r(172);const c=\"diag\";class DiagAPI{constructor(){function _logProxy(e){return function(...t){const r=(0,i.getGlobal)(\"diag\");if(!r)return;return r[e](...t)}}const e=this;const setLogger=(t,r={logLevel:o.DiagLogLevel.INFO})=>{var n,c,s;if(t===e){const t=new Error(\"Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation\");e.error((n=t.stack)!==null&&n!==void 0?n:t.message);return false}if(typeof r===\"number\"){r={logLevel:r}}const u=(0,i.getGlobal)(\"diag\");const l=(0,a.createLogLevelDiagLogger)((c=r.logLevel)!==null&&c!==void 0?c:o.DiagLogLevel.INFO,t);if(u&&!r.suppressOverrideMessage){const e=(s=(new Error).stack)!==null&&s!==void 0?s:\"<failed to generate stacktrace>\";u.warn(`Current logger will be overwritten from ${e}`);l.warn(`Current logger will overwrite one already registered from ${e}`)}return(0,i.registerGlobal)(\"diag\",l,e,true)};e.setLogger=setLogger;e.disable=()=>{(0,i.unregisterGlobal)(c,e)};e.createComponentLogger=e=>new n.DiagComponentLogger(e);e.verbose=_logProxy(\"verbose\");e.debug=_logProxy(\"debug\");e.info=_logProxy(\"info\");e.warn=_logProxy(\"warn\");e.error=_logProxy(\"error\")}static instance(){if(!this._instance){this._instance=new DiagAPI}return this._instance}}t.DiagAPI=DiagAPI},653:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.MetricsAPI=void 0;const n=r(660);const a=r(172);const o=r(930);const i=\"metrics\";class MetricsAPI{constructor(){}static getInstance(){if(!this._instance){this._instance=new MetricsAPI}return this._instance}setGlobalMeterProvider(e){return(0,a.registerGlobal)(i,e,o.DiagAPI.instance())}getMeterProvider(){return(0,a.getGlobal)(i)||n.NOOP_METER_PROVIDER}getMeter(e,t,r){return this.getMeterProvider().getMeter(e,t,r)}disable(){(0,a.unregisterGlobal)(i,o.DiagAPI.instance())}}t.MetricsAPI=MetricsAPI},181:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.PropagationAPI=void 0;const n=r(172);const a=r(874);const o=r(194);const i=r(277);const c=r(369);const s=r(930);const u=\"propagation\";const l=new a.NoopTextMapPropagator;class PropagationAPI{constructor(){this.createBaggage=c.createBaggage;this.getBaggage=i.getBaggage;this.getActiveBaggage=i.getActiveBaggage;this.setBaggage=i.setBaggage;this.deleteBaggage=i.deleteBaggage}static getInstance(){if(!this._instance){this._instance=new PropagationAPI}return this._instance}setGlobalPropagator(e){return(0,n.registerGlobal)(u,e,s.DiagAPI.instance())}inject(e,t,r=o.defaultTextMapSetter){return this._getGlobalPropagator().inject(e,t,r)}extract(e,t,r=o.defaultTextMapGetter){return this._getGlobalPropagator().extract(e,t,r)}fields(){return this._getGlobalPropagator().fields()}disable(){(0,n.unregisterGlobal)(u,s.DiagAPI.instance())}_getGlobalPropagator(){return(0,n.getGlobal)(u)||l}}t.PropagationAPI=PropagationAPI},997:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.TraceAPI=void 0;const n=r(172);const a=r(846);const o=r(139);const i=r(607);const c=r(930);const s=\"trace\";class TraceAPI{constructor(){this._proxyTracerProvider=new a.ProxyTracerProvider;this.wrapSpanContext=o.wrapSpanContext;this.isSpanContextValid=o.isSpanContextValid;this.deleteSpan=i.deleteSpan;this.getSpan=i.getSpan;this.getActiveSpan=i.getActiveSpan;this.getSpanContext=i.getSpanContext;this.setSpan=i.setSpan;this.setSpanContext=i.setSpanContext}static getInstance(){if(!this._instance){this._instance=new TraceAPI}return this._instance}setGlobalTracerProvider(e){const t=(0,n.registerGlobal)(s,this._proxyTracerProvider,c.DiagAPI.instance());if(t){this._proxyTracerProvider.setDelegate(e)}return t}getTracerProvider(){return(0,n.getGlobal)(s)||this._proxyTracerProvider}getTracer(e,t){return this.getTracerProvider().getTracer(e,t)}disable(){(0,n.unregisterGlobal)(s,c.DiagAPI.instance());this._proxyTracerProvider=new a.ProxyTracerProvider}}t.TraceAPI=TraceAPI},277:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.deleteBaggage=t.setBaggage=t.getActiveBaggage=t.getBaggage=void 0;const n=r(491);const a=r(780);const o=(0,a.createContextKey)(\"OpenTelemetry Baggage Key\");function getBaggage(e){return e.getValue(o)||undefined}t.getBaggage=getBaggage;function getActiveBaggage(){return getBaggage(n.ContextAPI.getInstance().active())}t.getActiveBaggage=getActiveBaggage;function setBaggage(e,t){return e.setValue(o,t)}t.setBaggage=setBaggage;function deleteBaggage(e){return e.deleteValue(o)}t.deleteBaggage=deleteBaggage},993:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.BaggageImpl=void 0;class BaggageImpl{constructor(e){this._entries=e?new Map(e):new Map}getEntry(e){const t=this._entries.get(e);if(!t){return undefined}return Object.assign({},t)}getAllEntries(){return Array.from(this._entries.entries()).map((([e,t])=>[e,t]))}setEntry(e,t){const r=new BaggageImpl(this._entries);r._entries.set(e,t);return r}removeEntry(e){const t=new BaggageImpl(this._entries);t._entries.delete(e);return t}removeEntries(...e){const t=new BaggageImpl(this._entries);for(const r of e){t._entries.delete(r)}return t}clear(){return new BaggageImpl}}t.BaggageImpl=BaggageImpl},830:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.baggageEntryMetadataSymbol=void 0;t.baggageEntryMetadataSymbol=Symbol(\"BaggageEntryMetadata\")},369:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.baggageEntryMetadataFromString=t.createBaggage=void 0;const n=r(930);const a=r(993);const o=r(830);const i=n.DiagAPI.instance();function createBaggage(e={}){return new a.BaggageImpl(new Map(Object.entries(e)))}t.createBaggage=createBaggage;function baggageEntryMetadataFromString(e){if(typeof e!==\"string\"){i.error(`Cannot create baggage metadata from unknown type: ${typeof e}`);e=\"\"}return{__TYPE__:o.baggageEntryMetadataSymbol,toString(){return e}}}t.baggageEntryMetadataFromString=baggageEntryMetadataFromString},67:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.context=void 0;const n=r(491);t.context=n.ContextAPI.getInstance()},223:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.NoopContextManager=void 0;const n=r(780);class NoopContextManager{active(){return n.ROOT_CONTEXT}with(e,t,r,...n){return t.call(r,...n)}bind(e,t){return t}enable(){return this}disable(){return this}}t.NoopContextManager=NoopContextManager},780:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.ROOT_CONTEXT=t.createContextKey=void 0;function createContextKey(e){return Symbol.for(e)}t.createContextKey=createContextKey;class BaseContext{constructor(e){const t=this;t._currentContext=e?new Map(e):new Map;t.getValue=e=>t._currentContext.get(e);t.setValue=(e,r)=>{const n=new BaseContext(t._currentContext);n._currentContext.set(e,r);return n};t.deleteValue=e=>{const r=new BaseContext(t._currentContext);r._currentContext.delete(e);return r}}}t.ROOT_CONTEXT=new BaseContext},506:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.diag=void 0;const n=r(930);t.diag=n.DiagAPI.instance()},56:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.DiagComponentLogger=void 0;const n=r(172);class DiagComponentLogger{constructor(e){this._namespace=e.namespace||\"DiagComponentLogger\"}debug(...e){return logProxy(\"debug\",this._namespace,e)}error(...e){return logProxy(\"error\",this._namespace,e)}info(...e){return logProxy(\"info\",this._namespace,e)}warn(...e){return logProxy(\"warn\",this._namespace,e)}verbose(...e){return logProxy(\"verbose\",this._namespace,e)}}t.DiagComponentLogger=DiagComponentLogger;function logProxy(e,t,r){const a=(0,n.getGlobal)(\"diag\");if(!a){return}r.unshift(t);return a[e](...r)}},972:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.DiagConsoleLogger=void 0;const r=[{n:\"error\",c:\"error\"},{n:\"warn\",c:\"warn\"},{n:\"info\",c:\"info\"},{n:\"debug\",c:\"debug\"},{n:\"verbose\",c:\"trace\"}];class DiagConsoleLogger{constructor(){function _consoleFunc(e){return function(...t){if(console){let r=console[e];if(typeof r!==\"function\"){r=console.log}if(typeof r===\"function\"){return r.apply(console,t)}}}}for(let e=0;e<r.length;e++){this[r[e].n]=_consoleFunc(r[e].c)}}}t.DiagConsoleLogger=DiagConsoleLogger},912:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.createLogLevelDiagLogger=void 0;const n=r(957);function createLogLevelDiagLogger(e,t){if(e<n.DiagLogLevel.NONE){e=n.DiagLogLevel.NONE}else if(e>n.DiagLogLevel.ALL){e=n.DiagLogLevel.ALL}t=t||{};function _filterFunc(r,n){const a=t[r];if(typeof a===\"function\"&&e>=n){return a.bind(t)}return function(){}}return{error:_filterFunc(\"error\",n.DiagLogLevel.ERROR),warn:_filterFunc(\"warn\",n.DiagLogLevel.WARN),info:_filterFunc(\"info\",n.DiagLogLevel.INFO),debug:_filterFunc(\"debug\",n.DiagLogLevel.DEBUG),verbose:_filterFunc(\"verbose\",n.DiagLogLevel.VERBOSE)}}t.createLogLevelDiagLogger=createLogLevelDiagLogger},957:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.DiagLogLevel=void 0;var r;(function(e){e[e[\"NONE\"]=0]=\"NONE\";e[e[\"ERROR\"]=30]=\"ERROR\";e[e[\"WARN\"]=50]=\"WARN\";e[e[\"INFO\"]=60]=\"INFO\";e[e[\"DEBUG\"]=70]=\"DEBUG\";e[e[\"VERBOSE\"]=80]=\"VERBOSE\";e[e[\"ALL\"]=9999]=\"ALL\"})(r=t.DiagLogLevel||(t.DiagLogLevel={}))},172:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.unregisterGlobal=t.getGlobal=t.registerGlobal=void 0;const n=r(200);const a=r(521);const o=r(130);const i=a.VERSION.split(\".\")[0];const c=Symbol.for(`opentelemetry.js.api.${i}`);const s=n._globalThis;function registerGlobal(e,t,r,n=false){var o;const i=s[c]=(o=s[c])!==null&&o!==void 0?o:{version:a.VERSION};if(!n&&i[e]){const t=new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${e}`);r.error(t.stack||t.message);return false}if(i.version!==a.VERSION){const t=new Error(`@opentelemetry/api: Registration of version v${i.version} for ${e} does not match previously registered API v${a.VERSION}`);r.error(t.stack||t.message);return false}i[e]=t;r.debug(`@opentelemetry/api: Registered a global for ${e} v${a.VERSION}.`);return true}t.registerGlobal=registerGlobal;function getGlobal(e){var t,r;const n=(t=s[c])===null||t===void 0?void 0:t.version;if(!n||!(0,o.isCompatible)(n)){return}return(r=s[c])===null||r===void 0?void 0:r[e]}t.getGlobal=getGlobal;function unregisterGlobal(e,t){t.debug(`@opentelemetry/api: Unregistering a global for ${e} v${a.VERSION}.`);const r=s[c];if(r){delete r[e]}}t.unregisterGlobal=unregisterGlobal},130:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.isCompatible=t._makeCompatibilityCheck=void 0;const n=r(521);const a=/^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;function _makeCompatibilityCheck(e){const t=new Set([e]);const r=new Set;const n=e.match(a);if(!n){return()=>false}const o={major:+n[1],minor:+n[2],patch:+n[3],prerelease:n[4]};if(o.prerelease!=null){return function isExactmatch(t){return t===e}}function _reject(e){r.add(e);return false}function _accept(e){t.add(e);return true}return function isCompatible(e){if(t.has(e)){return true}if(r.has(e)){return false}const n=e.match(a);if(!n){return _reject(e)}const i={major:+n[1],minor:+n[2],patch:+n[3],prerelease:n[4]};if(i.prerelease!=null){return _reject(e)}if(o.major!==i.major){return _reject(e)}if(o.major===0){if(o.minor===i.minor&&o.patch<=i.patch){return _accept(e)}return _reject(e)}if(o.minor<=i.minor){return _accept(e)}return _reject(e)}}t._makeCompatibilityCheck=_makeCompatibilityCheck;t.isCompatible=_makeCompatibilityCheck(n.VERSION)},886:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.metrics=void 0;const n=r(653);t.metrics=n.MetricsAPI.getInstance()},901:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.ValueType=void 0;var r;(function(e){e[e[\"INT\"]=0]=\"INT\";e[e[\"DOUBLE\"]=1]=\"DOUBLE\"})(r=t.ValueType||(t.ValueType={}))},102:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.createNoopMeter=t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC=t.NOOP_OBSERVABLE_GAUGE_METRIC=t.NOOP_OBSERVABLE_COUNTER_METRIC=t.NOOP_UP_DOWN_COUNTER_METRIC=t.NOOP_HISTOGRAM_METRIC=t.NOOP_COUNTER_METRIC=t.NOOP_METER=t.NoopObservableUpDownCounterMetric=t.NoopObservableGaugeMetric=t.NoopObservableCounterMetric=t.NoopObservableMetric=t.NoopHistogramMetric=t.NoopUpDownCounterMetric=t.NoopCounterMetric=t.NoopMetric=t.NoopMeter=void 0;class NoopMeter{constructor(){}createHistogram(e,r){return t.NOOP_HISTOGRAM_METRIC}createCounter(e,r){return t.NOOP_COUNTER_METRIC}createUpDownCounter(e,r){return t.NOOP_UP_DOWN_COUNTER_METRIC}createObservableGauge(e,r){return t.NOOP_OBSERVABLE_GAUGE_METRIC}createObservableCounter(e,r){return t.NOOP_OBSERVABLE_COUNTER_METRIC}createObservableUpDownCounter(e,r){return t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC}addBatchObservableCallback(e,t){}removeBatchObservableCallback(e){}}t.NoopMeter=NoopMeter;class NoopMetric{}t.NoopMetric=NoopMetric;class NoopCounterMetric extends NoopMetric{add(e,t){}}t.NoopCounterMetric=NoopCounterMetric;class NoopUpDownCounterMetric extends NoopMetric{add(e,t){}}t.NoopUpDownCounterMetric=NoopUpDownCounterMetric;class NoopHistogramMetric extends NoopMetric{record(e,t){}}t.NoopHistogramMetric=NoopHistogramMetric;class NoopObservableMetric{addCallback(e){}removeCallback(e){}}t.NoopObservableMetric=NoopObservableMetric;class NoopObservableCounterMetric extends NoopObservableMetric{}t.NoopObservableCounterMetric=NoopObservableCounterMetric;class NoopObservableGaugeMetric extends NoopObservableMetric{}t.NoopObservableGaugeMetric=NoopObservableGaugeMetric;class NoopObservableUpDownCounterMetric extends NoopObservableMetric{}t.NoopObservableUpDownCounterMetric=NoopObservableUpDownCounterMetric;t.NOOP_METER=new NoopMeter;t.NOOP_COUNTER_METRIC=new NoopCounterMetric;t.NOOP_HISTOGRAM_METRIC=new NoopHistogramMetric;t.NOOP_UP_DOWN_COUNTER_METRIC=new NoopUpDownCounterMetric;t.NOOP_OBSERVABLE_COUNTER_METRIC=new NoopObservableCounterMetric;t.NOOP_OBSERVABLE_GAUGE_METRIC=new NoopObservableGaugeMetric;t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC=new NoopObservableUpDownCounterMetric;function createNoopMeter(){return t.NOOP_METER}t.createNoopMeter=createNoopMeter},660:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.NOOP_METER_PROVIDER=t.NoopMeterProvider=void 0;const n=r(102);class NoopMeterProvider{getMeter(e,t,r){return n.NOOP_METER}}t.NoopMeterProvider=NoopMeterProvider;t.NOOP_METER_PROVIDER=new NoopMeterProvider},200:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){if(n===undefined)n=r;Object.defineProperty(e,n,{enumerable:true,get:function(){return t[r]}})}:function(e,t,r,n){if(n===undefined)n=r;e[n]=t[r]});var a=this&&this.__exportStar||function(e,t){for(var r in e)if(r!==\"default\"&&!Object.prototype.hasOwnProperty.call(t,r))n(t,e,r)};Object.defineProperty(t,\"__esModule\",{value:true});a(r(46),t)},651:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t._globalThis=void 0;t._globalThis=typeof globalThis===\"object\"?globalThis:global},46:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){if(n===undefined)n=r;Object.defineProperty(e,n,{enumerable:true,get:function(){return t[r]}})}:function(e,t,r,n){if(n===undefined)n=r;e[n]=t[r]});var a=this&&this.__exportStar||function(e,t){for(var r in e)if(r!==\"default\"&&!Object.prototype.hasOwnProperty.call(t,r))n(t,e,r)};Object.defineProperty(t,\"__esModule\",{value:true});a(r(651),t)},939:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.propagation=void 0;const n=r(181);t.propagation=n.PropagationAPI.getInstance()},874:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.NoopTextMapPropagator=void 0;class NoopTextMapPropagator{inject(e,t){}extract(e,t){return e}fields(){return[]}}t.NoopTextMapPropagator=NoopTextMapPropagator},194:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.defaultTextMapSetter=t.defaultTextMapGetter=void 0;t.defaultTextMapGetter={get(e,t){if(e==null){return undefined}return e[t]},keys(e){if(e==null){return[]}return Object.keys(e)}};t.defaultTextMapSetter={set(e,t,r){if(e==null){return}e[t]=r}}},845:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.trace=void 0;const n=r(997);t.trace=n.TraceAPI.getInstance()},403:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.NonRecordingSpan=void 0;const n=r(476);class NonRecordingSpan{constructor(e=n.INVALID_SPAN_CONTEXT){this._spanContext=e}spanContext(){return this._spanContext}setAttribute(e,t){return this}setAttributes(e){return this}addEvent(e,t){return this}setStatus(e){return this}updateName(e){return this}end(e){}isRecording(){return false}recordException(e,t){}}t.NonRecordingSpan=NonRecordingSpan},614:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.NoopTracer=void 0;const n=r(491);const a=r(607);const o=r(403);const i=r(139);const c=n.ContextAPI.getInstance();class NoopTracer{startSpan(e,t,r=c.active()){const n=Boolean(t===null||t===void 0?void 0:t.root);if(n){return new o.NonRecordingSpan}const s=r&&(0,a.getSpanContext)(r);if(isSpanContext(s)&&(0,i.isSpanContextValid)(s)){return new o.NonRecordingSpan(s)}else{return new o.NonRecordingSpan}}startActiveSpan(e,t,r,n){let o;let i;let s;if(arguments.length<2){return}else if(arguments.length===2){s=t}else if(arguments.length===3){o=t;s=r}else{o=t;i=r;s=n}const u=i!==null&&i!==void 0?i:c.active();const l=this.startSpan(e,o,u);const g=(0,a.setSpan)(u,l);return c.with(g,s,undefined,l)}}t.NoopTracer=NoopTracer;function isSpanContext(e){return typeof e===\"object\"&&typeof e[\"spanId\"]===\"string\"&&typeof e[\"traceId\"]===\"string\"&&typeof e[\"traceFlags\"]===\"number\"}},124:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.NoopTracerProvider=void 0;const n=r(614);class NoopTracerProvider{getTracer(e,t,r){return new n.NoopTracer}}t.NoopTracerProvider=NoopTracerProvider},125:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.ProxyTracer=void 0;const n=r(614);const a=new n.NoopTracer;class ProxyTracer{constructor(e,t,r,n){this._provider=e;this.name=t;this.version=r;this.options=n}startSpan(e,t,r){return this._getTracer().startSpan(e,t,r)}startActiveSpan(e,t,r,n){const a=this._getTracer();return Reflect.apply(a.startActiveSpan,a,arguments)}_getTracer(){if(this._delegate){return this._delegate}const e=this._provider.getDelegateTracer(this.name,this.version,this.options);if(!e){return a}this._delegate=e;return this._delegate}}t.ProxyTracer=ProxyTracer},846:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.ProxyTracerProvider=void 0;const n=r(125);const a=r(124);const o=new a.NoopTracerProvider;class ProxyTracerProvider{getTracer(e,t,r){var a;return(a=this.getDelegateTracer(e,t,r))!==null&&a!==void 0?a:new n.ProxyTracer(this,e,t,r)}getDelegate(){var e;return(e=this._delegate)!==null&&e!==void 0?e:o}setDelegate(e){this._delegate=e}getDelegateTracer(e,t,r){var n;return(n=this._delegate)===null||n===void 0?void 0:n.getTracer(e,t,r)}}t.ProxyTracerProvider=ProxyTracerProvider},996:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.SamplingDecision=void 0;var r;(function(e){e[e[\"NOT_RECORD\"]=0]=\"NOT_RECORD\";e[e[\"RECORD\"]=1]=\"RECORD\";e[e[\"RECORD_AND_SAMPLED\"]=2]=\"RECORD_AND_SAMPLED\"})(r=t.SamplingDecision||(t.SamplingDecision={}))},607:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.getSpanContext=t.setSpanContext=t.deleteSpan=t.setSpan=t.getActiveSpan=t.getSpan=void 0;const n=r(780);const a=r(403);const o=r(491);const i=(0,n.createContextKey)(\"OpenTelemetry Context Key SPAN\");function getSpan(e){return e.getValue(i)||undefined}t.getSpan=getSpan;function getActiveSpan(){return getSpan(o.ContextAPI.getInstance().active())}t.getActiveSpan=getActiveSpan;function setSpan(e,t){return e.setValue(i,t)}t.setSpan=setSpan;function deleteSpan(e){return e.deleteValue(i)}t.deleteSpan=deleteSpan;function setSpanContext(e,t){return setSpan(e,new a.NonRecordingSpan(t))}t.setSpanContext=setSpanContext;function getSpanContext(e){var t;return(t=getSpan(e))===null||t===void 0?void 0:t.spanContext()}t.getSpanContext=getSpanContext},325:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.TraceStateImpl=void 0;const n=r(564);const a=32;const o=512;const i=\",\";const c=\"=\";class TraceStateImpl{constructor(e){this._internalState=new Map;if(e)this._parse(e)}set(e,t){const r=this._clone();if(r._internalState.has(e)){r._internalState.delete(e)}r._internalState.set(e,t);return r}unset(e){const t=this._clone();t._internalState.delete(e);return t}get(e){return this._internalState.get(e)}serialize(){return this._keys().reduce(((e,t)=>{e.push(t+c+this.get(t));return e}),[]).join(i)}_parse(e){if(e.length>o)return;this._internalState=e.split(i).reverse().reduce(((e,t)=>{const r=t.trim();const a=r.indexOf(c);if(a!==-1){const o=r.slice(0,a);const i=r.slice(a+1,t.length);if((0,n.validateKey)(o)&&(0,n.validateValue)(i)){e.set(o,i)}else{}}return e}),new Map);if(this._internalState.size>a){this._internalState=new Map(Array.from(this._internalState.entries()).reverse().slice(0,a))}}_keys(){return Array.from(this._internalState.keys()).reverse()}_clone(){const e=new TraceStateImpl;e._internalState=new Map(this._internalState);return e}}t.TraceStateImpl=TraceStateImpl},564:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.validateValue=t.validateKey=void 0;const r=\"[_0-9a-z-*/]\";const n=`[a-z]${r}{0,255}`;const a=`[a-z0-9]${r}{0,240}@[a-z]${r}{0,13}`;const o=new RegExp(`^(?:${n}|${a})$`);const i=/^[ -~]{0,255}[!-~]$/;const c=/,|=/;function validateKey(e){return o.test(e)}t.validateKey=validateKey;function validateValue(e){return i.test(e)&&!c.test(e)}t.validateValue=validateValue},98:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.createTraceState=void 0;const n=r(325);function createTraceState(e){return new n.TraceStateImpl(e)}t.createTraceState=createTraceState},476:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.INVALID_SPAN_CONTEXT=t.INVALID_TRACEID=t.INVALID_SPANID=void 0;const n=r(475);t.INVALID_SPANID=\"0000000000000000\";t.INVALID_TRACEID=\"00000000000000000000000000000000\";t.INVALID_SPAN_CONTEXT={traceId:t.INVALID_TRACEID,spanId:t.INVALID_SPANID,traceFlags:n.TraceFlags.NONE}},357:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.SpanKind=void 0;var r;(function(e){e[e[\"INTERNAL\"]=0]=\"INTERNAL\";e[e[\"SERVER\"]=1]=\"SERVER\";e[e[\"CLIENT\"]=2]=\"CLIENT\";e[e[\"PRODUCER\"]=3]=\"PRODUCER\";e[e[\"CONSUMER\"]=4]=\"CONSUMER\"})(r=t.SpanKind||(t.SpanKind={}))},139:(e,t,r)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.wrapSpanContext=t.isSpanContextValid=t.isValidSpanId=t.isValidTraceId=void 0;const n=r(476);const a=r(403);const o=/^([0-9a-f]{32})$/i;const i=/^[0-9a-f]{16}$/i;function isValidTraceId(e){return o.test(e)&&e!==n.INVALID_TRACEID}t.isValidTraceId=isValidTraceId;function isValidSpanId(e){return i.test(e)&&e!==n.INVALID_SPANID}t.isValidSpanId=isValidSpanId;function isSpanContextValid(e){return isValidTraceId(e.traceId)&&isValidSpanId(e.spanId)}t.isSpanContextValid=isSpanContextValid;function wrapSpanContext(e){return new a.NonRecordingSpan(e)}t.wrapSpanContext=wrapSpanContext},847:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.SpanStatusCode=void 0;var r;(function(e){e[e[\"UNSET\"]=0]=\"UNSET\";e[e[\"OK\"]=1]=\"OK\";e[e[\"ERROR\"]=2]=\"ERROR\"})(r=t.SpanStatusCode||(t.SpanStatusCode={}))},475:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.TraceFlags=void 0;var r;(function(e){e[e[\"NONE\"]=0]=\"NONE\";e[e[\"SAMPLED\"]=1]=\"SAMPLED\"})(r=t.TraceFlags||(t.TraceFlags={}))},521:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:true});t.VERSION=void 0;t.VERSION=\"1.6.0\"}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var a=t[r]={exports:{}};var o=true;try{e[r].call(a.exports,a,a.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return a.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r={};(()=>{var e=r;Object.defineProperty(e,\"__esModule\",{value:true});e.trace=e.propagation=e.metrics=e.diag=e.context=e.INVALID_SPAN_CONTEXT=e.INVALID_TRACEID=e.INVALID_SPANID=e.isValidSpanId=e.isValidTraceId=e.isSpanContextValid=e.createTraceState=e.TraceFlags=e.SpanStatusCode=e.SpanKind=e.SamplingDecision=e.ProxyTracerProvider=e.ProxyTracer=e.defaultTextMapSetter=e.defaultTextMapGetter=e.ValueType=e.createNoopMeter=e.DiagLogLevel=e.DiagConsoleLogger=e.ROOT_CONTEXT=e.createContextKey=e.baggageEntryMetadataFromString=void 0;var t=__nccwpck_require__(369);Object.defineProperty(e,\"baggageEntryMetadataFromString\",{enumerable:true,get:function(){return t.baggageEntryMetadataFromString}});var n=__nccwpck_require__(780);Object.defineProperty(e,\"createContextKey\",{enumerable:true,get:function(){return n.createContextKey}});Object.defineProperty(e,\"ROOT_CONTEXT\",{enumerable:true,get:function(){return n.ROOT_CONTEXT}});var a=__nccwpck_require__(972);Object.defineProperty(e,\"DiagConsoleLogger\",{enumerable:true,get:function(){return a.DiagConsoleLogger}});var o=__nccwpck_require__(957);Object.defineProperty(e,\"DiagLogLevel\",{enumerable:true,get:function(){return o.DiagLogLevel}});var i=__nccwpck_require__(102);Object.defineProperty(e,\"createNoopMeter\",{enumerable:true,get:function(){return i.createNoopMeter}});var c=__nccwpck_require__(901);Object.defineProperty(e,\"ValueType\",{enumerable:true,get:function(){return c.ValueType}});var s=__nccwpck_require__(194);Object.defineProperty(e,\"defaultTextMapGetter\",{enumerable:true,get:function(){return s.defaultTextMapGetter}});Object.defineProperty(e,\"defaultTextMapSetter\",{enumerable:true,get:function(){return s.defaultTextMapSetter}});var u=__nccwpck_require__(125);Object.defineProperty(e,\"ProxyTracer\",{enumerable:true,get:function(){return u.ProxyTracer}});var l=__nccwpck_require__(846);Object.defineProperty(e,\"ProxyTracerProvider\",{enumerable:true,get:function(){return l.ProxyTracerProvider}});var g=__nccwpck_require__(996);Object.defineProperty(e,\"SamplingDecision\",{enumerable:true,get:function(){return g.SamplingDecision}});var p=__nccwpck_require__(357);Object.defineProperty(e,\"SpanKind\",{enumerable:true,get:function(){return p.SpanKind}});var d=__nccwpck_require__(847);Object.defineProperty(e,\"SpanStatusCode\",{enumerable:true,get:function(){return d.SpanStatusCode}});var _=__nccwpck_require__(475);Object.defineProperty(e,\"TraceFlags\",{enumerable:true,get:function(){return _.TraceFlags}});var f=__nccwpck_require__(98);Object.defineProperty(e,\"createTraceState\",{enumerable:true,get:function(){return f.createTraceState}});var b=__nccwpck_require__(139);Object.defineProperty(e,\"isSpanContextValid\",{enumerable:true,get:function(){return b.isSpanContextValid}});Object.defineProperty(e,\"isValidTraceId\",{enumerable:true,get:function(){return b.isValidTraceId}});Object.defineProperty(e,\"isValidSpanId\",{enumerable:true,get:function(){return b.isValidSpanId}});var v=__nccwpck_require__(476);Object.defineProperty(e,\"INVALID_SPANID\",{enumerable:true,get:function(){return v.INVALID_SPANID}});Object.defineProperty(e,\"INVALID_TRACEID\",{enumerable:true,get:function(){return v.INVALID_TRACEID}});Object.defineProperty(e,\"INVALID_SPAN_CONTEXT\",{enumerable:true,get:function(){return v.INVALID_SPAN_CONTEXT}});const O=__nccwpck_require__(67);Object.defineProperty(e,\"context\",{enumerable:true,get:function(){return O.context}});const P=__nccwpck_require__(506);Object.defineProperty(e,\"diag\",{enumerable:true,get:function(){return P.diag}});const N=__nccwpck_require__(886);Object.defineProperty(e,\"metrics\",{enumerable:true,get:function(){return N.metrics}});const S=__nccwpck_require__(939);Object.defineProperty(e,\"propagation\",{enumerable:true,get:function(){return S.propagation}});const C=__nccwpck_require__(845);Object.defineProperty(e,\"trace\",{enumerable:true,get:function(){return C.trace}});e[\"default\"]={context:O.context,diag:P.diag,metrics:N.metrics,propagation:S.propagation,trace:C.trace}})();module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL0BvcGVudGVsZW1ldHJ5L2FwaS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLHNDQUFzQyxXQUFXLEVBQUUsb0JBQW9CLGVBQWUsZUFBZSxlQUFlLGtCQUFrQixpQ0FBaUMsaUJBQWlCLGVBQWUscUJBQXFCLG9CQUFvQiw4QkFBOEIsc0JBQXNCLDJCQUEyQixxREFBcUQsU0FBUywwQ0FBMEMsaUJBQWlCLGtEQUFrRCxVQUFVLDJDQUEyQyxxQkFBcUIsNEJBQTRCLFVBQVUsb0NBQW9DLGdEQUFnRCx3QkFBd0IsZUFBZSxzQ0FBc0MsV0FBVyxFQUFFLGlCQUFpQixjQUFjLGVBQWUsZUFBZSxlQUFlLGVBQWUsY0FBYyxjQUFjLHNCQUFzQixzQkFBc0IsZ0NBQWdDLGFBQWEsbUJBQW1CLGFBQWEsc0JBQXNCLDZCQUE2QixJQUFJLFVBQVUsVUFBVSx3SkFBd0osb0RBQW9ELGFBQWEsd0JBQXdCLEdBQUcsWUFBWSxnQ0FBZ0Msa0dBQWtHLGtDQUFrQyxxRkFBcUYsa0RBQWtELEVBQUUsR0FBRyxvRUFBb0UsRUFBRSxHQUFHLDZDQUE2QyxzQkFBc0IsZUFBZSw2QkFBNkIsd0RBQXdELCtCQUErQiwyQkFBMkIseUJBQXlCLHlCQUF5QiwyQkFBMkIsa0JBQWtCLG9CQUFvQiwyQkFBMkIsdUJBQXVCLGtCQUFrQixlQUFlLHNDQUFzQyxXQUFXLEVBQUUsb0JBQW9CLGVBQWUsZUFBZSxlQUFlLGtCQUFrQixpQkFBaUIsZUFBZSxxQkFBcUIsb0JBQW9CLDhCQUE4QixzQkFBc0IsMEJBQTBCLHFEQUFxRCxtQkFBbUIsZ0RBQWdELGdCQUFnQiwrQ0FBK0MsVUFBVSxnREFBZ0Qsd0JBQXdCLGVBQWUsc0NBQXNDLFdBQVcsRUFBRSx3QkFBd0IsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsc0JBQXNCLG9DQUFvQyxxQkFBcUIsY0FBYyxtQ0FBbUMsNkJBQTZCLHlDQUF5Qyw2QkFBNkIsbUNBQW1DLHFCQUFxQixvQkFBb0Isa0NBQWtDLHNCQUFzQix1QkFBdUIscURBQXFELHFDQUFxQyxpREFBaUQsc0NBQXNDLGtEQUFrRCxTQUFTLDRDQUE0QyxVQUFVLCtDQUErQyx1QkFBdUIsNkJBQTZCLGdDQUFnQyxlQUFlLHNDQUFzQyxXQUFXLEVBQUUsa0JBQWtCLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxnQkFBZ0IsZUFBZSxjQUFjLG9EQUFvRCx1Q0FBdUMsNkNBQTZDLDZCQUE2Qix1QkFBdUIsbUNBQW1DLHFDQUFxQyx1QkFBdUIscUNBQXFDLHFCQUFxQixvQkFBb0IsNEJBQTRCLHNCQUFzQiwyQkFBMkIsK0VBQStFLE1BQU0seUNBQXlDLFNBQVMsb0JBQW9CLG9EQUFvRCxlQUFlLCtDQUErQyxVQUFVLCtDQUErQyxxREFBcUQsb0JBQW9CLGVBQWUsc0NBQXNDLFdBQVcsRUFBRSxvRUFBb0UsZUFBZSxlQUFlLDREQUE0RCx1QkFBdUIsZ0NBQWdDLHdCQUF3Qiw0QkFBNEIsdURBQXVELG9DQUFvQyx5QkFBeUIsdUJBQXVCLHdCQUF3QiwwQkFBMEIsd0JBQXdCLDhCQUE4QixhQUFhLHNDQUFzQyxXQUFXLEVBQUUscUJBQXFCLGtCQUFrQixlQUFlLG1DQUFtQyxZQUFZLDZCQUE2QixPQUFPLGlCQUFpQix1QkFBdUIsSUFBSSxnQkFBZ0IsaUVBQWlFLGNBQWMsdUNBQXVDLG9CQUFvQixTQUFTLGVBQWUsdUNBQXVDLHFCQUFxQixTQUFTLG9CQUFvQix1Q0FBdUMsa0JBQWtCLHFCQUFxQixTQUFTLFFBQVEsd0JBQXdCLDBCQUEwQixhQUFhLHNDQUFzQyxXQUFXLEVBQUUsb0NBQW9DLDREQUE0RCxlQUFlLHNDQUFzQyxXQUFXLEVBQUUsd0RBQXdELGVBQWUsZUFBZSxlQUFlLDZCQUE2QiwyQkFBMkIsRUFBRSxxREFBcUQsOEJBQThCLDJDQUEyQyx3QkFBd0IsNkRBQTZELFNBQVMsR0FBRyxLQUFLLE9BQU8saURBQWlELFdBQVcsZ0VBQWdFLGNBQWMsc0NBQXNDLFdBQVcsRUFBRSxpQkFBaUIsZUFBZSxxQ0FBcUMsZUFBZSxzQ0FBc0MsV0FBVyxFQUFFLDRCQUE0QixlQUFlLHlCQUF5QixTQUFTLHNCQUFzQixpQkFBaUIsc0JBQXNCLFVBQVUsU0FBUyxTQUFTLFlBQVksVUFBVSxhQUFhLHdDQUF3QyxhQUFhLHNDQUFzQyxXQUFXLEVBQUUseUNBQXlDLDZCQUE2QixxQkFBcUIsb0NBQW9DLGtCQUFrQixlQUFlLGFBQWEsdUNBQXVDLHVDQUF1QyxtQkFBbUIsMkNBQTJDLDJCQUEyQixVQUFVLGtCQUFrQiwyQ0FBMkMsNEJBQTRCLFdBQVcsK0JBQStCLGVBQWUsc0NBQXNDLFdBQVcsRUFBRSxjQUFjLGVBQWUsNEJBQTRCLGNBQWMsc0NBQXNDLFdBQVcsRUFBRSw2QkFBNkIsZUFBZSwwQkFBMEIsZUFBZSxtREFBbUQsWUFBWSwyQ0FBMkMsWUFBWSwyQ0FBMkMsV0FBVywwQ0FBMEMsV0FBVywwQ0FBMEMsY0FBYyw4Q0FBOEMsMENBQTBDLHlCQUF5QixnQ0FBZ0MsT0FBTyxPQUFPLGFBQWEsbUJBQW1CLGFBQWEsc0NBQXNDLFdBQVcsRUFBRSwyQkFBMkIsVUFBVSxvQkFBb0IsRUFBRSxrQkFBa0IsRUFBRSxrQkFBa0IsRUFBRSxvQkFBb0IsRUFBRSxzQkFBc0IsRUFBRSx3QkFBd0IsY0FBYyx5QkFBeUIsc0JBQXNCLFlBQVksaUJBQWlCLDBCQUEwQixjQUFjLDBCQUEwQiw2QkFBNkIsWUFBWSxXQUFXLEtBQUssb0NBQW9DLHNDQUFzQyxlQUFlLHNDQUFzQyxXQUFXLEVBQUUsa0NBQWtDLGVBQWUsdUNBQXVDLDBCQUEwQixzQkFBc0IsOEJBQThCLHFCQUFxQixRQUFRLDBCQUEwQixhQUFhLGdDQUFnQyxpQkFBaUIsb0JBQW9CLE9BQU8saVBBQWlQLG9EQUFvRCxhQUFhLHNDQUFzQyxXQUFXLEVBQUUsc0JBQXNCLE1BQU0sYUFBYSxzQkFBc0IseUJBQXlCLHVCQUF1Qix1QkFBdUIseUJBQXlCLDZCQUE2Qix1QkFBdUIsc0NBQXNDLEdBQUcsZUFBZSxzQ0FBc0MsV0FBVyxFQUFFLHVEQUF1RCxlQUFlLGVBQWUsZUFBZSxnQ0FBZ0MsMkNBQTJDLEVBQUUsR0FBRyxzQkFBc0IsdUNBQXVDLE1BQU0sNENBQTRDLG1CQUFtQixhQUFhLGtGQUFrRixFQUFFLEdBQUcsNEJBQTRCLGFBQWEsMEJBQTBCLGtFQUFrRSxXQUFXLE1BQU0sR0FBRyw0Q0FBNEMsVUFBVSxHQUFHLDRCQUE0QixhQUFhLE9BQU8sdURBQXVELEdBQUcsR0FBRyxVQUFVLElBQUksWUFBWSxnQ0FBZ0Msc0JBQXNCLFFBQVEscURBQXFELCtCQUErQixPQUFPLDhDQUE4QyxzQkFBc0IsK0JBQStCLDBEQUEwRCxHQUFHLEdBQUcsVUFBVSxJQUFJLGFBQWEsTUFBTSxhQUFhLG9DQUFvQyxlQUFlLHNDQUFzQyxXQUFXLEVBQUUsZ0RBQWdELGVBQWUsd0NBQXdDLG9DQUFvQyxxQkFBcUIsZ0JBQWdCLG1CQUFtQixPQUFPLGdCQUFnQixTQUFTLHFEQUFxRCx1QkFBdUIsZ0NBQWdDLGNBQWMsb0JBQW9CLFNBQVMsYUFBYSxvQkFBb0IsU0FBUyxZQUFZLGdDQUFnQyxhQUFhLFlBQVksYUFBYSxhQUFhLG1CQUFtQixPQUFPLGtCQUFrQixTQUFTLHFEQUFxRCx1QkFBdUIsa0JBQWtCLHNCQUFzQixrQkFBa0IsZ0JBQWdCLHdDQUF3QyxrQkFBa0Isa0JBQWtCLHFCQUFxQixrQkFBa0IsbUJBQW1CLGtEQUFrRCxrREFBa0QsZUFBZSxzQ0FBc0MsV0FBVyxFQUFFLGlCQUFpQixlQUFlLHFDQUFxQyxhQUFhLHNDQUFzQyxXQUFXLEVBQUUsbUJBQW1CLE1BQU0sYUFBYSxvQkFBb0IsMEJBQTBCLGdDQUFnQyxHQUFHLGFBQWEsc0NBQXNDLFdBQVcsRUFBRSw2YUFBNmEsZ0JBQWdCLGVBQWUscUJBQXFCLCtCQUErQixtQkFBbUIsNkJBQTZCLHlCQUF5QixxQ0FBcUMsMkJBQTJCLHNDQUFzQyw2QkFBNkIsd0NBQXdDLG1DQUFtQyxnREFBZ0QsaUNBQWlDLG1DQUFtQyxzQkFBc0Isa0JBQWtCLHdCQUF3QiwyQ0FBMkMsV0FBVyxzQ0FBc0MsaURBQWlELFdBQVcsa0RBQWtELDZDQUE2QyxjQUFjLDBDQUEwQywyQkFBMkIsZ0JBQWdCLG9CQUFvQiw0Q0FBNEMsZ0VBQWdFLDBEQUEwRCw4REFBOEQsc0RBQXNELHNFQUFzRSxzRUFBc0UsMkJBQTJCLDRDQUE0QyxnREFBZ0QsMERBQTBELGlFQUFpRSw2REFBNkQsK0VBQStFLDJCQUEyQixvQkFBb0Isa0NBQWtDLGVBQWUsc0NBQXNDLFdBQVcsRUFBRSxpREFBaUQsZUFBZSx3QkFBd0IsZ0JBQWdCLHFCQUFxQixzQ0FBc0MsNENBQTRDLHFCQUFxQixtRUFBbUUscUJBQXFCLDJCQUEyQiwrQkFBK0IsYUFBYSxFQUFFLG1CQUFtQixxQkFBcUIsVUFBVSxFQUFFLDZDQUE2QyxzRkFBc0Ysc0NBQXNDLFdBQVcsRUFBRSxXQUFXLGFBQWEsc0NBQXNDLFdBQVcsRUFBRSxxQkFBcUIsNkRBQTZELG9CQUFvQixtRUFBbUUscUJBQXFCLDJCQUEyQiwrQkFBK0IsYUFBYSxFQUFFLG1CQUFtQixxQkFBcUIsVUFBVSxFQUFFLDZDQUE2QyxzRkFBc0Ysc0NBQXNDLFdBQVcsRUFBRSxZQUFZLGVBQWUsc0NBQXNDLFdBQVcsRUFBRSxxQkFBcUIsZUFBZSw2Q0FBNkMsYUFBYSxzQ0FBc0MsV0FBVyxFQUFFLCtCQUErQiw0QkFBNEIsYUFBYSxhQUFhLFNBQVMsU0FBUyxVQUFVLDhDQUE4QyxhQUFhLHNDQUFzQyxXQUFXLEVBQUUscURBQXFELHdCQUF3QixTQUFTLFlBQVksaUJBQWlCLFlBQVksU0FBUyxZQUFZLFNBQVMsd0JBQXdCLHdCQUF3QixXQUFXLFlBQVksT0FBTyxTQUFTLGVBQWUsc0NBQXNDLFdBQVcsRUFBRSxlQUFlLGVBQWUsaUNBQWlDLGVBQWUsc0NBQXNDLFdBQVcsRUFBRSwwQkFBMEIsZUFBZSx1QkFBdUIsc0NBQXNDLG9CQUFvQixjQUFjLHlCQUF5QixrQkFBa0IsWUFBWSxpQkFBaUIsWUFBWSxjQUFjLFlBQVksYUFBYSxZQUFZLGNBQWMsWUFBWSxRQUFRLGNBQWMsYUFBYSx1QkFBdUIsb0NBQW9DLGVBQWUsc0NBQXNDLFdBQVcsRUFBRSxvQkFBb0IsZUFBZSxlQUFlLGVBQWUsZUFBZSxtQ0FBbUMsaUJBQWlCLDRCQUE0QixvREFBb0QsTUFBTSw4QkFBOEIsbUNBQW1DLGtEQUFrRCxpQ0FBaUMsS0FBSywrQkFBK0IseUJBQXlCLE1BQU0sTUFBTSxNQUFNLHVCQUF1QixPQUFPLDhCQUE4QixJQUFJLDhCQUE4QixJQUFJLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSwwQ0FBMEMsOEJBQThCLDJCQUEyQixnQ0FBZ0Msd0JBQXdCLDBCQUEwQiw4SEFBOEgsZUFBZSxzQ0FBc0MsV0FBVyxFQUFFLDRCQUE0QixlQUFlLHlCQUF5QixpQkFBaUIseUJBQXlCLHdDQUF3QyxlQUFlLHNDQUFzQyxXQUFXLEVBQUUscUJBQXFCLGVBQWUseUJBQXlCLGtCQUFrQixxQkFBcUIsaUJBQWlCLFlBQVksZUFBZSxlQUFlLGlCQUFpQiwwQ0FBMEMseUJBQXlCLDBCQUEwQixvREFBb0QsYUFBYSxtQkFBbUIsc0JBQXNCLDhFQUE4RSxPQUFPLFNBQVMsaUJBQWlCLHVCQUF1QiwwQkFBMEIsZUFBZSxzQ0FBc0MsV0FBVyxFQUFFLDZCQUE2QixlQUFlLGVBQWUsaUNBQWlDLDBCQUEwQixpQkFBaUIsTUFBTSwyRkFBMkYsY0FBYyxNQUFNLGdEQUFnRCxlQUFlLGlCQUFpQix5QkFBeUIsTUFBTSx1RUFBdUUsMENBQTBDLGFBQWEsc0NBQXNDLFdBQVcsRUFBRSwwQkFBMEIsTUFBTSxhQUFhLGtDQUFrQywwQkFBMEIsa0RBQWtELDhDQUE4QyxHQUFHLGVBQWUsc0NBQXNDLFdBQVcsRUFBRSwwRkFBMEYsZUFBZSxlQUFlLGVBQWUsaUVBQWlFLG9CQUFvQixnQ0FBZ0Msa0JBQWtCLHlCQUF5QixvREFBb0QsOEJBQThCLHNCQUFzQix1QkFBdUIsa0JBQWtCLHVCQUF1Qix3QkFBd0Isd0JBQXdCLDZCQUE2Qiw0Q0FBNEMsZ0NBQWdDLDJCQUEyQixNQUFNLCtEQUErRCxnQ0FBZ0MsZUFBZSxzQ0FBc0MsV0FBVyxFQUFFLHdCQUF3QixlQUFlLFdBQVcsWUFBWSxZQUFZLFlBQVkscUJBQXFCLGVBQWUsNEJBQTRCLG9CQUFvQixTQUFTLHNCQUFzQiw0QkFBNEIsMkJBQTJCLDBCQUEwQixTQUFTLFNBQVMsc0JBQXNCLDJCQUEyQixTQUFTLE9BQU8sa0NBQWtDLFlBQVksb0NBQW9DLHdCQUF3QixTQUFTLGNBQWMsVUFBVSxxQkFBcUIseURBQXlELGlCQUFpQixxQkFBcUIsV0FBVyxxQkFBcUIsOEJBQThCLGlEQUFpRCxXQUFXLE9BQU8sU0FBUyxXQUFXLCtCQUErQiw2RkFBNkYsUUFBUSx3REFBd0QsU0FBUywyQkFBMkIsOENBQThDLFVBQVUsZ0NBQWdDLGFBQWEsc0NBQXNDLFdBQVcsRUFBRSxxQ0FBcUMsdUJBQXVCLGdCQUFnQixHQUFHLE1BQU0sRUFBRSxtQkFBbUIsR0FBRyxNQUFNLFFBQVEsR0FBRyxLQUFLLEVBQUUsMEJBQTBCLEVBQUUsR0FBRyxFQUFFLEtBQUssZ0JBQWdCLE1BQU0sUUFBUSxjQUFjLHdCQUF3QixpQkFBaUIsMEJBQTBCLDBCQUEwQiw2QkFBNkIsOEJBQThCLGNBQWMsc0NBQXNDLFdBQVcsRUFBRSwwQkFBMEIsZUFBZSw2QkFBNkIsK0JBQStCLG9DQUFvQyxlQUFlLHNDQUFzQyxXQUFXLEVBQUUsaUVBQWlFLGVBQWUsb0NBQW9DLHFEQUFxRCx3QkFBd0IsZ0ZBQWdGLGFBQWEsc0NBQXNDLFdBQVcsRUFBRSxrQkFBa0IsTUFBTSxhQUFhLDhCQUE4QiwwQkFBMEIsMEJBQTBCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLEdBQUcsZUFBZSxzQ0FBc0MsV0FBVyxFQUFFLCtFQUErRSxlQUFlLGVBQWUsb0JBQW9CLEdBQUcsS0FBSyxtQkFBbUIsR0FBRyxJQUFJLDJCQUEyQix3Q0FBd0MsZ0NBQWdDLDBCQUEwQix1Q0FBdUMsOEJBQThCLCtCQUErQiwwREFBMEQsd0NBQXdDLDRCQUE0QixpQ0FBaUMsa0NBQWtDLGFBQWEsc0NBQXNDLFdBQVcsRUFBRSx3QkFBd0IsTUFBTSxhQUFhLHdCQUF3QixrQkFBa0Isd0JBQXdCLDBDQUEwQyxHQUFHLGFBQWEsc0NBQXNDLFdBQVcsRUFBRSxvQkFBb0IsTUFBTSxhQUFhLHNCQUFzQiw0QkFBNEIsa0NBQWtDLEdBQUcsYUFBYSxzQ0FBc0MsV0FBVyxFQUFFLGlCQUFpQixvQkFBb0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUkscURBQXFELFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLGlGQUFpRixTQUFTLE1BQU0sUUFBUSxzQ0FBc0MsV0FBVyxFQUFFLDZjQUE2YywrQkFBK0IsMERBQTBELCtCQUErQix5Q0FBeUMsRUFBRSwrQkFBK0IsNENBQTRDLCtCQUErQiwyQkFBMkIsRUFBRSx3Q0FBd0MsK0JBQStCLHVCQUF1QixFQUFFLCtCQUErQiw2Q0FBNkMsK0JBQStCLDRCQUE0QixFQUFFLCtCQUErQix3Q0FBd0MsK0JBQStCLHVCQUF1QixFQUFFLCtCQUErQiwyQ0FBMkMsK0JBQStCLDBCQUEwQixFQUFFLCtCQUErQixxQ0FBcUMsK0JBQStCLG9CQUFvQixFQUFFLCtCQUErQixnREFBZ0QsK0JBQStCLCtCQUErQixFQUFFLGdEQUFnRCwrQkFBK0IsK0JBQStCLEVBQUUsK0JBQStCLHVDQUF1QywrQkFBK0Isc0JBQXNCLEVBQUUsK0JBQStCLCtDQUErQywrQkFBK0IsOEJBQThCLEVBQUUsK0JBQStCLDRDQUE0QywrQkFBK0IsMkJBQTJCLEVBQUUsK0JBQStCLG9DQUFvQywrQkFBK0IsbUJBQW1CLEVBQUUsK0JBQStCLDBDQUEwQywrQkFBK0IseUJBQXlCLEVBQUUsK0JBQStCLHNDQUFzQywrQkFBK0IscUJBQXFCLEVBQUUsOEJBQThCLDRDQUE0QywrQkFBK0IsMkJBQTJCLEVBQUUsK0JBQStCLDhDQUE4QywrQkFBK0IsNkJBQTZCLEVBQUUsMENBQTBDLCtCQUErQix5QkFBeUIsRUFBRSx5Q0FBeUMsK0JBQStCLHdCQUF3QixFQUFFLCtCQUErQiwwQ0FBMEMsK0JBQStCLHlCQUF5QixFQUFFLDJDQUEyQywrQkFBK0IsMEJBQTBCLEVBQUUsZ0RBQWdELCtCQUErQiwrQkFBK0IsRUFBRSxnQ0FBZ0MsbUNBQW1DLCtCQUErQixrQkFBa0IsRUFBRSxpQ0FBaUMsZ0NBQWdDLCtCQUErQixlQUFlLEVBQUUsaUNBQWlDLG1DQUFtQywrQkFBK0Isa0JBQWtCLEVBQUUsaUNBQWlDLHVDQUF1QywrQkFBK0Isc0JBQXNCLEVBQUUsaUNBQWlDLGlDQUFpQywrQkFBK0IsZ0JBQWdCLEVBQUUsY0FBYyx5RkFBeUYsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxcQG9wZW50ZWxlbWV0cnlcXGFwaVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezQ5MTooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LkNvbnRleHRBUEk9dm9pZCAwO2NvbnN0IG49cigyMjMpO2NvbnN0IGE9cigxNzIpO2NvbnN0IG89cig5MzApO2NvbnN0IGk9XCJjb250ZXh0XCI7Y29uc3QgYz1uZXcgbi5Ob29wQ29udGV4dE1hbmFnZXI7Y2xhc3MgQ29udGV4dEFQSXtjb25zdHJ1Y3Rvcigpe31zdGF0aWMgZ2V0SW5zdGFuY2UoKXtpZighdGhpcy5faW5zdGFuY2Upe3RoaXMuX2luc3RhbmNlPW5ldyBDb250ZXh0QVBJfXJldHVybiB0aGlzLl9pbnN0YW5jZX1zZXRHbG9iYWxDb250ZXh0TWFuYWdlcihlKXtyZXR1cm4oMCxhLnJlZ2lzdGVyR2xvYmFsKShpLGUsby5EaWFnQVBJLmluc3RhbmNlKCkpfWFjdGl2ZSgpe3JldHVybiB0aGlzLl9nZXRDb250ZXh0TWFuYWdlcigpLmFjdGl2ZSgpfXdpdGgoZSx0LHIsLi4ubil7cmV0dXJuIHRoaXMuX2dldENvbnRleHRNYW5hZ2VyKCkud2l0aChlLHQsciwuLi5uKX1iaW5kKGUsdCl7cmV0dXJuIHRoaXMuX2dldENvbnRleHRNYW5hZ2VyKCkuYmluZChlLHQpfV9nZXRDb250ZXh0TWFuYWdlcigpe3JldHVybigwLGEuZ2V0R2xvYmFsKShpKXx8Y31kaXNhYmxlKCl7dGhpcy5fZ2V0Q29udGV4dE1hbmFnZXIoKS5kaXNhYmxlKCk7KDAsYS51bnJlZ2lzdGVyR2xvYmFsKShpLG8uRGlhZ0FQSS5pbnN0YW5jZSgpKX19dC5Db250ZXh0QVBJPUNvbnRleHRBUEl9LDkzMDooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LkRpYWdBUEk9dm9pZCAwO2NvbnN0IG49cig1Nik7Y29uc3QgYT1yKDkxMik7Y29uc3Qgbz1yKDk1Nyk7Y29uc3QgaT1yKDE3Mik7Y29uc3QgYz1cImRpYWdcIjtjbGFzcyBEaWFnQVBJe2NvbnN0cnVjdG9yKCl7ZnVuY3Rpb24gX2xvZ1Byb3h5KGUpe3JldHVybiBmdW5jdGlvbiguLi50KXtjb25zdCByPSgwLGkuZ2V0R2xvYmFsKShcImRpYWdcIik7aWYoIXIpcmV0dXJuO3JldHVybiByW2VdKC4uLnQpfX1jb25zdCBlPXRoaXM7Y29uc3Qgc2V0TG9nZ2VyPSh0LHI9e2xvZ0xldmVsOm8uRGlhZ0xvZ0xldmVsLklORk99KT0+e3ZhciBuLGMscztpZih0PT09ZSl7Y29uc3QgdD1uZXcgRXJyb3IoXCJDYW5ub3QgdXNlIGRpYWcgYXMgdGhlIGxvZ2dlciBmb3IgaXRzZWxmLiBQbGVhc2UgdXNlIGEgRGlhZ0xvZ2dlciBpbXBsZW1lbnRhdGlvbiBsaWtlIENvbnNvbGVEaWFnTG9nZ2VyIG9yIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uXCIpO2UuZXJyb3IoKG49dC5zdGFjaykhPT1udWxsJiZuIT09dm9pZCAwP246dC5tZXNzYWdlKTtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIHI9PT1cIm51bWJlclwiKXtyPXtsb2dMZXZlbDpyfX1jb25zdCB1PSgwLGkuZ2V0R2xvYmFsKShcImRpYWdcIik7Y29uc3QgbD0oMCxhLmNyZWF0ZUxvZ0xldmVsRGlhZ0xvZ2dlcikoKGM9ci5sb2dMZXZlbCkhPT1udWxsJiZjIT09dm9pZCAwP2M6by5EaWFnTG9nTGV2ZWwuSU5GTyx0KTtpZih1JiYhci5zdXBwcmVzc092ZXJyaWRlTWVzc2FnZSl7Y29uc3QgZT0ocz0obmV3IEVycm9yKS5zdGFjaykhPT1udWxsJiZzIT09dm9pZCAwP3M6XCI8ZmFpbGVkIHRvIGdlbmVyYXRlIHN0YWNrdHJhY2U+XCI7dS53YXJuKGBDdXJyZW50IGxvZ2dlciB3aWxsIGJlIG92ZXJ3cml0dGVuIGZyb20gJHtlfWApO2wud2FybihgQ3VycmVudCBsb2dnZXIgd2lsbCBvdmVyd3JpdGUgb25lIGFscmVhZHkgcmVnaXN0ZXJlZCBmcm9tICR7ZX1gKX1yZXR1cm4oMCxpLnJlZ2lzdGVyR2xvYmFsKShcImRpYWdcIixsLGUsdHJ1ZSl9O2Uuc2V0TG9nZ2VyPXNldExvZ2dlcjtlLmRpc2FibGU9KCk9PnsoMCxpLnVucmVnaXN0ZXJHbG9iYWwpKGMsZSl9O2UuY3JlYXRlQ29tcG9uZW50TG9nZ2VyPWU9Pm5ldyBuLkRpYWdDb21wb25lbnRMb2dnZXIoZSk7ZS52ZXJib3NlPV9sb2dQcm94eShcInZlcmJvc2VcIik7ZS5kZWJ1Zz1fbG9nUHJveHkoXCJkZWJ1Z1wiKTtlLmluZm89X2xvZ1Byb3h5KFwiaW5mb1wiKTtlLndhcm49X2xvZ1Byb3h5KFwid2FyblwiKTtlLmVycm9yPV9sb2dQcm94eShcImVycm9yXCIpfXN0YXRpYyBpbnN0YW5jZSgpe2lmKCF0aGlzLl9pbnN0YW5jZSl7dGhpcy5faW5zdGFuY2U9bmV3IERpYWdBUEl9cmV0dXJuIHRoaXMuX2luc3RhbmNlfX10LkRpYWdBUEk9RGlhZ0FQSX0sNjUzOihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuTWV0cmljc0FQST12b2lkIDA7Y29uc3Qgbj1yKDY2MCk7Y29uc3QgYT1yKDE3Mik7Y29uc3Qgbz1yKDkzMCk7Y29uc3QgaT1cIm1ldHJpY3NcIjtjbGFzcyBNZXRyaWNzQVBJe2NvbnN0cnVjdG9yKCl7fXN0YXRpYyBnZXRJbnN0YW5jZSgpe2lmKCF0aGlzLl9pbnN0YW5jZSl7dGhpcy5faW5zdGFuY2U9bmV3IE1ldHJpY3NBUEl9cmV0dXJuIHRoaXMuX2luc3RhbmNlfXNldEdsb2JhbE1ldGVyUHJvdmlkZXIoZSl7cmV0dXJuKDAsYS5yZWdpc3Rlckdsb2JhbCkoaSxlLG8uRGlhZ0FQSS5pbnN0YW5jZSgpKX1nZXRNZXRlclByb3ZpZGVyKCl7cmV0dXJuKDAsYS5nZXRHbG9iYWwpKGkpfHxuLk5PT1BfTUVURVJfUFJPVklERVJ9Z2V0TWV0ZXIoZSx0LHIpe3JldHVybiB0aGlzLmdldE1ldGVyUHJvdmlkZXIoKS5nZXRNZXRlcihlLHQscil9ZGlzYWJsZSgpeygwLGEudW5yZWdpc3Rlckdsb2JhbCkoaSxvLkRpYWdBUEkuaW5zdGFuY2UoKSl9fXQuTWV0cmljc0FQST1NZXRyaWNzQVBJfSwxODE6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5Qcm9wYWdhdGlvbkFQST12b2lkIDA7Y29uc3Qgbj1yKDE3Mik7Y29uc3QgYT1yKDg3NCk7Y29uc3Qgbz1yKDE5NCk7Y29uc3QgaT1yKDI3Nyk7Y29uc3QgYz1yKDM2OSk7Y29uc3Qgcz1yKDkzMCk7Y29uc3QgdT1cInByb3BhZ2F0aW9uXCI7Y29uc3QgbD1uZXcgYS5Ob29wVGV4dE1hcFByb3BhZ2F0b3I7Y2xhc3MgUHJvcGFnYXRpb25BUEl7Y29uc3RydWN0b3IoKXt0aGlzLmNyZWF0ZUJhZ2dhZ2U9Yy5jcmVhdGVCYWdnYWdlO3RoaXMuZ2V0QmFnZ2FnZT1pLmdldEJhZ2dhZ2U7dGhpcy5nZXRBY3RpdmVCYWdnYWdlPWkuZ2V0QWN0aXZlQmFnZ2FnZTt0aGlzLnNldEJhZ2dhZ2U9aS5zZXRCYWdnYWdlO3RoaXMuZGVsZXRlQmFnZ2FnZT1pLmRlbGV0ZUJhZ2dhZ2V9c3RhdGljIGdldEluc3RhbmNlKCl7aWYoIXRoaXMuX2luc3RhbmNlKXt0aGlzLl9pbnN0YW5jZT1uZXcgUHJvcGFnYXRpb25BUEl9cmV0dXJuIHRoaXMuX2luc3RhbmNlfXNldEdsb2JhbFByb3BhZ2F0b3IoZSl7cmV0dXJuKDAsbi5yZWdpc3Rlckdsb2JhbCkodSxlLHMuRGlhZ0FQSS5pbnN0YW5jZSgpKX1pbmplY3QoZSx0LHI9by5kZWZhdWx0VGV4dE1hcFNldHRlcil7cmV0dXJuIHRoaXMuX2dldEdsb2JhbFByb3BhZ2F0b3IoKS5pbmplY3QoZSx0LHIpfWV4dHJhY3QoZSx0LHI9by5kZWZhdWx0VGV4dE1hcEdldHRlcil7cmV0dXJuIHRoaXMuX2dldEdsb2JhbFByb3BhZ2F0b3IoKS5leHRyYWN0KGUsdCxyKX1maWVsZHMoKXtyZXR1cm4gdGhpcy5fZ2V0R2xvYmFsUHJvcGFnYXRvcigpLmZpZWxkcygpfWRpc2FibGUoKXsoMCxuLnVucmVnaXN0ZXJHbG9iYWwpKHUscy5EaWFnQVBJLmluc3RhbmNlKCkpfV9nZXRHbG9iYWxQcm9wYWdhdG9yKCl7cmV0dXJuKDAsbi5nZXRHbG9iYWwpKHUpfHxsfX10LlByb3BhZ2F0aW9uQVBJPVByb3BhZ2F0aW9uQVBJfSw5OTc6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5UcmFjZUFQST12b2lkIDA7Y29uc3Qgbj1yKDE3Mik7Y29uc3QgYT1yKDg0Nik7Y29uc3Qgbz1yKDEzOSk7Y29uc3QgaT1yKDYwNyk7Y29uc3QgYz1yKDkzMCk7Y29uc3Qgcz1cInRyYWNlXCI7Y2xhc3MgVHJhY2VBUEl7Y29uc3RydWN0b3IoKXt0aGlzLl9wcm94eVRyYWNlclByb3ZpZGVyPW5ldyBhLlByb3h5VHJhY2VyUHJvdmlkZXI7dGhpcy53cmFwU3BhbkNvbnRleHQ9by53cmFwU3BhbkNvbnRleHQ7dGhpcy5pc1NwYW5Db250ZXh0VmFsaWQ9by5pc1NwYW5Db250ZXh0VmFsaWQ7dGhpcy5kZWxldGVTcGFuPWkuZGVsZXRlU3Bhbjt0aGlzLmdldFNwYW49aS5nZXRTcGFuO3RoaXMuZ2V0QWN0aXZlU3Bhbj1pLmdldEFjdGl2ZVNwYW47dGhpcy5nZXRTcGFuQ29udGV4dD1pLmdldFNwYW5Db250ZXh0O3RoaXMuc2V0U3Bhbj1pLnNldFNwYW47dGhpcy5zZXRTcGFuQ29udGV4dD1pLnNldFNwYW5Db250ZXh0fXN0YXRpYyBnZXRJbnN0YW5jZSgpe2lmKCF0aGlzLl9pbnN0YW5jZSl7dGhpcy5faW5zdGFuY2U9bmV3IFRyYWNlQVBJfXJldHVybiB0aGlzLl9pbnN0YW5jZX1zZXRHbG9iYWxUcmFjZXJQcm92aWRlcihlKXtjb25zdCB0PSgwLG4ucmVnaXN0ZXJHbG9iYWwpKHMsdGhpcy5fcHJveHlUcmFjZXJQcm92aWRlcixjLkRpYWdBUEkuaW5zdGFuY2UoKSk7aWYodCl7dGhpcy5fcHJveHlUcmFjZXJQcm92aWRlci5zZXREZWxlZ2F0ZShlKX1yZXR1cm4gdH1nZXRUcmFjZXJQcm92aWRlcigpe3JldHVybigwLG4uZ2V0R2xvYmFsKShzKXx8dGhpcy5fcHJveHlUcmFjZXJQcm92aWRlcn1nZXRUcmFjZXIoZSx0KXtyZXR1cm4gdGhpcy5nZXRUcmFjZXJQcm92aWRlcigpLmdldFRyYWNlcihlLHQpfWRpc2FibGUoKXsoMCxuLnVucmVnaXN0ZXJHbG9iYWwpKHMsYy5EaWFnQVBJLmluc3RhbmNlKCkpO3RoaXMuX3Byb3h5VHJhY2VyUHJvdmlkZXI9bmV3IGEuUHJveHlUcmFjZXJQcm92aWRlcn19dC5UcmFjZUFQST1UcmFjZUFQSX0sMjc3OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuZGVsZXRlQmFnZ2FnZT10LnNldEJhZ2dhZ2U9dC5nZXRBY3RpdmVCYWdnYWdlPXQuZ2V0QmFnZ2FnZT12b2lkIDA7Y29uc3Qgbj1yKDQ5MSk7Y29uc3QgYT1yKDc4MCk7Y29uc3Qgbz0oMCxhLmNyZWF0ZUNvbnRleHRLZXkpKFwiT3BlblRlbGVtZXRyeSBCYWdnYWdlIEtleVwiKTtmdW5jdGlvbiBnZXRCYWdnYWdlKGUpe3JldHVybiBlLmdldFZhbHVlKG8pfHx1bmRlZmluZWR9dC5nZXRCYWdnYWdlPWdldEJhZ2dhZ2U7ZnVuY3Rpb24gZ2V0QWN0aXZlQmFnZ2FnZSgpe3JldHVybiBnZXRCYWdnYWdlKG4uQ29udGV4dEFQSS5nZXRJbnN0YW5jZSgpLmFjdGl2ZSgpKX10LmdldEFjdGl2ZUJhZ2dhZ2U9Z2V0QWN0aXZlQmFnZ2FnZTtmdW5jdGlvbiBzZXRCYWdnYWdlKGUsdCl7cmV0dXJuIGUuc2V0VmFsdWUobyx0KX10LnNldEJhZ2dhZ2U9c2V0QmFnZ2FnZTtmdW5jdGlvbiBkZWxldGVCYWdnYWdlKGUpe3JldHVybiBlLmRlbGV0ZVZhbHVlKG8pfXQuZGVsZXRlQmFnZ2FnZT1kZWxldGVCYWdnYWdlfSw5OTM6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuQmFnZ2FnZUltcGw9dm9pZCAwO2NsYXNzIEJhZ2dhZ2VJbXBse2NvbnN0cnVjdG9yKGUpe3RoaXMuX2VudHJpZXM9ZT9uZXcgTWFwKGUpOm5ldyBNYXB9Z2V0RW50cnkoZSl7Y29uc3QgdD10aGlzLl9lbnRyaWVzLmdldChlKTtpZighdCl7cmV0dXJuIHVuZGVmaW5lZH1yZXR1cm4gT2JqZWN0LmFzc2lnbih7fSx0KX1nZXRBbGxFbnRyaWVzKCl7cmV0dXJuIEFycmF5LmZyb20odGhpcy5fZW50cmllcy5lbnRyaWVzKCkpLm1hcCgoKFtlLHRdKT0+W2UsdF0pKX1zZXRFbnRyeShlLHQpe2NvbnN0IHI9bmV3IEJhZ2dhZ2VJbXBsKHRoaXMuX2VudHJpZXMpO3IuX2VudHJpZXMuc2V0KGUsdCk7cmV0dXJuIHJ9cmVtb3ZlRW50cnkoZSl7Y29uc3QgdD1uZXcgQmFnZ2FnZUltcGwodGhpcy5fZW50cmllcyk7dC5fZW50cmllcy5kZWxldGUoZSk7cmV0dXJuIHR9cmVtb3ZlRW50cmllcyguLi5lKXtjb25zdCB0PW5ldyBCYWdnYWdlSW1wbCh0aGlzLl9lbnRyaWVzKTtmb3IoY29uc3QgciBvZiBlKXt0Ll9lbnRyaWVzLmRlbGV0ZShyKX1yZXR1cm4gdH1jbGVhcigpe3JldHVybiBuZXcgQmFnZ2FnZUltcGx9fXQuQmFnZ2FnZUltcGw9QmFnZ2FnZUltcGx9LDgzMDooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5iYWdnYWdlRW50cnlNZXRhZGF0YVN5bWJvbD12b2lkIDA7dC5iYWdnYWdlRW50cnlNZXRhZGF0YVN5bWJvbD1TeW1ib2woXCJCYWdnYWdlRW50cnlNZXRhZGF0YVwiKX0sMzY5OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuYmFnZ2FnZUVudHJ5TWV0YWRhdGFGcm9tU3RyaW5nPXQuY3JlYXRlQmFnZ2FnZT12b2lkIDA7Y29uc3Qgbj1yKDkzMCk7Y29uc3QgYT1yKDk5Myk7Y29uc3Qgbz1yKDgzMCk7Y29uc3QgaT1uLkRpYWdBUEkuaW5zdGFuY2UoKTtmdW5jdGlvbiBjcmVhdGVCYWdnYWdlKGU9e30pe3JldHVybiBuZXcgYS5CYWdnYWdlSW1wbChuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGUpKSl9dC5jcmVhdGVCYWdnYWdlPWNyZWF0ZUJhZ2dhZ2U7ZnVuY3Rpb24gYmFnZ2FnZUVudHJ5TWV0YWRhdGFGcm9tU3RyaW5nKGUpe2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7aS5lcnJvcihgQ2Fubm90IGNyZWF0ZSBiYWdnYWdlIG1ldGFkYXRhIGZyb20gdW5rbm93biB0eXBlOiAke3R5cGVvZiBlfWApO2U9XCJcIn1yZXR1cm57X19UWVBFX186by5iYWdnYWdlRW50cnlNZXRhZGF0YVN5bWJvbCx0b1N0cmluZygpe3JldHVybiBlfX19dC5iYWdnYWdlRW50cnlNZXRhZGF0YUZyb21TdHJpbmc9YmFnZ2FnZUVudHJ5TWV0YWRhdGFGcm9tU3RyaW5nfSw2NzooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LmNvbnRleHQ9dm9pZCAwO2NvbnN0IG49cig0OTEpO3QuY29udGV4dD1uLkNvbnRleHRBUEkuZ2V0SW5zdGFuY2UoKX0sMjIzOihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuTm9vcENvbnRleHRNYW5hZ2VyPXZvaWQgMDtjb25zdCBuPXIoNzgwKTtjbGFzcyBOb29wQ29udGV4dE1hbmFnZXJ7YWN0aXZlKCl7cmV0dXJuIG4uUk9PVF9DT05URVhUfXdpdGgoZSx0LHIsLi4ubil7cmV0dXJuIHQuY2FsbChyLC4uLm4pfWJpbmQoZSx0KXtyZXR1cm4gdH1lbmFibGUoKXtyZXR1cm4gdGhpc31kaXNhYmxlKCl7cmV0dXJuIHRoaXN9fXQuTm9vcENvbnRleHRNYW5hZ2VyPU5vb3BDb250ZXh0TWFuYWdlcn0sNzgwOihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LlJPT1RfQ09OVEVYVD10LmNyZWF0ZUNvbnRleHRLZXk9dm9pZCAwO2Z1bmN0aW9uIGNyZWF0ZUNvbnRleHRLZXkoZSl7cmV0dXJuIFN5bWJvbC5mb3IoZSl9dC5jcmVhdGVDb250ZXh0S2V5PWNyZWF0ZUNvbnRleHRLZXk7Y2xhc3MgQmFzZUNvbnRleHR7Y29uc3RydWN0b3IoZSl7Y29uc3QgdD10aGlzO3QuX2N1cnJlbnRDb250ZXh0PWU/bmV3IE1hcChlKTpuZXcgTWFwO3QuZ2V0VmFsdWU9ZT0+dC5fY3VycmVudENvbnRleHQuZ2V0KGUpO3Quc2V0VmFsdWU9KGUscik9Pntjb25zdCBuPW5ldyBCYXNlQ29udGV4dCh0Ll9jdXJyZW50Q29udGV4dCk7bi5fY3VycmVudENvbnRleHQuc2V0KGUscik7cmV0dXJuIG59O3QuZGVsZXRlVmFsdWU9ZT0+e2NvbnN0IHI9bmV3IEJhc2VDb250ZXh0KHQuX2N1cnJlbnRDb250ZXh0KTtyLl9jdXJyZW50Q29udGV4dC5kZWxldGUoZSk7cmV0dXJuIHJ9fX10LlJPT1RfQ09OVEVYVD1uZXcgQmFzZUNvbnRleHR9LDUwNjooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LmRpYWc9dm9pZCAwO2NvbnN0IG49cig5MzApO3QuZGlhZz1uLkRpYWdBUEkuaW5zdGFuY2UoKX0sNTY6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5EaWFnQ29tcG9uZW50TG9nZ2VyPXZvaWQgMDtjb25zdCBuPXIoMTcyKTtjbGFzcyBEaWFnQ29tcG9uZW50TG9nZ2Vye2NvbnN0cnVjdG9yKGUpe3RoaXMuX25hbWVzcGFjZT1lLm5hbWVzcGFjZXx8XCJEaWFnQ29tcG9uZW50TG9nZ2VyXCJ9ZGVidWcoLi4uZSl7cmV0dXJuIGxvZ1Byb3h5KFwiZGVidWdcIix0aGlzLl9uYW1lc3BhY2UsZSl9ZXJyb3IoLi4uZSl7cmV0dXJuIGxvZ1Byb3h5KFwiZXJyb3JcIix0aGlzLl9uYW1lc3BhY2UsZSl9aW5mbyguLi5lKXtyZXR1cm4gbG9nUHJveHkoXCJpbmZvXCIsdGhpcy5fbmFtZXNwYWNlLGUpfXdhcm4oLi4uZSl7cmV0dXJuIGxvZ1Byb3h5KFwid2FyblwiLHRoaXMuX25hbWVzcGFjZSxlKX12ZXJib3NlKC4uLmUpe3JldHVybiBsb2dQcm94eShcInZlcmJvc2VcIix0aGlzLl9uYW1lc3BhY2UsZSl9fXQuRGlhZ0NvbXBvbmVudExvZ2dlcj1EaWFnQ29tcG9uZW50TG9nZ2VyO2Z1bmN0aW9uIGxvZ1Byb3h5KGUsdCxyKXtjb25zdCBhPSgwLG4uZ2V0R2xvYmFsKShcImRpYWdcIik7aWYoIWEpe3JldHVybn1yLnVuc2hpZnQodCk7cmV0dXJuIGFbZV0oLi4ucil9fSw5NzI6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuRGlhZ0NvbnNvbGVMb2dnZXI9dm9pZCAwO2NvbnN0IHI9W3tuOlwiZXJyb3JcIixjOlwiZXJyb3JcIn0se246XCJ3YXJuXCIsYzpcIndhcm5cIn0se246XCJpbmZvXCIsYzpcImluZm9cIn0se246XCJkZWJ1Z1wiLGM6XCJkZWJ1Z1wifSx7bjpcInZlcmJvc2VcIixjOlwidHJhY2VcIn1dO2NsYXNzIERpYWdDb25zb2xlTG9nZ2Vye2NvbnN0cnVjdG9yKCl7ZnVuY3Rpb24gX2NvbnNvbGVGdW5jKGUpe3JldHVybiBmdW5jdGlvbiguLi50KXtpZihjb25zb2xlKXtsZXQgcj1jb25zb2xlW2VdO2lmKHR5cGVvZiByIT09XCJmdW5jdGlvblwiKXtyPWNvbnNvbGUubG9nfWlmKHR5cGVvZiByPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gci5hcHBseShjb25zb2xlLHQpfX19fWZvcihsZXQgZT0wO2U8ci5sZW5ndGg7ZSsrKXt0aGlzW3JbZV0ubl09X2NvbnNvbGVGdW5jKHJbZV0uYyl9fX10LkRpYWdDb25zb2xlTG9nZ2VyPURpYWdDb25zb2xlTG9nZ2VyfSw5MTI6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5jcmVhdGVMb2dMZXZlbERpYWdMb2dnZXI9dm9pZCAwO2NvbnN0IG49cig5NTcpO2Z1bmN0aW9uIGNyZWF0ZUxvZ0xldmVsRGlhZ0xvZ2dlcihlLHQpe2lmKGU8bi5EaWFnTG9nTGV2ZWwuTk9ORSl7ZT1uLkRpYWdMb2dMZXZlbC5OT05FfWVsc2UgaWYoZT5uLkRpYWdMb2dMZXZlbC5BTEwpe2U9bi5EaWFnTG9nTGV2ZWwuQUxMfXQ9dHx8e307ZnVuY3Rpb24gX2ZpbHRlckZ1bmMocixuKXtjb25zdCBhPXRbcl07aWYodHlwZW9mIGE9PT1cImZ1bmN0aW9uXCImJmU+PW4pe3JldHVybiBhLmJpbmQodCl9cmV0dXJuIGZ1bmN0aW9uKCl7fX1yZXR1cm57ZXJyb3I6X2ZpbHRlckZ1bmMoXCJlcnJvclwiLG4uRGlhZ0xvZ0xldmVsLkVSUk9SKSx3YXJuOl9maWx0ZXJGdW5jKFwid2FyblwiLG4uRGlhZ0xvZ0xldmVsLldBUk4pLGluZm86X2ZpbHRlckZ1bmMoXCJpbmZvXCIsbi5EaWFnTG9nTGV2ZWwuSU5GTyksZGVidWc6X2ZpbHRlckZ1bmMoXCJkZWJ1Z1wiLG4uRGlhZ0xvZ0xldmVsLkRFQlVHKSx2ZXJib3NlOl9maWx0ZXJGdW5jKFwidmVyYm9zZVwiLG4uRGlhZ0xvZ0xldmVsLlZFUkJPU0UpfX10LmNyZWF0ZUxvZ0xldmVsRGlhZ0xvZ2dlcj1jcmVhdGVMb2dMZXZlbERpYWdMb2dnZXJ9LDk1NzooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5EaWFnTG9nTGV2ZWw9dm9pZCAwO3ZhciByOyhmdW5jdGlvbihlKXtlW2VbXCJOT05FXCJdPTBdPVwiTk9ORVwiO2VbZVtcIkVSUk9SXCJdPTMwXT1cIkVSUk9SXCI7ZVtlW1wiV0FSTlwiXT01MF09XCJXQVJOXCI7ZVtlW1wiSU5GT1wiXT02MF09XCJJTkZPXCI7ZVtlW1wiREVCVUdcIl09NzBdPVwiREVCVUdcIjtlW2VbXCJWRVJCT1NFXCJdPTgwXT1cIlZFUkJPU0VcIjtlW2VbXCJBTExcIl09OTk5OV09XCJBTExcIn0pKHI9dC5EaWFnTG9nTGV2ZWx8fCh0LkRpYWdMb2dMZXZlbD17fSkpfSwxNzI6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC51bnJlZ2lzdGVyR2xvYmFsPXQuZ2V0R2xvYmFsPXQucmVnaXN0ZXJHbG9iYWw9dm9pZCAwO2NvbnN0IG49cigyMDApO2NvbnN0IGE9cig1MjEpO2NvbnN0IG89cigxMzApO2NvbnN0IGk9YS5WRVJTSU9OLnNwbGl0KFwiLlwiKVswXTtjb25zdCBjPVN5bWJvbC5mb3IoYG9wZW50ZWxlbWV0cnkuanMuYXBpLiR7aX1gKTtjb25zdCBzPW4uX2dsb2JhbFRoaXM7ZnVuY3Rpb24gcmVnaXN0ZXJHbG9iYWwoZSx0LHIsbj1mYWxzZSl7dmFyIG87Y29uc3QgaT1zW2NdPShvPXNbY10pIT09bnVsbCYmbyE9PXZvaWQgMD9vOnt2ZXJzaW9uOmEuVkVSU0lPTn07aWYoIW4mJmlbZV0pe2NvbnN0IHQ9bmV3IEVycm9yKGBAb3BlbnRlbGVtZXRyeS9hcGk6IEF0dGVtcHRlZCBkdXBsaWNhdGUgcmVnaXN0cmF0aW9uIG9mIEFQSTogJHtlfWApO3IuZXJyb3IodC5zdGFja3x8dC5tZXNzYWdlKTtyZXR1cm4gZmFsc2V9aWYoaS52ZXJzaW9uIT09YS5WRVJTSU9OKXtjb25zdCB0PW5ldyBFcnJvcihgQG9wZW50ZWxlbWV0cnkvYXBpOiBSZWdpc3RyYXRpb24gb2YgdmVyc2lvbiB2JHtpLnZlcnNpb259IGZvciAke2V9IGRvZXMgbm90IG1hdGNoIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBBUEkgdiR7YS5WRVJTSU9OfWApO3IuZXJyb3IodC5zdGFja3x8dC5tZXNzYWdlKTtyZXR1cm4gZmFsc2V9aVtlXT10O3IuZGVidWcoYEBvcGVudGVsZW1ldHJ5L2FwaTogUmVnaXN0ZXJlZCBhIGdsb2JhbCBmb3IgJHtlfSB2JHthLlZFUlNJT059LmApO3JldHVybiB0cnVlfXQucmVnaXN0ZXJHbG9iYWw9cmVnaXN0ZXJHbG9iYWw7ZnVuY3Rpb24gZ2V0R2xvYmFsKGUpe3ZhciB0LHI7Y29uc3Qgbj0odD1zW2NdKT09PW51bGx8fHQ9PT12b2lkIDA/dm9pZCAwOnQudmVyc2lvbjtpZighbnx8ISgwLG8uaXNDb21wYXRpYmxlKShuKSl7cmV0dXJufXJldHVybihyPXNbY10pPT09bnVsbHx8cj09PXZvaWQgMD92b2lkIDA6cltlXX10LmdldEdsb2JhbD1nZXRHbG9iYWw7ZnVuY3Rpb24gdW5yZWdpc3Rlckdsb2JhbChlLHQpe3QuZGVidWcoYEBvcGVudGVsZW1ldHJ5L2FwaTogVW5yZWdpc3RlcmluZyBhIGdsb2JhbCBmb3IgJHtlfSB2JHthLlZFUlNJT059LmApO2NvbnN0IHI9c1tjXTtpZihyKXtkZWxldGUgcltlXX19dC51bnJlZ2lzdGVyR2xvYmFsPXVucmVnaXN0ZXJHbG9iYWx9LDEzMDooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LmlzQ29tcGF0aWJsZT10Ll9tYWtlQ29tcGF0aWJpbGl0eUNoZWNrPXZvaWQgMDtjb25zdCBuPXIoNTIxKTtjb25zdCBhPS9eKFxcZCspXFwuKFxcZCspXFwuKFxcZCspKC0oLispKT8kLztmdW5jdGlvbiBfbWFrZUNvbXBhdGliaWxpdHlDaGVjayhlKXtjb25zdCB0PW5ldyBTZXQoW2VdKTtjb25zdCByPW5ldyBTZXQ7Y29uc3Qgbj1lLm1hdGNoKGEpO2lmKCFuKXtyZXR1cm4oKT0+ZmFsc2V9Y29uc3Qgbz17bWFqb3I6K25bMV0sbWlub3I6K25bMl0scGF0Y2g6K25bM10scHJlcmVsZWFzZTpuWzRdfTtpZihvLnByZXJlbGVhc2UhPW51bGwpe3JldHVybiBmdW5jdGlvbiBpc0V4YWN0bWF0Y2godCl7cmV0dXJuIHQ9PT1lfX1mdW5jdGlvbiBfcmVqZWN0KGUpe3IuYWRkKGUpO3JldHVybiBmYWxzZX1mdW5jdGlvbiBfYWNjZXB0KGUpe3QuYWRkKGUpO3JldHVybiB0cnVlfXJldHVybiBmdW5jdGlvbiBpc0NvbXBhdGlibGUoZSl7aWYodC5oYXMoZSkpe3JldHVybiB0cnVlfWlmKHIuaGFzKGUpKXtyZXR1cm4gZmFsc2V9Y29uc3Qgbj1lLm1hdGNoKGEpO2lmKCFuKXtyZXR1cm4gX3JlamVjdChlKX1jb25zdCBpPXttYWpvcjorblsxXSxtaW5vcjorblsyXSxwYXRjaDorblszXSxwcmVyZWxlYXNlOm5bNF19O2lmKGkucHJlcmVsZWFzZSE9bnVsbCl7cmV0dXJuIF9yZWplY3QoZSl9aWYoby5tYWpvciE9PWkubWFqb3Ipe3JldHVybiBfcmVqZWN0KGUpfWlmKG8ubWFqb3I9PT0wKXtpZihvLm1pbm9yPT09aS5taW5vciYmby5wYXRjaDw9aS5wYXRjaCl7cmV0dXJuIF9hY2NlcHQoZSl9cmV0dXJuIF9yZWplY3QoZSl9aWYoby5taW5vcjw9aS5taW5vcil7cmV0dXJuIF9hY2NlcHQoZSl9cmV0dXJuIF9yZWplY3QoZSl9fXQuX21ha2VDb21wYXRpYmlsaXR5Q2hlY2s9X21ha2VDb21wYXRpYmlsaXR5Q2hlY2s7dC5pc0NvbXBhdGlibGU9X21ha2VDb21wYXRpYmlsaXR5Q2hlY2sobi5WRVJTSU9OKX0sODg2OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QubWV0cmljcz12b2lkIDA7Y29uc3Qgbj1yKDY1Myk7dC5tZXRyaWNzPW4uTWV0cmljc0FQSS5nZXRJbnN0YW5jZSgpfSw5MDE6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuVmFsdWVUeXBlPXZvaWQgMDt2YXIgcjsoZnVuY3Rpb24oZSl7ZVtlW1wiSU5UXCJdPTBdPVwiSU5UXCI7ZVtlW1wiRE9VQkxFXCJdPTFdPVwiRE9VQkxFXCJ9KShyPXQuVmFsdWVUeXBlfHwodC5WYWx1ZVR5cGU9e30pKX0sMTAyOihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LmNyZWF0ZU5vb3BNZXRlcj10Lk5PT1BfT0JTRVJWQUJMRV9VUF9ET1dOX0NPVU5URVJfTUVUUklDPXQuTk9PUF9PQlNFUlZBQkxFX0dBVUdFX01FVFJJQz10Lk5PT1BfT0JTRVJWQUJMRV9DT1VOVEVSX01FVFJJQz10Lk5PT1BfVVBfRE9XTl9DT1VOVEVSX01FVFJJQz10Lk5PT1BfSElTVE9HUkFNX01FVFJJQz10Lk5PT1BfQ09VTlRFUl9NRVRSSUM9dC5OT09QX01FVEVSPXQuTm9vcE9ic2VydmFibGVVcERvd25Db3VudGVyTWV0cmljPXQuTm9vcE9ic2VydmFibGVHYXVnZU1ldHJpYz10Lk5vb3BPYnNlcnZhYmxlQ291bnRlck1ldHJpYz10Lk5vb3BPYnNlcnZhYmxlTWV0cmljPXQuTm9vcEhpc3RvZ3JhbU1ldHJpYz10Lk5vb3BVcERvd25Db3VudGVyTWV0cmljPXQuTm9vcENvdW50ZXJNZXRyaWM9dC5Ob29wTWV0cmljPXQuTm9vcE1ldGVyPXZvaWQgMDtjbGFzcyBOb29wTWV0ZXJ7Y29uc3RydWN0b3IoKXt9Y3JlYXRlSGlzdG9ncmFtKGUscil7cmV0dXJuIHQuTk9PUF9ISVNUT0dSQU1fTUVUUklDfWNyZWF0ZUNvdW50ZXIoZSxyKXtyZXR1cm4gdC5OT09QX0NPVU5URVJfTUVUUklDfWNyZWF0ZVVwRG93bkNvdW50ZXIoZSxyKXtyZXR1cm4gdC5OT09QX1VQX0RPV05fQ09VTlRFUl9NRVRSSUN9Y3JlYXRlT2JzZXJ2YWJsZUdhdWdlKGUscil7cmV0dXJuIHQuTk9PUF9PQlNFUlZBQkxFX0dBVUdFX01FVFJJQ31jcmVhdGVPYnNlcnZhYmxlQ291bnRlcihlLHIpe3JldHVybiB0Lk5PT1BfT0JTRVJWQUJMRV9DT1VOVEVSX01FVFJJQ31jcmVhdGVPYnNlcnZhYmxlVXBEb3duQ291bnRlcihlLHIpe3JldHVybiB0Lk5PT1BfT0JTRVJWQUJMRV9VUF9ET1dOX0NPVU5URVJfTUVUUklDfWFkZEJhdGNoT2JzZXJ2YWJsZUNhbGxiYWNrKGUsdCl7fXJlbW92ZUJhdGNoT2JzZXJ2YWJsZUNhbGxiYWNrKGUpe319dC5Ob29wTWV0ZXI9Tm9vcE1ldGVyO2NsYXNzIE5vb3BNZXRyaWN7fXQuTm9vcE1ldHJpYz1Ob29wTWV0cmljO2NsYXNzIE5vb3BDb3VudGVyTWV0cmljIGV4dGVuZHMgTm9vcE1ldHJpY3thZGQoZSx0KXt9fXQuTm9vcENvdW50ZXJNZXRyaWM9Tm9vcENvdW50ZXJNZXRyaWM7Y2xhc3MgTm9vcFVwRG93bkNvdW50ZXJNZXRyaWMgZXh0ZW5kcyBOb29wTWV0cmlje2FkZChlLHQpe319dC5Ob29wVXBEb3duQ291bnRlck1ldHJpYz1Ob29wVXBEb3duQ291bnRlck1ldHJpYztjbGFzcyBOb29wSGlzdG9ncmFtTWV0cmljIGV4dGVuZHMgTm9vcE1ldHJpY3tyZWNvcmQoZSx0KXt9fXQuTm9vcEhpc3RvZ3JhbU1ldHJpYz1Ob29wSGlzdG9ncmFtTWV0cmljO2NsYXNzIE5vb3BPYnNlcnZhYmxlTWV0cmlje2FkZENhbGxiYWNrKGUpe31yZW1vdmVDYWxsYmFjayhlKXt9fXQuTm9vcE9ic2VydmFibGVNZXRyaWM9Tm9vcE9ic2VydmFibGVNZXRyaWM7Y2xhc3MgTm9vcE9ic2VydmFibGVDb3VudGVyTWV0cmljIGV4dGVuZHMgTm9vcE9ic2VydmFibGVNZXRyaWN7fXQuTm9vcE9ic2VydmFibGVDb3VudGVyTWV0cmljPU5vb3BPYnNlcnZhYmxlQ291bnRlck1ldHJpYztjbGFzcyBOb29wT2JzZXJ2YWJsZUdhdWdlTWV0cmljIGV4dGVuZHMgTm9vcE9ic2VydmFibGVNZXRyaWN7fXQuTm9vcE9ic2VydmFibGVHYXVnZU1ldHJpYz1Ob29wT2JzZXJ2YWJsZUdhdWdlTWV0cmljO2NsYXNzIE5vb3BPYnNlcnZhYmxlVXBEb3duQ291bnRlck1ldHJpYyBleHRlbmRzIE5vb3BPYnNlcnZhYmxlTWV0cmlje310Lk5vb3BPYnNlcnZhYmxlVXBEb3duQ291bnRlck1ldHJpYz1Ob29wT2JzZXJ2YWJsZVVwRG93bkNvdW50ZXJNZXRyaWM7dC5OT09QX01FVEVSPW5ldyBOb29wTWV0ZXI7dC5OT09QX0NPVU5URVJfTUVUUklDPW5ldyBOb29wQ291bnRlck1ldHJpYzt0Lk5PT1BfSElTVE9HUkFNX01FVFJJQz1uZXcgTm9vcEhpc3RvZ3JhbU1ldHJpYzt0Lk5PT1BfVVBfRE9XTl9DT1VOVEVSX01FVFJJQz1uZXcgTm9vcFVwRG93bkNvdW50ZXJNZXRyaWM7dC5OT09QX09CU0VSVkFCTEVfQ09VTlRFUl9NRVRSSUM9bmV3IE5vb3BPYnNlcnZhYmxlQ291bnRlck1ldHJpYzt0Lk5PT1BfT0JTRVJWQUJMRV9HQVVHRV9NRVRSSUM9bmV3IE5vb3BPYnNlcnZhYmxlR2F1Z2VNZXRyaWM7dC5OT09QX09CU0VSVkFCTEVfVVBfRE9XTl9DT1VOVEVSX01FVFJJQz1uZXcgTm9vcE9ic2VydmFibGVVcERvd25Db3VudGVyTWV0cmljO2Z1bmN0aW9uIGNyZWF0ZU5vb3BNZXRlcigpe3JldHVybiB0Lk5PT1BfTUVURVJ9dC5jcmVhdGVOb29wTWV0ZXI9Y3JlYXRlTm9vcE1ldGVyfSw2NjA6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5OT09QX01FVEVSX1BST1ZJREVSPXQuTm9vcE1ldGVyUHJvdmlkZXI9dm9pZCAwO2NvbnN0IG49cigxMDIpO2NsYXNzIE5vb3BNZXRlclByb3ZpZGVye2dldE1ldGVyKGUsdCxyKXtyZXR1cm4gbi5OT09QX01FVEVSfX10Lk5vb3BNZXRlclByb3ZpZGVyPU5vb3BNZXRlclByb3ZpZGVyO3QuTk9PUF9NRVRFUl9QUk9WSURFUj1uZXcgTm9vcE1ldGVyUHJvdmlkZXJ9LDIwMDpmdW5jdGlvbihlLHQscil7dmFyIG49dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxyLG4pe2lmKG49PT11bmRlZmluZWQpbj1yO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtyXX19KX06ZnVuY3Rpb24oZSx0LHIsbil7aWYobj09PXVuZGVmaW5lZCluPXI7ZVtuXT10W3JdfSk7dmFyIGE9dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIGUpaWYociE9PVwiZGVmYXVsdFwiJiYhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQscikpbih0LGUscil9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7YShyKDQ2KSx0KX0sNjUxOihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0Ll9nbG9iYWxUaGlzPXZvaWQgMDt0Ll9nbG9iYWxUaGlzPXR5cGVvZiBnbG9iYWxUaGlzPT09XCJvYmplY3RcIj9nbG9iYWxUaGlzOmdsb2JhbH0sNDY6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQscixuKXtpZihuPT09dW5kZWZpbmVkKW49cjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbcl19fSl9OmZ1bmN0aW9uKGUsdCxyLG4pe2lmKG49PT11bmRlZmluZWQpbj1yO2Vbbl09dFtyXX0pO3ZhciBhPXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiBlKWlmKHIhPT1cImRlZmF1bHRcIiYmIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpKW4odCxlLHIpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO2Eocig2NTEpLHQpfSw5Mzk6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5wcm9wYWdhdGlvbj12b2lkIDA7Y29uc3Qgbj1yKDE4MSk7dC5wcm9wYWdhdGlvbj1uLlByb3BhZ2F0aW9uQVBJLmdldEluc3RhbmNlKCl9LDg3NDooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5Ob29wVGV4dE1hcFByb3BhZ2F0b3I9dm9pZCAwO2NsYXNzIE5vb3BUZXh0TWFwUHJvcGFnYXRvcntpbmplY3QoZSx0KXt9ZXh0cmFjdChlLHQpe3JldHVybiBlfWZpZWxkcygpe3JldHVybltdfX10Lk5vb3BUZXh0TWFwUHJvcGFnYXRvcj1Ob29wVGV4dE1hcFByb3BhZ2F0b3J9LDE5NDooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5kZWZhdWx0VGV4dE1hcFNldHRlcj10LmRlZmF1bHRUZXh0TWFwR2V0dGVyPXZvaWQgMDt0LmRlZmF1bHRUZXh0TWFwR2V0dGVyPXtnZXQoZSx0KXtpZihlPT1udWxsKXtyZXR1cm4gdW5kZWZpbmVkfXJldHVybiBlW3RdfSxrZXlzKGUpe2lmKGU9PW51bGwpe3JldHVybltdfXJldHVybiBPYmplY3Qua2V5cyhlKX19O3QuZGVmYXVsdFRleHRNYXBTZXR0ZXI9e3NldChlLHQscil7aWYoZT09bnVsbCl7cmV0dXJufWVbdF09cn19fSw4NDU6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC50cmFjZT12b2lkIDA7Y29uc3Qgbj1yKDk5Nyk7dC50cmFjZT1uLlRyYWNlQVBJLmdldEluc3RhbmNlKCl9LDQwMzooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0Lk5vblJlY29yZGluZ1NwYW49dm9pZCAwO2NvbnN0IG49cig0NzYpO2NsYXNzIE5vblJlY29yZGluZ1NwYW57Y29uc3RydWN0b3IoZT1uLklOVkFMSURfU1BBTl9DT05URVhUKXt0aGlzLl9zcGFuQ29udGV4dD1lfXNwYW5Db250ZXh0KCl7cmV0dXJuIHRoaXMuX3NwYW5Db250ZXh0fXNldEF0dHJpYnV0ZShlLHQpe3JldHVybiB0aGlzfXNldEF0dHJpYnV0ZXMoZSl7cmV0dXJuIHRoaXN9YWRkRXZlbnQoZSx0KXtyZXR1cm4gdGhpc31zZXRTdGF0dXMoZSl7cmV0dXJuIHRoaXN9dXBkYXRlTmFtZShlKXtyZXR1cm4gdGhpc31lbmQoZSl7fWlzUmVjb3JkaW5nKCl7cmV0dXJuIGZhbHNlfXJlY29yZEV4Y2VwdGlvbihlLHQpe319dC5Ob25SZWNvcmRpbmdTcGFuPU5vblJlY29yZGluZ1NwYW59LDYxNDooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0Lk5vb3BUcmFjZXI9dm9pZCAwO2NvbnN0IG49cig0OTEpO2NvbnN0IGE9cig2MDcpO2NvbnN0IG89cig0MDMpO2NvbnN0IGk9cigxMzkpO2NvbnN0IGM9bi5Db250ZXh0QVBJLmdldEluc3RhbmNlKCk7Y2xhc3MgTm9vcFRyYWNlcntzdGFydFNwYW4oZSx0LHI9Yy5hY3RpdmUoKSl7Y29uc3Qgbj1Cb29sZWFuKHQ9PT1udWxsfHx0PT09dm9pZCAwP3ZvaWQgMDp0LnJvb3QpO2lmKG4pe3JldHVybiBuZXcgby5Ob25SZWNvcmRpbmdTcGFufWNvbnN0IHM9ciYmKDAsYS5nZXRTcGFuQ29udGV4dCkocik7aWYoaXNTcGFuQ29udGV4dChzKSYmKDAsaS5pc1NwYW5Db250ZXh0VmFsaWQpKHMpKXtyZXR1cm4gbmV3IG8uTm9uUmVjb3JkaW5nU3BhbihzKX1lbHNle3JldHVybiBuZXcgby5Ob25SZWNvcmRpbmdTcGFufX1zdGFydEFjdGl2ZVNwYW4oZSx0LHIsbil7bGV0IG87bGV0IGk7bGV0IHM7aWYoYXJndW1lbnRzLmxlbmd0aDwyKXtyZXR1cm59ZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoPT09Mil7cz10fWVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aD09PTMpe289dDtzPXJ9ZWxzZXtvPXQ7aT1yO3M9bn1jb25zdCB1PWkhPT1udWxsJiZpIT09dm9pZCAwP2k6Yy5hY3RpdmUoKTtjb25zdCBsPXRoaXMuc3RhcnRTcGFuKGUsbyx1KTtjb25zdCBnPSgwLGEuc2V0U3BhbikodSxsKTtyZXR1cm4gYy53aXRoKGcscyx1bmRlZmluZWQsbCl9fXQuTm9vcFRyYWNlcj1Ob29wVHJhY2VyO2Z1bmN0aW9uIGlzU3BhbkNvbnRleHQoZSl7cmV0dXJuIHR5cGVvZiBlPT09XCJvYmplY3RcIiYmdHlwZW9mIGVbXCJzcGFuSWRcIl09PT1cInN0cmluZ1wiJiZ0eXBlb2YgZVtcInRyYWNlSWRcIl09PT1cInN0cmluZ1wiJiZ0eXBlb2YgZVtcInRyYWNlRmxhZ3NcIl09PT1cIm51bWJlclwifX0sMTI0OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuTm9vcFRyYWNlclByb3ZpZGVyPXZvaWQgMDtjb25zdCBuPXIoNjE0KTtjbGFzcyBOb29wVHJhY2VyUHJvdmlkZXJ7Z2V0VHJhY2VyKGUsdCxyKXtyZXR1cm4gbmV3IG4uTm9vcFRyYWNlcn19dC5Ob29wVHJhY2VyUHJvdmlkZXI9Tm9vcFRyYWNlclByb3ZpZGVyfSwxMjU6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5Qcm94eVRyYWNlcj12b2lkIDA7Y29uc3Qgbj1yKDYxNCk7Y29uc3QgYT1uZXcgbi5Ob29wVHJhY2VyO2NsYXNzIFByb3h5VHJhY2Vye2NvbnN0cnVjdG9yKGUsdCxyLG4pe3RoaXMuX3Byb3ZpZGVyPWU7dGhpcy5uYW1lPXQ7dGhpcy52ZXJzaW9uPXI7dGhpcy5vcHRpb25zPW59c3RhcnRTcGFuKGUsdCxyKXtyZXR1cm4gdGhpcy5fZ2V0VHJhY2VyKCkuc3RhcnRTcGFuKGUsdCxyKX1zdGFydEFjdGl2ZVNwYW4oZSx0LHIsbil7Y29uc3QgYT10aGlzLl9nZXRUcmFjZXIoKTtyZXR1cm4gUmVmbGVjdC5hcHBseShhLnN0YXJ0QWN0aXZlU3BhbixhLGFyZ3VtZW50cyl9X2dldFRyYWNlcigpe2lmKHRoaXMuX2RlbGVnYXRlKXtyZXR1cm4gdGhpcy5fZGVsZWdhdGV9Y29uc3QgZT10aGlzLl9wcm92aWRlci5nZXREZWxlZ2F0ZVRyYWNlcih0aGlzLm5hbWUsdGhpcy52ZXJzaW9uLHRoaXMub3B0aW9ucyk7aWYoIWUpe3JldHVybiBhfXRoaXMuX2RlbGVnYXRlPWU7cmV0dXJuIHRoaXMuX2RlbGVnYXRlfX10LlByb3h5VHJhY2VyPVByb3h5VHJhY2VyfSw4NDY6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5Qcm94eVRyYWNlclByb3ZpZGVyPXZvaWQgMDtjb25zdCBuPXIoMTI1KTtjb25zdCBhPXIoMTI0KTtjb25zdCBvPW5ldyBhLk5vb3BUcmFjZXJQcm92aWRlcjtjbGFzcyBQcm94eVRyYWNlclByb3ZpZGVye2dldFRyYWNlcihlLHQscil7dmFyIGE7cmV0dXJuKGE9dGhpcy5nZXREZWxlZ2F0ZVRyYWNlcihlLHQscikpIT09bnVsbCYmYSE9PXZvaWQgMD9hOm5ldyBuLlByb3h5VHJhY2VyKHRoaXMsZSx0LHIpfWdldERlbGVnYXRlKCl7dmFyIGU7cmV0dXJuKGU9dGhpcy5fZGVsZWdhdGUpIT09bnVsbCYmZSE9PXZvaWQgMD9lOm99c2V0RGVsZWdhdGUoZSl7dGhpcy5fZGVsZWdhdGU9ZX1nZXREZWxlZ2F0ZVRyYWNlcihlLHQscil7dmFyIG47cmV0dXJuKG49dGhpcy5fZGVsZWdhdGUpPT09bnVsbHx8bj09PXZvaWQgMD92b2lkIDA6bi5nZXRUcmFjZXIoZSx0LHIpfX10LlByb3h5VHJhY2VyUHJvdmlkZXI9UHJveHlUcmFjZXJQcm92aWRlcn0sOTk2OihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LlNhbXBsaW5nRGVjaXNpb249dm9pZCAwO3ZhciByOyhmdW5jdGlvbihlKXtlW2VbXCJOT1RfUkVDT1JEXCJdPTBdPVwiTk9UX1JFQ09SRFwiO2VbZVtcIlJFQ09SRFwiXT0xXT1cIlJFQ09SRFwiO2VbZVtcIlJFQ09SRF9BTkRfU0FNUExFRFwiXT0yXT1cIlJFQ09SRF9BTkRfU0FNUExFRFwifSkocj10LlNhbXBsaW5nRGVjaXNpb258fCh0LlNhbXBsaW5nRGVjaXNpb249e30pKX0sNjA3OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuZ2V0U3BhbkNvbnRleHQ9dC5zZXRTcGFuQ29udGV4dD10LmRlbGV0ZVNwYW49dC5zZXRTcGFuPXQuZ2V0QWN0aXZlU3Bhbj10LmdldFNwYW49dm9pZCAwO2NvbnN0IG49cig3ODApO2NvbnN0IGE9cig0MDMpO2NvbnN0IG89cig0OTEpO2NvbnN0IGk9KDAsbi5jcmVhdGVDb250ZXh0S2V5KShcIk9wZW5UZWxlbWV0cnkgQ29udGV4dCBLZXkgU1BBTlwiKTtmdW5jdGlvbiBnZXRTcGFuKGUpe3JldHVybiBlLmdldFZhbHVlKGkpfHx1bmRlZmluZWR9dC5nZXRTcGFuPWdldFNwYW47ZnVuY3Rpb24gZ2V0QWN0aXZlU3Bhbigpe3JldHVybiBnZXRTcGFuKG8uQ29udGV4dEFQSS5nZXRJbnN0YW5jZSgpLmFjdGl2ZSgpKX10LmdldEFjdGl2ZVNwYW49Z2V0QWN0aXZlU3BhbjtmdW5jdGlvbiBzZXRTcGFuKGUsdCl7cmV0dXJuIGUuc2V0VmFsdWUoaSx0KX10LnNldFNwYW49c2V0U3BhbjtmdW5jdGlvbiBkZWxldGVTcGFuKGUpe3JldHVybiBlLmRlbGV0ZVZhbHVlKGkpfXQuZGVsZXRlU3Bhbj1kZWxldGVTcGFuO2Z1bmN0aW9uIHNldFNwYW5Db250ZXh0KGUsdCl7cmV0dXJuIHNldFNwYW4oZSxuZXcgYS5Ob25SZWNvcmRpbmdTcGFuKHQpKX10LnNldFNwYW5Db250ZXh0PXNldFNwYW5Db250ZXh0O2Z1bmN0aW9uIGdldFNwYW5Db250ZXh0KGUpe3ZhciB0O3JldHVybih0PWdldFNwYW4oZSkpPT09bnVsbHx8dD09PXZvaWQgMD92b2lkIDA6dC5zcGFuQ29udGV4dCgpfXQuZ2V0U3BhbkNvbnRleHQ9Z2V0U3BhbkNvbnRleHR9LDMyNTooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LlRyYWNlU3RhdGVJbXBsPXZvaWQgMDtjb25zdCBuPXIoNTY0KTtjb25zdCBhPTMyO2NvbnN0IG89NTEyO2NvbnN0IGk9XCIsXCI7Y29uc3QgYz1cIj1cIjtjbGFzcyBUcmFjZVN0YXRlSW1wbHtjb25zdHJ1Y3RvcihlKXt0aGlzLl9pbnRlcm5hbFN0YXRlPW5ldyBNYXA7aWYoZSl0aGlzLl9wYXJzZShlKX1zZXQoZSx0KXtjb25zdCByPXRoaXMuX2Nsb25lKCk7aWYoci5faW50ZXJuYWxTdGF0ZS5oYXMoZSkpe3IuX2ludGVybmFsU3RhdGUuZGVsZXRlKGUpfXIuX2ludGVybmFsU3RhdGUuc2V0KGUsdCk7cmV0dXJuIHJ9dW5zZXQoZSl7Y29uc3QgdD10aGlzLl9jbG9uZSgpO3QuX2ludGVybmFsU3RhdGUuZGVsZXRlKGUpO3JldHVybiB0fWdldChlKXtyZXR1cm4gdGhpcy5faW50ZXJuYWxTdGF0ZS5nZXQoZSl9c2VyaWFsaXplKCl7cmV0dXJuIHRoaXMuX2tleXMoKS5yZWR1Y2UoKChlLHQpPT57ZS5wdXNoKHQrYyt0aGlzLmdldCh0KSk7cmV0dXJuIGV9KSxbXSkuam9pbihpKX1fcGFyc2UoZSl7aWYoZS5sZW5ndGg+bylyZXR1cm47dGhpcy5faW50ZXJuYWxTdGF0ZT1lLnNwbGl0KGkpLnJldmVyc2UoKS5yZWR1Y2UoKChlLHQpPT57Y29uc3Qgcj10LnRyaW0oKTtjb25zdCBhPXIuaW5kZXhPZihjKTtpZihhIT09LTEpe2NvbnN0IG89ci5zbGljZSgwLGEpO2NvbnN0IGk9ci5zbGljZShhKzEsdC5sZW5ndGgpO2lmKCgwLG4udmFsaWRhdGVLZXkpKG8pJiYoMCxuLnZhbGlkYXRlVmFsdWUpKGkpKXtlLnNldChvLGkpfWVsc2V7fX1yZXR1cm4gZX0pLG5ldyBNYXApO2lmKHRoaXMuX2ludGVybmFsU3RhdGUuc2l6ZT5hKXt0aGlzLl9pbnRlcm5hbFN0YXRlPW5ldyBNYXAoQXJyYXkuZnJvbSh0aGlzLl9pbnRlcm5hbFN0YXRlLmVudHJpZXMoKSkucmV2ZXJzZSgpLnNsaWNlKDAsYSkpfX1fa2V5cygpe3JldHVybiBBcnJheS5mcm9tKHRoaXMuX2ludGVybmFsU3RhdGUua2V5cygpKS5yZXZlcnNlKCl9X2Nsb25lKCl7Y29uc3QgZT1uZXcgVHJhY2VTdGF0ZUltcGw7ZS5faW50ZXJuYWxTdGF0ZT1uZXcgTWFwKHRoaXMuX2ludGVybmFsU3RhdGUpO3JldHVybiBlfX10LlRyYWNlU3RhdGVJbXBsPVRyYWNlU3RhdGVJbXBsfSw1NjQ6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QudmFsaWRhdGVWYWx1ZT10LnZhbGlkYXRlS2V5PXZvaWQgMDtjb25zdCByPVwiW18wLTlhLXotKi9dXCI7Y29uc3Qgbj1gW2Etel0ke3J9ezAsMjU1fWA7Y29uc3QgYT1gW2EtejAtOV0ke3J9ezAsMjQwfUBbYS16XSR7cn17MCwxM31gO2NvbnN0IG89bmV3IFJlZ0V4cChgXig/OiR7bn18JHthfSkkYCk7Y29uc3QgaT0vXlsgLX5dezAsMjU1fVshLX5dJC87Y29uc3QgYz0vLHw9LztmdW5jdGlvbiB2YWxpZGF0ZUtleShlKXtyZXR1cm4gby50ZXN0KGUpfXQudmFsaWRhdGVLZXk9dmFsaWRhdGVLZXk7ZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZShlKXtyZXR1cm4gaS50ZXN0KGUpJiYhYy50ZXN0KGUpfXQudmFsaWRhdGVWYWx1ZT12YWxpZGF0ZVZhbHVlfSw5ODooZSx0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt0LmNyZWF0ZVRyYWNlU3RhdGU9dm9pZCAwO2NvbnN0IG49cigzMjUpO2Z1bmN0aW9uIGNyZWF0ZVRyYWNlU3RhdGUoZSl7cmV0dXJuIG5ldyBuLlRyYWNlU3RhdGVJbXBsKGUpfXQuY3JlYXRlVHJhY2VTdGF0ZT1jcmVhdGVUcmFjZVN0YXRlfSw0NzY6KGUsdCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5JTlZBTElEX1NQQU5fQ09OVEVYVD10LklOVkFMSURfVFJBQ0VJRD10LklOVkFMSURfU1BBTklEPXZvaWQgMDtjb25zdCBuPXIoNDc1KTt0LklOVkFMSURfU1BBTklEPVwiMDAwMDAwMDAwMDAwMDAwMFwiO3QuSU5WQUxJRF9UUkFDRUlEPVwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjt0LklOVkFMSURfU1BBTl9DT05URVhUPXt0cmFjZUlkOnQuSU5WQUxJRF9UUkFDRUlELHNwYW5JZDp0LklOVkFMSURfU1BBTklELHRyYWNlRmxhZ3M6bi5UcmFjZUZsYWdzLk5PTkV9fSwzNTc6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuU3BhbktpbmQ9dm9pZCAwO3ZhciByOyhmdW5jdGlvbihlKXtlW2VbXCJJTlRFUk5BTFwiXT0wXT1cIklOVEVSTkFMXCI7ZVtlW1wiU0VSVkVSXCJdPTFdPVwiU0VSVkVSXCI7ZVtlW1wiQ0xJRU5UXCJdPTJdPVwiQ0xJRU5UXCI7ZVtlW1wiUFJPRFVDRVJcIl09M109XCJQUk9EVUNFUlwiO2VbZVtcIkNPTlNVTUVSXCJdPTRdPVwiQ09OU1VNRVJcIn0pKHI9dC5TcGFuS2luZHx8KHQuU3BhbktpbmQ9e30pKX0sMTM5OihlLHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3Qud3JhcFNwYW5Db250ZXh0PXQuaXNTcGFuQ29udGV4dFZhbGlkPXQuaXNWYWxpZFNwYW5JZD10LmlzVmFsaWRUcmFjZUlkPXZvaWQgMDtjb25zdCBuPXIoNDc2KTtjb25zdCBhPXIoNDAzKTtjb25zdCBvPS9eKFswLTlhLWZdezMyfSkkL2k7Y29uc3QgaT0vXlswLTlhLWZdezE2fSQvaTtmdW5jdGlvbiBpc1ZhbGlkVHJhY2VJZChlKXtyZXR1cm4gby50ZXN0KGUpJiZlIT09bi5JTlZBTElEX1RSQUNFSUR9dC5pc1ZhbGlkVHJhY2VJZD1pc1ZhbGlkVHJhY2VJZDtmdW5jdGlvbiBpc1ZhbGlkU3BhbklkKGUpe3JldHVybiBpLnRlc3QoZSkmJmUhPT1uLklOVkFMSURfU1BBTklEfXQuaXNWYWxpZFNwYW5JZD1pc1ZhbGlkU3BhbklkO2Z1bmN0aW9uIGlzU3BhbkNvbnRleHRWYWxpZChlKXtyZXR1cm4gaXNWYWxpZFRyYWNlSWQoZS50cmFjZUlkKSYmaXNWYWxpZFNwYW5JZChlLnNwYW5JZCl9dC5pc1NwYW5Db250ZXh0VmFsaWQ9aXNTcGFuQ29udGV4dFZhbGlkO2Z1bmN0aW9uIHdyYXBTcGFuQ29udGV4dChlKXtyZXR1cm4gbmV3IGEuTm9uUmVjb3JkaW5nU3BhbihlKX10LndyYXBTcGFuQ29udGV4dD13cmFwU3BhbkNvbnRleHR9LDg0NzooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5TcGFuU3RhdHVzQ29kZT12b2lkIDA7dmFyIHI7KGZ1bmN0aW9uKGUpe2VbZVtcIlVOU0VUXCJdPTBdPVwiVU5TRVRcIjtlW2VbXCJPS1wiXT0xXT1cIk9LXCI7ZVtlW1wiRVJST1JcIl09Ml09XCJFUlJPUlwifSkocj10LlNwYW5TdGF0dXNDb2RlfHwodC5TcGFuU3RhdHVzQ29kZT17fSkpfSw0NzU6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3QuVHJhY2VGbGFncz12b2lkIDA7dmFyIHI7KGZ1bmN0aW9uKGUpe2VbZVtcIk5PTkVcIl09MF09XCJOT05FXCI7ZVtlW1wiU0FNUExFRFwiXT0xXT1cIlNBTVBMRURcIn0pKHI9dC5UcmFjZUZsYWdzfHwodC5UcmFjZUZsYWdzPXt9KSl9LDUyMTooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dC5WRVJTSU9OPXZvaWQgMDt0LlZFUlNJT049XCIxLjYuMFwifX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGE9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXS5jYWxsKGEuZXhwb3J0cyxhLGEuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gYS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj17fTsoKCk9Pnt2YXIgZT1yO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZS50cmFjZT1lLnByb3BhZ2F0aW9uPWUubWV0cmljcz1lLmRpYWc9ZS5jb250ZXh0PWUuSU5WQUxJRF9TUEFOX0NPTlRFWFQ9ZS5JTlZBTElEX1RSQUNFSUQ9ZS5JTlZBTElEX1NQQU5JRD1lLmlzVmFsaWRTcGFuSWQ9ZS5pc1ZhbGlkVHJhY2VJZD1lLmlzU3BhbkNvbnRleHRWYWxpZD1lLmNyZWF0ZVRyYWNlU3RhdGU9ZS5UcmFjZUZsYWdzPWUuU3BhblN0YXR1c0NvZGU9ZS5TcGFuS2luZD1lLlNhbXBsaW5nRGVjaXNpb249ZS5Qcm94eVRyYWNlclByb3ZpZGVyPWUuUHJveHlUcmFjZXI9ZS5kZWZhdWx0VGV4dE1hcFNldHRlcj1lLmRlZmF1bHRUZXh0TWFwR2V0dGVyPWUuVmFsdWVUeXBlPWUuY3JlYXRlTm9vcE1ldGVyPWUuRGlhZ0xvZ0xldmVsPWUuRGlhZ0NvbnNvbGVMb2dnZXI9ZS5ST09UX0NPTlRFWFQ9ZS5jcmVhdGVDb250ZXh0S2V5PWUuYmFnZ2FnZUVudHJ5TWV0YWRhdGFGcm9tU3RyaW5nPXZvaWQgMDt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDM2OSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJiYWdnYWdlRW50cnlNZXRhZGF0YUZyb21TdHJpbmdcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiB0LmJhZ2dhZ2VFbnRyeU1ldGFkYXRhRnJvbVN0cmluZ319KTt2YXIgbj1fX25jY3dwY2tfcmVxdWlyZV9fKDc4MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJjcmVhdGVDb250ZXh0S2V5XCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbi5jcmVhdGVDb250ZXh0S2V5fX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiUk9PVF9DT05URVhUXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbi5ST09UX0NPTlRFWFR9fSk7dmFyIGE9X19uY2N3cGNrX3JlcXVpcmVfXyg5NzIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiRGlhZ0NvbnNvbGVMb2dnZXJcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBhLkRpYWdDb25zb2xlTG9nZ2VyfX0pO3ZhciBvPV9fbmNjd3Bja19yZXF1aXJlX18oOTU3KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIkRpYWdMb2dMZXZlbFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uRGlhZ0xvZ0xldmVsfX0pO3ZhciBpPV9fbmNjd3Bja19yZXF1aXJlX18oMTAyKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImNyZWF0ZU5vb3BNZXRlclwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGkuY3JlYXRlTm9vcE1ldGVyfX0pO3ZhciBjPV9fbmNjd3Bja19yZXF1aXJlX18oOTAxKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIlZhbHVlVHlwZVwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuVmFsdWVUeXBlfX0pO3ZhciBzPV9fbmNjd3Bja19yZXF1aXJlX18oMTk0KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRUZXh0TWFwR2V0dGVyXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5kZWZhdWx0VGV4dE1hcEdldHRlcn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRUZXh0TWFwU2V0dGVyXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5kZWZhdWx0VGV4dE1hcFNldHRlcn19KTt2YXIgdT1fX25jY3dwY2tfcmVxdWlyZV9fKDEyNSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJQcm94eVRyYWNlclwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUuUHJveHlUcmFjZXJ9fSk7dmFyIGw9X19uY2N3cGNrX3JlcXVpcmVfXyg4NDYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiUHJveHlUcmFjZXJQcm92aWRlclwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGwuUHJveHlUcmFjZXJQcm92aWRlcn19KTt2YXIgZz1fX25jY3dwY2tfcmVxdWlyZV9fKDk5Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJTYW1wbGluZ0RlY2lzaW9uXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZy5TYW1wbGluZ0RlY2lzaW9ufX0pO3ZhciBwPV9fbmNjd3Bja19yZXF1aXJlX18oMzU3KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIlNwYW5LaW5kXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcC5TcGFuS2luZH19KTt2YXIgZD1fX25jY3dwY2tfcmVxdWlyZV9fKDg0Nyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJTcGFuU3RhdHVzQ29kZVwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuU3BhblN0YXR1c0NvZGV9fSk7dmFyIF89X19uY2N3cGNrX3JlcXVpcmVfXyg0NzUpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiVHJhY2VGbGFnc1wiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIF8uVHJhY2VGbGFnc319KTt2YXIgZj1fX25jY3dwY2tfcmVxdWlyZV9fKDk4KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImNyZWF0ZVRyYWNlU3RhdGVcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBmLmNyZWF0ZVRyYWNlU3RhdGV9fSk7dmFyIGI9X19uY2N3cGNrX3JlcXVpcmVfXygxMzkpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiaXNTcGFuQ29udGV4dFZhbGlkXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5pc1NwYW5Db250ZXh0VmFsaWR9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJpc1ZhbGlkVHJhY2VJZFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuaXNWYWxpZFRyYWNlSWR9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJpc1ZhbGlkU3BhbklkXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5pc1ZhbGlkU3BhbklkfX0pO3ZhciB2PV9fbmNjd3Bja19yZXF1aXJlX18oNDc2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIklOVkFMSURfU1BBTklEXCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdi5JTlZBTElEX1NQQU5JRH19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIklOVkFMSURfVFJBQ0VJRFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHYuSU5WQUxJRF9UUkFDRUlEfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiSU5WQUxJRF9TUEFOX0NPTlRFWFRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiB2LklOVkFMSURfU1BBTl9DT05URVhUfX0pO2NvbnN0IE89X19uY2N3cGNrX3JlcXVpcmVfXyg2Nyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJjb250ZXh0XCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTy5jb250ZXh0fX0pO2NvbnN0IFA9X19uY2N3cGNrX3JlcXVpcmVfXyg1MDYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGlhZ1wiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFAuZGlhZ319KTtjb25zdCBOPV9fbmNjd3Bja19yZXF1aXJlX18oODg2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIm1ldHJpY3NcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBOLm1ldHJpY3N9fSk7Y29uc3QgUz1fX25jY3dwY2tfcmVxdWlyZV9fKDkzOSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJwcm9wYWdhdGlvblwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFMucHJvcGFnYXRpb259fSk7Y29uc3QgQz1fX25jY3dwY2tfcmVxdWlyZV9fKDg0NSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJ0cmFjZVwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEMudHJhY2V9fSk7ZVtcImRlZmF1bHRcIl09e2NvbnRleHQ6Ty5jb250ZXh0LGRpYWc6UC5kaWFnLG1ldHJpY3M6Ti5tZXRyaWNzLHByb3BhZ2F0aW9uOlMucHJvcGFnYXRpb24sdHJhY2U6Qy50cmFjZX19KSgpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/@opentelemetry/api/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.node.development.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.node.development.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @license React\n * react-dom-server-legacy.node.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n\n\n JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n\n Copyright (c) 2011 Gary Court\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n*/\n\n true &&\n  (function () {\n    function styleReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\73 \" : \"\\\\53 \") + suffix;\n    }\n    function scriptReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n    }\n    function objectName(object) {\n      return Object.prototype.toString\n        .call(object)\n        .replace(/^\\[object (.*)\\]$/, function (m, p0) {\n          return p0;\n        });\n    }\n    function describeKeyForErrorMessage(key) {\n      var encodedKey = JSON.stringify(key);\n      return '\"' + key + '\"' === encodedKey ? key : encodedKey;\n    }\n    function describeValueForErrorMessage(value) {\n      switch (typeof value) {\n        case \"string\":\n          return JSON.stringify(\n            10 >= value.length ? value : value.slice(0, 10) + \"...\"\n          );\n        case \"object\":\n          if (isArrayImpl(value)) return \"[...]\";\n          if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)\n            return \"client\";\n          value = objectName(value);\n          return \"Object\" === value ? \"{...}\" : value;\n        case \"function\":\n          return value.$$typeof === CLIENT_REFERENCE_TAG\n            ? \"client\"\n            : (value = value.displayName || value.name)\n              ? \"function \" + value\n              : \"function\";\n        default:\n          return String(value);\n      }\n    }\n    function describeElementType(type) {\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeElementType(type.render);\n          case REACT_MEMO_TYPE:\n            return describeElementType(type.type);\n          case REACT_LAZY_TYPE:\n            var payload = type._payload;\n            type = type._init;\n            try {\n              return describeElementType(type(payload));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function describeObjectForErrorMessage(objectOrArray, expandedName) {\n      var objKind = objectName(objectOrArray);\n      if (\"Object\" !== objKind && \"Array\" !== objKind) return objKind;\n      var start = -1,\n        length = 0;\n      if (isArrayImpl(objectOrArray))\n        if (jsxChildrenParents.has(objectOrArray)) {\n          var type = jsxChildrenParents.get(objectOrArray);\n          objKind = \"<\" + describeElementType(type) + \">\";\n          for (var i = 0; i < objectOrArray.length; i++) {\n            var value = objectOrArray[i];\n            value =\n              \"string\" === typeof value\n                ? value\n                : \"object\" === typeof value && null !== value\n                  ? \"{\" + describeObjectForErrorMessage(value) + \"}\"\n                  : \"{\" + describeValueForErrorMessage(value) + \"}\";\n            \"\" + i === expandedName\n              ? ((start = objKind.length),\n                (length = value.length),\n                (objKind += value))\n              : (objKind =\n                  15 > value.length && 40 > objKind.length + value.length\n                    ? objKind + value\n                    : objKind + \"{...}\");\n          }\n          objKind += \"</\" + describeElementType(type) + \">\";\n        } else {\n          objKind = \"[\";\n          for (type = 0; type < objectOrArray.length; type++)\n            0 < type && (objKind += \", \"),\n              (i = objectOrArray[type]),\n              (i =\n                \"object\" === typeof i && null !== i\n                  ? describeObjectForErrorMessage(i)\n                  : describeValueForErrorMessage(i)),\n              \"\" + type === expandedName\n                ? ((start = objKind.length),\n                  (length = i.length),\n                  (objKind += i))\n                : (objKind =\n                    10 > i.length && 40 > objKind.length + i.length\n                      ? objKind + i\n                      : objKind + \"...\");\n          objKind += \"]\";\n        }\n      else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)\n        objKind = \"<\" + describeElementType(objectOrArray.type) + \"/>\";\n      else {\n        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return \"client\";\n        if (jsxPropsParents.has(objectOrArray)) {\n          objKind = jsxPropsParents.get(objectOrArray);\n          objKind = \"<\" + (describeElementType(objKind) || \"...\");\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++) {\n            objKind += \" \";\n            value = type[i];\n            objKind += describeKeyForErrorMessage(value) + \"=\";\n            var _value2 = objectOrArray[value];\n            var _substr2 =\n              value === expandedName &&\n              \"object\" === typeof _value2 &&\n              null !== _value2\n                ? describeObjectForErrorMessage(_value2)\n                : describeValueForErrorMessage(_value2);\n            \"string\" !== typeof _value2 && (_substr2 = \"{\" + _substr2 + \"}\");\n            value === expandedName\n              ? ((start = objKind.length),\n                (length = _substr2.length),\n                (objKind += _substr2))\n              : (objKind =\n                  10 > _substr2.length && 40 > objKind.length + _substr2.length\n                    ? objKind + _substr2\n                    : objKind + \"...\");\n          }\n          objKind += \">\";\n        } else {\n          objKind = \"{\";\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++)\n            0 < i && (objKind += \", \"),\n              (value = type[i]),\n              (objKind += describeKeyForErrorMessage(value) + \": \"),\n              (_value2 = objectOrArray[value]),\n              (_value2 =\n                \"object\" === typeof _value2 && null !== _value2\n                  ? describeObjectForErrorMessage(_value2)\n                  : describeValueForErrorMessage(_value2)),\n              value === expandedName\n                ? ((start = objKind.length),\n                  (length = _value2.length),\n                  (objKind += _value2))\n                : (objKind =\n                    10 > _value2.length && 40 > objKind.length + _value2.length\n                      ? objKind + _value2\n                      : objKind + \"...\");\n          objKind += \"}\";\n        }\n      }\n      return void 0 === expandedName\n        ? objKind\n        : -1 < start && 0 < length\n          ? ((objectOrArray = \" \".repeat(start) + \"^\".repeat(length)),\n            \"\\n  \" + objKind + \"\\n  \" + objectOrArray)\n          : \"\\n  \" + objKind;\n    }\n    function murmurhash3_32_gc(key, seed) {\n      var remainder = key.length & 3;\n      var bytes = key.length - remainder;\n      var h1 = seed;\n      for (seed = 0; seed < bytes; ) {\n        var k1 =\n          (key.charCodeAt(seed) & 255) |\n          ((key.charCodeAt(++seed) & 255) << 8) |\n          ((key.charCodeAt(++seed) & 255) << 16) |\n          ((key.charCodeAt(++seed) & 255) << 24);\n        ++seed;\n        k1 =\n          (3432918353 * (k1 & 65535) +\n            (((3432918353 * (k1 >>> 16)) & 65535) << 16)) &\n          4294967295;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 =\n          (461845907 * (k1 & 65535) +\n            (((461845907 * (k1 >>> 16)) & 65535) << 16)) &\n          4294967295;\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1 =\n          (5 * (h1 & 65535) + (((5 * (h1 >>> 16)) & 65535) << 16)) & 4294967295;\n        h1 = (h1 & 65535) + 27492 + ((((h1 >>> 16) + 58964) & 65535) << 16);\n      }\n      k1 = 0;\n      switch (remainder) {\n        case 3:\n          k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;\n        case 2:\n          k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;\n        case 1:\n          (k1 ^= key.charCodeAt(seed) & 255),\n            (k1 =\n              (3432918353 * (k1 & 65535) +\n                (((3432918353 * (k1 >>> 16)) & 65535) << 16)) &\n              4294967295),\n            (k1 = (k1 << 15) | (k1 >>> 17)),\n            (h1 ^=\n              (461845907 * (k1 & 65535) +\n                (((461845907 * (k1 >>> 16)) & 65535) << 16)) &\n              4294967295);\n      }\n      h1 ^= key.length;\n      h1 ^= h1 >>> 16;\n      h1 =\n        (2246822507 * (h1 & 65535) +\n          (((2246822507 * (h1 >>> 16)) & 65535) << 16)) &\n        4294967295;\n      h1 ^= h1 >>> 13;\n      h1 =\n        (3266489909 * (h1 & 65535) +\n          (((3266489909 * (h1 >>> 16)) & 65535) << 16)) &\n        4294967295;\n      return (h1 ^ (h1 >>> 16)) >>> 0;\n    }\n    function typeName(value) {\n      return (\n        (\"function\" === typeof Symbol &&\n          Symbol.toStringTag &&\n          value[Symbol.toStringTag]) ||\n        value.constructor.name ||\n        \"Object\"\n      );\n    }\n    function willCoercionThrow(value) {\n      try {\n        return testStringCoercion(value), !1;\n      } catch (e) {\n        return !0;\n      }\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkAttributeStringCoercion(value, attributeName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            attributeName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkCSSPropertyStringCoercion(value, propName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            propName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkHtmlStringCoercion(value) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.\",\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function isAttributeNameSafe(attributeName) {\n      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))\n        return !0;\n      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))\n        return !1;\n      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\n        return (validatedAttributeNameCache[attributeName] = !0);\n      illegalAttributeNameCache[attributeName] = !0;\n      console.error(\"Invalid attribute name: `%s`\", attributeName);\n      return !1;\n    }\n    function checkControlledValueProps(tagName, props) {\n      hasReadOnlyValue[props.type] ||\n        props.onChange ||\n        props.onInput ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.value ||\n        (\"select\" === tagName\n          ? console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.\"\n            )\n          : console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\"\n            ));\n      props.onChange ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.checked ||\n        console.error(\n          \"You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.\"\n        );\n    }\n    function validateProperty$1(tagName, name) {\n      if (\n        hasOwnProperty.call(warnedProperties$1, name) &&\n        warnedProperties$1[name]\n      )\n        return !0;\n      if (rARIACamel$1.test(name)) {\n        tagName = \"aria-\" + name.slice(4).toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\",\n              name\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n        if (name !== tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. Did you mean `%s`?\",\n              name,\n              tagName\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n      }\n      if (rARIA$1.test(name)) {\n        tagName = name.toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName) return (warnedProperties$1[name] = !0), !1;\n        name !== tagName &&\n          (console.error(\n            \"Unknown ARIA attribute `%s`. Did you mean `%s`?\",\n            name,\n            tagName\n          ),\n          (warnedProperties$1[name] = !0));\n      }\n      return !0;\n    }\n    function validateProperties$2(type, props) {\n      var invalidProps = [],\n        key;\n      for (key in props)\n        validateProperty$1(type, key) || invalidProps.push(key);\n      props = invalidProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === invalidProps.length\n        ? console.error(\n            \"Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          )\n        : 1 < invalidProps.length &&\n          console.error(\n            \"Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          );\n    }\n    function validateProperty(tagName, name, value, eventRegistry) {\n      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])\n        return !0;\n      var lowerCasedName = name.toLowerCase();\n      if (\"onfocusin\" === lowerCasedName || \"onfocusout\" === lowerCasedName)\n        return (\n          console.error(\n            \"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"function\" === typeof value &&\n        ((\"form\" === tagName && \"action\" === name) ||\n          (\"input\" === tagName && \"formAction\" === name) ||\n          (\"button\" === tagName && \"formAction\" === name))\n      )\n        return !0;\n      if (null != eventRegistry) {\n        tagName = eventRegistry.possibleRegistrationNames;\n        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))\n          return !0;\n        eventRegistry = tagName.hasOwnProperty(lowerCasedName)\n          ? tagName[lowerCasedName]\n          : null;\n        if (null != eventRegistry)\n          return (\n            console.error(\n              \"Invalid event handler property `%s`. Did you mean `%s`?\",\n              name,\n              eventRegistry\n            ),\n            (warnedProperties[name] = !0)\n          );\n        if (EVENT_NAME_REGEX.test(name))\n          return (\n            console.error(\n              \"Unknown event handler property `%s`. It will be ignored.\",\n              name\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (EVENT_NAME_REGEX.test(name))\n        return (\n          INVALID_EVENT_NAME_REGEX.test(name) &&\n            console.error(\n              \"Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.\",\n              name\n            ),\n          (warnedProperties[name] = !0)\n        );\n      if (rARIA.test(name) || rARIACamel.test(name)) return !0;\n      if (\"innerhtml\" === lowerCasedName)\n        return (\n          console.error(\n            \"Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"aria\" === lowerCasedName)\n        return (\n          console.error(\n            \"The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"is\" === lowerCasedName &&\n        null !== value &&\n        void 0 !== value &&\n        \"string\" !== typeof value\n      )\n        return (\n          console.error(\n            \"Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.\",\n            typeof value\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"number\" === typeof value && isNaN(value))\n        return (\n          console.error(\n            \"Received NaN for the `%s` attribute. If this is expected, cast the value to a string.\",\n            name\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n        if (\n          ((lowerCasedName = possibleStandardNames[lowerCasedName]),\n          lowerCasedName !== name)\n        )\n          return (\n            console.error(\n              \"Invalid DOM property `%s`. Did you mean `%s`?\",\n              name,\n              lowerCasedName\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (name !== lowerCasedName)\n        return (\n          console.error(\n            \"React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.\",\n            name,\n            lowerCasedName\n          ),\n          (warnedProperties[name] = !0)\n        );\n      switch (name) {\n        case \"dangerouslySetInnerHTML\":\n        case \"children\":\n        case \"style\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"ref\":\n          return !0;\n        case \"innerText\":\n        case \"textContent\":\n          return !0;\n      }\n      switch (typeof value) {\n        case \"boolean\":\n          switch (name) {\n            case \"autoFocus\":\n            case \"checked\":\n            case \"multiple\":\n            case \"muted\":\n            case \"selected\":\n            case \"contentEditable\":\n            case \"spellCheck\":\n            case \"draggable\":\n            case \"value\":\n            case \"autoReverse\":\n            case \"externalResourcesRequired\":\n            case \"focusable\":\n            case \"preserveAlpha\":\n            case \"allowFullScreen\":\n            case \"async\":\n            case \"autoPlay\":\n            case \"controls\":\n            case \"default\":\n            case \"defer\":\n            case \"disabled\":\n            case \"disablePictureInPicture\":\n            case \"disableRemotePlayback\":\n            case \"formNoValidate\":\n            case \"hidden\":\n            case \"loop\":\n            case \"noModule\":\n            case \"noValidate\":\n            case \"open\":\n            case \"playsInline\":\n            case \"readOnly\":\n            case \"required\":\n            case \"reversed\":\n            case \"scoped\":\n            case \"seamless\":\n            case \"itemScope\":\n            case \"capture\":\n            case \"download\":\n            case \"inert\":\n              return !0;\n            default:\n              lowerCasedName = name.toLowerCase().slice(0, 5);\n              if (\"data-\" === lowerCasedName || \"aria-\" === lowerCasedName)\n                return !0;\n              value\n                ? console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name\n                  )\n                : console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name,\n                    name,\n                    name\n                  );\n              return (warnedProperties[name] = !0);\n          }\n        case \"function\":\n        case \"symbol\":\n          return (warnedProperties[name] = !0), !1;\n        case \"string\":\n          if (\"false\" === value || \"true\" === value) {\n            switch (name) {\n              case \"checked\":\n              case \"selected\":\n              case \"multiple\":\n              case \"muted\":\n              case \"allowFullScreen\":\n              case \"async\":\n              case \"autoPlay\":\n              case \"controls\":\n              case \"default\":\n              case \"defer\":\n              case \"disabled\":\n              case \"disablePictureInPicture\":\n              case \"disableRemotePlayback\":\n              case \"formNoValidate\":\n              case \"hidden\":\n              case \"loop\":\n              case \"noModule\":\n              case \"noValidate\":\n              case \"open\":\n              case \"playsInline\":\n              case \"readOnly\":\n              case \"required\":\n              case \"reversed\":\n              case \"scoped\":\n              case \"seamless\":\n              case \"itemScope\":\n              case \"inert\":\n                break;\n              default:\n                return !0;\n            }\n            console.error(\n              \"Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?\",\n              value,\n              name,\n              \"false\" === value\n                ? \"The browser will interpret it as a truthy value.\"\n                : 'Although this works, it will not work as expected if you pass the string \"false\".',\n              name,\n              value\n            );\n            warnedProperties[name] = !0;\n          }\n      }\n      return !0;\n    }\n    function warnUnknownProperties(type, props, eventRegistry) {\n      var unknownProps = [],\n        key;\n      for (key in props)\n        validateProperty(type, key, props[key], eventRegistry) ||\n          unknownProps.push(key);\n      props = unknownProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === unknownProps.length\n        ? console.error(\n            \"Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          )\n        : 1 < unknownProps.length &&\n          console.error(\n            \"Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          );\n    }\n    function camelize(string) {\n      return string.replace(hyphenPattern, function (_, character) {\n        return character.toUpperCase();\n      });\n    }\n    function escapeTextForBrowser(text) {\n      if (\n        \"boolean\" === typeof text ||\n        \"number\" === typeof text ||\n        \"bigint\" === typeof text\n      )\n        return \"\" + text;\n      checkHtmlStringCoercion(text);\n      text = \"\" + text;\n      var match = matchHtmlRegExp.exec(text);\n      if (match) {\n        var html = \"\",\n          index,\n          lastIndex = 0;\n        for (index = match.index; index < text.length; index++) {\n          switch (text.charCodeAt(index)) {\n            case 34:\n              match = \"&quot;\";\n              break;\n            case 38:\n              match = \"&amp;\";\n              break;\n            case 39:\n              match = \"&#x27;\";\n              break;\n            case 60:\n              match = \"&lt;\";\n              break;\n            case 62:\n              match = \"&gt;\";\n              break;\n            default:\n              continue;\n          }\n          lastIndex !== index && (html += text.slice(lastIndex, index));\n          lastIndex = index + 1;\n          html += match;\n        }\n        text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;\n      }\n      return text;\n    }\n    function sanitizeURL(url) {\n      return isJavaScriptProtocol.test(\"\" + url)\n        ? \"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')\"\n        : url;\n    }\n    function escapeEntireInlineScriptContent(scriptText) {\n      checkHtmlStringCoercion(scriptText);\n      return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n    }\n    function createResumableState(\n      identifierPrefix,\n      externalRuntimeConfig,\n      bootstrapScriptContent,\n      bootstrapScripts,\n      bootstrapModules\n    ) {\n      return {\n        idPrefix: void 0 === identifierPrefix ? \"\" : identifierPrefix,\n        nextFormID: 0,\n        streamingFormat: 0,\n        bootstrapScriptContent: bootstrapScriptContent,\n        bootstrapScripts: bootstrapScripts,\n        bootstrapModules: bootstrapModules,\n        instructions: NothingSent,\n        hasBody: !1,\n        hasHtml: !1,\n        unknownResources: {},\n        dnsResources: {},\n        connectResources: { default: {}, anonymous: {}, credentials: {} },\n        imageResources: {},\n        styleResources: {},\n        scriptResources: {},\n        moduleUnknownResources: {},\n        moduleScriptResources: {}\n      };\n    }\n    function createPreambleState() {\n      return {\n        htmlChunks: null,\n        headChunks: null,\n        bodyChunks: null,\n        contribution: NoContribution\n      };\n    }\n    function createFormatContext(insertionMode, selectedValue, tagScope) {\n      return {\n        insertionMode: insertionMode,\n        selectedValue: selectedValue,\n        tagScope: tagScope\n      };\n    }\n    function getChildFormatContext(parentContext, type, props) {\n      switch (type) {\n        case \"noscript\":\n          return createFormatContext(\n            HTML_MODE,\n            null,\n            parentContext.tagScope | 1\n          );\n        case \"select\":\n          return createFormatContext(\n            HTML_MODE,\n            null != props.value ? props.value : props.defaultValue,\n            parentContext.tagScope\n          );\n        case \"svg\":\n          return createFormatContext(SVG_MODE, null, parentContext.tagScope);\n        case \"picture\":\n          return createFormatContext(\n            HTML_MODE,\n            null,\n            parentContext.tagScope | 2\n          );\n        case \"math\":\n          return createFormatContext(MATHML_MODE, null, parentContext.tagScope);\n        case \"foreignObject\":\n          return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n        case \"table\":\n          return createFormatContext(\n            HTML_TABLE_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"thead\":\n        case \"tbody\":\n        case \"tfoot\":\n          return createFormatContext(\n            HTML_TABLE_BODY_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"colgroup\":\n          return createFormatContext(\n            HTML_COLGROUP_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"tr\":\n          return createFormatContext(\n            HTML_TABLE_ROW_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"head\":\n          if (parentContext.insertionMode < HTML_MODE)\n            return createFormatContext(\n              HTML_HEAD_MODE,\n              null,\n              parentContext.tagScope\n            );\n          break;\n        case \"html\":\n          if (parentContext.insertionMode === ROOT_HTML_MODE)\n            return createFormatContext(\n              HTML_HTML_MODE,\n              null,\n              parentContext.tagScope\n            );\n      }\n      return parentContext.insertionMode >= HTML_TABLE_MODE ||\n        parentContext.insertionMode < HTML_MODE\n        ? createFormatContext(HTML_MODE, null, parentContext.tagScope)\n        : parentContext;\n    }\n    function pushStyleAttribute(target, style) {\n      if (\"object\" !== typeof style)\n        throw Error(\n          \"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\"\n        );\n      var isFirst = !0,\n        styleName;\n      for (styleName in style)\n        if (hasOwnProperty.call(style, styleName)) {\n          var styleValue = style[styleName];\n          if (\n            null != styleValue &&\n            \"boolean\" !== typeof styleValue &&\n            \"\" !== styleValue\n          ) {\n            if (0 === styleName.indexOf(\"--\")) {\n              var nameChunk = escapeTextForBrowser(styleName);\n              checkCSSPropertyStringCoercion(styleValue, styleName);\n              styleValue = escapeTextForBrowser((\"\" + styleValue).trim());\n            } else {\n              nameChunk = styleName;\n              var value = styleValue;\n              if (-1 < nameChunk.indexOf(\"-\")) {\n                var name = nameChunk;\n                (warnedStyleNames.hasOwnProperty(name) &&\n                  warnedStyleNames[name]) ||\n                  ((warnedStyleNames[name] = !0),\n                  console.error(\n                    \"Unsupported style property %s. Did you mean %s?\",\n                    name,\n                    camelize(name.replace(msPattern$1, \"ms-\"))\n                  ));\n              } else if (badVendoredStyleNamePattern.test(nameChunk))\n                (name = nameChunk),\n                  (warnedStyleNames.hasOwnProperty(name) &&\n                    warnedStyleNames[name]) ||\n                    ((warnedStyleNames[name] = !0),\n                    console.error(\n                      \"Unsupported vendor-prefixed style property %s. Did you mean %s?\",\n                      name,\n                      name.charAt(0).toUpperCase() + name.slice(1)\n                    ));\n              else if (badStyleValueWithSemicolonPattern.test(value)) {\n                name = nameChunk;\n                var value$jscomp$0 = value;\n                (warnedStyleValues.hasOwnProperty(value$jscomp$0) &&\n                  warnedStyleValues[value$jscomp$0]) ||\n                  ((warnedStyleValues[value$jscomp$0] = !0),\n                  console.error(\n                    'Style property values shouldn\\'t contain a semicolon. Try \"%s: %s\" instead.',\n                    name,\n                    value$jscomp$0.replace(\n                      badStyleValueWithSemicolonPattern,\n                      \"\"\n                    )\n                  ));\n              }\n              \"number\" === typeof value &&\n                (isNaN(value)\n                  ? warnedForNaNValue ||\n                    ((warnedForNaNValue = !0),\n                    console.error(\n                      \"`NaN` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    ))\n                  : isFinite(value) ||\n                    warnedForInfinityValue ||\n                    ((warnedForInfinityValue = !0),\n                    console.error(\n                      \"`Infinity` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    )));\n              nameChunk = styleName;\n              value = styleNameCache.get(nameChunk);\n              void 0 !== value\n                ? (nameChunk = value)\n                : ((value = escapeTextForBrowser(\n                    nameChunk\n                      .replace(uppercasePattern, \"-$1\")\n                      .toLowerCase()\n                      .replace(msPattern, \"-ms-\")\n                  )),\n                  styleNameCache.set(nameChunk, value),\n                  (nameChunk = value));\n              \"number\" === typeof styleValue\n                ? (styleValue =\n                    0 === styleValue || unitlessNumbers.has(styleName)\n                      ? \"\" + styleValue\n                      : styleValue + \"px\")\n                : (checkCSSPropertyStringCoercion(styleValue, styleName),\n                  (styleValue = escapeTextForBrowser(\n                    (\"\" + styleValue).trim()\n                  )));\n            }\n            isFirst\n              ? ((isFirst = !1),\n                target.push(\n                  styleAttributeStart,\n                  nameChunk,\n                  styleAssign,\n                  styleValue\n                ))\n              : target.push(styleSeparator, nameChunk, styleAssign, styleValue);\n          }\n        }\n      isFirst || target.push(attributeEnd);\n    }\n    function pushBooleanAttribute(target, name, value) {\n      value &&\n        \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        target.push(attributeSeparator, name, attributeEmptyString);\n    }\n    function pushStringAttribute(target, name, value) {\n      \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        \"boolean\" !== typeof value &&\n        target.push(\n          attributeSeparator,\n          name,\n          attributeAssign,\n          escapeTextForBrowser(value),\n          attributeEnd\n        );\n    }\n    function pushAdditionalFormField(value, key) {\n      this.push('<input type=\"hidden\"');\n      validateAdditionalFormField(value);\n      pushStringAttribute(this, \"name\", key);\n      pushStringAttribute(this, \"value\", value);\n      this.push(endOfStartTagSelfClosing);\n    }\n    function validateAdditionalFormField(value) {\n      if (\"string\" !== typeof value)\n        throw Error(\n          \"File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.\"\n        );\n    }\n    function getCustomFormFields(resumableState, formAction) {\n      if (\"function\" === typeof formAction.$$FORM_ACTION) {\n        var id = resumableState.nextFormID++;\n        resumableState = resumableState.idPrefix + id;\n        try {\n          var customFields = formAction.$$FORM_ACTION(resumableState);\n          if (customFields) {\n            var formData = customFields.data;\n            null != formData && formData.forEach(validateAdditionalFormField);\n          }\n          return customFields;\n        } catch (x) {\n          if (\n            \"object\" === typeof x &&\n            null !== x &&\n            \"function\" === typeof x.then\n          )\n            throw x;\n          console.error(\n            \"Failed to serialize an action for progressive enhancement:\\n%s\",\n            x\n          );\n        }\n      }\n      return null;\n    }\n    function pushFormActionAttribute(\n      target,\n      resumableState,\n      renderState,\n      formAction,\n      formEncType,\n      formMethod,\n      formTarget,\n      name\n    ) {\n      var formData = null;\n      if (\"function\" === typeof formAction) {\n        null === name ||\n          didWarnFormActionName ||\n          ((didWarnFormActionName = !0),\n          console.error(\n            'Cannot specify a \"name\" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'\n          ));\n        (null === formEncType && null === formMethod) ||\n          didWarnFormActionMethod ||\n          ((didWarnFormActionMethod = !0),\n          console.error(\n            \"Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.\"\n          ));\n        null === formTarget ||\n          didWarnFormActionTarget ||\n          ((didWarnFormActionTarget = !0),\n          console.error(\n            \"Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window.\"\n          ));\n        var customFields = getCustomFormFields(resumableState, formAction);\n        null !== customFields\n          ? ((name = customFields.name),\n            (formAction = customFields.action || \"\"),\n            (formEncType = customFields.encType),\n            (formMethod = customFields.method),\n            (formTarget = customFields.target),\n            (formData = customFields.data))\n          : (target.push(\n              attributeSeparator,\n              \"formAction\",\n              attributeAssign,\n              actionJavaScriptURL,\n              attributeEnd\n            ),\n            (formTarget = formMethod = formEncType = formAction = name = null),\n            injectFormReplayingRuntime(resumableState, renderState));\n      }\n      null != name && pushAttribute(target, \"name\", name);\n      null != formAction && pushAttribute(target, \"formAction\", formAction);\n      null != formEncType && pushAttribute(target, \"formEncType\", formEncType);\n      null != formMethod && pushAttribute(target, \"formMethod\", formMethod);\n      null != formTarget && pushAttribute(target, \"formTarget\", formTarget);\n      return formData;\n    }\n    function pushAttribute(target, name, value) {\n      switch (name) {\n        case \"className\":\n          pushStringAttribute(target, \"class\", value);\n          break;\n        case \"tabIndex\":\n          pushStringAttribute(target, \"tabindex\", value);\n          break;\n        case \"dir\":\n        case \"role\":\n        case \"viewBox\":\n        case \"width\":\n        case \"height\":\n          pushStringAttribute(target, name, value);\n          break;\n        case \"style\":\n          pushStyleAttribute(target, value);\n          break;\n        case \"src\":\n        case \"href\":\n          if (\"\" === value) {\n            \"src\" === name\n              ? console.error(\n                  'An empty string (\"\") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                )\n              : console.error(\n                  'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                );\n            break;\n          }\n        case \"action\":\n        case \"formAction\":\n          if (\n            null == value ||\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            name,\n            attributeAssign,\n            escapeTextForBrowser(value),\n            attributeEnd\n          );\n          break;\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"ref\":\n          break;\n        case \"autoFocus\":\n        case \"multiple\":\n        case \"muted\":\n          pushBooleanAttribute(target, name.toLowerCase(), value);\n          break;\n        case \"xlinkHref\":\n          if (\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            \"xlink:href\",\n            attributeAssign,\n            escapeTextForBrowser(value),\n            attributeEnd\n          );\n          break;\n        case \"contentEditable\":\n        case \"spellCheck\":\n        case \"draggable\":\n        case \"value\":\n        case \"autoReverse\":\n        case \"externalResourcesRequired\":\n        case \"focusable\":\n        case \"preserveAlpha\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"inert\":\n          \"\" !== value ||\n            didWarnForNewBooleanPropsWithEmptyValue[name] ||\n            ((didWarnForNewBooleanPropsWithEmptyValue[name] = !0),\n            console.error(\n              \"Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.\",\n              name\n            ));\n        case \"allowFullScreen\":\n        case \"async\":\n        case \"autoPlay\":\n        case \"controls\":\n        case \"default\":\n        case \"defer\":\n        case \"disabled\":\n        case \"disablePictureInPicture\":\n        case \"disableRemotePlayback\":\n        case \"formNoValidate\":\n        case \"hidden\":\n        case \"loop\":\n        case \"noModule\":\n        case \"noValidate\":\n        case \"open\":\n        case \"playsInline\":\n        case \"readOnly\":\n        case \"required\":\n        case \"reversed\":\n        case \"scoped\":\n        case \"seamless\":\n        case \"itemScope\":\n          value &&\n            \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(attributeSeparator, name, attributeEmptyString);\n          break;\n        case \"capture\":\n        case \"download\":\n          !0 === value\n            ? target.push(attributeSeparator, name, attributeEmptyString)\n            : !1 !== value &&\n              \"function\" !== typeof value &&\n              \"symbol\" !== typeof value &&\n              target.push(\n                attributeSeparator,\n                name,\n                attributeAssign,\n                escapeTextForBrowser(value),\n                attributeEnd\n              );\n          break;\n        case \"cols\":\n        case \"rows\":\n        case \"size\":\n        case \"span\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            !isNaN(value) &&\n            1 <= value &&\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"rowSpan\":\n        case \"start\":\n          \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            isNaN(value) ||\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"xlinkActuate\":\n          pushStringAttribute(target, \"xlink:actuate\", value);\n          break;\n        case \"xlinkArcrole\":\n          pushStringAttribute(target, \"xlink:arcrole\", value);\n          break;\n        case \"xlinkRole\":\n          pushStringAttribute(target, \"xlink:role\", value);\n          break;\n        case \"xlinkShow\":\n          pushStringAttribute(target, \"xlink:show\", value);\n          break;\n        case \"xlinkTitle\":\n          pushStringAttribute(target, \"xlink:title\", value);\n          break;\n        case \"xlinkType\":\n          pushStringAttribute(target, \"xlink:type\", value);\n          break;\n        case \"xmlBase\":\n          pushStringAttribute(target, \"xml:base\", value);\n          break;\n        case \"xmlLang\":\n          pushStringAttribute(target, \"xml:lang\", value);\n          break;\n        case \"xmlSpace\":\n          pushStringAttribute(target, \"xml:space\", value);\n          break;\n        default:\n          if (\n            !(2 < name.length) ||\n            (\"o\" !== name[0] && \"O\" !== name[0]) ||\n            (\"n\" !== name[1] && \"N\" !== name[1])\n          )\n            if (\n              ((name = aliases.get(name) || name), isAttributeNameSafe(name))\n            ) {\n              switch (typeof value) {\n                case \"function\":\n                case \"symbol\":\n                  return;\n                case \"boolean\":\n                  var prefix = name.toLowerCase().slice(0, 5);\n                  if (\"data-\" !== prefix && \"aria-\" !== prefix) return;\n              }\n              target.push(\n                attributeSeparator,\n                name,\n                attributeAssign,\n                escapeTextForBrowser(value),\n                attributeEnd\n              );\n            }\n      }\n    }\n    function pushInnerHTML(target, innerHTML, children) {\n      if (null != innerHTML) {\n        if (null != children)\n          throw Error(\n            \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n          );\n        if (\"object\" !== typeof innerHTML || !(\"__html\" in innerHTML))\n          throw Error(\n            \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n          );\n        innerHTML = innerHTML.__html;\n        null !== innerHTML &&\n          void 0 !== innerHTML &&\n          (checkHtmlStringCoercion(innerHTML), target.push(\"\" + innerHTML));\n      }\n    }\n    function checkSelectProp(props, propName) {\n      var value = props[propName];\n      null != value &&\n        ((value = isArrayImpl(value)),\n        props.multiple && !value\n          ? console.error(\n              \"The `%s` prop supplied to <select> must be an array if `multiple` is true.\",\n              propName\n            )\n          : !props.multiple &&\n            value &&\n            console.error(\n              \"The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.\",\n              propName\n            ));\n    }\n    function flattenOptionChildren(children) {\n      var content = \"\";\n      React.Children.forEach(children, function (child) {\n        null != child &&\n          ((content += child),\n          didWarnInvalidOptionChildren ||\n            \"string\" === typeof child ||\n            \"number\" === typeof child ||\n            \"bigint\" === typeof child ||\n            ((didWarnInvalidOptionChildren = !0),\n            console.error(\n              \"Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.\"\n            )));\n      });\n      return content;\n    }\n    function injectFormReplayingRuntime(resumableState, renderState) {\n      (resumableState.instructions & 16) === NothingSent &&\n        ((resumableState.instructions |= 16),\n        renderState.bootstrapChunks.unshift(\n          renderState.startInlineScript,\n          formReplayingRuntimeScript,\n          \"\\x3c/script>\"\n        ));\n    }\n    function pushLinkImpl(target, props) {\n      target.push(startChunkForTag(\"link\"));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function escapeStyleTextContent(styleText) {\n      checkHtmlStringCoercion(styleText);\n      return (\"\" + styleText).replace(styleRegex, styleReplacer);\n    }\n    function pushSelfClosing(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  tag +\n                    \" is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function pushTitleImpl(target, props) {\n      target.push(startChunkForTag(\"title\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      props = Array.isArray(children)\n        ? 2 > children.length\n          ? children[0]\n          : null\n        : children;\n      \"function\" !== typeof props &&\n        \"symbol\" !== typeof props &&\n        null !== props &&\n        void 0 !== props &&\n        target.push(escapeTextForBrowser(\"\" + props));\n      pushInnerHTML(target, innerHTML, children);\n      target.push(endChunkForTag(\"title\"));\n      return null;\n    }\n    function pushScriptImpl(target, props) {\n      target.push(startChunkForTag(\"script\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      null != children &&\n        \"string\" !== typeof children &&\n        ((props =\n          \"number\" === typeof children\n            ? \"a number for children\"\n            : Array.isArray(children)\n              ? \"an array for children\"\n              : \"something unexpected for children\"),\n        console.error(\n          \"A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.\",\n          props\n        ));\n      pushInnerHTML(target, innerHTML, children);\n      \"string\" === typeof children &&\n        target.push(escapeEntireInlineScriptContent(children));\n      target.push(endChunkForTag(\"script\"));\n      return null;\n    }\n    function pushStartSingletonElement(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      var innerHTML = (tag = null),\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                tag = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      pushInnerHTML(target, innerHTML, tag);\n      return tag;\n    }\n    function pushStartGenericElement(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      var innerHTML = (tag = null),\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                tag = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      pushInnerHTML(target, innerHTML, tag);\n      return \"string\" === typeof tag\n        ? (target.push(escapeTextForBrowser(tag)), null)\n        : tag;\n    }\n    function startChunkForTag(tag) {\n      var tagStartChunk = validatedTagCache.get(tag);\n      if (void 0 === tagStartChunk) {\n        if (!VALID_TAG_REGEX.test(tag)) throw Error(\"Invalid tag: \" + tag);\n        tagStartChunk = \"<\" + tag;\n        validatedTagCache.set(tag, tagStartChunk);\n      }\n      return tagStartChunk;\n    }\n    function pushStartInstance(\n      target$jscomp$0,\n      type,\n      props,\n      resumableState,\n      renderState,\n      preambleState,\n      hoistableState,\n      formatContext,\n      textEmbedded,\n      isFallback\n    ) {\n      validateProperties$2(type, props);\n      (\"input\" !== type && \"textarea\" !== type && \"select\" !== type) ||\n        null == props ||\n        null !== props.value ||\n        didWarnValueNull ||\n        ((didWarnValueNull = !0),\n        \"select\" === type && props.multiple\n          ? console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.\",\n              type\n            )\n          : console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.\",\n              type\n            ));\n      b: if (-1 === type.indexOf(\"-\")) var JSCompiler_inline_result = !1;\n      else\n        switch (type) {\n          case \"annotation-xml\":\n          case \"color-profile\":\n          case \"font-face\":\n          case \"font-face-src\":\n          case \"font-face-uri\":\n          case \"font-face-format\":\n          case \"font-face-name\":\n          case \"missing-glyph\":\n            JSCompiler_inline_result = !1;\n            break b;\n          default:\n            JSCompiler_inline_result = !0;\n        }\n      JSCompiler_inline_result ||\n        \"string\" === typeof props.is ||\n        warnUnknownProperties(type, props, null);\n      !props.suppressContentEditableWarning &&\n        props.contentEditable &&\n        null != props.children &&\n        console.error(\n          \"A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.\"\n        );\n      formatContext.insertionMode !== SVG_MODE &&\n        formatContext.insertionMode !== MATHML_MODE &&\n        -1 === type.indexOf(\"-\") &&\n        type.toLowerCase() !== type &&\n        console.error(\n          \"<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.\",\n          type\n        );\n      switch (type) {\n        case \"div\":\n        case \"span\":\n        case \"svg\":\n        case \"path\":\n          break;\n        case \"a\":\n          target$jscomp$0.push(startChunkForTag(\"a\"));\n          var children = null,\n            innerHTML = null,\n            propKey;\n          for (propKey in props)\n            if (hasOwnProperty.call(props, propKey)) {\n              var propValue = props[propKey];\n              if (null != propValue)\n                switch (propKey) {\n                  case \"children\":\n                    children = propValue;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML = propValue;\n                    break;\n                  case \"href\":\n                    \"\" === propValue\n                      ? pushStringAttribute(target$jscomp$0, \"href\", \"\")\n                      : pushAttribute(target$jscomp$0, propKey, propValue);\n                    break;\n                  default:\n                    pushAttribute(target$jscomp$0, propKey, propValue);\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML, children);\n          if (\"string\" === typeof children) {\n            target$jscomp$0.push(escapeTextForBrowser(children));\n            var JSCompiler_inline_result$jscomp$0 = null;\n          } else JSCompiler_inline_result$jscomp$0 = children;\n          return JSCompiler_inline_result$jscomp$0;\n        case \"g\":\n        case \"p\":\n        case \"li\":\n          break;\n        case \"select\":\n          checkControlledValueProps(\"select\", props);\n          checkSelectProp(props, \"value\");\n          checkSelectProp(props, \"defaultValue\");\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultSelectValue ||\n            (console.error(\n              \"Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultSelectValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"select\"));\n          var children$jscomp$0 = null,\n            innerHTML$jscomp$0 = null,\n            propKey$jscomp$0;\n          for (propKey$jscomp$0 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$0)) {\n              var propValue$jscomp$0 = props[propKey$jscomp$0];\n              if (null != propValue$jscomp$0)\n                switch (propKey$jscomp$0) {\n                  case \"children\":\n                    children$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"defaultValue\":\n                  case \"value\":\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$0,\n                      propValue$jscomp$0\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);\n          return children$jscomp$0;\n        case \"option\":\n          var selectedValue = formatContext.selectedValue;\n          target$jscomp$0.push(startChunkForTag(\"option\"));\n          var children$jscomp$1 = null,\n            value = null,\n            selected = null,\n            innerHTML$jscomp$1 = null,\n            propKey$jscomp$1;\n          for (propKey$jscomp$1 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$1)) {\n              var propValue$jscomp$1 = props[propKey$jscomp$1];\n              if (null != propValue$jscomp$1)\n                switch (propKey$jscomp$1) {\n                  case \"children\":\n                    children$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"selected\":\n                    selected = propValue$jscomp$1;\n                    didWarnSelectedSetOnOption ||\n                      (console.error(\n                        \"Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.\"\n                      ),\n                      (didWarnSelectedSetOnOption = !0));\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"value\":\n                    value = propValue$jscomp$1;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$1,\n                      propValue$jscomp$1\n                    );\n                }\n            }\n          if (null != selectedValue) {\n            if (null !== value) {\n              checkAttributeStringCoercion(value, \"value\");\n              var stringValue = \"\" + value;\n            } else\n              null === innerHTML$jscomp$1 ||\n                didWarnInvalidOptionInnerHTML ||\n                ((didWarnInvalidOptionInnerHTML = !0),\n                console.error(\n                  \"Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.\"\n                )),\n                (stringValue = flattenOptionChildren(children$jscomp$1));\n            if (isArrayImpl(selectedValue))\n              for (var i = 0; i < selectedValue.length; i++) {\n                if (\n                  (checkAttributeStringCoercion(selectedValue[i], \"value\"),\n                  \"\" + selectedValue[i] === stringValue)\n                ) {\n                  target$jscomp$0.push(' selected=\"\"');\n                  break;\n                }\n              }\n            else\n              checkAttributeStringCoercion(selectedValue, \"select.value\"),\n                \"\" + selectedValue === stringValue &&\n                  target$jscomp$0.push(' selected=\"\"');\n          } else selected && target$jscomp$0.push(' selected=\"\"');\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);\n          return children$jscomp$1;\n        case \"textarea\":\n          checkControlledValueProps(\"textarea\", props);\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultTextareaValue ||\n            (console.error(\n              \"Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultTextareaValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"textarea\"));\n          var value$jscomp$0 = null,\n            defaultValue = null,\n            children$jscomp$2 = null,\n            propKey$jscomp$2;\n          for (propKey$jscomp$2 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$2)) {\n              var propValue$jscomp$2 = props[propKey$jscomp$2];\n              if (null != propValue$jscomp$2)\n                switch (propKey$jscomp$2) {\n                  case \"children\":\n                    children$jscomp$2 = propValue$jscomp$2;\n                    break;\n                  case \"value\":\n                    value$jscomp$0 = propValue$jscomp$2;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue = propValue$jscomp$2;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"`dangerouslySetInnerHTML` does not make sense on <textarea>.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$2,\n                      propValue$jscomp$2\n                    );\n                }\n            }\n          null === value$jscomp$0 &&\n            null !== defaultValue &&\n            (value$jscomp$0 = defaultValue);\n          target$jscomp$0.push(endOfStartTag);\n          if (null != children$jscomp$2) {\n            console.error(\n              \"Use the `defaultValue` or `value` props instead of setting children on <textarea>.\"\n            );\n            if (null != value$jscomp$0)\n              throw Error(\n                \"If you supply `defaultValue` on a <textarea>, do not pass children.\"\n              );\n            if (isArrayImpl(children$jscomp$2)) {\n              if (1 < children$jscomp$2.length)\n                throw Error(\"<textarea> can only have at most one child.\");\n              checkHtmlStringCoercion(children$jscomp$2[0]);\n              value$jscomp$0 = \"\" + children$jscomp$2[0];\n            }\n            checkHtmlStringCoercion(children$jscomp$2);\n            value$jscomp$0 = \"\" + children$jscomp$2;\n          }\n          \"string\" === typeof value$jscomp$0 &&\n            \"\\n\" === value$jscomp$0[0] &&\n            target$jscomp$0.push(leadingNewline);\n          null !== value$jscomp$0 &&\n            (checkAttributeStringCoercion(value$jscomp$0, \"value\"),\n            target$jscomp$0.push(escapeTextForBrowser(\"\" + value$jscomp$0)));\n          return null;\n        case \"input\":\n          checkControlledValueProps(\"input\", props);\n          target$jscomp$0.push(startChunkForTag(\"input\"));\n          var name = null,\n            formAction = null,\n            formEncType = null,\n            formMethod = null,\n            formTarget = null,\n            value$jscomp$1 = null,\n            defaultValue$jscomp$0 = null,\n            checked = null,\n            defaultChecked = null,\n            propKey$jscomp$3;\n          for (propKey$jscomp$3 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$3)) {\n              var propValue$jscomp$3 = props[propKey$jscomp$3];\n              if (null != propValue$jscomp$3)\n                switch (propKey$jscomp$3) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  case \"name\":\n                    name = propValue$jscomp$3;\n                    break;\n                  case \"formAction\":\n                    formAction = propValue$jscomp$3;\n                    break;\n                  case \"formEncType\":\n                    formEncType = propValue$jscomp$3;\n                    break;\n                  case \"formMethod\":\n                    formMethod = propValue$jscomp$3;\n                    break;\n                  case \"formTarget\":\n                    formTarget = propValue$jscomp$3;\n                    break;\n                  case \"defaultChecked\":\n                    defaultChecked = propValue$jscomp$3;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue$jscomp$0 = propValue$jscomp$3;\n                    break;\n                  case \"checked\":\n                    checked = propValue$jscomp$3;\n                    break;\n                  case \"value\":\n                    value$jscomp$1 = propValue$jscomp$3;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$3,\n                      propValue$jscomp$3\n                    );\n                }\n            }\n          null === formAction ||\n            \"image\" === props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'An input can only specify a formAction along with type=\"submit\" or type=\"image\".'\n            ));\n          var formData = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction,\n            formEncType,\n            formMethod,\n            formTarget,\n            name\n          );\n          null === checked ||\n            null === defaultChecked ||\n            didWarnDefaultChecked ||\n            (console.error(\n              \"%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultChecked = !0));\n          null === value$jscomp$1 ||\n            null === defaultValue$jscomp$0 ||\n            didWarnDefaultInputValue ||\n            (console.error(\n              \"%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultInputValue = !0));\n          null !== checked\n            ? pushBooleanAttribute(target$jscomp$0, \"checked\", checked)\n            : null !== defaultChecked &&\n              pushBooleanAttribute(target$jscomp$0, \"checked\", defaultChecked);\n          null !== value$jscomp$1\n            ? pushAttribute(target$jscomp$0, \"value\", value$jscomp$1)\n            : null !== defaultValue$jscomp$0 &&\n              pushAttribute(target$jscomp$0, \"value\", defaultValue$jscomp$0);\n          target$jscomp$0.push(endOfStartTagSelfClosing);\n          null != formData &&\n            formData.forEach(pushAdditionalFormField, target$jscomp$0);\n          return null;\n        case \"button\":\n          target$jscomp$0.push(startChunkForTag(\"button\"));\n          var children$jscomp$3 = null,\n            innerHTML$jscomp$2 = null,\n            name$jscomp$0 = null,\n            formAction$jscomp$0 = null,\n            formEncType$jscomp$0 = null,\n            formMethod$jscomp$0 = null,\n            formTarget$jscomp$0 = null,\n            propKey$jscomp$4;\n          for (propKey$jscomp$4 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$4)) {\n              var propValue$jscomp$4 = props[propKey$jscomp$4];\n              if (null != propValue$jscomp$4)\n                switch (propKey$jscomp$4) {\n                  case \"children\":\n                    children$jscomp$3 = propValue$jscomp$4;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$2 = propValue$jscomp$4;\n                    break;\n                  case \"name\":\n                    name$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formAction\":\n                    formAction$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formEncType\":\n                    formEncType$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formMethod\":\n                    formMethod$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formTarget\":\n                    formTarget$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$4,\n                      propValue$jscomp$4\n                    );\n                }\n            }\n          null === formAction$jscomp$0 ||\n            null == props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'A button can only specify a formAction along with type=\"submit\" or no type.'\n            ));\n          var formData$jscomp$0 = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction$jscomp$0,\n            formEncType$jscomp$0,\n            formMethod$jscomp$0,\n            formTarget$jscomp$0,\n            name$jscomp$0\n          );\n          target$jscomp$0.push(endOfStartTag);\n          null != formData$jscomp$0 &&\n            formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);\n          if (\"string\" === typeof children$jscomp$3) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));\n            var JSCompiler_inline_result$jscomp$1 = null;\n          } else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;\n          return JSCompiler_inline_result$jscomp$1;\n        case \"form\":\n          target$jscomp$0.push(startChunkForTag(\"form\"));\n          var children$jscomp$4 = null,\n            innerHTML$jscomp$3 = null,\n            formAction$jscomp$1 = null,\n            formEncType$jscomp$1 = null,\n            formMethod$jscomp$1 = null,\n            formTarget$jscomp$1 = null,\n            propKey$jscomp$5;\n          for (propKey$jscomp$5 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$5)) {\n              var propValue$jscomp$5 = props[propKey$jscomp$5];\n              if (null != propValue$jscomp$5)\n                switch (propKey$jscomp$5) {\n                  case \"children\":\n                    children$jscomp$4 = propValue$jscomp$5;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$3 = propValue$jscomp$5;\n                    break;\n                  case \"action\":\n                    formAction$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"encType\":\n                    formEncType$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"method\":\n                    formMethod$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"target\":\n                    formTarget$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$5,\n                      propValue$jscomp$5\n                    );\n                }\n            }\n          var formData$jscomp$1 = null,\n            formActionName = null;\n          if (\"function\" === typeof formAction$jscomp$1) {\n            (null === formEncType$jscomp$1 && null === formMethod$jscomp$1) ||\n              didWarnFormActionMethod ||\n              ((didWarnFormActionMethod = !0),\n              console.error(\n                \"Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.\"\n              ));\n            null === formTarget$jscomp$1 ||\n              didWarnFormActionTarget ||\n              ((didWarnFormActionTarget = !0),\n              console.error(\n                \"Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window.\"\n              ));\n            var customFields = getCustomFormFields(\n              resumableState,\n              formAction$jscomp$1\n            );\n            null !== customFields\n              ? ((formAction$jscomp$1 = customFields.action || \"\"),\n                (formEncType$jscomp$1 = customFields.encType),\n                (formMethod$jscomp$1 = customFields.method),\n                (formTarget$jscomp$1 = customFields.target),\n                (formData$jscomp$1 = customFields.data),\n                (formActionName = customFields.name))\n              : (target$jscomp$0.push(\n                  attributeSeparator,\n                  \"action\",\n                  attributeAssign,\n                  actionJavaScriptURL,\n                  attributeEnd\n                ),\n                (formTarget$jscomp$1 =\n                  formMethod$jscomp$1 =\n                  formEncType$jscomp$1 =\n                  formAction$jscomp$1 =\n                    null),\n                injectFormReplayingRuntime(resumableState, renderState));\n          }\n          null != formAction$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"action\", formAction$jscomp$1);\n          null != formEncType$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"encType\", formEncType$jscomp$1);\n          null != formMethod$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"method\", formMethod$jscomp$1);\n          null != formTarget$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"target\", formTarget$jscomp$1);\n          target$jscomp$0.push(endOfStartTag);\n          null !== formActionName &&\n            (target$jscomp$0.push('<input type=\"hidden\"'),\n            pushStringAttribute(target$jscomp$0, \"name\", formActionName),\n            target$jscomp$0.push(endOfStartTagSelfClosing),\n            null != formData$jscomp$1 &&\n              formData$jscomp$1.forEach(\n                pushAdditionalFormField,\n                target$jscomp$0\n              ));\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);\n          if (\"string\" === typeof children$jscomp$4) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));\n            var JSCompiler_inline_result$jscomp$2 = null;\n          } else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;\n          return JSCompiler_inline_result$jscomp$2;\n        case \"menuitem\":\n          target$jscomp$0.push(startChunkForTag(\"menuitem\"));\n          for (var propKey$jscomp$6 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$6)) {\n              var propValue$jscomp$6 = props[propKey$jscomp$6];\n              if (null != propValue$jscomp$6)\n                switch (propKey$jscomp$6) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$6,\n                      propValue$jscomp$6\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          return null;\n        case \"object\":\n          target$jscomp$0.push(startChunkForTag(\"object\"));\n          var children$jscomp$5 = null,\n            innerHTML$jscomp$4 = null,\n            propKey$jscomp$7;\n          for (propKey$jscomp$7 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$7)) {\n              var propValue$jscomp$7 = props[propKey$jscomp$7];\n              if (null != propValue$jscomp$7)\n                switch (propKey$jscomp$7) {\n                  case \"children\":\n                    children$jscomp$5 = propValue$jscomp$7;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$4 = propValue$jscomp$7;\n                    break;\n                  case \"data\":\n                    checkAttributeStringCoercion(propValue$jscomp$7, \"data\");\n                    var sanitizedValue = sanitizeURL(\"\" + propValue$jscomp$7);\n                    if (\"\" === sanitizedValue) {\n                      console.error(\n                        'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                        propKey$jscomp$7,\n                        propKey$jscomp$7\n                      );\n                      break;\n                    }\n                    target$jscomp$0.push(\n                      attributeSeparator,\n                      \"data\",\n                      attributeAssign,\n                      escapeTextForBrowser(sanitizedValue),\n                      attributeEnd\n                    );\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$7,\n                      propValue$jscomp$7\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);\n          if (\"string\" === typeof children$jscomp$5) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));\n            var JSCompiler_inline_result$jscomp$3 = null;\n          } else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;\n          return JSCompiler_inline_result$jscomp$3;\n        case \"title\":\n          var insertionMode = formatContext.insertionMode,\n            noscriptTagInScope = !!(formatContext.tagScope & 1);\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$6 = props.children,\n              child = Array.isArray(children$jscomp$6)\n                ? 2 > children$jscomp$6.length\n                  ? children$jscomp$6[0]\n                  : null\n                : children$jscomp$6;\n            Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length\n              ? console.error(\n                  \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.\",\n                  children$jscomp$6.length\n                )\n              : \"function\" === typeof child || \"symbol\" === typeof child\n                ? console.error(\n                    \"React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.\",\n                    \"function\" === typeof child ? \"a Function\" : \"a Sybmol\"\n                  )\n                : child &&\n                  child.toString === {}.toString &&\n                  (null != child.$$typeof\n                    ? console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.\"\n                      )\n                    : console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>.\"\n                      ));\n          }\n          if (\n            insertionMode === SVG_MODE ||\n            noscriptTagInScope ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(\n              target$jscomp$0,\n              props\n            );\n          else\n            isFallback\n              ? (JSCompiler_inline_result$jscomp$4 = null)\n              : (pushTitleImpl(renderState.hoistableChunks, props),\n                (JSCompiler_inline_result$jscomp$4 = void 0));\n          return JSCompiler_inline_result$jscomp$4;\n        case \"link\":\n          var rel = props.rel,\n            href = props.href,\n            precedence = props.precedence;\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp ||\n            \"string\" !== typeof rel ||\n            \"string\" !== typeof href ||\n            \"\" === href\n          ) {\n            \"stylesheet\" === rel &&\n              \"string\" === typeof props.precedence &&\n              ((\"string\" === typeof href && href) ||\n                console.error(\n                  'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',\n                  null === href\n                    ? \"`null`\"\n                    : void 0 === href\n                      ? \"`undefined`\"\n                      : \"\" === href\n                        ? \"an empty string\"\n                        : 'something with type \"' + typeof href + '\"'\n                ));\n            pushLinkImpl(target$jscomp$0, props);\n            var JSCompiler_inline_result$jscomp$5 = null;\n          } else if (\"stylesheet\" === props.rel)\n            if (\n              \"string\" !== typeof precedence ||\n              null != props.disabled ||\n              props.onLoad ||\n              props.onError\n            ) {\n              if (\"string\" === typeof precedence)\n                if (null != props.disabled)\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'\n                  );\n                else if (props.onLoad || props.onError) {\n                  var propDescription =\n                    props.onLoad && props.onError\n                      ? \"`onLoad` and `onError` props\"\n                      : props.onLoad\n                        ? \"`onLoad` prop\"\n                        : \"`onError` prop\";\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',\n                    propDescription,\n                    propDescription\n                  );\n                }\n              JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                target$jscomp$0,\n                props\n              );\n            } else {\n              var styleQueue = renderState.styles.get(precedence),\n                resourceState = resumableState.styleResources.hasOwnProperty(\n                  href\n                )\n                  ? resumableState.styleResources[href]\n                  : void 0;\n              if (resourceState !== EXISTS) {\n                resumableState.styleResources[href] = EXISTS;\n                styleQueue ||\n                  ((styleQueue = {\n                    precedence: escapeTextForBrowser(precedence),\n                    rules: [],\n                    hrefs: [],\n                    sheets: new Map()\n                  }),\n                  renderState.styles.set(precedence, styleQueue));\n                var resource = {\n                  state: PENDING$1,\n                  props: assign({}, props, {\n                    \"data-precedence\": props.precedence,\n                    precedence: null\n                  })\n                };\n                if (resourceState) {\n                  2 === resourceState.length &&\n                    adoptPreloadCredentials(resource.props, resourceState);\n                  var preloadResource =\n                    renderState.preloads.stylesheets.get(href);\n                  preloadResource && 0 < preloadResource.length\n                    ? (preloadResource.length = 0)\n                    : (resource.state = PRELOADED);\n                }\n                styleQueue.sheets.set(href, resource);\n                hoistableState && hoistableState.stylesheets.add(resource);\n              } else if (styleQueue) {\n                var _resource = styleQueue.sheets.get(href);\n                _resource &&\n                  hoistableState &&\n                  hoistableState.stylesheets.add(_resource);\n              }\n              textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\");\n              JSCompiler_inline_result$jscomp$5 = null;\n            }\n          else\n            props.onLoad || props.onError\n              ? (JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                  target$jscomp$0,\n                  props\n                ))\n              : (textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\"),\n                (JSCompiler_inline_result$jscomp$5 = isFallback\n                  ? null\n                  : pushLinkImpl(renderState.hoistableChunks, props)));\n          return JSCompiler_inline_result$jscomp$5;\n        case \"script\":\n          var asyncProp = props.async;\n          if (\n            \"string\" !== typeof props.src ||\n            !props.src ||\n            !asyncProp ||\n            \"function\" === typeof asyncProp ||\n            \"symbol\" === typeof asyncProp ||\n            props.onLoad ||\n            props.onError ||\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(\n              target$jscomp$0,\n              props\n            );\n          else {\n            var key = props.src;\n            if (\"module\" === props.type) {\n              var resources = resumableState.moduleScriptResources;\n              var preloads = renderState.preloads.moduleScripts;\n            } else\n              (resources = resumableState.scriptResources),\n                (preloads = renderState.preloads.scripts);\n            var resourceState$jscomp$0 = resources.hasOwnProperty(key)\n              ? resources[key]\n              : void 0;\n            if (resourceState$jscomp$0 !== EXISTS) {\n              resources[key] = EXISTS;\n              var scriptProps = props;\n              if (resourceState$jscomp$0) {\n                2 === resourceState$jscomp$0.length &&\n                  ((scriptProps = assign({}, props)),\n                  adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));\n                var preloadResource$jscomp$0 = preloads.get(key);\n                preloadResource$jscomp$0 &&\n                  (preloadResource$jscomp$0.length = 0);\n              }\n              var resource$jscomp$0 = [];\n              renderState.scripts.add(resource$jscomp$0);\n              pushScriptImpl(resource$jscomp$0, scriptProps);\n            }\n            textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\");\n            JSCompiler_inline_result$jscomp$6 = null;\n          }\n          return JSCompiler_inline_result$jscomp$6;\n        case \"style\":\n          var insertionMode$jscomp$0 = formatContext.insertionMode,\n            noscriptTagInScope$jscomp$0 = !!(formatContext.tagScope & 1);\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$7 = props.children,\n              child$jscomp$0 = Array.isArray(children$jscomp$7)\n                ? 2 > children$jscomp$7.length\n                  ? children$jscomp$7[0]\n                  : null\n                : children$jscomp$7;\n            (\"function\" === typeof child$jscomp$0 ||\n              \"symbol\" === typeof child$jscomp$0 ||\n              Array.isArray(child$jscomp$0)) &&\n              console.error(\n                \"React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.\",\n                \"function\" === typeof child$jscomp$0\n                  ? \"a Function\"\n                  : \"symbol\" === typeof child$jscomp$0\n                    ? \"a Sybmol\"\n                    : \"an Array\"\n              );\n          }\n          var precedence$jscomp$0 = props.precedence,\n            href$jscomp$0 = props.href;\n          if (\n            insertionMode$jscomp$0 === SVG_MODE ||\n            noscriptTagInScope$jscomp$0 ||\n            null != props.itemProp ||\n            \"string\" !== typeof precedence$jscomp$0 ||\n            \"string\" !== typeof href$jscomp$0 ||\n            \"\" === href$jscomp$0\n          ) {\n            target$jscomp$0.push(startChunkForTag(\"style\"));\n            var children$jscomp$8 = null,\n              innerHTML$jscomp$5 = null,\n              propKey$jscomp$8;\n            for (propKey$jscomp$8 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$8)) {\n                var propValue$jscomp$8 = props[propKey$jscomp$8];\n                if (null != propValue$jscomp$8)\n                  switch (propKey$jscomp$8) {\n                    case \"children\":\n                      children$jscomp$8 = propValue$jscomp$8;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$5 = propValue$jscomp$8;\n                      break;\n                    default:\n                      pushAttribute(\n                        target$jscomp$0,\n                        propKey$jscomp$8,\n                        propValue$jscomp$8\n                      );\n                  }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            var child$jscomp$1 = Array.isArray(children$jscomp$8)\n              ? 2 > children$jscomp$8.length\n                ? children$jscomp$8[0]\n                : null\n              : children$jscomp$8;\n            \"function\" !== typeof child$jscomp$1 &&\n              \"symbol\" !== typeof child$jscomp$1 &&\n              null !== child$jscomp$1 &&\n              void 0 !== child$jscomp$1 &&\n              target$jscomp$0.push(escapeStyleTextContent(child$jscomp$1));\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$5,\n              children$jscomp$8\n            );\n            target$jscomp$0.push(endChunkForTag(\"style\"));\n            var JSCompiler_inline_result$jscomp$7 = null;\n          } else {\n            href$jscomp$0.includes(\" \") &&\n              console.error(\n                'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".',\n                href$jscomp$0\n              );\n            var styleQueue$jscomp$0 =\n                renderState.styles.get(precedence$jscomp$0),\n              resourceState$jscomp$1 =\n                resumableState.styleResources.hasOwnProperty(href$jscomp$0)\n                  ? resumableState.styleResources[href$jscomp$0]\n                  : void 0;\n            if (resourceState$jscomp$1 !== EXISTS) {\n              resumableState.styleResources[href$jscomp$0] = EXISTS;\n              resourceState$jscomp$1 &&\n                console.error(\n                  'React encountered a hoistable style tag for the same href as a preload: \"%s\". When using a style tag to inline styles you should not also preload it as a stylsheet.',\n                  href$jscomp$0\n                );\n              styleQueue$jscomp$0\n                ? styleQueue$jscomp$0.hrefs.push(\n                    escapeTextForBrowser(href$jscomp$0)\n                  )\n                : ((styleQueue$jscomp$0 = {\n                    precedence: escapeTextForBrowser(precedence$jscomp$0),\n                    rules: [],\n                    hrefs: [escapeTextForBrowser(href$jscomp$0)],\n                    sheets: new Map()\n                  }),\n                  renderState.styles.set(\n                    precedence$jscomp$0,\n                    styleQueue$jscomp$0\n                  ));\n              var target = styleQueue$jscomp$0.rules,\n                children$jscomp$9 = null,\n                innerHTML$jscomp$6 = null,\n                propKey$jscomp$9;\n              for (propKey$jscomp$9 in props)\n                if (hasOwnProperty.call(props, propKey$jscomp$9)) {\n                  var propValue$jscomp$9 = props[propKey$jscomp$9];\n                  if (null != propValue$jscomp$9)\n                    switch (propKey$jscomp$9) {\n                      case \"children\":\n                        children$jscomp$9 = propValue$jscomp$9;\n                        break;\n                      case \"dangerouslySetInnerHTML\":\n                        innerHTML$jscomp$6 = propValue$jscomp$9;\n                    }\n                }\n              var child$jscomp$2 = Array.isArray(children$jscomp$9)\n                ? 2 > children$jscomp$9.length\n                  ? children$jscomp$9[0]\n                  : null\n                : children$jscomp$9;\n              \"function\" !== typeof child$jscomp$2 &&\n                \"symbol\" !== typeof child$jscomp$2 &&\n                null !== child$jscomp$2 &&\n                void 0 !== child$jscomp$2 &&\n                target.push(escapeStyleTextContent(child$jscomp$2));\n              pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);\n            }\n            styleQueue$jscomp$0 &&\n              hoistableState &&\n              hoistableState.styles.add(styleQueue$jscomp$0);\n            textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\");\n            JSCompiler_inline_result$jscomp$7 = void 0;\n          }\n          return JSCompiler_inline_result$jscomp$7;\n        case \"meta\":\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(\n              target$jscomp$0,\n              props,\n              \"meta\"\n            );\n          else\n            textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\"),\n              (JSCompiler_inline_result$jscomp$8 = isFallback\n                ? null\n                : \"string\" === typeof props.charSet\n                  ? pushSelfClosing(renderState.charsetChunks, props, \"meta\")\n                  : \"viewport\" === props.name\n                    ? pushSelfClosing(renderState.viewportChunks, props, \"meta\")\n                    : pushSelfClosing(\n                        renderState.hoistableChunks,\n                        props,\n                        \"meta\"\n                      ));\n          return JSCompiler_inline_result$jscomp$8;\n        case \"listing\":\n        case \"pre\":\n          target$jscomp$0.push(startChunkForTag(type));\n          var children$jscomp$10 = null,\n            innerHTML$jscomp$7 = null,\n            propKey$jscomp$10;\n          for (propKey$jscomp$10 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$10)) {\n              var propValue$jscomp$10 = props[propKey$jscomp$10];\n              if (null != propValue$jscomp$10)\n                switch (propKey$jscomp$10) {\n                  case \"children\":\n                    children$jscomp$10 = propValue$jscomp$10;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$7 = propValue$jscomp$10;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$10,\n                      propValue$jscomp$10\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          if (null != innerHTML$jscomp$7) {\n            if (null != children$jscomp$10)\n              throw Error(\n                \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n              );\n            if (\n              \"object\" !== typeof innerHTML$jscomp$7 ||\n              !(\"__html\" in innerHTML$jscomp$7)\n            )\n              throw Error(\n                \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n              );\n            var html = innerHTML$jscomp$7.__html;\n            null !== html &&\n              void 0 !== html &&\n              (\"string\" === typeof html && 0 < html.length && \"\\n\" === html[0]\n                ? target$jscomp$0.push(leadingNewline, html)\n                : (checkHtmlStringCoercion(html),\n                  target$jscomp$0.push(\"\" + html)));\n          }\n          \"string\" === typeof children$jscomp$10 &&\n            \"\\n\" === children$jscomp$10[0] &&\n            target$jscomp$0.push(leadingNewline);\n          return children$jscomp$10;\n        case \"img\":\n          var src = props.src,\n            srcSet = props.srcSet;\n          if (\n            !(\n              \"lazy\" === props.loading ||\n              (!src && !srcSet) ||\n              (\"string\" !== typeof src && null != src) ||\n              (\"string\" !== typeof srcSet && null != srcSet)\n            ) &&\n            \"low\" !== props.fetchPriority &&\n            !1 === !!(formatContext.tagScope & 3) &&\n            (\"string\" !== typeof src ||\n              \":\" !== src[4] ||\n              (\"d\" !== src[0] && \"D\" !== src[0]) ||\n              (\"a\" !== src[1] && \"A\" !== src[1]) ||\n              (\"t\" !== src[2] && \"T\" !== src[2]) ||\n              (\"a\" !== src[3] && \"A\" !== src[3])) &&\n            (\"string\" !== typeof srcSet ||\n              \":\" !== srcSet[4] ||\n              (\"d\" !== srcSet[0] && \"D\" !== srcSet[0]) ||\n              (\"a\" !== srcSet[1] && \"A\" !== srcSet[1]) ||\n              (\"t\" !== srcSet[2] && \"T\" !== srcSet[2]) ||\n              (\"a\" !== srcSet[3] && \"A\" !== srcSet[3]))\n          ) {\n            var sizes = \"string\" === typeof props.sizes ? props.sizes : void 0,\n              key$jscomp$0 = srcSet ? srcSet + \"\\n\" + (sizes || \"\") : src,\n              promotablePreloads = renderState.preloads.images,\n              resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);\n            if (resource$jscomp$1) {\n              if (\n                \"high\" === props.fetchPriority ||\n                10 > renderState.highImagePreloads.size\n              )\n                promotablePreloads.delete(key$jscomp$0),\n                  renderState.highImagePreloads.add(resource$jscomp$1);\n            } else if (\n              !resumableState.imageResources.hasOwnProperty(key$jscomp$0)\n            ) {\n              resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;\n              var input = props.crossOrigin;\n              var crossOrigin =\n                \"string\" === typeof input\n                  ? \"use-credentials\" === input\n                    ? input\n                    : \"\"\n                  : void 0;\n              var headers = renderState.headers,\n                header;\n              headers &&\n              0 < headers.remainingCapacity &&\n              \"string\" !== typeof props.srcSet &&\n              (\"high\" === props.fetchPriority ||\n                500 > headers.highImagePreloads.length) &&\n              ((header = getPreloadAsHeader(src, \"image\", {\n                imageSrcSet: props.srcSet,\n                imageSizes: props.sizes,\n                crossOrigin: crossOrigin,\n                integrity: props.integrity,\n                nonce: props.nonce,\n                type: props.type,\n                fetchPriority: props.fetchPriority,\n                referrerPolicy: props.refererPolicy\n              })),\n              0 <= (headers.remainingCapacity -= header.length + 2))\n                ? ((renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS),\n                  headers.highImagePreloads &&\n                    (headers.highImagePreloads += \", \"),\n                  (headers.highImagePreloads += header))\n                : ((resource$jscomp$1 = []),\n                  pushLinkImpl(resource$jscomp$1, {\n                    rel: \"preload\",\n                    as: \"image\",\n                    href: srcSet ? void 0 : src,\n                    imageSrcSet: srcSet,\n                    imageSizes: sizes,\n                    crossOrigin: crossOrigin,\n                    integrity: props.integrity,\n                    type: props.type,\n                    fetchPriority: props.fetchPriority,\n                    referrerPolicy: props.referrerPolicy\n                  }),\n                  \"high\" === props.fetchPriority ||\n                  10 > renderState.highImagePreloads.size\n                    ? renderState.highImagePreloads.add(resource$jscomp$1)\n                    : (renderState.bulkPreloads.add(resource$jscomp$1),\n                      promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));\n            }\n          }\n          return pushSelfClosing(target$jscomp$0, props, \"img\");\n        case \"base\":\n        case \"area\":\n        case \"br\":\n        case \"col\":\n        case \"embed\":\n        case \"hr\":\n        case \"keygen\":\n        case \"param\":\n        case \"source\":\n        case \"track\":\n        case \"wbr\":\n          return pushSelfClosing(target$jscomp$0, props, type);\n        case \"annotation-xml\":\n        case \"color-profile\":\n        case \"font-face\":\n        case \"font-face-src\":\n        case \"font-face-uri\":\n        case \"font-face-format\":\n        case \"font-face-name\":\n        case \"missing-glyph\":\n          break;\n        case \"head\":\n          if (formatContext.insertionMode < HTML_MODE) {\n            var preamble = preambleState || renderState.preamble;\n            if (preamble.headChunks)\n              throw Error(\"The `<head>` tag may only be rendered once.\");\n            preamble.headChunks = [];\n            var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(\n              preamble.headChunks,\n              props,\n              \"head\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"head\"\n            );\n          return JSCompiler_inline_result$jscomp$9;\n        case \"body\":\n          if (formatContext.insertionMode < HTML_MODE) {\n            var preamble$jscomp$0 = preambleState || renderState.preamble;\n            if (preamble$jscomp$0.bodyChunks)\n              throw Error(\"The `<body>` tag may only be rendered once.\");\n            preamble$jscomp$0.bodyChunks = [];\n            var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(\n              preamble$jscomp$0.bodyChunks,\n              props,\n              \"body\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"body\"\n            );\n          return JSCompiler_inline_result$jscomp$10;\n        case \"html\":\n          if (formatContext.insertionMode === ROOT_HTML_MODE) {\n            var preamble$jscomp$1 = preambleState || renderState.preamble;\n            if (preamble$jscomp$1.htmlChunks)\n              throw Error(\"The `<html>` tag may only be rendered once.\");\n            preamble$jscomp$1.htmlChunks = [doctypeChunk];\n            var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(\n              preamble$jscomp$1.htmlChunks,\n              props,\n              \"html\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"html\"\n            );\n          return JSCompiler_inline_result$jscomp$11;\n        default:\n          if (-1 !== type.indexOf(\"-\")) {\n            target$jscomp$0.push(startChunkForTag(type));\n            var children$jscomp$11 = null,\n              innerHTML$jscomp$8 = null,\n              propKey$jscomp$11;\n            for (propKey$jscomp$11 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$11)) {\n                var propValue$jscomp$11 = props[propKey$jscomp$11];\n                if (null != propValue$jscomp$11) {\n                  var attributeName = propKey$jscomp$11;\n                  switch (propKey$jscomp$11) {\n                    case \"children\":\n                      children$jscomp$11 = propValue$jscomp$11;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$8 = propValue$jscomp$11;\n                      break;\n                    case \"style\":\n                      pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);\n                      break;\n                    case \"suppressContentEditableWarning\":\n                    case \"suppressHydrationWarning\":\n                    case \"ref\":\n                      break;\n                    case \"className\":\n                      attributeName = \"class\";\n                    default:\n                      if (\n                        isAttributeNameSafe(propKey$jscomp$11) &&\n                        \"function\" !== typeof propValue$jscomp$11 &&\n                        \"symbol\" !== typeof propValue$jscomp$11 &&\n                        !1 !== propValue$jscomp$11\n                      ) {\n                        if (!0 === propValue$jscomp$11)\n                          propValue$jscomp$11 = \"\";\n                        else if (\"object\" === typeof propValue$jscomp$11)\n                          continue;\n                        target$jscomp$0.push(\n                          attributeSeparator,\n                          attributeName,\n                          attributeAssign,\n                          escapeTextForBrowser(propValue$jscomp$11),\n                          attributeEnd\n                        );\n                      }\n                  }\n                }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$8,\n              children$jscomp$11\n            );\n            return children$jscomp$11;\n          }\n      }\n      return pushStartGenericElement(target$jscomp$0, props, type);\n    }\n    function endChunkForTag(tag) {\n      var chunk = endTagCache.get(tag);\n      void 0 === chunk &&\n        ((chunk = \"</\" + tag + \">\"), endTagCache.set(tag, chunk));\n      return chunk;\n    }\n    function hoistPreambleState(renderState, preambleState) {\n      renderState = renderState.preamble;\n      null === renderState.htmlChunks &&\n        preambleState.htmlChunks &&\n        ((renderState.htmlChunks = preambleState.htmlChunks),\n        (preambleState.contribution |= 1));\n      null === renderState.headChunks &&\n        preambleState.headChunks &&\n        ((renderState.headChunks = preambleState.headChunks),\n        (preambleState.contribution |= 4));\n      null === renderState.bodyChunks &&\n        preambleState.bodyChunks &&\n        ((renderState.bodyChunks = preambleState.bodyChunks),\n        (preambleState.contribution |= 2));\n    }\n    function writeBootstrap(destination, renderState) {\n      renderState = renderState.bootstrapChunks;\n      for (var i = 0; i < renderState.length - 1; i++)\n        destination.push(renderState[i]);\n      return i < renderState.length\n        ? ((i = renderState[i]), (renderState.length = 0), destination.push(i))\n        : !0;\n    }\n    function writeStartPendingSuspenseBoundary(destination, renderState, id) {\n      destination.push(startPendingSuspenseBoundary1);\n      if (null === id)\n        throw Error(\n          \"An ID must have been assigned before we can complete the boundary.\"\n        );\n      destination.push(renderState.boundaryPrefix);\n      renderState = id.toString(16);\n      destination.push(renderState);\n      return destination.push(startPendingSuspenseBoundary2);\n    }\n    function writePreambleContribution(destination, preambleState) {\n      preambleState = preambleState.contribution;\n      preambleState !== NoContribution &&\n        (destination.push(boundaryPreambleContributionChunkStart),\n        destination.push(\"\" + preambleState),\n        destination.push(boundaryPreambleContributionChunkEnd));\n    }\n    function writeStartSegment(destination, renderState, formatContext, id) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_HEAD_MODE:\n        case HTML_MODE:\n          return (\n            destination.push(startSegmentHTML),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentHTML2)\n          );\n        case SVG_MODE:\n          return (\n            destination.push(startSegmentSVG),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentSVG2)\n          );\n        case MATHML_MODE:\n          return (\n            destination.push(startSegmentMathML),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentMathML2)\n          );\n        case HTML_TABLE_MODE:\n          return (\n            destination.push(startSegmentTable),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentTable2)\n          );\n        case HTML_TABLE_BODY_MODE:\n          return (\n            destination.push(startSegmentTableBody),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentTableBody2)\n          );\n        case HTML_TABLE_ROW_MODE:\n          return (\n            destination.push(startSegmentTableRow),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentTableRow2)\n          );\n        case HTML_COLGROUP_MODE:\n          return (\n            destination.push(startSegmentColGroup),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentColGroup2)\n          );\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function writeEndSegment(destination, formatContext) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_HEAD_MODE:\n        case HTML_MODE:\n          return destination.push(endSegmentHTML);\n        case SVG_MODE:\n          return destination.push(endSegmentSVG);\n        case MATHML_MODE:\n          return destination.push(endSegmentMathML);\n        case HTML_TABLE_MODE:\n          return destination.push(endSegmentTable);\n        case HTML_TABLE_BODY_MODE:\n          return destination.push(endSegmentTableBody);\n        case HTML_TABLE_ROW_MODE:\n          return destination.push(endSegmentTableRow);\n        case HTML_COLGROUP_MODE:\n          return destination.push(endSegmentColGroup);\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function escapeJSStringsForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInInstructionScripts,\n        function (match) {\n          switch (match) {\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function escapeJSObjectForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInScripts,\n        function (match) {\n          switch (match) {\n            case \"&\":\n              return \"\\\\u0026\";\n            case \">\":\n              return \"\\\\u003e\";\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function flushStyleTagsLateForBoundary(styleQueue) {\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      0 < rules.length &&\n        0 === hrefs.length &&\n        console.error(\n          \"React expected to have at least one href for an a hoistable style but found none. This is a bug in React.\"\n        );\n      var i = 0;\n      if (hrefs.length) {\n        this.push(lateStyleTagResourceOpen1);\n        this.push(styleQueue.precedence);\n        for (this.push(lateStyleTagResourceOpen2); i < hrefs.length - 1; i++)\n          this.push(hrefs[i]), this.push(spaceSeparator);\n        this.push(hrefs[i]);\n        this.push(lateStyleTagResourceOpen3);\n        for (i = 0; i < rules.length; i++) this.push(rules[i]);\n        destinationHasCapacity = this.push(lateStyleTagTemplateClose);\n        currentlyRenderingBoundaryHasStylesToHoist = !0;\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function hasStylesToHoist(stylesheet) {\n      return stylesheet.state !== PREAMBLE\n        ? (currentlyRenderingBoundaryHasStylesToHoist = !0)\n        : !1;\n    }\n    function writeHoistablesForBoundary(\n      destination,\n      hoistableState,\n      renderState\n    ) {\n      currentlyRenderingBoundaryHasStylesToHoist = !1;\n      destinationHasCapacity = !0;\n      hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);\n      hoistableState.stylesheets.forEach(hasStylesToHoist);\n      currentlyRenderingBoundaryHasStylesToHoist &&\n        (renderState.stylesToHoist = !0);\n      return destinationHasCapacity;\n    }\n    function flushResource(resource) {\n      for (var i = 0; i < resource.length; i++) this.push(resource[i]);\n      resource.length = 0;\n    }\n    function flushStyleInPreamble(stylesheet) {\n      pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);\n      for (var i = 0; i < stylesheetFlushingQueue.length; i++)\n        this.push(stylesheetFlushingQueue[i]);\n      stylesheetFlushingQueue.length = 0;\n      stylesheet.state = PREAMBLE;\n    }\n    function flushStylesInPreamble(styleQueue) {\n      var hasStylesheets = 0 < styleQueue.sheets.size;\n      styleQueue.sheets.forEach(flushStyleInPreamble, this);\n      styleQueue.sheets.clear();\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      if (!hasStylesheets || hrefs.length) {\n        this.push(styleTagResourceOpen1);\n        this.push(styleQueue.precedence);\n        styleQueue = 0;\n        if (hrefs.length) {\n          for (\n            this.push(styleTagResourceOpen2);\n            styleQueue < hrefs.length - 1;\n            styleQueue++\n          )\n            this.push(hrefs[styleQueue]), this.push(spaceSeparator);\n          this.push(hrefs[styleQueue]);\n        }\n        this.push(styleTagResourceOpen3);\n        for (styleQueue = 0; styleQueue < rules.length; styleQueue++)\n          this.push(rules[styleQueue]);\n        this.push(styleTagResourceClose);\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function preloadLateStyle(stylesheet) {\n      if (stylesheet.state === PENDING$1) {\n        stylesheet.state = PRELOADED;\n        var props = stylesheet.props;\n        pushLinkImpl(stylesheetFlushingQueue, {\n          rel: \"preload\",\n          as: \"style\",\n          href: stylesheet.props.href,\n          crossOrigin: props.crossOrigin,\n          fetchPriority: props.fetchPriority,\n          integrity: props.integrity,\n          media: props.media,\n          hrefLang: props.hrefLang,\n          referrerPolicy: props.referrerPolicy\n        });\n        for (\n          stylesheet = 0;\n          stylesheet < stylesheetFlushingQueue.length;\n          stylesheet++\n        )\n          this.push(stylesheetFlushingQueue[stylesheet]);\n        stylesheetFlushingQueue.length = 0;\n      }\n    }\n    function preloadLateStyles(styleQueue) {\n      styleQueue.sheets.forEach(preloadLateStyle, this);\n      styleQueue.sheets.clear();\n    }\n    function writeStyleResourceDependenciesInJS(destination, hoistableState) {\n      destination.push(arrayFirstOpenBracket);\n      var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n      hoistableState.stylesheets.forEach(function (resource) {\n        if (resource.state !== PREAMBLE)\n          if (resource.state === LATE)\n            destination.push(nextArrayOpenBrackChunk),\n              (resource = resource.props.href),\n              checkAttributeStringCoercion(resource, \"href\"),\n              (resource = escapeJSObjectForInstructionScripts(\"\" + resource)),\n              destination.push(resource),\n              destination.push(arrayCloseBracket),\n              (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);\n          else {\n            destination.push(nextArrayOpenBrackChunk);\n            var precedence = resource.props[\"data-precedence\"],\n              props = resource.props,\n              coercedHref = sanitizeURL(\"\" + resource.props.href);\n            coercedHref = escapeJSObjectForInstructionScripts(coercedHref);\n            destination.push(coercedHref);\n            checkAttributeStringCoercion(precedence, \"precedence\");\n            precedence = \"\" + precedence;\n            destination.push(arrayInterstitial);\n            precedence = escapeJSObjectForInstructionScripts(precedence);\n            destination.push(precedence);\n            for (var propKey in props)\n              if (\n                hasOwnProperty.call(props, propKey) &&\n                ((precedence = props[propKey]), null != precedence)\n              )\n                switch (propKey) {\n                  case \"href\":\n                  case \"rel\":\n                  case \"precedence\":\n                  case \"data-precedence\":\n                    break;\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    writeStyleResourceAttributeInJS(\n                      destination,\n                      propKey,\n                      precedence\n                    );\n                }\n            destination.push(arrayCloseBracket);\n            nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n            resource.state = LATE;\n          }\n      });\n      destination.push(arrayCloseBracket);\n    }\n    function writeStyleResourceAttributeInJS(destination, name, value) {\n      var attributeName = name.toLowerCase();\n      switch (typeof value) {\n        case \"function\":\n        case \"symbol\":\n          return;\n      }\n      switch (name) {\n        case \"innerHTML\":\n        case \"dangerouslySetInnerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"style\":\n        case \"ref\":\n          return;\n        case \"className\":\n          attributeName = \"class\";\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        case \"hidden\":\n          if (!1 === value) return;\n          name = \"\";\n          break;\n        case \"src\":\n        case \"href\":\n          value = sanitizeURL(value);\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        default:\n          if (\n            (2 < name.length &&\n              (\"o\" === name[0] || \"O\" === name[0]) &&\n              (\"n\" === name[1] || \"N\" === name[1])) ||\n            !isAttributeNameSafe(name)\n          )\n            return;\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n      }\n      destination.push(arrayInterstitial);\n      attributeName = escapeJSObjectForInstructionScripts(attributeName);\n      destination.push(attributeName);\n      destination.push(arrayInterstitial);\n      attributeName = escapeJSObjectForInstructionScripts(name);\n      destination.push(attributeName);\n    }\n    function createHoistableState() {\n      return { styles: new Set(), stylesheets: new Set() };\n    }\n    function preloadBootstrapScriptOrModule(\n      resumableState,\n      renderState,\n      href,\n      props\n    ) {\n      (resumableState.scriptResources.hasOwnProperty(href) ||\n        resumableState.moduleScriptResources.hasOwnProperty(href)) &&\n        console.error(\n          'Internal React Error: React expected bootstrap script or module with src \"%s\" to not have been preloaded already. please file an issue',\n          href\n        );\n      resumableState.scriptResources[href] = EXISTS;\n      resumableState.moduleScriptResources[href] = EXISTS;\n      resumableState = [];\n      pushLinkImpl(resumableState, props);\n      renderState.bootstrapScripts.add(resumableState);\n    }\n    function adoptPreloadCredentials(target, preloadState) {\n      null == target.crossOrigin && (target.crossOrigin = preloadState[0]);\n      null == target.integrity && (target.integrity = preloadState[1]);\n    }\n    function getPreloadAsHeader(href, as, params) {\n      href = escapeHrefForLinkHeaderURLContext(href);\n      as = escapeStringForLinkHeaderQuotedParamValueContext(as, \"as\");\n      as = \"<\" + href + '>; rel=preload; as=\"' + as + '\"';\n      for (var paramName in params)\n        hasOwnProperty.call(params, paramName) &&\n          ((href = params[paramName]),\n          \"string\" === typeof href &&\n            (as +=\n              \"; \" +\n              paramName.toLowerCase() +\n              '=\"' +\n              escapeStringForLinkHeaderQuotedParamValueContext(\n                href,\n                paramName\n              ) +\n              '\"'));\n      return as;\n    }\n    function escapeHrefForLinkHeaderURLContext(hrefInput) {\n      checkAttributeStringCoercion(hrefInput, \"href\");\n      return (\"\" + hrefInput).replace(\n        regexForHrefInLinkHeaderURLContext,\n        escapeHrefForLinkHeaderURLContextReplacer\n      );\n    }\n    function escapeHrefForLinkHeaderURLContextReplacer(match) {\n      switch (match) {\n        case \"<\":\n          return \"%3C\";\n        case \">\":\n          return \"%3E\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {\n      willCoercionThrow(value) &&\n        (console.error(\n          \"The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          name,\n          typeName(value)\n        ),\n        testStringCoercion(value));\n      return (\"\" + value).replace(\n        regexForLinkHeaderQuotedParamValueContext,\n        escapeStringForLinkHeaderQuotedParamValueContextReplacer\n      );\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {\n      switch (match) {\n        case '\"':\n          return \"%22\";\n        case \"'\":\n          return \"%27\";\n        case \";\":\n          return \"%3B\";\n        case \",\":\n          return \"%2C\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function hoistStyleQueueDependency(styleQueue) {\n      this.styles.add(styleQueue);\n    }\n    function hoistStylesheetDependency(stylesheet) {\n      this.stylesheets.add(stylesheet);\n    }\n    function createRenderState(resumableState, generateStaticMarkup) {\n      var idPrefix = resumableState.idPrefix,\n        bootstrapChunks = [],\n        bootstrapScriptContent = resumableState.bootstrapScriptContent,\n        bootstrapScripts = resumableState.bootstrapScripts,\n        bootstrapModules = resumableState.bootstrapModules;\n      void 0 !== bootstrapScriptContent &&\n        bootstrapChunks.push(\n          \"<script>\",\n          escapeEntireInlineScriptContent(bootstrapScriptContent),\n          \"\\x3c/script>\"\n        );\n      idPrefix = {\n        placeholderPrefix: idPrefix + \"P:\",\n        segmentPrefix: idPrefix + \"S:\",\n        boundaryPrefix: idPrefix + \"B:\",\n        startInlineScript: \"<script>\",\n        preamble: createPreambleState(),\n        externalRuntimeScript: null,\n        bootstrapChunks: bootstrapChunks,\n        importMapChunks: [],\n        onHeaders: void 0,\n        headers: null,\n        resets: {\n          font: {},\n          dns: {},\n          connect: { default: {}, anonymous: {}, credentials: {} },\n          image: {},\n          style: {}\n        },\n        charsetChunks: [],\n        viewportChunks: [],\n        hoistableChunks: [],\n        preconnects: new Set(),\n        fontPreloads: new Set(),\n        highImagePreloads: new Set(),\n        styles: new Map(),\n        bootstrapScripts: new Set(),\n        scripts: new Set(),\n        bulkPreloads: new Set(),\n        preloads: {\n          images: new Map(),\n          stylesheets: new Map(),\n          scripts: new Map(),\n          moduleScripts: new Map()\n        },\n        nonce: void 0,\n        hoistableState: null,\n        stylesToHoist: !1\n      };\n      if (void 0 !== bootstrapScripts)\n        for (\n          bootstrapScriptContent = 0;\n          bootstrapScriptContent < bootstrapScripts.length;\n          bootstrapScriptContent++\n        ) {\n          var scriptConfig = bootstrapScripts[bootstrapScriptContent],\n            src,\n            crossOrigin = void 0,\n            integrity = void 0,\n            props = {\n              rel: \"preload\",\n              as: \"script\",\n              fetchPriority: \"low\",\n              nonce: void 0\n            };\n          \"string\" === typeof scriptConfig\n            ? (props.href = src = scriptConfig)\n            : ((props.href = src = scriptConfig.src),\n              (props.integrity = integrity =\n                \"string\" === typeof scriptConfig.integrity\n                  ? scriptConfig.integrity\n                  : void 0),\n              (props.crossOrigin = crossOrigin =\n                \"string\" === typeof scriptConfig ||\n                null == scriptConfig.crossOrigin\n                  ? void 0\n                  : \"use-credentials\" === scriptConfig.crossOrigin\n                    ? \"use-credentials\"\n                    : \"\"));\n          preloadBootstrapScriptOrModule(resumableState, idPrefix, src, props);\n          bootstrapChunks.push('<script src=\"', escapeTextForBrowser(src));\n          \"string\" === typeof integrity &&\n            bootstrapChunks.push(\n              '\" integrity=\"',\n              escapeTextForBrowser(integrity)\n            );\n          \"string\" === typeof crossOrigin &&\n            bootstrapChunks.push(\n              '\" crossorigin=\"',\n              escapeTextForBrowser(crossOrigin)\n            );\n          bootstrapChunks.push('\" async=\"\">\\x3c/script>');\n        }\n      if (void 0 !== bootstrapModules)\n        for (\n          bootstrapScripts = 0;\n          bootstrapScripts < bootstrapModules.length;\n          bootstrapScripts++\n        )\n          (bootstrapScriptContent = bootstrapModules[bootstrapScripts]),\n            (crossOrigin = src = void 0),\n            (integrity = {\n              rel: \"modulepreload\",\n              fetchPriority: \"low\",\n              nonce: void 0\n            }),\n            \"string\" === typeof bootstrapScriptContent\n              ? (integrity.href = scriptConfig = bootstrapScriptContent)\n              : ((integrity.href = scriptConfig = bootstrapScriptContent.src),\n                (integrity.integrity = crossOrigin =\n                  \"string\" === typeof bootstrapScriptContent.integrity\n                    ? bootstrapScriptContent.integrity\n                    : void 0),\n                (integrity.crossOrigin = src =\n                  \"string\" === typeof bootstrapScriptContent ||\n                  null == bootstrapScriptContent.crossOrigin\n                    ? void 0\n                    : \"use-credentials\" === bootstrapScriptContent.crossOrigin\n                      ? \"use-credentials\"\n                      : \"\")),\n            preloadBootstrapScriptOrModule(\n              resumableState,\n              idPrefix,\n              scriptConfig,\n              integrity\n            ),\n            bootstrapChunks.push(\n              '<script type=\"module\" src=\"',\n              escapeTextForBrowser(scriptConfig)\n            ),\n            \"string\" === typeof crossOrigin &&\n              bootstrapChunks.push(\n                '\" integrity=\"',\n                escapeTextForBrowser(crossOrigin)\n              ),\n            \"string\" === typeof src &&\n              bootstrapChunks.push(\n                '\" crossorigin=\"',\n                escapeTextForBrowser(src)\n              ),\n            bootstrapChunks.push('\" async=\"\">\\x3c/script>');\n      return {\n        placeholderPrefix: idPrefix.placeholderPrefix,\n        segmentPrefix: idPrefix.segmentPrefix,\n        boundaryPrefix: idPrefix.boundaryPrefix,\n        startInlineScript: idPrefix.startInlineScript,\n        preamble: idPrefix.preamble,\n        externalRuntimeScript: idPrefix.externalRuntimeScript,\n        bootstrapChunks: idPrefix.bootstrapChunks,\n        importMapChunks: idPrefix.importMapChunks,\n        onHeaders: idPrefix.onHeaders,\n        headers: idPrefix.headers,\n        resets: idPrefix.resets,\n        charsetChunks: idPrefix.charsetChunks,\n        viewportChunks: idPrefix.viewportChunks,\n        hoistableChunks: idPrefix.hoistableChunks,\n        preconnects: idPrefix.preconnects,\n        fontPreloads: idPrefix.fontPreloads,\n        highImagePreloads: idPrefix.highImagePreloads,\n        styles: idPrefix.styles,\n        bootstrapScripts: idPrefix.bootstrapScripts,\n        scripts: idPrefix.scripts,\n        bulkPreloads: idPrefix.bulkPreloads,\n        preloads: idPrefix.preloads,\n        stylesToHoist: idPrefix.stylesToHoist,\n        generateStaticMarkup: generateStaticMarkup\n      };\n    }\n    function pushTextInstance(target, text, renderState, textEmbedded) {\n      if (renderState.generateStaticMarkup)\n        return target.push(escapeTextForBrowser(text)), !1;\n      \"\" === text\n        ? (target = textEmbedded)\n        : (textEmbedded && target.push(\"\\x3c!-- --\\x3e\"),\n          target.push(escapeTextForBrowser(text)),\n          (target = !0));\n      return target;\n    }\n    function pushSegmentFinale(\n      target,\n      renderState,\n      lastPushedText,\n      textEmbedded\n    ) {\n      renderState.generateStaticMarkup ||\n        (lastPushedText && textEmbedded && target.push(\"\\x3c!-- --\\x3e\"));\n    }\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function popToNearestCommonAncestor(prev, next) {\n      if (prev !== next) {\n        prev.context._currentValue2 = prev.parentValue;\n        prev = prev.parent;\n        var parentNext = next.parent;\n        if (null === prev) {\n          if (null !== parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n        } else {\n          if (null === parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n          popToNearestCommonAncestor(prev, parentNext);\n        }\n        next.context._currentValue2 = next.value;\n      }\n    }\n    function popAllPrevious(prev) {\n      prev.context._currentValue2 = prev.parentValue;\n      prev = prev.parent;\n      null !== prev && popAllPrevious(prev);\n    }\n    function pushAllNext(next) {\n      var parentNext = next.parent;\n      null !== parentNext && pushAllNext(parentNext);\n      next.context._currentValue2 = next.value;\n    }\n    function popPreviousToCommonLevel(prev, next) {\n      prev.context._currentValue2 = prev.parentValue;\n      prev = prev.parent;\n      if (null === prev)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === next.depth\n        ? popToNearestCommonAncestor(prev, next)\n        : popPreviousToCommonLevel(prev, next);\n    }\n    function popNextToCommonLevel(prev, next) {\n      var parentNext = next.parent;\n      if (null === parentNext)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === parentNext.depth\n        ? popToNearestCommonAncestor(prev, parentNext)\n        : popNextToCommonLevel(prev, parentNext);\n      next.context._currentValue2 = next.value;\n    }\n    function switchContext(newSnapshot) {\n      var prev = currentActiveSnapshot;\n      prev !== newSnapshot &&\n        (null === prev\n          ? pushAllNext(newSnapshot)\n          : null === newSnapshot\n            ? popAllPrevious(prev)\n            : prev.depth === newSnapshot.depth\n              ? popToNearestCommonAncestor(prev, newSnapshot)\n              : prev.depth > newSnapshot.depth\n                ? popPreviousToCommonLevel(prev, newSnapshot)\n                : popNextToCommonLevel(prev, newSnapshot),\n        (currentActiveSnapshot = newSnapshot));\n    }\n    function warnOnInvalidCallback(callback) {\n      if (null !== callback && \"function\" !== typeof callback) {\n        var key = String(callback);\n        didWarnOnInvalidCallback.has(key) ||\n          (didWarnOnInvalidCallback.add(key),\n          console.error(\n            \"Expected the last optional `callback` argument to be a function. Instead received: %s.\",\n            callback\n          ));\n      }\n    }\n    function warnNoop(publicInstance, callerName) {\n      publicInstance =\n        ((publicInstance = publicInstance.constructor) &&\n          getComponentNameFromType(publicInstance)) ||\n        \"ReactClass\";\n      var warningKey = publicInstance + \".\" + callerName;\n      didWarnAboutNoopUpdateForComponent[warningKey] ||\n        (console.error(\n          \"Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\\n\\nPlease check the code for the %s component.\",\n          callerName,\n          publicInstance\n        ),\n        (didWarnAboutNoopUpdateForComponent[warningKey] = !0));\n    }\n    function pushTreeContext(baseContext, totalChildren, index) {\n      var baseIdWithLeadingBit = baseContext.id;\n      baseContext = baseContext.overflow;\n      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n      baseIdWithLeadingBit &= ~(1 << baseLength);\n      index += 1;\n      var length = 32 - clz32(totalChildren) + baseLength;\n      if (30 < length) {\n        var numberOfOverflowBits = baseLength - (baseLength % 5);\n        length = (\n          baseIdWithLeadingBit &\n          ((1 << numberOfOverflowBits) - 1)\n        ).toString(32);\n        baseIdWithLeadingBit >>= numberOfOverflowBits;\n        baseLength -= numberOfOverflowBits;\n        return {\n          id:\n            (1 << (32 - clz32(totalChildren) + baseLength)) |\n            (index << baseLength) |\n            baseIdWithLeadingBit,\n          overflow: length + baseContext\n        };\n      }\n      return {\n        id: (1 << length) | (index << baseLength) | baseIdWithLeadingBit,\n        overflow: baseContext\n      };\n    }\n    function clz32Fallback(x) {\n      x >>>= 0;\n      return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;\n    }\n    function noop$2() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n      index = thenableState[index];\n      void 0 === index\n        ? thenableState.push(thenable)\n        : index !== thenable &&\n          (thenable.then(noop$2, noop$2), (thenable = index));\n      switch (thenable.status) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n        default:\n          \"string\" === typeof thenable.status\n            ? thenable.then(noop$2, noop$2)\n            : ((thenableState = thenable),\n              (thenableState.status = \"pending\"),\n              thenableState.then(\n                function (fulfilledValue) {\n                  if (\"pending\" === thenable.status) {\n                    var fulfilledThenable = thenable;\n                    fulfilledThenable.status = \"fulfilled\";\n                    fulfilledThenable.value = fulfilledValue;\n                  }\n                },\n                function (error) {\n                  if (\"pending\" === thenable.status) {\n                    var rejectedThenable = thenable;\n                    rejectedThenable.status = \"rejected\";\n                    rejectedThenable.reason = error;\n                  }\n                }\n              ));\n          switch (thenable.status) {\n            case \"fulfilled\":\n              return thenable.value;\n            case \"rejected\":\n              throw thenable.reason;\n          }\n          suspendedThenable = thenable;\n          throw SuspenseException;\n      }\n    }\n    function getSuspendedThenable() {\n      if (null === suspendedThenable)\n        throw Error(\n          \"Expected a suspended thenable. This is a bug in React. Please file an issue.\"\n        );\n      var thenable = suspendedThenable;\n      suspendedThenable = null;\n      return thenable;\n    }\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function resolveCurrentlyRenderingComponent() {\n      if (null === currentlyRenderingComponent)\n        throw Error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\"\n        );\n      return currentlyRenderingComponent;\n    }\n    function createHook() {\n      if (0 < numberOfReRenders)\n        throw Error(\"Rendered more hooks than during the previous render\");\n      return { memoizedState: null, queue: null, next: null };\n    }\n    function createWorkInProgressHook() {\n      null === workInProgressHook\n        ? null === firstWorkInProgressHook\n          ? ((isReRender = !1),\n            (firstWorkInProgressHook = workInProgressHook = createHook()))\n          : ((isReRender = !0), (workInProgressHook = firstWorkInProgressHook))\n        : null === workInProgressHook.next\n          ? ((isReRender = !1),\n            (workInProgressHook = workInProgressHook.next = createHook()))\n          : ((isReRender = !0), (workInProgressHook = workInProgressHook.next));\n      return workInProgressHook;\n    }\n    function getThenableStateAfterSuspending() {\n      var state = thenableState;\n      thenableState = null;\n      return state;\n    }\n    function resetHooksState() {\n      isInHookUserCodeInDev = !1;\n      currentlyRenderingKeyPath =\n        currentlyRenderingRequest =\n        currentlyRenderingTask =\n        currentlyRenderingComponent =\n          null;\n      didScheduleRenderPhaseUpdate = !1;\n      firstWorkInProgressHook = null;\n      numberOfReRenders = 0;\n      workInProgressHook = renderPhaseUpdates = null;\n    }\n    function readContext(context) {\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\"\n        );\n      return context._currentValue2;\n    }\n    function basicStateReducer(state, action) {\n      return \"function\" === typeof action ? action(state) : action;\n    }\n    function useReducer(reducer, initialArg, init) {\n      reducer !== basicStateReducer && (currentHookNameInDev = \"useReducer\");\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      if (isReRender) {\n        init = workInProgressHook.queue;\n        initialArg = init.dispatch;\n        if (null !== renderPhaseUpdates) {\n          var firstRenderPhaseUpdate = renderPhaseUpdates.get(init);\n          if (void 0 !== firstRenderPhaseUpdate) {\n            renderPhaseUpdates.delete(init);\n            init = workInProgressHook.memoizedState;\n            do {\n              var action = firstRenderPhaseUpdate.action;\n              isInHookUserCodeInDev = !0;\n              init = reducer(init, action);\n              isInHookUserCodeInDev = !1;\n              firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;\n            } while (null !== firstRenderPhaseUpdate);\n            workInProgressHook.memoizedState = init;\n            return [init, initialArg];\n          }\n        }\n        return [workInProgressHook.memoizedState, initialArg];\n      }\n      isInHookUserCodeInDev = !0;\n      reducer =\n        reducer === basicStateReducer\n          ? \"function\" === typeof initialArg\n            ? initialArg()\n            : initialArg\n          : void 0 !== init\n            ? init(initialArg)\n            : initialArg;\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = reducer;\n      reducer = workInProgressHook.queue = { last: null, dispatch: null };\n      reducer = reducer.dispatch = dispatchAction.bind(\n        null,\n        currentlyRenderingComponent,\n        reducer\n      );\n      return [workInProgressHook.memoizedState, reducer];\n    }\n    function useMemo(nextCreate, deps) {\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      deps = void 0 === deps ? null : deps;\n      if (null !== workInProgressHook) {\n        var prevState = workInProgressHook.memoizedState;\n        if (null !== prevState && null !== deps) {\n          a: {\n            var JSCompiler_inline_result = prevState[1];\n            if (null === JSCompiler_inline_result)\n              console.error(\n                \"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\",\n                currentHookNameInDev\n              ),\n                (JSCompiler_inline_result = !1);\n            else {\n              deps.length !== JSCompiler_inline_result.length &&\n                console.error(\n                  \"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\",\n                  currentHookNameInDev,\n                  \"[\" + deps.join(\", \") + \"]\",\n                  \"[\" + JSCompiler_inline_result.join(\", \") + \"]\"\n                );\n              for (\n                var i = 0;\n                i < JSCompiler_inline_result.length && i < deps.length;\n                i++\n              )\n                if (!objectIs(deps[i], JSCompiler_inline_result[i])) {\n                  JSCompiler_inline_result = !1;\n                  break a;\n                }\n              JSCompiler_inline_result = !0;\n            }\n          }\n          if (JSCompiler_inline_result) return prevState[0];\n        }\n      }\n      isInHookUserCodeInDev = !0;\n      nextCreate = nextCreate();\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = [nextCreate, deps];\n      return nextCreate;\n    }\n    function dispatchAction(componentIdentity, queue, action) {\n      if (25 <= numberOfReRenders)\n        throw Error(\n          \"Too many re-renders. React limits the number of renders to prevent an infinite loop.\"\n        );\n      if (componentIdentity === currentlyRenderingComponent)\n        if (\n          ((didScheduleRenderPhaseUpdate = !0),\n          (componentIdentity = { action: action, next: null }),\n          null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),\n          (action = renderPhaseUpdates.get(queue)),\n          void 0 === action)\n        )\n          renderPhaseUpdates.set(queue, componentIdentity);\n        else {\n          for (queue = action; null !== queue.next; ) queue = queue.next;\n          queue.next = componentIdentity;\n        }\n    }\n    function unsupportedStartTransition() {\n      throw Error(\"startTransition cannot be called during server rendering.\");\n    }\n    function unsupportedSetOptimisticState() {\n      throw Error(\"Cannot update optimistic state while rendering.\");\n    }\n    function useActionState(action, initialState, permalink) {\n      resolveCurrentlyRenderingComponent();\n      var actionStateHookIndex = actionStateCounter++,\n        request = currentlyRenderingRequest;\n      if (\"function\" === typeof action.$$FORM_ACTION) {\n        var nextPostbackStateKey = null,\n          componentKeyPath = currentlyRenderingKeyPath;\n        request = request.formState;\n        var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;\n        if (null !== request && \"function\" === typeof isSignatureEqual) {\n          var postbackKey = request[1];\n          isSignatureEqual.call(action, request[2], request[3]) &&\n            ((nextPostbackStateKey =\n              void 0 !== permalink\n                ? \"p\" + permalink\n                : \"k\" +\n                  murmurhash3_32_gc(\n                    JSON.stringify([\n                      componentKeyPath,\n                      null,\n                      actionStateHookIndex\n                    ]),\n                    0\n                  )),\n            postbackKey === nextPostbackStateKey &&\n              ((actionStateMatchingIndex = actionStateHookIndex),\n              (initialState = request[0])));\n        }\n        var boundAction = action.bind(null, initialState);\n        action = function (payload) {\n          boundAction(payload);\n        };\n        \"function\" === typeof boundAction.$$FORM_ACTION &&\n          (action.$$FORM_ACTION = function (prefix) {\n            prefix = boundAction.$$FORM_ACTION(prefix);\n            void 0 !== permalink &&\n              (checkAttributeStringCoercion(permalink, \"target\"),\n              (permalink += \"\"),\n              (prefix.action = permalink));\n            var formData = prefix.data;\n            formData &&\n              (null === nextPostbackStateKey &&\n                (nextPostbackStateKey =\n                  void 0 !== permalink\n                    ? \"p\" + permalink\n                    : \"k\" +\n                      murmurhash3_32_gc(\n                        JSON.stringify([\n                          componentKeyPath,\n                          null,\n                          actionStateHookIndex\n                        ]),\n                        0\n                      )),\n              formData.append(\"$ACTION_KEY\", nextPostbackStateKey));\n            return prefix;\n          });\n        return [initialState, action, !1];\n      }\n      var _boundAction = action.bind(null, initialState);\n      return [\n        initialState,\n        function (payload) {\n          _boundAction(payload);\n        },\n        !1\n      ];\n    }\n    function unwrapThenable(thenable) {\n      var index = thenableIndexCounter;\n      thenableIndexCounter += 1;\n      null === thenableState && (thenableState = []);\n      return trackUsedThenable(thenableState, thenable, index);\n    }\n    function unsupportedRefresh() {\n      throw Error(\"Cache cannot be refreshed during server rendering.\");\n    }\n    function noop$1() {}\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function formatOwnerStack(error) {\n      var prevPrepareStackTrace = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      error = error.stack;\n      Error.prepareStackTrace = prevPrepareStackTrace;\n      error.startsWith(\"Error: react-stack-top-frame\\n\") &&\n        (error = error.slice(29));\n      prevPrepareStackTrace = error.indexOf(\"\\n\");\n      -1 !== prevPrepareStackTrace &&\n        (error = error.slice(prevPrepareStackTrace + 1));\n      prevPrepareStackTrace = error.indexOf(\"react-stack-bottom-frame\");\n      -1 !== prevPrepareStackTrace &&\n        (prevPrepareStackTrace = error.lastIndexOf(\n          \"\\n\",\n          prevPrepareStackTrace\n        ));\n      if (-1 !== prevPrepareStackTrace)\n        error = error.slice(0, prevPrepareStackTrace);\n      else return \"\";\n      return error;\n    }\n    function describeComponentStackByType(type) {\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      if (\"function\" === typeof type)\n        return type.prototype && type.prototype.isReactComponent\n          ? describeNativeComponentFrame(type, !0)\n          : describeNativeComponentFrame(type, !1);\n      if (\"object\" === typeof type && null !== type) {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeNativeComponentFrame(type.render, !1);\n          case REACT_MEMO_TYPE:\n            return describeNativeComponentFrame(type.type, !1);\n          case REACT_LAZY_TYPE:\n            var lazyComponent = type,\n              payload = lazyComponent._payload;\n            lazyComponent = lazyComponent._init;\n            try {\n              type = lazyComponent(payload);\n            } catch (x) {\n              return describeBuiltInComponentFrame(\"Lazy\");\n            }\n            return describeComponentStackByType(type);\n        }\n        if (\"string\" === typeof type.name)\n          return (\n            (payload = type.env),\n            describeBuiltInComponentFrame(\n              type.name + (payload ? \" [\" + payload + \"]\" : \"\")\n            )\n          );\n      }\n      switch (type) {\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n      }\n      return \"\";\n    }\n    function defaultErrorHandler(error) {\n      if (\n        \"object\" === typeof error &&\n        null !== error &&\n        \"string\" === typeof error.environmentName\n      ) {\n        var JSCompiler_inline_result = error.environmentName;\n        error = [error].slice(0);\n        \"string\" === typeof error[0]\n          ? error.splice(\n              0,\n              1,\n              \"[%s] \" + error[0],\n              \" \" + JSCompiler_inline_result + \" \"\n            )\n          : error.splice(0, 0, \"[%s] \", \" \" + JSCompiler_inline_result + \" \");\n        error.unshift(console);\n        JSCompiler_inline_result = bind.apply(console.error, error);\n        JSCompiler_inline_result();\n      } else console.error(error);\n      return null;\n    }\n    function noop() {}\n    function RequestInstance(\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      var abortSet = new Set();\n      this.destination = null;\n      this.flushScheduled = !1;\n      this.resumableState = resumableState;\n      this.renderState = renderState;\n      this.rootFormatContext = rootFormatContext;\n      this.progressiveChunkSize =\n        void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;\n      this.status = 10;\n      this.fatalError = null;\n      this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;\n      this.completedPreambleSegments = this.completedRootSegment = null;\n      this.abortableTasks = abortSet;\n      this.pingedTasks = [];\n      this.clientRenderedBoundaries = [];\n      this.completedBoundaries = [];\n      this.partialBoundaries = [];\n      this.trackedPostpones = null;\n      this.onError = void 0 === onError ? defaultErrorHandler : onError;\n      this.onPostpone = void 0 === onPostpone ? noop : onPostpone;\n      this.onAllReady = void 0 === onAllReady ? noop : onAllReady;\n      this.onShellReady = void 0 === onShellReady ? noop : onShellReady;\n      this.onShellError = void 0 === onShellError ? noop : onShellError;\n      this.onFatalError = void 0 === onFatalError ? noop : onFatalError;\n      this.formState = void 0 === formState ? null : formState;\n      this.didWarnForKey = null;\n    }\n    function createRequest(\n      children,\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      resumableState = new RequestInstance(\n        resumableState,\n        renderState,\n        rootFormatContext,\n        progressiveChunkSize,\n        onError,\n        onAllReady,\n        onShellReady,\n        onShellError,\n        onFatalError,\n        onPostpone,\n        formState\n      );\n      renderState = createPendingSegment(\n        resumableState,\n        0,\n        null,\n        rootFormatContext,\n        !1,\n        !1\n      );\n      renderState.parentFlushed = !0;\n      children = createRenderTask(\n        resumableState,\n        null,\n        children,\n        -1,\n        null,\n        renderState,\n        null,\n        null,\n        resumableState.abortableTasks,\n        null,\n        rootFormatContext,\n        null,\n        emptyTreeContext,\n        null,\n        !1,\n        emptyContextObject,\n        null\n      );\n      pushComponentStack(children);\n      resumableState.pingedTasks.push(children);\n      return resumableState;\n    }\n    function pingTask(request, task) {\n      request.pingedTasks.push(task);\n      1 === request.pingedTasks.length &&\n        ((request.flushScheduled = null !== request.destination),\n        performWork(request));\n    }\n    function createSuspenseBoundary(\n      request,\n      fallbackAbortableTasks,\n      contentPreamble,\n      fallbackPreamble\n    ) {\n      return {\n        status: PENDING,\n        rootSegmentID: -1,\n        parentFlushed: !1,\n        pendingTasks: 0,\n        completedSegments: [],\n        byteSize: 0,\n        fallbackAbortableTasks: fallbackAbortableTasks,\n        errorDigest: null,\n        contentState: createHoistableState(),\n        fallbackState: createHoistableState(),\n        contentPreamble: contentPreamble,\n        fallbackPreamble: fallbackPreamble,\n        trackedContentKeyPath: null,\n        trackedFallbackNode: null,\n        errorMessage: null,\n        errorStack: null,\n        errorComponentStack: null\n      };\n    }\n    function createRenderTask(\n      request,\n      thenableState,\n      node,\n      childIndex,\n      blockedBoundary,\n      blockedSegment,\n      blockedPreamble,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      componentStack,\n      isFallback,\n      legacyContext,\n      debugTask\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      var task = {\n        replay: null,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: blockedSegment,\n        blockedPreamble: blockedPreamble,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        componentStack: componentStack,\n        thenableState: thenableState,\n        isFallback: isFallback\n      };\n      task.debugTask = debugTask;\n      abortSet.add(task);\n      return task;\n    }\n    function createReplayTask(\n      request,\n      thenableState,\n      replay,\n      node,\n      childIndex,\n      blockedBoundary,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      componentStack,\n      isFallback,\n      legacyContext,\n      debugTask\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      replay.pendingTasks++;\n      var task = {\n        replay: replay,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: null,\n        blockedPreamble: null,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        componentStack: componentStack,\n        thenableState: thenableState,\n        isFallback: isFallback\n      };\n      task.debugTask = debugTask;\n      abortSet.add(task);\n      return task;\n    }\n    function createPendingSegment(\n      request,\n      index,\n      boundary,\n      parentFormatContext,\n      lastPushedText,\n      textEmbedded\n    ) {\n      return {\n        status: PENDING,\n        parentFlushed: !1,\n        id: -1,\n        index: index,\n        chunks: [],\n        children: [],\n        preambleChildren: [],\n        parentFormatContext: parentFormatContext,\n        boundary: boundary,\n        lastPushedText: lastPushedText,\n        textEmbedded: textEmbedded\n      };\n    }\n    function getCurrentStackInDEV() {\n      if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)\n        return \"\";\n      var componentStack = currentTaskInDEV.componentStack;\n      try {\n        var info = \"\";\n        if (\"string\" === typeof componentStack.type)\n          info += describeBuiltInComponentFrame(componentStack.type);\n        else if (\"function\" === typeof componentStack.type) {\n          if (!componentStack.owner) {\n            var JSCompiler_temp_const = info,\n              fn = componentStack.type,\n              name = fn ? fn.displayName || fn.name : \"\";\n            var JSCompiler_inline_result = name\n              ? describeBuiltInComponentFrame(name)\n              : \"\";\n            info = JSCompiler_temp_const + JSCompiler_inline_result;\n          }\n        } else\n          componentStack.owner ||\n            (info += describeComponentStackByType(componentStack.type));\n        for (; componentStack; )\n          (JSCompiler_temp_const = null),\n            null != componentStack.debugStack\n              ? (JSCompiler_temp_const = formatOwnerStack(\n                  componentStack.debugStack\n                ))\n              : ((JSCompiler_inline_result = componentStack),\n                null != JSCompiler_inline_result.stack &&\n                  (JSCompiler_temp_const =\n                    \"string\" !== typeof JSCompiler_inline_result.stack\n                      ? (JSCompiler_inline_result.stack = formatOwnerStack(\n                          JSCompiler_inline_result.stack\n                        ))\n                      : JSCompiler_inline_result.stack)),\n            (componentStack = componentStack.owner) &&\n              JSCompiler_temp_const &&\n              (info += \"\\n\" + JSCompiler_temp_const);\n        var JSCompiler_inline_result$jscomp$0 = info;\n      } catch (x) {\n        JSCompiler_inline_result$jscomp$0 =\n          \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n      }\n      return JSCompiler_inline_result$jscomp$0;\n    }\n    function pushServerComponentStack(task, debugInfo) {\n      if (null != debugInfo)\n        for (var i = 0; i < debugInfo.length; i++) {\n          var componentInfo = debugInfo[i];\n          \"string\" === typeof componentInfo.name &&\n            void 0 !== componentInfo.debugStack &&\n            ((task.componentStack = {\n              parent: task.componentStack,\n              type: componentInfo,\n              owner: componentInfo.owner,\n              stack: componentInfo.debugStack\n            }),\n            (task.debugTask = componentInfo.debugTask));\n        }\n    }\n    function pushComponentStack(task) {\n      var node = task.node;\n      if (\"object\" === typeof node && null !== node)\n        switch (node.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n            var type = node.type,\n              owner = node._owner,\n              stack = node._debugStack;\n            pushServerComponentStack(task, node._debugInfo);\n            task.debugTask = node._debugTask;\n            task.componentStack = {\n              parent: task.componentStack,\n              type: type,\n              owner: owner,\n              stack: stack\n            };\n            break;\n          case REACT_LAZY_TYPE:\n            pushServerComponentStack(task, node._debugInfo);\n            break;\n          default:\n            \"function\" === typeof node.then &&\n              pushServerComponentStack(task, node._debugInfo);\n        }\n    }\n    function getThrownInfo(node$jscomp$0) {\n      var errorInfo = {};\n      node$jscomp$0 &&\n        Object.defineProperty(errorInfo, \"componentStack\", {\n          configurable: !0,\n          enumerable: !0,\n          get: function () {\n            try {\n              var info = \"\",\n                node = node$jscomp$0;\n              do\n                (info += describeComponentStackByType(node.type)),\n                  (node = node.parent);\n              while (node);\n              var stack = info;\n            } catch (x) {\n              stack = \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n            Object.defineProperty(errorInfo, \"componentStack\", {\n              value: stack\n            });\n            return stack;\n          }\n        });\n      return errorInfo;\n    }\n    function encodeErrorForBoundary(\n      boundary,\n      digest,\n      error,\n      thrownInfo,\n      wasAborted\n    ) {\n      boundary.errorDigest = digest;\n      error instanceof Error\n        ? ((digest = String(error.message)), (error = String(error.stack)))\n        : ((digest =\n            \"object\" === typeof error && null !== error\n              ? describeObjectForErrorMessage(error)\n              : String(error)),\n          (error = null));\n      wasAborted = wasAborted\n        ? \"Switched to client rendering because the server rendering aborted due to:\\n\\n\"\n        : \"Switched to client rendering because the server rendering errored:\\n\\n\";\n      boundary.errorMessage = wasAborted + digest;\n      boundary.errorStack = null !== error ? wasAborted + error : null;\n      boundary.errorComponentStack = thrownInfo.componentStack;\n    }\n    function logRecoverableError(request, error, errorInfo, debugTask) {\n      request = request.onError;\n      error = debugTask\n        ? debugTask.run(request.bind(null, error, errorInfo))\n        : request(error, errorInfo);\n      if (null != error && \"string\" !== typeof error)\n        console.error(\n          'onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"%s\" instead',\n          typeof error\n        );\n      else return error;\n    }\n    function fatalError(request, error, errorInfo, debugTask) {\n      errorInfo = request.onShellError;\n      var onFatalError = request.onFatalError;\n      debugTask\n        ? (debugTask.run(errorInfo.bind(null, error)),\n          debugTask.run(onFatalError.bind(null, error)))\n        : (errorInfo(error), onFatalError(error));\n      null !== request.destination\n        ? ((request.status = CLOSED), request.destination.destroy(error))\n        : ((request.status = 13), (request.fatalError = error));\n    }\n    function renderWithHooks(\n      request,\n      task,\n      keyPath,\n      Component,\n      props,\n      secondArg\n    ) {\n      var prevThenableState = task.thenableState;\n      task.thenableState = null;\n      currentlyRenderingComponent = {};\n      currentlyRenderingTask = task;\n      currentlyRenderingRequest = request;\n      currentlyRenderingKeyPath = keyPath;\n      isInHookUserCodeInDev = !1;\n      actionStateCounter = localIdCounter = 0;\n      actionStateMatchingIndex = -1;\n      thenableIndexCounter = 0;\n      thenableState = prevThenableState;\n      for (\n        request = callComponentInDEV(Component, props, secondArg);\n        didScheduleRenderPhaseUpdate;\n\n      )\n        (didScheduleRenderPhaseUpdate = !1),\n          (actionStateCounter = localIdCounter = 0),\n          (actionStateMatchingIndex = -1),\n          (thenableIndexCounter = 0),\n          (numberOfReRenders += 1),\n          (workInProgressHook = null),\n          (request = Component(props, secondArg));\n      resetHooksState();\n      return request;\n    }\n    function finishFunctionComponent(\n      request,\n      task,\n      keyPath,\n      children,\n      hasId,\n      actionStateCount,\n      actionStateMatchingIndex\n    ) {\n      var didEmitActionStateMarkers = !1;\n      if (0 !== actionStateCount && null !== request.formState) {\n        var segment = task.blockedSegment;\n        if (null !== segment) {\n          didEmitActionStateMarkers = !0;\n          segment = segment.chunks;\n          for (var i = 0; i < actionStateCount; i++)\n            i === actionStateMatchingIndex\n              ? segment.push(\"\\x3c!--F!--\\x3e\")\n              : segment.push(\"\\x3c!--F--\\x3e\");\n        }\n      }\n      actionStateCount = task.keyPath;\n      task.keyPath = keyPath;\n      hasId\n        ? ((keyPath = task.treeContext),\n          (task.treeContext = pushTreeContext(keyPath, 1, 0)),\n          renderNode(request, task, children, -1),\n          (task.treeContext = keyPath))\n        : didEmitActionStateMarkers\n          ? renderNode(request, task, children, -1)\n          : renderNodeDestructive(request, task, children, -1);\n      task.keyPath = actionStateCount;\n    }\n    function renderElement(request, task, keyPath, type, props, ref) {\n      if (\"function\" === typeof type)\n        if (type.prototype && type.prototype.isReactComponent) {\n          var newProps = props;\n          if (\"ref\" in props) {\n            newProps = {};\n            for (var propName in props)\n              \"ref\" !== propName && (newProps[propName] = props[propName]);\n          }\n          var defaultProps = type.defaultProps;\n          if (defaultProps) {\n            newProps === props && (newProps = assign({}, newProps, props));\n            for (var _propName in defaultProps)\n              void 0 === newProps[_propName] &&\n                (newProps[_propName] = defaultProps[_propName]);\n          }\n          var resolvedProps = newProps;\n          var context = emptyContextObject,\n            contextType = type.contextType;\n          if (\n            \"contextType\" in type &&\n            null !== contextType &&\n            (void 0 === contextType ||\n              contextType.$$typeof !== REACT_CONTEXT_TYPE) &&\n            !didWarnAboutInvalidateContextType.has(type)\n          ) {\n            didWarnAboutInvalidateContextType.add(type);\n            var addendum =\n              void 0 === contextType\n                ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\"\n                : \"object\" !== typeof contextType\n                  ? \" However, it is set to a \" + typeof contextType + \".\"\n                  : contextType.$$typeof === REACT_CONSUMER_TYPE\n                    ? \" Did you accidentally pass the Context.Consumer instead?\"\n                    : \" However, it is set to an object with keys {\" +\n                      Object.keys(contextType).join(\", \") +\n                      \"}.\";\n            console.error(\n              \"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\",\n              getComponentNameFromType(type) || \"Component\",\n              addendum\n            );\n          }\n          \"object\" === typeof contextType &&\n            null !== contextType &&\n            (context = contextType._currentValue2);\n          var instance = new type(resolvedProps, context);\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps &&\n            (null === instance.state || void 0 === instance.state)\n          ) {\n            var componentName = getComponentNameFromType(type) || \"Component\";\n            didWarnAboutUninitializedState.has(componentName) ||\n              (didWarnAboutUninitializedState.add(componentName),\n              console.error(\n                \"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\",\n                componentName,\n                null === instance.state ? \"null\" : \"undefined\",\n                componentName\n              ));\n          }\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps ||\n            \"function\" === typeof instance.getSnapshotBeforeUpdate\n          ) {\n            var foundWillMountName = null,\n              foundWillReceivePropsName = null,\n              foundWillUpdateName = null;\n            \"function\" === typeof instance.componentWillMount &&\n            !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ? (foundWillMountName = \"componentWillMount\")\n              : \"function\" === typeof instance.UNSAFE_componentWillMount &&\n                (foundWillMountName = \"UNSAFE_componentWillMount\");\n            \"function\" === typeof instance.componentWillReceiveProps &&\n            !0 !==\n              instance.componentWillReceiveProps.__suppressDeprecationWarning\n              ? (foundWillReceivePropsName = \"componentWillReceiveProps\")\n              : \"function\" ===\n                  typeof instance.UNSAFE_componentWillReceiveProps &&\n                (foundWillReceivePropsName =\n                  \"UNSAFE_componentWillReceiveProps\");\n            \"function\" === typeof instance.componentWillUpdate &&\n            !0 !== instance.componentWillUpdate.__suppressDeprecationWarning\n              ? (foundWillUpdateName = \"componentWillUpdate\")\n              : \"function\" === typeof instance.UNSAFE_componentWillUpdate &&\n                (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n            if (\n              null !== foundWillMountName ||\n              null !== foundWillReceivePropsName ||\n              null !== foundWillUpdateName\n            ) {\n              var _componentName =\n                  getComponentNameFromType(type) || \"Component\",\n                newApiName =\n                  \"function\" === typeof type.getDerivedStateFromProps\n                    ? \"getDerivedStateFromProps()\"\n                    : \"getSnapshotBeforeUpdate()\";\n              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) ||\n                (didWarnAboutLegacyLifecyclesAndDerivedState.add(\n                  _componentName\n                ),\n                console.error(\n                  \"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\",\n                  _componentName,\n                  newApiName,\n                  null !== foundWillMountName\n                    ? \"\\n  \" + foundWillMountName\n                    : \"\",\n                  null !== foundWillReceivePropsName\n                    ? \"\\n  \" + foundWillReceivePropsName\n                    : \"\",\n                  null !== foundWillUpdateName\n                    ? \"\\n  \" + foundWillUpdateName\n                    : \"\"\n                ));\n            }\n          }\n          var name = getComponentNameFromType(type) || \"Component\";\n          instance.render ||\n            (type.prototype && \"function\" === typeof type.prototype.render\n              ? console.error(\n                  \"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\",\n                  name\n                )\n              : console.error(\n                  \"No `render` method found on the %s instance: you may have forgotten to define `render`.\",\n                  name\n                ));\n          !instance.getInitialState ||\n            instance.getInitialState.isReactClassApproved ||\n            instance.state ||\n            console.error(\n              \"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\",\n              name\n            );\n          instance.getDefaultProps &&\n            !instance.getDefaultProps.isReactClassApproved &&\n            console.error(\n              \"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\",\n              name\n            );\n          instance.contextType &&\n            console.error(\n              \"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\",\n              name\n            );\n          type.childContextTypes &&\n            !didWarnAboutChildContextTypes.has(type) &&\n            (didWarnAboutChildContextTypes.add(type),\n            console.error(\n              \"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          type.contextTypes &&\n            !didWarnAboutContextTypes$1.has(type) &&\n            (didWarnAboutContextTypes$1.add(type),\n            console.error(\n              \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          \"function\" === typeof instance.componentShouldUpdate &&\n            console.error(\n              \"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\",\n              name\n            );\n          type.prototype &&\n            type.prototype.isPureReactComponent &&\n            \"undefined\" !== typeof instance.shouldComponentUpdate &&\n            console.error(\n              \"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\",\n              getComponentNameFromType(type) || \"A pure component\"\n            );\n          \"function\" === typeof instance.componentDidUnmount &&\n            console.error(\n              \"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\",\n              name\n            );\n          \"function\" === typeof instance.componentDidReceiveProps &&\n            console.error(\n              \"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\",\n              name\n            );\n          \"function\" === typeof instance.componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",\n              name\n            );\n          \"function\" === typeof instance.UNSAFE_componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\",\n              name\n            );\n          var hasMutatedProps = instance.props !== resolvedProps;\n          void 0 !== instance.props &&\n            hasMutatedProps &&\n            console.error(\n              \"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\",\n              name\n            );\n          instance.defaultProps &&\n            console.error(\n              \"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\",\n              name,\n              name\n            );\n          \"function\" !== typeof instance.getSnapshotBeforeUpdate ||\n            \"function\" === typeof instance.componentDidUpdate ||\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) ||\n            (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type),\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\",\n              getComponentNameFromType(type)\n            ));\n          \"function\" === typeof instance.getDerivedStateFromProps &&\n            console.error(\n              \"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof instance.getDerivedStateFromError &&\n            console.error(\n              \"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof type.getSnapshotBeforeUpdate &&\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\",\n              name\n            );\n          var state = instance.state;\n          state &&\n            (\"object\" !== typeof state || isArrayImpl(state)) &&\n            console.error(\"%s.state: must be set to an object or null\", name);\n          \"function\" === typeof instance.getChildContext &&\n            \"object\" !== typeof type.childContextTypes &&\n            console.error(\n              \"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\",\n              name\n            );\n          var initialState = void 0 !== instance.state ? instance.state : null;\n          instance.updater = classComponentUpdater;\n          instance.props = resolvedProps;\n          instance.state = initialState;\n          var internalInstance = { queue: [], replace: !1 };\n          instance._reactInternals = internalInstance;\n          var contextType$jscomp$0 = type.contextType;\n          instance.context =\n            \"object\" === typeof contextType$jscomp$0 &&\n            null !== contextType$jscomp$0\n              ? contextType$jscomp$0._currentValue2\n              : emptyContextObject;\n          if (instance.state === resolvedProps) {\n            var componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Component\";\n            didWarnAboutDirectlyAssigningPropsToState.has(\n              componentName$jscomp$0\n            ) ||\n              (didWarnAboutDirectlyAssigningPropsToState.add(\n                componentName$jscomp$0\n              ),\n              console.error(\n                \"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\",\n                componentName$jscomp$0\n              ));\n          }\n          var getDerivedStateFromProps = type.getDerivedStateFromProps;\n          if (\"function\" === typeof getDerivedStateFromProps) {\n            var partialState = getDerivedStateFromProps(\n              resolvedProps,\n              initialState\n            );\n            if (void 0 === partialState) {\n              var componentName$jscomp$1 =\n                getComponentNameFromType(type) || \"Component\";\n              didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) ||\n                (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1),\n                console.error(\n                  \"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\",\n                  componentName$jscomp$1\n                ));\n            }\n            var JSCompiler_inline_result =\n              null === partialState || void 0 === partialState\n                ? initialState\n                : assign({}, initialState, partialState);\n            instance.state = JSCompiler_inline_result;\n          }\n          if (\n            \"function\" !== typeof type.getDerivedStateFromProps &&\n            \"function\" !== typeof instance.getSnapshotBeforeUpdate &&\n            (\"function\" === typeof instance.UNSAFE_componentWillMount ||\n              \"function\" === typeof instance.componentWillMount)\n          ) {\n            var oldState = instance.state;\n            if (\"function\" === typeof instance.componentWillMount) {\n              if (\n                !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ) {\n                var componentName$jscomp$2 =\n                  getComponentNameFromType(type) || \"Unknown\";\n                didWarnAboutDeprecatedWillMount[componentName$jscomp$2] ||\n                  (console.warn(\n                    \"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\\n\\nPlease update the following components: %s\",\n                    componentName$jscomp$2\n                  ),\n                  (didWarnAboutDeprecatedWillMount[componentName$jscomp$2] =\n                    !0));\n              }\n              instance.componentWillMount();\n            }\n            \"function\" === typeof instance.UNSAFE_componentWillMount &&\n              instance.UNSAFE_componentWillMount();\n            oldState !== instance.state &&\n              (console.error(\n                \"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\",\n                getComponentNameFromType(type) || \"Component\"\n              ),\n              classComponentUpdater.enqueueReplaceState(\n                instance,\n                instance.state,\n                null\n              ));\n            if (\n              null !== internalInstance.queue &&\n              0 < internalInstance.queue.length\n            ) {\n              var oldQueue = internalInstance.queue,\n                oldReplace = internalInstance.replace;\n              internalInstance.queue = null;\n              internalInstance.replace = !1;\n              if (oldReplace && 1 === oldQueue.length)\n                instance.state = oldQueue[0];\n              else {\n                for (\n                  var nextState = oldReplace ? oldQueue[0] : instance.state,\n                    dontMutate = !0,\n                    i = oldReplace ? 1 : 0;\n                  i < oldQueue.length;\n                  i++\n                ) {\n                  var partial = oldQueue[i],\n                    partialState$jscomp$0 =\n                      \"function\" === typeof partial\n                        ? partial.call(\n                            instance,\n                            nextState,\n                            resolvedProps,\n                            void 0\n                          )\n                        : partial;\n                  null != partialState$jscomp$0 &&\n                    (dontMutate\n                      ? ((dontMutate = !1),\n                        (nextState = assign(\n                          {},\n                          nextState,\n                          partialState$jscomp$0\n                        )))\n                      : assign(nextState, partialState$jscomp$0));\n                }\n                instance.state = nextState;\n              }\n            } else internalInstance.queue = null;\n          }\n          var nextChildren = callRenderInDEV(instance);\n          if (12 === request.status) throw null;\n          instance.props !== resolvedProps &&\n            (didWarnAboutReassigningProps ||\n              console.error(\n                \"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\",\n                getComponentNameFromType(type) || \"a component\"\n              ),\n            (didWarnAboutReassigningProps = !0));\n          var prevKeyPath = task.keyPath;\n          task.keyPath = keyPath;\n          renderNodeDestructive(request, task, nextChildren, -1);\n          task.keyPath = prevKeyPath;\n        } else {\n          if (type.prototype && \"function\" === typeof type.prototype.render) {\n            var componentName$jscomp$3 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutBadClass[componentName$jscomp$3] ||\n              (console.error(\n                \"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\",\n                componentName$jscomp$3,\n                componentName$jscomp$3\n              ),\n              (didWarnAboutBadClass[componentName$jscomp$3] = !0));\n          }\n          var value = renderWithHooks(\n            request,\n            task,\n            keyPath,\n            type,\n            props,\n            void 0\n          );\n          if (12 === request.status) throw null;\n          var hasId = 0 !== localIdCounter,\n            actionStateCount = actionStateCounter,\n            actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;\n          if (type.contextTypes) {\n            var _componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypes[_componentName$jscomp$0] ||\n              ((didWarnAboutContextTypes[_componentName$jscomp$0] = !0),\n              console.error(\n                \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\",\n                _componentName$jscomp$0\n              ));\n          }\n          type &&\n            type.childContextTypes &&\n            console.error(\n              \"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\",\n              type.displayName || type.name || \"Component\"\n            );\n          if (\"function\" === typeof type.getDerivedStateFromProps) {\n            var _componentName2 = getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] ||\n              (console.error(\n                \"%s: Function components do not support getDerivedStateFromProps.\",\n                _componentName2\n              ),\n              (didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] =\n                !0));\n          }\n          if (\n            \"object\" === typeof type.contextType &&\n            null !== type.contextType\n          ) {\n            var _componentName3 = getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypeOnFunctionComponent[_componentName3] ||\n              (console.error(\n                \"%s: Function components do not support contextType.\",\n                _componentName3\n              ),\n              (didWarnAboutContextTypeOnFunctionComponent[_componentName3] =\n                !0));\n          }\n          finishFunctionComponent(\n            request,\n            task,\n            keyPath,\n            value,\n            hasId,\n            actionStateCount,\n            actionStateMatchingIndex$jscomp$0\n          );\n        }\n      else if (\"string\" === typeof type) {\n        var segment = task.blockedSegment;\n        if (null === segment) {\n          var children = props.children,\n            prevContext = task.formatContext,\n            prevKeyPath$jscomp$0 = task.keyPath;\n          task.formatContext = getChildFormatContext(prevContext, type, props);\n          task.keyPath = keyPath;\n          renderNode(request, task, children, -1);\n          task.formatContext = prevContext;\n          task.keyPath = prevKeyPath$jscomp$0;\n        } else {\n          var _children = pushStartInstance(\n            segment.chunks,\n            type,\n            props,\n            request.resumableState,\n            request.renderState,\n            task.blockedPreamble,\n            task.hoistableState,\n            task.formatContext,\n            segment.lastPushedText,\n            task.isFallback\n          );\n          segment.lastPushedText = !1;\n          var _prevContext = task.formatContext,\n            _prevKeyPath2 = task.keyPath;\n          task.keyPath = keyPath;\n          if (\n            (task.formatContext = getChildFormatContext(\n              _prevContext,\n              type,\n              props\n            )).insertionMode === HTML_HEAD_MODE\n          ) {\n            var preambleSegment = createPendingSegment(\n              request,\n              0,\n              null,\n              task.formatContext,\n              !1,\n              !1\n            );\n            segment.preambleChildren.push(preambleSegment);\n            var preambleTask = createRenderTask(\n              request,\n              null,\n              _children,\n              -1,\n              task.blockedBoundary,\n              preambleSegment,\n              task.blockedPreamble,\n              task.hoistableState,\n              request.abortableTasks,\n              task.keyPath,\n              task.formatContext,\n              task.context,\n              task.treeContext,\n              task.componentStack,\n              task.isFallback,\n              emptyContextObject,\n              task.debugTask\n            );\n            pushComponentStack(preambleTask);\n            request.pingedTasks.push(preambleTask);\n          } else renderNode(request, task, _children, -1);\n          task.formatContext = _prevContext;\n          task.keyPath = _prevKeyPath2;\n          a: {\n            var target = segment.chunks,\n              resumableState = request.resumableState;\n            switch (type) {\n              case \"title\":\n              case \"style\":\n              case \"script\":\n              case \"area\":\n              case \"base\":\n              case \"br\":\n              case \"col\":\n              case \"embed\":\n              case \"hr\":\n              case \"img\":\n              case \"input\":\n              case \"keygen\":\n              case \"link\":\n              case \"meta\":\n              case \"param\":\n              case \"source\":\n              case \"track\":\n              case \"wbr\":\n                break a;\n              case \"body\":\n                if (_prevContext.insertionMode <= HTML_HTML_MODE) {\n                  resumableState.hasBody = !0;\n                  break a;\n                }\n                break;\n              case \"html\":\n                if (_prevContext.insertionMode === ROOT_HTML_MODE) {\n                  resumableState.hasHtml = !0;\n                  break a;\n                }\n                break;\n              case \"head\":\n                if (_prevContext.insertionMode <= HTML_HTML_MODE) break a;\n            }\n            target.push(endChunkForTag(type));\n          }\n          segment.lastPushedText = !1;\n        }\n      } else {\n        switch (type) {\n          case REACT_LEGACY_HIDDEN_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_FRAGMENT_TYPE:\n            var prevKeyPath$jscomp$1 = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, props.children, -1);\n            task.keyPath = prevKeyPath$jscomp$1;\n            return;\n          case REACT_OFFSCREEN_TYPE:\n            if (\"hidden\" !== props.mode) {\n              var prevKeyPath$jscomp$2 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, props.children, -1);\n              task.keyPath = prevKeyPath$jscomp$2;\n            }\n            return;\n          case REACT_SUSPENSE_LIST_TYPE:\n            var _prevKeyPath3 = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, props.children, -1);\n            task.keyPath = _prevKeyPath3;\n            return;\n          case REACT_VIEW_TRANSITION_TYPE:\n          case REACT_SCOPE_TYPE:\n            throw Error(\n              \"ReactDOMServer does not yet support scope components.\"\n            );\n          case REACT_SUSPENSE_TYPE:\n            a: if (null !== task.replay) {\n              var _prevKeyPath = task.keyPath;\n              task.keyPath = keyPath;\n              var _content = props.children;\n              try {\n                renderNode(request, task, _content, -1);\n              } finally {\n                task.keyPath = _prevKeyPath;\n              }\n            } else {\n              var prevKeyPath$jscomp$3 = task.keyPath,\n                parentBoundary = task.blockedBoundary,\n                parentPreamble = task.blockedPreamble,\n                parentHoistableState = task.hoistableState,\n                parentSegment = task.blockedSegment,\n                fallback = props.fallback,\n                content = props.children,\n                fallbackAbortSet = new Set();\n              var newBoundary =\n                task.formatContext.insertionMode < HTML_MODE\n                  ? createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      createPreambleState(),\n                      createPreambleState()\n                    )\n                  : createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      null,\n                      null\n                    );\n              null !== request.trackedPostpones &&\n                (newBoundary.trackedContentKeyPath = keyPath);\n              var boundarySegment = createPendingSegment(\n                request,\n                parentSegment.chunks.length,\n                newBoundary,\n                task.formatContext,\n                !1,\n                !1\n              );\n              parentSegment.children.push(boundarySegment);\n              parentSegment.lastPushedText = !1;\n              var contentRootSegment = createPendingSegment(\n                request,\n                0,\n                null,\n                task.formatContext,\n                !1,\n                !1\n              );\n              contentRootSegment.parentFlushed = !0;\n              if (null !== request.trackedPostpones) {\n                var fallbackKeyPath = [\n                    keyPath[0],\n                    \"Suspense Fallback\",\n                    keyPath[2]\n                  ],\n                  fallbackReplayNode = [\n                    fallbackKeyPath[1],\n                    fallbackKeyPath[2],\n                    [],\n                    null\n                  ];\n                request.trackedPostpones.workingMap.set(\n                  fallbackKeyPath,\n                  fallbackReplayNode\n                );\n                newBoundary.trackedFallbackNode = fallbackReplayNode;\n                task.blockedSegment = boundarySegment;\n                task.blockedPreamble = newBoundary.fallbackPreamble;\n                task.keyPath = fallbackKeyPath;\n                boundarySegment.status = 6;\n                try {\n                  renderNode(request, task, fallback, -1),\n                    pushSegmentFinale(\n                      boundarySegment.chunks,\n                      request.renderState,\n                      boundarySegment.lastPushedText,\n                      boundarySegment.textEmbedded\n                    ),\n                    (boundarySegment.status = COMPLETED);\n                } catch (thrownValue) {\n                  throw (\n                    ((boundarySegment.status = 12 === request.status ? 3 : 4),\n                    thrownValue)\n                  );\n                } finally {\n                  (task.blockedSegment = parentSegment),\n                    (task.blockedPreamble = parentPreamble),\n                    (task.keyPath = prevKeyPath$jscomp$3);\n                }\n                var suspendedPrimaryTask = createRenderTask(\n                  request,\n                  null,\n                  content,\n                  -1,\n                  newBoundary,\n                  contentRootSegment,\n                  newBoundary.contentPreamble,\n                  newBoundary.contentState,\n                  task.abortSet,\n                  keyPath,\n                  task.formatContext,\n                  task.context,\n                  task.treeContext,\n                  task.componentStack,\n                  task.isFallback,\n                  emptyContextObject,\n                  task.debugTask\n                );\n                pushComponentStack(suspendedPrimaryTask);\n                request.pingedTasks.push(suspendedPrimaryTask);\n              } else {\n                task.blockedBoundary = newBoundary;\n                task.blockedPreamble = newBoundary.contentPreamble;\n                task.hoistableState = newBoundary.contentState;\n                task.blockedSegment = contentRootSegment;\n                task.keyPath = keyPath;\n                contentRootSegment.status = 6;\n                try {\n                  if (\n                    (renderNode(request, task, content, -1),\n                    pushSegmentFinale(\n                      contentRootSegment.chunks,\n                      request.renderState,\n                      contentRootSegment.lastPushedText,\n                      contentRootSegment.textEmbedded\n                    ),\n                    (contentRootSegment.status = COMPLETED),\n                    queueCompletedSegment(newBoundary, contentRootSegment),\n                    0 === newBoundary.pendingTasks &&\n                      newBoundary.status === PENDING)\n                  ) {\n                    newBoundary.status = COMPLETED;\n                    0 === request.pendingRootTasks &&\n                      task.blockedPreamble &&\n                      preparePreamble(request);\n                    break a;\n                  }\n                } catch (thrownValue$2) {\n                  newBoundary.status = CLIENT_RENDERED;\n                  if (12 === request.status) {\n                    contentRootSegment.status = 3;\n                    var error = request.fatalError;\n                  } else\n                    (contentRootSegment.status = 4), (error = thrownValue$2);\n                  var thrownInfo = getThrownInfo(task.componentStack);\n                  var errorDigest = logRecoverableError(\n                    request,\n                    error,\n                    thrownInfo,\n                    task.debugTask\n                  );\n                  encodeErrorForBoundary(\n                    newBoundary,\n                    errorDigest,\n                    error,\n                    thrownInfo,\n                    !1\n                  );\n                  untrackBoundary(request, newBoundary);\n                } finally {\n                  (task.blockedBoundary = parentBoundary),\n                    (task.blockedPreamble = parentPreamble),\n                    (task.hoistableState = parentHoistableState),\n                    (task.blockedSegment = parentSegment),\n                    (task.keyPath = prevKeyPath$jscomp$3);\n                }\n                var suspendedFallbackTask = createRenderTask(\n                  request,\n                  null,\n                  fallback,\n                  -1,\n                  parentBoundary,\n                  boundarySegment,\n                  newBoundary.fallbackPreamble,\n                  newBoundary.fallbackState,\n                  fallbackAbortSet,\n                  [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                  task.formatContext,\n                  task.context,\n                  task.treeContext,\n                  task.componentStack,\n                  !0,\n                  emptyContextObject,\n                  task.debugTask\n                );\n                pushComponentStack(suspendedFallbackTask);\n                request.pingedTasks.push(suspendedFallbackTask);\n              }\n            }\n            return;\n        }\n        if (\"object\" === typeof type && null !== type)\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              if (\"ref\" in props) {\n                var propsWithoutRef = {};\n                for (var key in props)\n                  \"ref\" !== key && (propsWithoutRef[key] = props[key]);\n              } else propsWithoutRef = props;\n              var children$jscomp$0 = renderWithHooks(\n                request,\n                task,\n                keyPath,\n                type.render,\n                propsWithoutRef,\n                ref\n              );\n              finishFunctionComponent(\n                request,\n                task,\n                keyPath,\n                children$jscomp$0,\n                0 !== localIdCounter,\n                actionStateCounter,\n                actionStateMatchingIndex\n              );\n              return;\n            case REACT_MEMO_TYPE:\n              renderElement(request, task, keyPath, type.type, props, ref);\n              return;\n            case REACT_PROVIDER_TYPE:\n            case REACT_CONTEXT_TYPE:\n              var value$jscomp$0 = props.value,\n                children$jscomp$1 = props.children;\n              var prevSnapshot = task.context;\n              var prevKeyPath$jscomp$4 = task.keyPath;\n              var prevValue = type._currentValue2;\n              type._currentValue2 = value$jscomp$0;\n              void 0 !== type._currentRenderer2 &&\n                null !== type._currentRenderer2 &&\n                type._currentRenderer2 !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer2 = rendererSigil;\n              var prevNode = currentActiveSnapshot,\n                newNode = {\n                  parent: prevNode,\n                  depth: null === prevNode ? 0 : prevNode.depth + 1,\n                  context: type,\n                  parentValue: prevValue,\n                  value: value$jscomp$0\n                };\n              currentActiveSnapshot = newNode;\n              task.context = newNode;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, children$jscomp$1, -1);\n              var prevSnapshot$jscomp$0 = currentActiveSnapshot;\n              if (null === prevSnapshot$jscomp$0)\n                throw Error(\n                  \"Tried to pop a Context at the root of the app. This is a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context !== type &&\n                console.error(\n                  \"The parent context is not the expected context. This is probably a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context._currentValue2 =\n                prevSnapshot$jscomp$0.parentValue;\n              void 0 !== type._currentRenderer2 &&\n                null !== type._currentRenderer2 &&\n                type._currentRenderer2 !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer2 = rendererSigil;\n              var JSCompiler_inline_result$jscomp$0 = (currentActiveSnapshot =\n                prevSnapshot$jscomp$0.parent);\n              task.context = JSCompiler_inline_result$jscomp$0;\n              task.keyPath = prevKeyPath$jscomp$4;\n              prevSnapshot !== task.context &&\n                console.error(\n                  \"Popping the context provider did not return back to the original snapshot. This is a bug in React.\"\n                );\n              return;\n            case REACT_CONSUMER_TYPE:\n              var context$jscomp$0 = type._context,\n                render = props.children;\n              \"function\" !== typeof render &&\n                console.error(\n                  \"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"\n                );\n              var newChildren = render(context$jscomp$0._currentValue2),\n                prevKeyPath$jscomp$5 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, newChildren, -1);\n              task.keyPath = prevKeyPath$jscomp$5;\n              return;\n            case REACT_LAZY_TYPE:\n              var Component = callLazyInitInDEV(type);\n              if (12 === request.status) throw null;\n              renderElement(request, task, keyPath, Component, props, ref);\n              return;\n          }\n        var info = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          info +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        throw Error(\n          \"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" +\n            ((null == type ? type : typeof type) + \".\" + info)\n        );\n      }\n    }\n    function resumeNode(request, task, segmentId, node, childIndex) {\n      var prevReplay = task.replay,\n        blockedBoundary = task.blockedBoundary,\n        resumedSegment = createPendingSegment(\n          request,\n          0,\n          null,\n          task.formatContext,\n          !1,\n          !1\n        );\n      resumedSegment.id = segmentId;\n      resumedSegment.parentFlushed = !0;\n      try {\n        (task.replay = null),\n          (task.blockedSegment = resumedSegment),\n          renderNode(request, task, node, childIndex),\n          (resumedSegment.status = COMPLETED),\n          null === blockedBoundary\n            ? (request.completedRootSegment = resumedSegment)\n            : (queueCompletedSegment(blockedBoundary, resumedSegment),\n              blockedBoundary.parentFlushed &&\n                request.partialBoundaries.push(blockedBoundary));\n      } finally {\n        (task.replay = prevReplay), (task.blockedSegment = null);\n      }\n    }\n    function replayElement(\n      request,\n      task,\n      keyPath,\n      name,\n      keyOrIndex,\n      childIndex,\n      type,\n      props,\n      ref,\n      replay\n    ) {\n      childIndex = replay.nodes;\n      for (var i = 0; i < childIndex.length; i++) {\n        var node = childIndex[i];\n        if (keyOrIndex === node[1]) {\n          if (4 === node.length) {\n            if (null !== name && name !== node[0])\n              throw Error(\n                \"Expected the resume to render <\" +\n                  node[0] +\n                  \"> in this slot but instead it rendered <\" +\n                  name +\n                  \">. The tree doesn't match so React will fallback to client rendering.\"\n              );\n            var childNodes = node[2];\n            node = node[3];\n            name = task.node;\n            task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };\n            try {\n              renderElement(request, task, keyPath, type, props, ref);\n              if (\n                1 === task.replay.pendingTasks &&\n                0 < task.replay.nodes.length\n              )\n                throw Error(\n                  \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                );\n              task.replay.pendingTasks--;\n            } catch (x) {\n              if (\n                \"object\" === typeof x &&\n                null !== x &&\n                (x === SuspenseException || \"function\" === typeof x.then)\n              )\n                throw (task.node === name && (task.replay = replay), x);\n              task.replay.pendingTasks--;\n              type = getThrownInfo(task.componentStack);\n              props = request;\n              request = task.blockedBoundary;\n              keyPath = x;\n              ref = node;\n              node = logRecoverableError(props, keyPath, type, task.debugTask);\n              abortRemainingReplayNodes(\n                props,\n                request,\n                childNodes,\n                ref,\n                keyPath,\n                node,\n                type,\n                !1\n              );\n            }\n            task.replay = replay;\n          } else {\n            if (type !== REACT_SUSPENSE_TYPE)\n              throw Error(\n                \"Expected the resume to render <Suspense> in this slot but instead it rendered <\" +\n                  (getComponentNameFromType(type) || \"Unknown\") +\n                  \">. The tree doesn't match so React will fallback to client rendering.\"\n              );\n            a: {\n              replay = void 0;\n              type = node[5];\n              ref = node[2];\n              name = node[3];\n              keyOrIndex = null === node[4] ? [] : node[4][2];\n              node = null === node[4] ? null : node[4][3];\n              var prevKeyPath = task.keyPath,\n                previousReplaySet = task.replay,\n                parentBoundary = task.blockedBoundary,\n                parentHoistableState = task.hoistableState,\n                content = props.children,\n                fallback = props.fallback,\n                fallbackAbortSet = new Set();\n              props =\n                task.formatContext.insertionMode < HTML_MODE\n                  ? createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      createPreambleState(),\n                      createPreambleState()\n                    )\n                  : createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      null,\n                      null\n                    );\n              props.parentFlushed = !0;\n              props.rootSegmentID = type;\n              task.blockedBoundary = props;\n              task.hoistableState = props.contentState;\n              task.keyPath = keyPath;\n              task.replay = { nodes: ref, slots: name, pendingTasks: 1 };\n              try {\n                renderNode(request, task, content, -1);\n                if (\n                  1 === task.replay.pendingTasks &&\n                  0 < task.replay.nodes.length\n                )\n                  throw Error(\n                    \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                  );\n                task.replay.pendingTasks--;\n                if (0 === props.pendingTasks && props.status === PENDING) {\n                  props.status = COMPLETED;\n                  request.completedBoundaries.push(props);\n                  break a;\n                }\n              } catch (error) {\n                (props.status = CLIENT_RENDERED),\n                  (childNodes = getThrownInfo(task.componentStack)),\n                  (replay = logRecoverableError(\n                    request,\n                    error,\n                    childNodes,\n                    task.debugTask\n                  )),\n                  encodeErrorForBoundary(props, replay, error, childNodes, !1),\n                  task.replay.pendingTasks--,\n                  request.clientRenderedBoundaries.push(props);\n              } finally {\n                (task.blockedBoundary = parentBoundary),\n                  (task.hoistableState = parentHoistableState),\n                  (task.replay = previousReplaySet),\n                  (task.keyPath = prevKeyPath);\n              }\n              props = createReplayTask(\n                request,\n                null,\n                { nodes: keyOrIndex, slots: node, pendingTasks: 0 },\n                fallback,\n                -1,\n                parentBoundary,\n                props.fallbackState,\n                fallbackAbortSet,\n                [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                task.formatContext,\n                task.context,\n                task.treeContext,\n                task.componentStack,\n                !0,\n                emptyContextObject,\n                task.debugTask\n              );\n              pushComponentStack(props);\n              request.pingedTasks.push(props);\n            }\n          }\n          childIndex.splice(i, 1);\n          break;\n        }\n      }\n    }\n    function renderNodeDestructive(request, task, node, childIndex) {\n      null !== task.replay && \"number\" === typeof task.replay.slots\n        ? resumeNode(request, task, task.replay.slots, node, childIndex)\n        : ((task.node = node),\n          (task.childIndex = childIndex),\n          (node = task.componentStack),\n          (childIndex = task.debugTask),\n          pushComponentStack(task),\n          retryNode(request, task),\n          (task.componentStack = node),\n          (task.debugTask = childIndex));\n    }\n    function retryNode(request, task) {\n      var node = task.node,\n        childIndex = task.childIndex;\n      if (null !== node) {\n        if (\"object\" === typeof node) {\n          switch (node.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              var type = node.type,\n                key = node.key;\n              node = node.props;\n              var refProp = node.ref;\n              refProp = void 0 !== refProp ? refProp : null;\n              var debugTask = task.debugTask,\n                name = getComponentNameFromType(type);\n              key = null == key ? (-1 === childIndex ? 0 : childIndex) : key;\n              var keyPath = [task.keyPath, name, key];\n              null !== task.replay\n                ? debugTask\n                  ? debugTask.run(\n                      replayElement.bind(\n                        null,\n                        request,\n                        task,\n                        keyPath,\n                        name,\n                        key,\n                        childIndex,\n                        type,\n                        node,\n                        refProp,\n                        task.replay\n                      )\n                    )\n                  : replayElement(\n                      request,\n                      task,\n                      keyPath,\n                      name,\n                      key,\n                      childIndex,\n                      type,\n                      node,\n                      refProp,\n                      task.replay\n                    )\n                : debugTask\n                  ? debugTask.run(\n                      renderElement.bind(\n                        null,\n                        request,\n                        task,\n                        keyPath,\n                        type,\n                        node,\n                        refProp\n                      )\n                    )\n                  : renderElement(request, task, keyPath, type, node, refProp);\n              return;\n            case REACT_PORTAL_TYPE:\n              throw Error(\n                \"Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.\"\n              );\n            case REACT_LAZY_TYPE:\n              node = callLazyInitInDEV(node);\n              if (12 === request.status) throw null;\n              renderNodeDestructive(request, task, node, childIndex);\n              return;\n          }\n          if (isArrayImpl(node)) {\n            renderChildrenArray(request, task, node, childIndex);\n            return;\n          }\n          null === node || \"object\" !== typeof node\n            ? (key = null)\n            : ((type =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (key = \"function\" === typeof type ? type : null));\n          if (key && (type = key.call(node))) {\n            if (type === node) {\n              if (\n                -1 !== childIndex ||\n                null === task.componentStack ||\n                \"function\" !== typeof task.componentStack.type ||\n                \"[object GeneratorFunction]\" !==\n                  Object.prototype.toString.call(task.componentStack.type) ||\n                \"[object Generator]\" !== Object.prototype.toString.call(type)\n              )\n                didWarnAboutGenerators ||\n                  console.error(\n                    \"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"\n                  ),\n                  (didWarnAboutGenerators = !0);\n            } else\n              node.entries !== key ||\n                didWarnAboutMaps ||\n                (console.error(\n                  \"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"\n                ),\n                (didWarnAboutMaps = !0));\n            node = type.next();\n            if (!node.done) {\n              key = [];\n              do key.push(node.value), (node = type.next());\n              while (!node.done);\n              renderChildrenArray(request, task, key, childIndex);\n            }\n            return;\n          }\n          if (\"function\" === typeof node.then)\n            return (\n              (task.thenableState = null),\n              renderNodeDestructive(\n                request,\n                task,\n                unwrapThenable(node),\n                childIndex\n              )\n            );\n          if (node.$$typeof === REACT_CONTEXT_TYPE)\n            return renderNodeDestructive(\n              request,\n              task,\n              node._currentValue2,\n              childIndex\n            );\n          request = Object.prototype.toString.call(node);\n          throw Error(\n            \"Objects are not valid as a React child (found: \" +\n              (\"[object Object]\" === request\n                ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\"\n                : request) +\n              \"). If you meant to render a collection of children, use an array instead.\"\n          );\n        }\n        \"string\" === typeof node\n          ? ((task = task.blockedSegment),\n            null !== task &&\n              (task.lastPushedText = pushTextInstance(\n                task.chunks,\n                node,\n                request.renderState,\n                task.lastPushedText\n              )))\n          : \"number\" === typeof node || \"bigint\" === typeof node\n            ? ((task = task.blockedSegment),\n              null !== task &&\n                (task.lastPushedText = pushTextInstance(\n                  task.chunks,\n                  \"\" + node,\n                  request.renderState,\n                  task.lastPushedText\n                )))\n            : (\"function\" === typeof node &&\n                ((request = node.displayName || node.name || \"Component\"),\n                console.error(\n                  \"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\",\n                  request,\n                  request\n                )),\n              \"symbol\" === typeof node &&\n                console.error(\n                  \"Symbols are not valid as a React child.\\n  %s\",\n                  String(node)\n                ));\n      }\n    }\n    function renderChildrenArray(request, task, children, childIndex) {\n      var prevKeyPath = task.keyPath,\n        previousComponentStack = task.componentStack;\n      var previousDebugTask = task.debugTask;\n      pushServerComponentStack(task, task.node._debugInfo);\n      if (\n        -1 !== childIndex &&\n        ((task.keyPath = [task.keyPath, \"Fragment\", childIndex]),\n        null !== task.replay)\n      ) {\n        for (\n          var replay = task.replay, replayNodes = replay.nodes, j = 0;\n          j < replayNodes.length;\n          j++\n        ) {\n          var node = replayNodes[j];\n          if (node[1] === childIndex) {\n            childIndex = node[2];\n            node = node[3];\n            task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };\n            try {\n              renderChildrenArray(request, task, children, -1);\n              if (\n                1 === task.replay.pendingTasks &&\n                0 < task.replay.nodes.length\n              )\n                throw Error(\n                  \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                );\n              task.replay.pendingTasks--;\n            } catch (x) {\n              if (\n                \"object\" === typeof x &&\n                null !== x &&\n                (x === SuspenseException || \"function\" === typeof x.then)\n              )\n                throw x;\n              task.replay.pendingTasks--;\n              var thrownInfo = getThrownInfo(task.componentStack);\n              children = task.blockedBoundary;\n              var error = x,\n                resumeSlots = node;\n              node = logRecoverableError(\n                request,\n                error,\n                thrownInfo,\n                task.debugTask\n              );\n              abortRemainingReplayNodes(\n                request,\n                children,\n                childIndex,\n                resumeSlots,\n                error,\n                node,\n                thrownInfo,\n                !1\n              );\n            }\n            task.replay = replay;\n            replayNodes.splice(j, 1);\n            break;\n          }\n        }\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        task.debugTask = previousDebugTask;\n        return;\n      }\n      replay = task.treeContext;\n      replayNodes = children.length;\n      if (\n        null !== task.replay &&\n        ((j = task.replay.slots), null !== j && \"object\" === typeof j)\n      ) {\n        for (childIndex = 0; childIndex < replayNodes; childIndex++)\n          (node = children[childIndex]),\n            (task.treeContext = pushTreeContext(\n              replay,\n              replayNodes,\n              childIndex\n            )),\n            (error = j[childIndex]),\n            \"number\" === typeof error\n              ? (resumeNode(request, task, error, node, childIndex),\n                delete j[childIndex])\n              : renderNode(request, task, node, childIndex);\n        task.treeContext = replay;\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        task.debugTask = previousDebugTask;\n        return;\n      }\n      for (j = 0; j < replayNodes; j++) {\n        childIndex = children[j];\n        resumeSlots = request;\n        node = task;\n        error = childIndex;\n        if (\n          null !== error &&\n          \"object\" === typeof error &&\n          (error.$$typeof === REACT_ELEMENT_TYPE ||\n            error.$$typeof === REACT_PORTAL_TYPE) &&\n          error._store &&\n          ((!error._store.validated && null == error.key) ||\n            2 === error._store.validated)\n        ) {\n          if (\"object\" !== typeof error._store)\n            throw Error(\n              \"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\"\n            );\n          error._store.validated = 1;\n          thrownInfo = resumeSlots.didWarnForKey;\n          null == thrownInfo &&\n            (thrownInfo = resumeSlots.didWarnForKey = new WeakSet());\n          resumeSlots = node.componentStack;\n          if (null !== resumeSlots && !thrownInfo.has(resumeSlots)) {\n            thrownInfo.add(resumeSlots);\n            var componentName = getComponentNameFromType(error.type);\n            thrownInfo = error._owner;\n            var parentOwner = resumeSlots.owner;\n            resumeSlots = \"\";\n            if (parentOwner && \"undefined\" !== typeof parentOwner.type) {\n              var name = getComponentNameFromType(parentOwner.type);\n              name &&\n                (resumeSlots =\n                  \"\\n\\nCheck the render method of `\" + name + \"`.\");\n            }\n            resumeSlots ||\n              (componentName &&\n                (resumeSlots =\n                  \"\\n\\nCheck the top-level render call using <\" +\n                  componentName +\n                  \">.\"));\n            componentName = \"\";\n            null != thrownInfo &&\n              parentOwner !== thrownInfo &&\n              ((parentOwner = null),\n              \"undefined\" !== typeof thrownInfo.type\n                ? (parentOwner = getComponentNameFromType(thrownInfo.type))\n                : \"string\" === typeof thrownInfo.name &&\n                  (parentOwner = thrownInfo.name),\n              parentOwner &&\n                (componentName =\n                  \" It was passed a child from \" + parentOwner + \".\"));\n            thrownInfo = node.componentStack;\n            node.componentStack = {\n              parent: node.componentStack,\n              type: error.type,\n              owner: error._owner,\n              stack: error._debugStack\n            };\n            console.error(\n              'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n              resumeSlots,\n              componentName\n            );\n            node.componentStack = thrownInfo;\n          }\n        }\n        task.treeContext = pushTreeContext(replay, replayNodes, j);\n        renderNode(request, task, childIndex, j);\n      }\n      task.treeContext = replay;\n      task.keyPath = prevKeyPath;\n      task.componentStack = previousComponentStack;\n      task.debugTask = previousDebugTask;\n    }\n    function untrackBoundary(request, boundary) {\n      request = request.trackedPostpones;\n      null !== request &&\n        ((boundary = boundary.trackedContentKeyPath),\n        null !== boundary &&\n          ((boundary = request.workingMap.get(boundary)),\n          void 0 !== boundary &&\n            ((boundary.length = 4), (boundary[2] = []), (boundary[3] = null))));\n    }\n    function spawnNewSuspendedReplayTask(request, task, thenableState) {\n      return createReplayTask(\n        request,\n        thenableState,\n        task.replay,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.componentStack,\n        task.isFallback,\n        emptyContextObject,\n        task.debugTask\n      );\n    }\n    function spawnNewSuspendedRenderTask(request, task, thenableState) {\n      var segment = task.blockedSegment,\n        newSegment = createPendingSegment(\n          request,\n          segment.chunks.length,\n          null,\n          task.formatContext,\n          segment.lastPushedText,\n          !0\n        );\n      segment.children.push(newSegment);\n      segment.lastPushedText = !1;\n      return createRenderTask(\n        request,\n        thenableState,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        newSegment,\n        task.blockedPreamble,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.componentStack,\n        task.isFallback,\n        emptyContextObject,\n        task.debugTask\n      );\n    }\n    function renderNode(request, task, node, childIndex) {\n      var previousFormatContext = task.formatContext,\n        previousContext = task.context,\n        previousKeyPath = task.keyPath,\n        previousTreeContext = task.treeContext,\n        previousComponentStack = task.componentStack,\n        previousDebugTask = task.debugTask,\n        segment = task.blockedSegment;\n      if (null === segment)\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue) {\n          if (\n            (resetHooksState(),\n            (node =\n              thrownValue === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue),\n            \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              childIndex = getThenableStateAfterSuspending();\n              request = spawnNewSuspendedReplayTask(\n                request,\n                task,\n                childIndex\n              ).ping;\n              node.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              node = getThenableStateAfterSuspending();\n              node = spawnNewSuspendedReplayTask(request, task, node);\n              request.pingedTasks.push(node);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      else {\n        var childrenLength = segment.children.length,\n          chunkLength = segment.chunks.length;\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue$3) {\n          if (\n            (resetHooksState(),\n            (segment.children.length = childrenLength),\n            (segment.chunks.length = chunkLength),\n            (node =\n              thrownValue$3 === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue$3),\n            \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              childIndex = getThenableStateAfterSuspending();\n              request = spawnNewSuspendedRenderTask(\n                request,\n                task,\n                childIndex\n              ).ping;\n              node.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              node = getThenableStateAfterSuspending();\n              node = spawnNewSuspendedRenderTask(request, task, node);\n              request.pingedTasks.push(node);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      }\n      task.formatContext = previousFormatContext;\n      task.context = previousContext;\n      task.keyPath = previousKeyPath;\n      task.treeContext = previousTreeContext;\n      switchContext(previousContext);\n      throw node;\n    }\n    function abortTaskSoft(task) {\n      var boundary = task.blockedBoundary;\n      task = task.blockedSegment;\n      null !== task && ((task.status = 3), finishedTask(this, boundary, task));\n    }\n    function abortRemainingReplayNodes(\n      request$jscomp$0,\n      boundary,\n      nodes,\n      slots,\n      error$jscomp$0,\n      errorDigest$jscomp$0,\n      errorInfo$jscomp$0,\n      aborted\n    ) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        if (4 === node.length)\n          abortRemainingReplayNodes(\n            request$jscomp$0,\n            boundary,\n            node[2],\n            node[3],\n            error$jscomp$0,\n            errorDigest$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          );\n        else {\n          var request = request$jscomp$0;\n          node = node[5];\n          var error = error$jscomp$0,\n            errorDigest = errorDigest$jscomp$0,\n            errorInfo = errorInfo$jscomp$0,\n            wasAborted = aborted,\n            resumedBoundary = createSuspenseBoundary(\n              request,\n              new Set(),\n              null,\n              null\n            );\n          resumedBoundary.parentFlushed = !0;\n          resumedBoundary.rootSegmentID = node;\n          resumedBoundary.status = CLIENT_RENDERED;\n          encodeErrorForBoundary(\n            resumedBoundary,\n            errorDigest,\n            error,\n            errorInfo,\n            wasAborted\n          );\n          resumedBoundary.parentFlushed &&\n            request.clientRenderedBoundaries.push(resumedBoundary);\n        }\n      }\n      nodes.length = 0;\n      if (null !== slots) {\n        if (null === boundary)\n          throw Error(\n            \"We should not have any resumable nodes in the shell. This is a bug in React.\"\n          );\n        boundary.status !== CLIENT_RENDERED &&\n          ((boundary.status = CLIENT_RENDERED),\n          encodeErrorForBoundary(\n            boundary,\n            errorDigest$jscomp$0,\n            error$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          ),\n          boundary.parentFlushed &&\n            request$jscomp$0.clientRenderedBoundaries.push(boundary));\n        if (\"object\" === typeof slots)\n          for (var index in slots) delete slots[index];\n      }\n    }\n    function abortTask(task, request, error) {\n      var boundary = task.blockedBoundary,\n        segment = task.blockedSegment;\n      if (null !== segment) {\n        if (6 === segment.status) return;\n        segment.status = 3;\n      }\n      segment = getThrownInfo(task.componentStack);\n      if (null === boundary) {\n        if (13 !== request.status && request.status !== CLOSED) {\n          boundary = task.replay;\n          if (null === boundary) {\n            logRecoverableError(request, error, segment, null);\n            fatalError(request, error, segment, null);\n            return;\n          }\n          boundary.pendingTasks--;\n          0 === boundary.pendingTasks &&\n            0 < boundary.nodes.length &&\n            ((task = logRecoverableError(request, error, segment, null)),\n            abortRemainingReplayNodes(\n              request,\n              null,\n              boundary.nodes,\n              boundary.slots,\n              error,\n              task,\n              segment,\n              !0\n            ));\n          request.pendingRootTasks--;\n          0 === request.pendingRootTasks && completeShell(request);\n        }\n      } else\n        boundary.pendingTasks--,\n          boundary.status !== CLIENT_RENDERED &&\n            ((boundary.status = CLIENT_RENDERED),\n            (task = logRecoverableError(request, error, segment, null)),\n            (boundary.status = CLIENT_RENDERED),\n            encodeErrorForBoundary(boundary, task, error, segment, !0),\n            untrackBoundary(request, boundary),\n            boundary.parentFlushed &&\n              request.clientRenderedBoundaries.push(boundary)),\n          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n            return abortTask(fallbackTask, request, error);\n          }),\n          boundary.fallbackAbortableTasks.clear();\n      request.allPendingTasks--;\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function safelyEmitEarlyPreloads(request, shellComplete) {\n      try {\n        var renderState = request.renderState,\n          onHeaders = renderState.onHeaders;\n        if (onHeaders) {\n          var headers = renderState.headers;\n          if (headers) {\n            renderState.headers = null;\n            var linkHeader = headers.preconnects;\n            headers.fontPreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.fontPreloads));\n            headers.highImagePreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.highImagePreloads));\n            if (!shellComplete) {\n              var queueIter = renderState.styles.values(),\n                queueStep = queueIter.next();\n              b: for (\n                ;\n                0 < headers.remainingCapacity && !queueStep.done;\n                queueStep = queueIter.next()\n              )\n                for (\n                  var sheetIter = queueStep.value.sheets.values(),\n                    sheetStep = sheetIter.next();\n                  0 < headers.remainingCapacity && !sheetStep.done;\n                  sheetStep = sheetIter.next()\n                ) {\n                  var sheet = sheetStep.value,\n                    props = sheet.props,\n                    key = props.href,\n                    props$jscomp$0 = sheet.props;\n                  var header = getPreloadAsHeader(\n                    props$jscomp$0.href,\n                    \"style\",\n                    {\n                      crossOrigin: props$jscomp$0.crossOrigin,\n                      integrity: props$jscomp$0.integrity,\n                      nonce: props$jscomp$0.nonce,\n                      type: props$jscomp$0.type,\n                      fetchPriority: props$jscomp$0.fetchPriority,\n                      referrerPolicy: props$jscomp$0.referrerPolicy,\n                      media: props$jscomp$0.media\n                    }\n                  );\n                  if (0 <= (headers.remainingCapacity -= header.length + 2))\n                    (renderState.resets.style[key] = PRELOAD_NO_CREDS),\n                      linkHeader && (linkHeader += \", \"),\n                      (linkHeader += header),\n                      (renderState.resets.style[key] =\n                        \"string\" === typeof props.crossOrigin ||\n                        \"string\" === typeof props.integrity\n                          ? [props.crossOrigin, props.integrity]\n                          : PRELOAD_NO_CREDS);\n                  else break b;\n                }\n            }\n            linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});\n          }\n        }\n      } catch (error) {\n        logRecoverableError(request, error, {}, null);\n      }\n    }\n    function completeShell(request) {\n      null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);\n      null === request.trackedPostpones && preparePreamble(request);\n      request.onShellError = noop;\n      request = request.onShellReady;\n      request();\n    }\n    function completeAll(request) {\n      safelyEmitEarlyPreloads(\n        request,\n        null === request.trackedPostpones\n          ? !0\n          : null === request.completedRootSegment ||\n              request.completedRootSegment.status !== POSTPONED\n      );\n      preparePreamble(request);\n      request = request.onAllReady;\n      request();\n    }\n    function queueCompletedSegment(boundary, segment) {\n      if (\n        0 === segment.chunks.length &&\n        1 === segment.children.length &&\n        null === segment.children[0].boundary &&\n        -1 === segment.children[0].id\n      ) {\n        var childSegment = segment.children[0];\n        childSegment.id = segment.id;\n        childSegment.parentFlushed = !0;\n        childSegment.status === COMPLETED &&\n          queueCompletedSegment(boundary, childSegment);\n      } else boundary.completedSegments.push(segment);\n    }\n    function finishedTask(request, boundary, segment) {\n      if (null === boundary) {\n        if (null !== segment && segment.parentFlushed) {\n          if (null !== request.completedRootSegment)\n            throw Error(\n              \"There can only be one root segment. This is a bug in React.\"\n            );\n          request.completedRootSegment = segment;\n        }\n        request.pendingRootTasks--;\n        0 === request.pendingRootTasks && completeShell(request);\n      } else\n        boundary.pendingTasks--,\n          boundary.status !== CLIENT_RENDERED &&\n            (0 === boundary.pendingTasks\n              ? (boundary.status === PENDING && (boundary.status = COMPLETED),\n                null !== segment &&\n                  segment.parentFlushed &&\n                  segment.status === COMPLETED &&\n                  queueCompletedSegment(boundary, segment),\n                boundary.parentFlushed &&\n                  request.completedBoundaries.push(boundary),\n                boundary.status === COMPLETED &&\n                  (boundary.fallbackAbortableTasks.forEach(\n                    abortTaskSoft,\n                    request\n                  ),\n                  boundary.fallbackAbortableTasks.clear(),\n                  0 === request.pendingRootTasks &&\n                    null === request.trackedPostpones &&\n                    null !== boundary.contentPreamble &&\n                    preparePreamble(request)))\n              : null !== segment &&\n                segment.parentFlushed &&\n                segment.status === COMPLETED &&\n                (queueCompletedSegment(boundary, segment),\n                1 === boundary.completedSegments.length &&\n                  boundary.parentFlushed &&\n                  request.partialBoundaries.push(boundary)));\n      request.allPendingTasks--;\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function performWork(request$jscomp$2) {\n      if (\n        request$jscomp$2.status !== CLOSED &&\n        13 !== request$jscomp$2.status\n      ) {\n        var prevContext = currentActiveSnapshot,\n          prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = HooksDispatcher;\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        var prevRequest = currentRequest;\n        currentRequest = request$jscomp$2;\n        var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;\n        var prevResumableState = currentResumableState;\n        currentResumableState = request$jscomp$2.resumableState;\n        try {\n          var pingedTasks = request$jscomp$2.pingedTasks,\n            i;\n          for (i = 0; i < pingedTasks.length; i++) {\n            var request = request$jscomp$2,\n              task = pingedTasks[i],\n              segment = task.blockedSegment;\n            if (null === segment) {\n              var prevTaskInDEV = void 0,\n                request$jscomp$0 = request;\n              request = task;\n              if (0 !== request.replay.pendingTasks) {\n                switchContext(request.context);\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = request;\n                try {\n                  \"number\" === typeof request.replay.slots\n                    ? resumeNode(\n                        request$jscomp$0,\n                        request,\n                        request.replay.slots,\n                        request.node,\n                        request.childIndex\n                      )\n                    : retryNode(request$jscomp$0, request);\n                  if (\n                    1 === request.replay.pendingTasks &&\n                    0 < request.replay.nodes.length\n                  )\n                    throw Error(\n                      \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                    );\n                  request.replay.pendingTasks--;\n                  request.abortSet.delete(request);\n                  finishedTask(request$jscomp$0, request.blockedBoundary, null);\n                } catch (thrownValue) {\n                  resetHooksState();\n                  var x =\n                    thrownValue === SuspenseException\n                      ? getSuspendedThenable()\n                      : thrownValue;\n                  if (\n                    \"object\" === typeof x &&\n                    null !== x &&\n                    \"function\" === typeof x.then\n                  ) {\n                    var ping = request.ping;\n                    x.then(ping, ping);\n                    request.thenableState = getThenableStateAfterSuspending();\n                  } else {\n                    request.replay.pendingTasks--;\n                    request.abortSet.delete(request);\n                    var errorInfo = getThrownInfo(request.componentStack),\n                      errorDigest = void 0,\n                      request$jscomp$1 = request$jscomp$0,\n                      boundary = request.blockedBoundary,\n                      error$jscomp$0 =\n                        12 === request$jscomp$0.status\n                          ? request$jscomp$0.fatalError\n                          : x,\n                      errorInfo$jscomp$0 = errorInfo,\n                      replayNodes = request.replay.nodes,\n                      resumeSlots = request.replay.slots;\n                    errorDigest = logRecoverableError(\n                      request$jscomp$1,\n                      error$jscomp$0,\n                      errorInfo$jscomp$0,\n                      request.debugTask\n                    );\n                    abortRemainingReplayNodes(\n                      request$jscomp$1,\n                      boundary,\n                      replayNodes,\n                      resumeSlots,\n                      error$jscomp$0,\n                      errorDigest,\n                      errorInfo$jscomp$0,\n                      !1\n                    );\n                    request$jscomp$0.pendingRootTasks--;\n                    0 === request$jscomp$0.pendingRootTasks &&\n                      completeShell(request$jscomp$0);\n                    request$jscomp$0.allPendingTasks--;\n                    0 === request$jscomp$0.allPendingTasks &&\n                      completeAll(request$jscomp$0);\n                  }\n                } finally {\n                  currentTaskInDEV = prevTaskInDEV;\n                }\n              }\n            } else if (\n              ((request$jscomp$0 = prevTaskInDEV = void 0),\n              (errorDigest = task),\n              (request$jscomp$1 = segment),\n              request$jscomp$1.status === PENDING)\n            ) {\n              request$jscomp$1.status = 6;\n              switchContext(errorDigest.context);\n              request$jscomp$0 = currentTaskInDEV;\n              currentTaskInDEV = errorDigest;\n              var childrenLength = request$jscomp$1.children.length,\n                chunkLength = request$jscomp$1.chunks.length;\n              try {\n                retryNode(request, errorDigest),\n                  pushSegmentFinale(\n                    request$jscomp$1.chunks,\n                    request.renderState,\n                    request$jscomp$1.lastPushedText,\n                    request$jscomp$1.textEmbedded\n                  ),\n                  errorDigest.abortSet.delete(errorDigest),\n                  (request$jscomp$1.status = COMPLETED),\n                  finishedTask(\n                    request,\n                    errorDigest.blockedBoundary,\n                    request$jscomp$1\n                  );\n              } catch (thrownValue) {\n                resetHooksState();\n                request$jscomp$1.children.length = childrenLength;\n                request$jscomp$1.chunks.length = chunkLength;\n                var x$jscomp$0 =\n                  thrownValue === SuspenseException\n                    ? getSuspendedThenable()\n                    : 12 === request.status\n                      ? request.fatalError\n                      : thrownValue;\n                if (\n                  \"object\" === typeof x$jscomp$0 &&\n                  null !== x$jscomp$0 &&\n                  \"function\" === typeof x$jscomp$0.then\n                ) {\n                  request$jscomp$1.status = PENDING;\n                  errorDigest.thenableState = getThenableStateAfterSuspending();\n                  var ping$jscomp$0 = errorDigest.ping;\n                  x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);\n                } else {\n                  var errorInfo$jscomp$1 = getThrownInfo(\n                    errorDigest.componentStack\n                  );\n                  errorDigest.abortSet.delete(errorDigest);\n                  request$jscomp$1.status = 4;\n                  var boundary$jscomp$0 = errorDigest.blockedBoundary,\n                    debugTask = errorDigest.debugTask;\n                  prevTaskInDEV = logRecoverableError(\n                    request,\n                    x$jscomp$0,\n                    errorInfo$jscomp$1,\n                    debugTask\n                  );\n                  null === boundary$jscomp$0\n                    ? fatalError(\n                        request,\n                        x$jscomp$0,\n                        errorInfo$jscomp$1,\n                        debugTask\n                      )\n                    : (boundary$jscomp$0.pendingTasks--,\n                      boundary$jscomp$0.status !== CLIENT_RENDERED &&\n                        ((boundary$jscomp$0.status = CLIENT_RENDERED),\n                        encodeErrorForBoundary(\n                          boundary$jscomp$0,\n                          prevTaskInDEV,\n                          x$jscomp$0,\n                          errorInfo$jscomp$1,\n                          !1\n                        ),\n                        untrackBoundary(request, boundary$jscomp$0),\n                        boundary$jscomp$0.parentFlushed &&\n                          request.clientRenderedBoundaries.push(\n                            boundary$jscomp$0\n                          ),\n                        0 === request.pendingRootTasks &&\n                          null === request.trackedPostpones &&\n                          null !== boundary$jscomp$0.contentPreamble &&\n                          preparePreamble(request)));\n                  request.allPendingTasks--;\n                  0 === request.allPendingTasks && completeAll(request);\n                }\n              } finally {\n                currentTaskInDEV = request$jscomp$0;\n              }\n            }\n          }\n          pingedTasks.splice(0, i);\n          null !== request$jscomp$2.destination &&\n            flushCompletedQueues(\n              request$jscomp$2,\n              request$jscomp$2.destination\n            );\n        } catch (error) {\n          (pingedTasks = {}),\n            logRecoverableError(request$jscomp$2, error, pingedTasks, null),\n            fatalError(request$jscomp$2, error, pingedTasks, null);\n        } finally {\n          (currentResumableState = prevResumableState),\n            (ReactSharedInternals.H = prevDispatcher),\n            (ReactSharedInternals.A = prevAsyncDispatcher),\n            (ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl),\n            prevDispatcher === HooksDispatcher && switchContext(prevContext),\n            (currentRequest = prevRequest);\n        }\n      }\n    }\n    function preparePreambleFromSubtree(\n      request,\n      segment,\n      collectedPreambleSegments\n    ) {\n      segment.preambleChildren.length &&\n        collectedPreambleSegments.push(segment.preambleChildren);\n      for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)\n        pendingPreambles =\n          preparePreambleFromSegment(\n            request,\n            segment.children[i],\n            collectedPreambleSegments\n          ) || pendingPreambles;\n      return pendingPreambles;\n    }\n    function preparePreambleFromSegment(\n      request,\n      segment,\n      collectedPreambleSegments\n    ) {\n      var boundary = segment.boundary;\n      if (null === boundary)\n        return preparePreambleFromSubtree(\n          request,\n          segment,\n          collectedPreambleSegments\n        );\n      var preamble = boundary.contentPreamble,\n        fallbackPreamble = boundary.fallbackPreamble;\n      if (null === preamble || null === fallbackPreamble) return !1;\n      switch (boundary.status) {\n        case COMPLETED:\n          hoistPreambleState(request.renderState, preamble);\n          segment = boundary.completedSegments[0];\n          if (!segment)\n            throw Error(\n              \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n            );\n          return preparePreambleFromSubtree(\n            request,\n            segment,\n            collectedPreambleSegments\n          );\n        case POSTPONED:\n          if (null !== request.trackedPostpones) return !0;\n        case CLIENT_RENDERED:\n          if (segment.status === COMPLETED)\n            return (\n              hoistPreambleState(request.renderState, fallbackPreamble),\n              preparePreambleFromSubtree(\n                request,\n                segment,\n                collectedPreambleSegments\n              )\n            );\n        default:\n          return !0;\n      }\n    }\n    function preparePreamble(request) {\n      if (\n        request.completedRootSegment &&\n        null === request.completedPreambleSegments\n      ) {\n        var collectedPreambleSegments = [],\n          hasPendingPreambles = preparePreambleFromSegment(\n            request,\n            request.completedRootSegment,\n            collectedPreambleSegments\n          ),\n          preamble = request.renderState.preamble;\n        if (\n          !1 === hasPendingPreambles ||\n          (preamble.headChunks && preamble.bodyChunks)\n        )\n          request.completedPreambleSegments = collectedPreambleSegments;\n      }\n    }\n    function flushSubtree(request, destination, segment, hoistableState) {\n      segment.parentFlushed = !0;\n      switch (segment.status) {\n        case PENDING:\n          segment.id = request.nextSegmentId++;\n        case POSTPONED:\n          return (\n            (hoistableState = segment.id),\n            (segment.lastPushedText = !1),\n            (segment.textEmbedded = !1),\n            (request = request.renderState),\n            destination.push(placeholder1),\n            destination.push(request.placeholderPrefix),\n            (request = hoistableState.toString(16)),\n            destination.push(request),\n            destination.push(placeholder2)\n          );\n        case COMPLETED:\n          segment.status = FLUSHED;\n          var r = !0,\n            chunks = segment.chunks,\n            chunkIdx = 0;\n          segment = segment.children;\n          for (var childIdx = 0; childIdx < segment.length; childIdx++) {\n            for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++)\n              destination.push(chunks[chunkIdx]);\n            r = flushSegment(request, destination, r, hoistableState);\n          }\n          for (; chunkIdx < chunks.length - 1; chunkIdx++)\n            destination.push(chunks[chunkIdx]);\n          chunkIdx < chunks.length && (r = destination.push(chunks[chunkIdx]));\n          return r;\n        default:\n          throw Error(\n            \"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\"\n          );\n      }\n    }\n    function flushSegment(request, destination, segment, hoistableState) {\n      var boundary = segment.boundary;\n      if (null === boundary)\n        return flushSubtree(request, destination, segment, hoistableState);\n      boundary.parentFlushed = !0;\n      if (boundary.status === CLIENT_RENDERED) {\n        if (!request.renderState.generateStaticMarkup) {\n          var errorDigest = boundary.errorDigest,\n            errorMessage = boundary.errorMessage,\n            errorStack = boundary.errorStack,\n            errorComponentStack = boundary.errorComponentStack;\n          destination.push(startClientRenderedSuspenseBoundary);\n          destination.push(clientRenderedSuspenseBoundaryError1);\n          errorDigest &&\n            (destination.push(clientRenderedSuspenseBoundaryError1A),\n            (errorDigest = escapeTextForBrowser(errorDigest)),\n            destination.push(errorDigest),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          errorMessage &&\n            (destination.push(clientRenderedSuspenseBoundaryError1B),\n            (errorMessage = escapeTextForBrowser(errorMessage)),\n            destination.push(errorMessage),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          errorStack &&\n            (destination.push(clientRenderedSuspenseBoundaryError1C),\n            (errorStack = escapeTextForBrowser(errorStack)),\n            destination.push(errorStack),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          errorComponentStack &&\n            (destination.push(clientRenderedSuspenseBoundaryError1D),\n            (errorComponentStack = escapeTextForBrowser(errorComponentStack)),\n            destination.push(errorComponentStack),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          destination.push(clientRenderedSuspenseBoundaryError2);\n        }\n        flushSubtree(request, destination, segment, hoistableState);\n        request.renderState.generateStaticMarkup\n          ? (destination = !0)\n          : ((request = boundary.fallbackPreamble) &&\n              writePreambleContribution(destination, request),\n            (destination = destination.push(endSuspenseBoundary)));\n        return destination;\n      }\n      if (boundary.status !== COMPLETED)\n        return (\n          boundary.status === PENDING &&\n            (boundary.rootSegmentID = request.nextSegmentId++),\n          0 < boundary.completedSegments.length &&\n            request.partialBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          hoistableState &&\n            ((boundary = boundary.fallbackState),\n            boundary.styles.forEach(hoistStyleQueueDependency, hoistableState),\n            boundary.stylesheets.forEach(\n              hoistStylesheetDependency,\n              hoistableState\n            )),\n          flushSubtree(request, destination, segment, hoistableState),\n          destination.push(endSuspenseBoundary)\n        );\n      if (boundary.byteSize > request.progressiveChunkSize)\n        return (\n          (boundary.rootSegmentID = request.nextSegmentId++),\n          request.completedBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          flushSubtree(request, destination, segment, hoistableState),\n          destination.push(endSuspenseBoundary)\n        );\n      hoistableState &&\n        ((segment = boundary.contentState),\n        segment.styles.forEach(hoistStyleQueueDependency, hoistableState),\n        segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));\n      request.renderState.generateStaticMarkup ||\n        destination.push(startCompletedSuspenseBoundary);\n      segment = boundary.completedSegments;\n      if (1 !== segment.length)\n        throw Error(\n          \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n        );\n      flushSegment(request, destination, segment[0], hoistableState);\n      request.renderState.generateStaticMarkup\n        ? (destination = !0)\n        : ((request = boundary.contentPreamble) &&\n            writePreambleContribution(destination, request),\n          (destination = destination.push(endSuspenseBoundary)));\n      return destination;\n    }\n    function flushSegmentContainer(\n      request,\n      destination,\n      segment,\n      hoistableState\n    ) {\n      writeStartSegment(\n        destination,\n        request.renderState,\n        segment.parentFormatContext,\n        segment.id\n      );\n      flushSegment(request, destination, segment, hoistableState);\n      return writeEndSegment(destination, segment.parentFormatContext);\n    }\n    function flushCompletedBoundary(request, destination, boundary) {\n      for (\n        var completedSegments = boundary.completedSegments, i = 0;\n        i < completedSegments.length;\n        i++\n      )\n        flushPartiallyCompletedSegment(\n          request,\n          destination,\n          boundary,\n          completedSegments[i]\n        );\n      completedSegments.length = 0;\n      writeHoistablesForBoundary(\n        destination,\n        boundary.contentState,\n        request.renderState\n      );\n      completedSegments = request.resumableState;\n      request = request.renderState;\n      i = boundary.rootSegmentID;\n      boundary = boundary.contentState;\n      var requiresStyleInsertion = request.stylesToHoist;\n      request.stylesToHoist = !1;\n      destination.push(request.startInlineScript);\n      requiresStyleInsertion\n        ? (completedSegments.instructions & SentCompleteBoundaryFunction) ===\n          NothingSent\n          ? ((completedSegments.instructions =\n              completedSegments.instructions |\n              SentStyleInsertionFunction |\n              SentCompleteBoundaryFunction),\n            destination.push(completeBoundaryWithStylesScript1FullBoth))\n          : (completedSegments.instructions & SentStyleInsertionFunction) ===\n              NothingSent\n            ? ((completedSegments.instructions |= SentStyleInsertionFunction),\n              destination.push(completeBoundaryWithStylesScript1FullPartial))\n            : destination.push(completeBoundaryWithStylesScript1Partial)\n        : (completedSegments.instructions & SentCompleteBoundaryFunction) ===\n            NothingSent\n          ? ((completedSegments.instructions |= SentCompleteBoundaryFunction),\n            destination.push(completeBoundaryScript1Full))\n          : destination.push(completeBoundaryScript1Partial);\n      completedSegments = i.toString(16);\n      destination.push(request.boundaryPrefix);\n      destination.push(completedSegments);\n      destination.push(completeBoundaryScript2);\n      destination.push(request.segmentPrefix);\n      destination.push(completedSegments);\n      requiresStyleInsertion\n        ? (destination.push(completeBoundaryScript3a),\n          writeStyleResourceDependenciesInJS(destination, boundary))\n        : destination.push(completeBoundaryScript3b);\n      boundary = destination.push(completeBoundaryScriptEnd);\n      return writeBootstrap(destination, request) && boundary;\n    }\n    function flushPartiallyCompletedSegment(\n      request,\n      destination,\n      boundary,\n      segment\n    ) {\n      if (segment.status === FLUSHED) return !0;\n      var hoistableState = boundary.contentState,\n        segmentID = segment.id;\n      if (-1 === segmentID) {\n        if (-1 === (segment.id = boundary.rootSegmentID))\n          throw Error(\n            \"A root segment ID must have been assigned by now. This is a bug in React.\"\n          );\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      }\n      if (segmentID === boundary.rootSegmentID)\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      flushSegmentContainer(request, destination, segment, hoistableState);\n      boundary = request.resumableState;\n      request = request.renderState;\n      destination.push(request.startInlineScript);\n      (boundary.instructions & SentCompleteSegmentFunction) === NothingSent\n        ? ((boundary.instructions |= SentCompleteSegmentFunction),\n          destination.push(completeSegmentScript1Full))\n        : destination.push(completeSegmentScript1Partial);\n      destination.push(request.segmentPrefix);\n      segmentID = segmentID.toString(16);\n      destination.push(segmentID);\n      destination.push(completeSegmentScript2);\n      destination.push(request.placeholderPrefix);\n      destination.push(segmentID);\n      destination = destination.push(completeSegmentScriptEnd);\n      return destination;\n    }\n    function flushCompletedQueues(request, destination) {\n      try {\n        if (!(0 < request.pendingRootTasks)) {\n          var i,\n            completedRootSegment = request.completedRootSegment;\n          if (null !== completedRootSegment) {\n            if (completedRootSegment.status === POSTPONED) return;\n            var completedPreambleSegments = request.completedPreambleSegments;\n            if (null === completedPreambleSegments) return;\n            var renderState = request.renderState,\n              preamble = renderState.preamble,\n              htmlChunks = preamble.htmlChunks,\n              headChunks = preamble.headChunks,\n              i$jscomp$0;\n            if (htmlChunks) {\n              for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)\n                destination.push(htmlChunks[i$jscomp$0]);\n              if (headChunks)\n                for (\n                  i$jscomp$0 = 0;\n                  i$jscomp$0 < headChunks.length;\n                  i$jscomp$0++\n                )\n                  destination.push(headChunks[i$jscomp$0]);\n              else {\n                var chunk = startChunkForTag(\"head\");\n                destination.push(chunk);\n                destination.push(endOfStartTag);\n              }\n            } else if (headChunks)\n              for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)\n                destination.push(headChunks[i$jscomp$0]);\n            var charsetChunks = renderState.charsetChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < charsetChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(charsetChunks[i$jscomp$0]);\n            charsetChunks.length = 0;\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var viewportChunks = renderState.viewportChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < viewportChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(viewportChunks[i$jscomp$0]);\n            viewportChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear();\n            renderState.styles.forEach(flushStylesInPreamble, destination);\n            var importMapChunks = renderState.importMapChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < importMapChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(importMapChunks[i$jscomp$0]);\n            importMapChunks.length = 0;\n            renderState.bootstrapScripts.forEach(flushResource, destination);\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear();\n            var hoistableChunks = renderState.hoistableChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < hoistableChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(hoistableChunks[i$jscomp$0]);\n            for (\n              renderState = hoistableChunks.length = 0;\n              renderState < completedPreambleSegments.length;\n              renderState++\n            ) {\n              var segments = completedPreambleSegments[renderState];\n              for (preamble = 0; preamble < segments.length; preamble++)\n                flushSegment(request, destination, segments[preamble], null);\n            }\n            var preamble$jscomp$0 = request.renderState.preamble,\n              headChunks$jscomp$0 = preamble$jscomp$0.headChunks;\n            if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {\n              var chunk$jscomp$0 = endChunkForTag(\"head\");\n              destination.push(chunk$jscomp$0);\n            }\n            var bodyChunks = preamble$jscomp$0.bodyChunks;\n            if (bodyChunks)\n              for (\n                completedPreambleSegments = 0;\n                completedPreambleSegments < bodyChunks.length;\n                completedPreambleSegments++\n              )\n                destination.push(bodyChunks[completedPreambleSegments]);\n            flushSegment(request, destination, completedRootSegment, null);\n            request.completedRootSegment = null;\n            writeBootstrap(destination, request.renderState);\n          }\n          var renderState$jscomp$0 = request.renderState;\n          completedRootSegment = 0;\n          var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < viewportChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            destination.push(viewportChunks$jscomp$0[completedRootSegment]);\n          viewportChunks$jscomp$0.length = 0;\n          renderState$jscomp$0.preconnects.forEach(flushResource, destination);\n          renderState$jscomp$0.preconnects.clear();\n          renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);\n          renderState$jscomp$0.fontPreloads.clear();\n          renderState$jscomp$0.highImagePreloads.forEach(\n            flushResource,\n            destination\n          );\n          renderState$jscomp$0.highImagePreloads.clear();\n          renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);\n          renderState$jscomp$0.scripts.forEach(flushResource, destination);\n          renderState$jscomp$0.scripts.clear();\n          renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);\n          renderState$jscomp$0.bulkPreloads.clear();\n          var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < hoistableChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            destination.push(hoistableChunks$jscomp$0[completedRootSegment]);\n          hoistableChunks$jscomp$0.length = 0;\n          var clientRenderedBoundaries = request.clientRenderedBoundaries;\n          for (i = 0; i < clientRenderedBoundaries.length; i++) {\n            var boundary = clientRenderedBoundaries[i];\n            renderState$jscomp$0 = destination;\n            var resumableState = request.resumableState,\n              renderState$jscomp$1 = request.renderState,\n              id = boundary.rootSegmentID,\n              errorDigest = boundary.errorDigest,\n              errorMessage = boundary.errorMessage,\n              errorStack = boundary.errorStack,\n              errorComponentStack = boundary.errorComponentStack;\n            renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript);\n            (resumableState.instructions & SentClientRenderFunction) ===\n            NothingSent\n              ? ((resumableState.instructions |= SentClientRenderFunction),\n                renderState$jscomp$0.push(clientRenderScript1Full))\n              : renderState$jscomp$0.push(clientRenderScript1Partial);\n            renderState$jscomp$0.push(renderState$jscomp$1.boundaryPrefix);\n            var chunk$jscomp$1 = id.toString(16);\n            renderState$jscomp$0.push(chunk$jscomp$1);\n            renderState$jscomp$0.push(clientRenderScript1A);\n            if (\n              errorDigest ||\n              errorMessage ||\n              errorStack ||\n              errorComponentStack\n            ) {\n              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(\n                errorDigest || \"\"\n              );\n              renderState$jscomp$0.push(chunk$jscomp$2);\n            }\n            if (errorMessage || errorStack || errorComponentStack) {\n              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$3 = escapeJSStringsForInstructionScripts(\n                errorMessage || \"\"\n              );\n              renderState$jscomp$0.push(chunk$jscomp$3);\n            }\n            if (errorStack || errorComponentStack) {\n              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$4 = escapeJSStringsForInstructionScripts(\n                errorStack || \"\"\n              );\n              renderState$jscomp$0.push(chunk$jscomp$4);\n            }\n            if (errorComponentStack) {\n              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$5 =\n                escapeJSStringsForInstructionScripts(errorComponentStack);\n              renderState$jscomp$0.push(chunk$jscomp$5);\n            }\n            var JSCompiler_inline_result = renderState$jscomp$0.push(\n              clientRenderScriptEnd\n            );\n            if (!JSCompiler_inline_result) {\n              request.destination = null;\n              i++;\n              clientRenderedBoundaries.splice(0, i);\n              return;\n            }\n          }\n          clientRenderedBoundaries.splice(0, i);\n          var completedBoundaries = request.completedBoundaries;\n          for (i = 0; i < completedBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(\n                request,\n                destination,\n                completedBoundaries[i]\n              )\n            ) {\n              request.destination = null;\n              i++;\n              completedBoundaries.splice(0, i);\n              return;\n            }\n          completedBoundaries.splice(0, i);\n          var partialBoundaries = request.partialBoundaries;\n          for (i = 0; i < partialBoundaries.length; i++) {\n            a: {\n              clientRenderedBoundaries = request;\n              boundary = destination;\n              var boundary$jscomp$0 = partialBoundaries[i],\n                completedSegments = boundary$jscomp$0.completedSegments;\n              for (\n                JSCompiler_inline_result = 0;\n                JSCompiler_inline_result < completedSegments.length;\n                JSCompiler_inline_result++\n              )\n                if (\n                  !flushPartiallyCompletedSegment(\n                    clientRenderedBoundaries,\n                    boundary,\n                    boundary$jscomp$0,\n                    completedSegments[JSCompiler_inline_result]\n                  )\n                ) {\n                  JSCompiler_inline_result++;\n                  completedSegments.splice(0, JSCompiler_inline_result);\n                  var JSCompiler_inline_result$jscomp$0 = !1;\n                  break a;\n                }\n              completedSegments.splice(0, JSCompiler_inline_result);\n              JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n                boundary,\n                boundary$jscomp$0.contentState,\n                clientRenderedBoundaries.renderState\n              );\n            }\n            if (!JSCompiler_inline_result$jscomp$0) {\n              request.destination = null;\n              i++;\n              partialBoundaries.splice(0, i);\n              return;\n            }\n          }\n          partialBoundaries.splice(0, i);\n          var largeBoundaries = request.completedBoundaries;\n          for (i = 0; i < largeBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(request, destination, largeBoundaries[i])\n            ) {\n              request.destination = null;\n              i++;\n              largeBoundaries.splice(0, i);\n              return;\n            }\n          largeBoundaries.splice(0, i);\n        }\n      } finally {\n        0 === request.allPendingTasks &&\n          0 === request.pingedTasks.length &&\n          0 === request.clientRenderedBoundaries.length &&\n          0 === request.completedBoundaries.length &&\n          ((request.flushScheduled = !1),\n          (i = request.resumableState),\n          i.hasBody &&\n            ((partialBoundaries = endChunkForTag(\"body\")),\n            destination.push(partialBoundaries)),\n          i.hasHtml && ((i = endChunkForTag(\"html\")), destination.push(i)),\n          0 !== request.abortableTasks.size &&\n            console.error(\n              \"There was still abortable task at the root when we closed. This is a bug in React.\"\n            ),\n          (request.status = CLOSED),\n          destination.push(null),\n          (request.destination = null));\n      }\n    }\n    function startWork(request) {\n      request.flushScheduled = null !== request.destination;\n      performWork(request);\n      10 === request.status && (request.status = 11);\n      null === request.trackedPostpones &&\n        safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);\n    }\n    function enqueueFlush(request) {\n      if (\n        !1 === request.flushScheduled &&\n        0 === request.pingedTasks.length &&\n        null !== request.destination\n      ) {\n        request.flushScheduled = !0;\n        var destination = request.destination;\n        destination\n          ? flushCompletedQueues(request, destination)\n          : (request.flushScheduled = !1);\n      }\n    }\n    function startFlowing(request, destination) {\n      if (13 === request.status)\n        (request.status = CLOSED), destination.destroy(request.fatalError);\n      else if (request.status !== CLOSED && null === request.destination) {\n        request.destination = destination;\n        try {\n          flushCompletedQueues(request, destination);\n        } catch (error) {\n          (destination = {}),\n            logRecoverableError(request, error, destination, null),\n            fatalError(request, error, destination, null);\n        }\n      }\n    }\n    function abort(request, reason) {\n      if (11 === request.status || 10 === request.status) request.status = 12;\n      try {\n        var abortableTasks = request.abortableTasks;\n        if (0 < abortableTasks.size) {\n          var error =\n            void 0 === reason\n              ? Error(\"The render was aborted by the server without a reason.\")\n              : \"object\" === typeof reason &&\n                  null !== reason &&\n                  \"function\" === typeof reason.then\n                ? Error(\"The render was aborted by the server with a promise.\")\n                : reason;\n          request.fatalError = error;\n          abortableTasks.forEach(function (task) {\n            return abortTask(task, request, error);\n          });\n          abortableTasks.clear();\n        }\n        null !== request.destination &&\n          flushCompletedQueues(request, request.destination);\n      } catch (error$4) {\n        (reason = {}),\n          logRecoverableError(request, error$4, reason, null),\n          fatalError(request, error$4, reason, null);\n      }\n    }\n    function onError() {}\n    function renderToStringImpl(\n      children,\n      options,\n      generateStaticMarkup,\n      abortReason\n    ) {\n      var didFatal = !1,\n        fatalError = null,\n        result = \"\",\n        readyToStream = !1;\n      options = createResumableState(\n        options ? options.identifierPrefix : void 0\n      );\n      children = createRequest(\n        children,\n        options,\n        createRenderState(options, generateStaticMarkup),\n        createFormatContext(ROOT_HTML_MODE, null, 0),\n        Infinity,\n        onError,\n        void 0,\n        function () {\n          readyToStream = !0;\n        },\n        void 0,\n        void 0,\n        void 0\n      );\n      startWork(children);\n      abort(children, abortReason);\n      startFlowing(children, {\n        push: function (chunk) {\n          null !== chunk && (result += chunk);\n          return !0;\n        },\n        destroy: function (error) {\n          didFatal = !0;\n          fatalError = error;\n        }\n      });\n      if (didFatal && fatalError !== abortReason) throw fatalError;\n      if (!readyToStream)\n        throw Error(\n          \"A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.\"\n        );\n      return result;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(rsc)/./node_modules/next/dist/compiled/react/index.js\"),\n      ReactDOM = __webpack_require__(/*! next/dist/compiled/react-dom */ \"(rsc)/./node_modules/next/dist/compiled/react-dom/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_SCOPE_TYPE = Symbol.for(\"react.scope\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\"),\n      REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"),\n      REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      isArrayImpl = Array.isArray,\n      jsxPropsParents = new WeakMap(),\n      jsxChildrenParents = new WeakMap(),\n      CLIENT_REFERENCE_TAG = Symbol.for(\"react.client.reference\"),\n      assign = Object.assign,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      VALID_ATTRIBUTE_NAME_REGEX = RegExp(\n        \"^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      illegalAttributeNameCache = {},\n      validatedAttributeNameCache = {},\n      unitlessNumbers = new Set(\n        \"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\n          \" \"\n        )\n      ),\n      aliases = new Map([\n        [\"acceptCharset\", \"accept-charset\"],\n        [\"htmlFor\", \"for\"],\n        [\"httpEquiv\", \"http-equiv\"],\n        [\"crossOrigin\", \"crossorigin\"],\n        [\"accentHeight\", \"accent-height\"],\n        [\"alignmentBaseline\", \"alignment-baseline\"],\n        [\"arabicForm\", \"arabic-form\"],\n        [\"baselineShift\", \"baseline-shift\"],\n        [\"capHeight\", \"cap-height\"],\n        [\"clipPath\", \"clip-path\"],\n        [\"clipRule\", \"clip-rule\"],\n        [\"colorInterpolation\", \"color-interpolation\"],\n        [\"colorInterpolationFilters\", \"color-interpolation-filters\"],\n        [\"colorProfile\", \"color-profile\"],\n        [\"colorRendering\", \"color-rendering\"],\n        [\"dominantBaseline\", \"dominant-baseline\"],\n        [\"enableBackground\", \"enable-background\"],\n        [\"fillOpacity\", \"fill-opacity\"],\n        [\"fillRule\", \"fill-rule\"],\n        [\"floodColor\", \"flood-color\"],\n        [\"floodOpacity\", \"flood-opacity\"],\n        [\"fontFamily\", \"font-family\"],\n        [\"fontSize\", \"font-size\"],\n        [\"fontSizeAdjust\", \"font-size-adjust\"],\n        [\"fontStretch\", \"font-stretch\"],\n        [\"fontStyle\", \"font-style\"],\n        [\"fontVariant\", \"font-variant\"],\n        [\"fontWeight\", \"font-weight\"],\n        [\"glyphName\", \"glyph-name\"],\n        [\"glyphOrientationHorizontal\", \"glyph-orientation-horizontal\"],\n        [\"glyphOrientationVertical\", \"glyph-orientation-vertical\"],\n        [\"horizAdvX\", \"horiz-adv-x\"],\n        [\"horizOriginX\", \"horiz-origin-x\"],\n        [\"imageRendering\", \"image-rendering\"],\n        [\"letterSpacing\", \"letter-spacing\"],\n        [\"lightingColor\", \"lighting-color\"],\n        [\"markerEnd\", \"marker-end\"],\n        [\"markerMid\", \"marker-mid\"],\n        [\"markerStart\", \"marker-start\"],\n        [\"overlinePosition\", \"overline-position\"],\n        [\"overlineThickness\", \"overline-thickness\"],\n        [\"paintOrder\", \"paint-order\"],\n        [\"panose-1\", \"panose-1\"],\n        [\"pointerEvents\", \"pointer-events\"],\n        [\"renderingIntent\", \"rendering-intent\"],\n        [\"shapeRendering\", \"shape-rendering\"],\n        [\"stopColor\", \"stop-color\"],\n        [\"stopOpacity\", \"stop-opacity\"],\n        [\"strikethroughPosition\", \"strikethrough-position\"],\n        [\"strikethroughThickness\", \"strikethrough-thickness\"],\n        [\"strokeDasharray\", \"stroke-dasharray\"],\n        [\"strokeDashoffset\", \"stroke-dashoffset\"],\n        [\"strokeLinecap\", \"stroke-linecap\"],\n        [\"strokeLinejoin\", \"stroke-linejoin\"],\n        [\"strokeMiterlimit\", \"stroke-miterlimit\"],\n        [\"strokeOpacity\", \"stroke-opacity\"],\n        [\"strokeWidth\", \"stroke-width\"],\n        [\"textAnchor\", \"text-anchor\"],\n        [\"textDecoration\", \"text-decoration\"],\n        [\"textRendering\", \"text-rendering\"],\n        [\"transformOrigin\", \"transform-origin\"],\n        [\"underlinePosition\", \"underline-position\"],\n        [\"underlineThickness\", \"underline-thickness\"],\n        [\"unicodeBidi\", \"unicode-bidi\"],\n        [\"unicodeRange\", \"unicode-range\"],\n        [\"unitsPerEm\", \"units-per-em\"],\n        [\"vAlphabetic\", \"v-alphabetic\"],\n        [\"vHanging\", \"v-hanging\"],\n        [\"vIdeographic\", \"v-ideographic\"],\n        [\"vMathematical\", \"v-mathematical\"],\n        [\"vectorEffect\", \"vector-effect\"],\n        [\"vertAdvY\", \"vert-adv-y\"],\n        [\"vertOriginX\", \"vert-origin-x\"],\n        [\"vertOriginY\", \"vert-origin-y\"],\n        [\"wordSpacing\", \"word-spacing\"],\n        [\"writingMode\", \"writing-mode\"],\n        [\"xmlnsXlink\", \"xmlns:xlink\"],\n        [\"xHeight\", \"x-height\"]\n      ]),\n      hasReadOnlyValue = {\n        button: !0,\n        checkbox: !0,\n        image: !0,\n        hidden: !0,\n        radio: !0,\n        reset: !0,\n        submit: !0\n      },\n      ariaProperties = {\n        \"aria-current\": 0,\n        \"aria-description\": 0,\n        \"aria-details\": 0,\n        \"aria-disabled\": 0,\n        \"aria-hidden\": 0,\n        \"aria-invalid\": 0,\n        \"aria-keyshortcuts\": 0,\n        \"aria-label\": 0,\n        \"aria-roledescription\": 0,\n        \"aria-autocomplete\": 0,\n        \"aria-checked\": 0,\n        \"aria-expanded\": 0,\n        \"aria-haspopup\": 0,\n        \"aria-level\": 0,\n        \"aria-modal\": 0,\n        \"aria-multiline\": 0,\n        \"aria-multiselectable\": 0,\n        \"aria-orientation\": 0,\n        \"aria-placeholder\": 0,\n        \"aria-pressed\": 0,\n        \"aria-readonly\": 0,\n        \"aria-required\": 0,\n        \"aria-selected\": 0,\n        \"aria-sort\": 0,\n        \"aria-valuemax\": 0,\n        \"aria-valuemin\": 0,\n        \"aria-valuenow\": 0,\n        \"aria-valuetext\": 0,\n        \"aria-atomic\": 0,\n        \"aria-busy\": 0,\n        \"aria-live\": 0,\n        \"aria-relevant\": 0,\n        \"aria-dropeffect\": 0,\n        \"aria-grabbed\": 0,\n        \"aria-activedescendant\": 0,\n        \"aria-colcount\": 0,\n        \"aria-colindex\": 0,\n        \"aria-colspan\": 0,\n        \"aria-controls\": 0,\n        \"aria-describedby\": 0,\n        \"aria-errormessage\": 0,\n        \"aria-flowto\": 0,\n        \"aria-labelledby\": 0,\n        \"aria-owns\": 0,\n        \"aria-posinset\": 0,\n        \"aria-rowcount\": 0,\n        \"aria-rowindex\": 0,\n        \"aria-rowspan\": 0,\n        \"aria-setsize\": 0\n      },\n      warnedProperties$1 = {},\n      rARIA$1 = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel$1 = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      didWarnValueNull = !1,\n      possibleStandardNames = {\n        accept: \"accept\",\n        acceptcharset: \"acceptCharset\",\n        \"accept-charset\": \"acceptCharset\",\n        accesskey: \"accessKey\",\n        action: \"action\",\n        allowfullscreen: \"allowFullScreen\",\n        alt: \"alt\",\n        as: \"as\",\n        async: \"async\",\n        autocapitalize: \"autoCapitalize\",\n        autocomplete: \"autoComplete\",\n        autocorrect: \"autoCorrect\",\n        autofocus: \"autoFocus\",\n        autoplay: \"autoPlay\",\n        autosave: \"autoSave\",\n        capture: \"capture\",\n        cellpadding: \"cellPadding\",\n        cellspacing: \"cellSpacing\",\n        challenge: \"challenge\",\n        charset: \"charSet\",\n        checked: \"checked\",\n        children: \"children\",\n        cite: \"cite\",\n        class: \"className\",\n        classid: \"classID\",\n        classname: \"className\",\n        cols: \"cols\",\n        colspan: \"colSpan\",\n        content: \"content\",\n        contenteditable: \"contentEditable\",\n        contextmenu: \"contextMenu\",\n        controls: \"controls\",\n        controlslist: \"controlsList\",\n        coords: \"coords\",\n        crossorigin: \"crossOrigin\",\n        dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n        data: \"data\",\n        datetime: \"dateTime\",\n        default: \"default\",\n        defaultchecked: \"defaultChecked\",\n        defaultvalue: \"defaultValue\",\n        defer: \"defer\",\n        dir: \"dir\",\n        disabled: \"disabled\",\n        disablepictureinpicture: \"disablePictureInPicture\",\n        disableremoteplayback: \"disableRemotePlayback\",\n        download: \"download\",\n        draggable: \"draggable\",\n        enctype: \"encType\",\n        enterkeyhint: \"enterKeyHint\",\n        fetchpriority: \"fetchPriority\",\n        for: \"htmlFor\",\n        form: \"form\",\n        formmethod: \"formMethod\",\n        formaction: \"formAction\",\n        formenctype: \"formEncType\",\n        formnovalidate: \"formNoValidate\",\n        formtarget: \"formTarget\",\n        frameborder: \"frameBorder\",\n        headers: \"headers\",\n        height: \"height\",\n        hidden: \"hidden\",\n        high: \"high\",\n        href: \"href\",\n        hreflang: \"hrefLang\",\n        htmlfor: \"htmlFor\",\n        httpequiv: \"httpEquiv\",\n        \"http-equiv\": \"httpEquiv\",\n        icon: \"icon\",\n        id: \"id\",\n        imagesizes: \"imageSizes\",\n        imagesrcset: \"imageSrcSet\",\n        inert: \"inert\",\n        innerhtml: \"innerHTML\",\n        inputmode: \"inputMode\",\n        integrity: \"integrity\",\n        is: \"is\",\n        itemid: \"itemID\",\n        itemprop: \"itemProp\",\n        itemref: \"itemRef\",\n        itemscope: \"itemScope\",\n        itemtype: \"itemType\",\n        keyparams: \"keyParams\",\n        keytype: \"keyType\",\n        kind: \"kind\",\n        label: \"label\",\n        lang: \"lang\",\n        list: \"list\",\n        loop: \"loop\",\n        low: \"low\",\n        manifest: \"manifest\",\n        marginwidth: \"marginWidth\",\n        marginheight: \"marginHeight\",\n        max: \"max\",\n        maxlength: \"maxLength\",\n        media: \"media\",\n        mediagroup: \"mediaGroup\",\n        method: \"method\",\n        min: \"min\",\n        minlength: \"minLength\",\n        multiple: \"multiple\",\n        muted: \"muted\",\n        name: \"name\",\n        nomodule: \"noModule\",\n        nonce: \"nonce\",\n        novalidate: \"noValidate\",\n        open: \"open\",\n        optimum: \"optimum\",\n        pattern: \"pattern\",\n        placeholder: \"placeholder\",\n        playsinline: \"playsInline\",\n        poster: \"poster\",\n        preload: \"preload\",\n        profile: \"profile\",\n        radiogroup: \"radioGroup\",\n        readonly: \"readOnly\",\n        referrerpolicy: \"referrerPolicy\",\n        rel: \"rel\",\n        required: \"required\",\n        reversed: \"reversed\",\n        role: \"role\",\n        rows: \"rows\",\n        rowspan: \"rowSpan\",\n        sandbox: \"sandbox\",\n        scope: \"scope\",\n        scoped: \"scoped\",\n        scrolling: \"scrolling\",\n        seamless: \"seamless\",\n        selected: \"selected\",\n        shape: \"shape\",\n        size: \"size\",\n        sizes: \"sizes\",\n        span: \"span\",\n        spellcheck: \"spellCheck\",\n        src: \"src\",\n        srcdoc: \"srcDoc\",\n        srclang: \"srcLang\",\n        srcset: \"srcSet\",\n        start: \"start\",\n        step: \"step\",\n        style: \"style\",\n        summary: \"summary\",\n        tabindex: \"tabIndex\",\n        target: \"target\",\n        title: \"title\",\n        type: \"type\",\n        usemap: \"useMap\",\n        value: \"value\",\n        width: \"width\",\n        wmode: \"wmode\",\n        wrap: \"wrap\",\n        about: \"about\",\n        accentheight: \"accentHeight\",\n        \"accent-height\": \"accentHeight\",\n        accumulate: \"accumulate\",\n        additive: \"additive\",\n        alignmentbaseline: \"alignmentBaseline\",\n        \"alignment-baseline\": \"alignmentBaseline\",\n        allowreorder: \"allowReorder\",\n        alphabetic: \"alphabetic\",\n        amplitude: \"amplitude\",\n        arabicform: \"arabicForm\",\n        \"arabic-form\": \"arabicForm\",\n        ascent: \"ascent\",\n        attributename: \"attributeName\",\n        attributetype: \"attributeType\",\n        autoreverse: \"autoReverse\",\n        azimuth: \"azimuth\",\n        basefrequency: \"baseFrequency\",\n        baselineshift: \"baselineShift\",\n        \"baseline-shift\": \"baselineShift\",\n        baseprofile: \"baseProfile\",\n        bbox: \"bbox\",\n        begin: \"begin\",\n        bias: \"bias\",\n        by: \"by\",\n        calcmode: \"calcMode\",\n        capheight: \"capHeight\",\n        \"cap-height\": \"capHeight\",\n        clip: \"clip\",\n        clippath: \"clipPath\",\n        \"clip-path\": \"clipPath\",\n        clippathunits: \"clipPathUnits\",\n        cliprule: \"clipRule\",\n        \"clip-rule\": \"clipRule\",\n        color: \"color\",\n        colorinterpolation: \"colorInterpolation\",\n        \"color-interpolation\": \"colorInterpolation\",\n        colorinterpolationfilters: \"colorInterpolationFilters\",\n        \"color-interpolation-filters\": \"colorInterpolationFilters\",\n        colorprofile: \"colorProfile\",\n        \"color-profile\": \"colorProfile\",\n        colorrendering: \"colorRendering\",\n        \"color-rendering\": \"colorRendering\",\n        contentscripttype: \"contentScriptType\",\n        contentstyletype: \"contentStyleType\",\n        cursor: \"cursor\",\n        cx: \"cx\",\n        cy: \"cy\",\n        d: \"d\",\n        datatype: \"datatype\",\n        decelerate: \"decelerate\",\n        descent: \"descent\",\n        diffuseconstant: \"diffuseConstant\",\n        direction: \"direction\",\n        display: \"display\",\n        divisor: \"divisor\",\n        dominantbaseline: \"dominantBaseline\",\n        \"dominant-baseline\": \"dominantBaseline\",\n        dur: \"dur\",\n        dx: \"dx\",\n        dy: \"dy\",\n        edgemode: \"edgeMode\",\n        elevation: \"elevation\",\n        enablebackground: \"enableBackground\",\n        \"enable-background\": \"enableBackground\",\n        end: \"end\",\n        exponent: \"exponent\",\n        externalresourcesrequired: \"externalResourcesRequired\",\n        fill: \"fill\",\n        fillopacity: \"fillOpacity\",\n        \"fill-opacity\": \"fillOpacity\",\n        fillrule: \"fillRule\",\n        \"fill-rule\": \"fillRule\",\n        filter: \"filter\",\n        filterres: \"filterRes\",\n        filterunits: \"filterUnits\",\n        floodopacity: \"floodOpacity\",\n        \"flood-opacity\": \"floodOpacity\",\n        floodcolor: \"floodColor\",\n        \"flood-color\": \"floodColor\",\n        focusable: \"focusable\",\n        fontfamily: \"fontFamily\",\n        \"font-family\": \"fontFamily\",\n        fontsize: \"fontSize\",\n        \"font-size\": \"fontSize\",\n        fontsizeadjust: \"fontSizeAdjust\",\n        \"font-size-adjust\": \"fontSizeAdjust\",\n        fontstretch: \"fontStretch\",\n        \"font-stretch\": \"fontStretch\",\n        fontstyle: \"fontStyle\",\n        \"font-style\": \"fontStyle\",\n        fontvariant: \"fontVariant\",\n        \"font-variant\": \"fontVariant\",\n        fontweight: \"fontWeight\",\n        \"font-weight\": \"fontWeight\",\n        format: \"format\",\n        from: \"from\",\n        fx: \"fx\",\n        fy: \"fy\",\n        g1: \"g1\",\n        g2: \"g2\",\n        glyphname: \"glyphName\",\n        \"glyph-name\": \"glyphName\",\n        glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n        \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n        glyphorientationvertical: \"glyphOrientationVertical\",\n        \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n        glyphref: \"glyphRef\",\n        gradienttransform: \"gradientTransform\",\n        gradientunits: \"gradientUnits\",\n        hanging: \"hanging\",\n        horizadvx: \"horizAdvX\",\n        \"horiz-adv-x\": \"horizAdvX\",\n        horizoriginx: \"horizOriginX\",\n        \"horiz-origin-x\": \"horizOriginX\",\n        ideographic: \"ideographic\",\n        imagerendering: \"imageRendering\",\n        \"image-rendering\": \"imageRendering\",\n        in2: \"in2\",\n        in: \"in\",\n        inlist: \"inlist\",\n        intercept: \"intercept\",\n        k1: \"k1\",\n        k2: \"k2\",\n        k3: \"k3\",\n        k4: \"k4\",\n        k: \"k\",\n        kernelmatrix: \"kernelMatrix\",\n        kernelunitlength: \"kernelUnitLength\",\n        kerning: \"kerning\",\n        keypoints: \"keyPoints\",\n        keysplines: \"keySplines\",\n        keytimes: \"keyTimes\",\n        lengthadjust: \"lengthAdjust\",\n        letterspacing: \"letterSpacing\",\n        \"letter-spacing\": \"letterSpacing\",\n        lightingcolor: \"lightingColor\",\n        \"lighting-color\": \"lightingColor\",\n        limitingconeangle: \"limitingConeAngle\",\n        local: \"local\",\n        markerend: \"markerEnd\",\n        \"marker-end\": \"markerEnd\",\n        markerheight: \"markerHeight\",\n        markermid: \"markerMid\",\n        \"marker-mid\": \"markerMid\",\n        markerstart: \"markerStart\",\n        \"marker-start\": \"markerStart\",\n        markerunits: \"markerUnits\",\n        markerwidth: \"markerWidth\",\n        mask: \"mask\",\n        maskcontentunits: \"maskContentUnits\",\n        maskunits: \"maskUnits\",\n        mathematical: \"mathematical\",\n        mode: \"mode\",\n        numoctaves: \"numOctaves\",\n        offset: \"offset\",\n        opacity: \"opacity\",\n        operator: \"operator\",\n        order: \"order\",\n        orient: \"orient\",\n        orientation: \"orientation\",\n        origin: \"origin\",\n        overflow: \"overflow\",\n        overlineposition: \"overlinePosition\",\n        \"overline-position\": \"overlinePosition\",\n        overlinethickness: \"overlineThickness\",\n        \"overline-thickness\": \"overlineThickness\",\n        paintorder: \"paintOrder\",\n        \"paint-order\": \"paintOrder\",\n        panose1: \"panose1\",\n        \"panose-1\": \"panose1\",\n        pathlength: \"pathLength\",\n        patterncontentunits: \"patternContentUnits\",\n        patterntransform: \"patternTransform\",\n        patternunits: \"patternUnits\",\n        pointerevents: \"pointerEvents\",\n        \"pointer-events\": \"pointerEvents\",\n        points: \"points\",\n        pointsatx: \"pointsAtX\",\n        pointsaty: \"pointsAtY\",\n        pointsatz: \"pointsAtZ\",\n        popover: \"popover\",\n        popovertarget: \"popoverTarget\",\n        popovertargetaction: \"popoverTargetAction\",\n        prefix: \"prefix\",\n        preservealpha: \"preserveAlpha\",\n        preserveaspectratio: \"preserveAspectRatio\",\n        primitiveunits: \"primitiveUnits\",\n        property: \"property\",\n        r: \"r\",\n        radius: \"radius\",\n        refx: \"refX\",\n        refy: \"refY\",\n        renderingintent: \"renderingIntent\",\n        \"rendering-intent\": \"renderingIntent\",\n        repeatcount: \"repeatCount\",\n        repeatdur: \"repeatDur\",\n        requiredextensions: \"requiredExtensions\",\n        requiredfeatures: \"requiredFeatures\",\n        resource: \"resource\",\n        restart: \"restart\",\n        result: \"result\",\n        results: \"results\",\n        rotate: \"rotate\",\n        rx: \"rx\",\n        ry: \"ry\",\n        scale: \"scale\",\n        security: \"security\",\n        seed: \"seed\",\n        shaperendering: \"shapeRendering\",\n        \"shape-rendering\": \"shapeRendering\",\n        slope: \"slope\",\n        spacing: \"spacing\",\n        specularconstant: \"specularConstant\",\n        specularexponent: \"specularExponent\",\n        speed: \"speed\",\n        spreadmethod: \"spreadMethod\",\n        startoffset: \"startOffset\",\n        stddeviation: \"stdDeviation\",\n        stemh: \"stemh\",\n        stemv: \"stemv\",\n        stitchtiles: \"stitchTiles\",\n        stopcolor: \"stopColor\",\n        \"stop-color\": \"stopColor\",\n        stopopacity: \"stopOpacity\",\n        \"stop-opacity\": \"stopOpacity\",\n        strikethroughposition: \"strikethroughPosition\",\n        \"strikethrough-position\": \"strikethroughPosition\",\n        strikethroughthickness: \"strikethroughThickness\",\n        \"strikethrough-thickness\": \"strikethroughThickness\",\n        string: \"string\",\n        stroke: \"stroke\",\n        strokedasharray: \"strokeDasharray\",\n        \"stroke-dasharray\": \"strokeDasharray\",\n        strokedashoffset: \"strokeDashoffset\",\n        \"stroke-dashoffset\": \"strokeDashoffset\",\n        strokelinecap: \"strokeLinecap\",\n        \"stroke-linecap\": \"strokeLinecap\",\n        strokelinejoin: \"strokeLinejoin\",\n        \"stroke-linejoin\": \"strokeLinejoin\",\n        strokemiterlimit: \"strokeMiterlimit\",\n        \"stroke-miterlimit\": \"strokeMiterlimit\",\n        strokewidth: \"strokeWidth\",\n        \"stroke-width\": \"strokeWidth\",\n        strokeopacity: \"strokeOpacity\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n        suppresshydrationwarning: \"suppressHydrationWarning\",\n        surfacescale: \"surfaceScale\",\n        systemlanguage: \"systemLanguage\",\n        tablevalues: \"tableValues\",\n        targetx: \"targetX\",\n        targety: \"targetY\",\n        textanchor: \"textAnchor\",\n        \"text-anchor\": \"textAnchor\",\n        textdecoration: \"textDecoration\",\n        \"text-decoration\": \"textDecoration\",\n        textlength: \"textLength\",\n        textrendering: \"textRendering\",\n        \"text-rendering\": \"textRendering\",\n        to: \"to\",\n        transform: \"transform\",\n        transformorigin: \"transformOrigin\",\n        \"transform-origin\": \"transformOrigin\",\n        typeof: \"typeof\",\n        u1: \"u1\",\n        u2: \"u2\",\n        underlineposition: \"underlinePosition\",\n        \"underline-position\": \"underlinePosition\",\n        underlinethickness: \"underlineThickness\",\n        \"underline-thickness\": \"underlineThickness\",\n        unicode: \"unicode\",\n        unicodebidi: \"unicodeBidi\",\n        \"unicode-bidi\": \"unicodeBidi\",\n        unicoderange: \"unicodeRange\",\n        \"unicode-range\": \"unicodeRange\",\n        unitsperem: \"unitsPerEm\",\n        \"units-per-em\": \"unitsPerEm\",\n        unselectable: \"unselectable\",\n        valphabetic: \"vAlphabetic\",\n        \"v-alphabetic\": \"vAlphabetic\",\n        values: \"values\",\n        vectoreffect: \"vectorEffect\",\n        \"vector-effect\": \"vectorEffect\",\n        version: \"version\",\n        vertadvy: \"vertAdvY\",\n        \"vert-adv-y\": \"vertAdvY\",\n        vertoriginx: \"vertOriginX\",\n        \"vert-origin-x\": \"vertOriginX\",\n        vertoriginy: \"vertOriginY\",\n        \"vert-origin-y\": \"vertOriginY\",\n        vhanging: \"vHanging\",\n        \"v-hanging\": \"vHanging\",\n        videographic: \"vIdeographic\",\n        \"v-ideographic\": \"vIdeographic\",\n        viewbox: \"viewBox\",\n        viewtarget: \"viewTarget\",\n        visibility: \"visibility\",\n        vmathematical: \"vMathematical\",\n        \"v-mathematical\": \"vMathematical\",\n        vocab: \"vocab\",\n        widths: \"widths\",\n        wordspacing: \"wordSpacing\",\n        \"word-spacing\": \"wordSpacing\",\n        writingmode: \"writingMode\",\n        \"writing-mode\": \"writingMode\",\n        x1: \"x1\",\n        x2: \"x2\",\n        x: \"x\",\n        xchannelselector: \"xChannelSelector\",\n        xheight: \"xHeight\",\n        \"x-height\": \"xHeight\",\n        xlinkactuate: \"xlinkActuate\",\n        \"xlink:actuate\": \"xlinkActuate\",\n        xlinkarcrole: \"xlinkArcrole\",\n        \"xlink:arcrole\": \"xlinkArcrole\",\n        xlinkhref: \"xlinkHref\",\n        \"xlink:href\": \"xlinkHref\",\n        xlinkrole: \"xlinkRole\",\n        \"xlink:role\": \"xlinkRole\",\n        xlinkshow: \"xlinkShow\",\n        \"xlink:show\": \"xlinkShow\",\n        xlinktitle: \"xlinkTitle\",\n        \"xlink:title\": \"xlinkTitle\",\n        xlinktype: \"xlinkType\",\n        \"xlink:type\": \"xlinkType\",\n        xmlbase: \"xmlBase\",\n        \"xml:base\": \"xmlBase\",\n        xmllang: \"xmlLang\",\n        \"xml:lang\": \"xmlLang\",\n        xmlns: \"xmlns\",\n        \"xml:space\": \"xmlSpace\",\n        xmlnsxlink: \"xmlnsXlink\",\n        \"xmlns:xlink\": \"xmlnsXlink\",\n        xmlspace: \"xmlSpace\",\n        y1: \"y1\",\n        y2: \"y2\",\n        y: \"y\",\n        ychannelselector: \"yChannelSelector\",\n        z: \"z\",\n        zoomandpan: \"zoomAndPan\"\n      },\n      warnedProperties = {},\n      EVENT_NAME_REGEX = /^on./,\n      INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,\n      rARIA = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,\n      msPattern$1 = /^-ms-/,\n      hyphenPattern = /-(.)/g,\n      badStyleValueWithSemicolonPattern = /;\\s*$/,\n      warnedStyleNames = {},\n      warnedStyleValues = {},\n      warnedForNaNValue = !1,\n      warnedForInfinityValue = !1,\n      matchHtmlRegExp = /[\"'&<>]/,\n      uppercasePattern = /([A-Z])/g,\n      msPattern = /^ms-/,\n      isJavaScriptProtocol =\n        /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i,\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      ReactDOMSharedInternals =\n        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      NotPending = Object.freeze({\n        pending: !1,\n        data: null,\n        method: null,\n        action: null\n      }),\n      previousDispatcher = ReactDOMSharedInternals.d;\n    ReactDOMSharedInternals.d = {\n      f: previousDispatcher.f,\n      r: previousDispatcher.r,\n      D: function (href) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            if (!resumableState.dnsResources.hasOwnProperty(href)) {\n              resumableState.dnsResources[href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              )\n                JSCompiler_temp =\n                  ((header =\n                    \"<\" +\n                    escapeHrefForLinkHeaderURLContext(href) +\n                    \">; rel=dns-prefetch\"),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              JSCompiler_temp\n                ? ((renderState.resets.dns[href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((header = []),\n                  pushLinkImpl(header, { href: href, rel: \"dns-prefetch\" }),\n                  renderState.preconnects.add(header));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.D(href);\n      },\n      C: function (href, crossOrigin) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            var bucket =\n              \"use-credentials\" === crossOrigin\n                ? \"credentials\"\n                : \"string\" === typeof crossOrigin\n                  ? \"anonymous\"\n                  : \"default\";\n            if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {\n              resumableState.connectResources[bucket][href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              ) {\n                JSCompiler_temp =\n                  \"<\" +\n                  escapeHrefForLinkHeaderURLContext(href) +\n                  \">; rel=preconnect\";\n                if (\"string\" === typeof crossOrigin) {\n                  var escapedCrossOrigin =\n                    escapeStringForLinkHeaderQuotedParamValueContext(\n                      crossOrigin,\n                      \"crossOrigin\"\n                    );\n                  JSCompiler_temp +=\n                    '; crossorigin=\"' + escapedCrossOrigin + '\"';\n                }\n                JSCompiler_temp =\n                  ((header = JSCompiler_temp),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              }\n              JSCompiler_temp\n                ? ((renderState.resets.connect[bucket][href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((bucket = []),\n                  pushLinkImpl(bucket, {\n                    rel: \"preconnect\",\n                    href: href,\n                    crossOrigin: crossOrigin\n                  }),\n                  renderState.preconnects.add(bucket));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.C(href, crossOrigin);\n      },\n      L: function (href, as, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (as && href) {\n            switch (as) {\n              case \"image\":\n                if (options) {\n                  var imageSrcSet = options.imageSrcSet;\n                  var imageSizes = options.imageSizes;\n                  var fetchPriority = options.fetchPriority;\n                }\n                var key = imageSrcSet\n                  ? imageSrcSet + \"\\n\" + (imageSizes || \"\")\n                  : href;\n                if (resumableState.imageResources.hasOwnProperty(key)) return;\n                resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                resumableState = renderState.headers;\n                var header;\n                resumableState &&\n                0 < resumableState.remainingCapacity &&\n                \"string\" !== typeof imageSrcSet &&\n                \"high\" === fetchPriority &&\n                ((header = getPreloadAsHeader(href, as, options)),\n                0 <= (resumableState.remainingCapacity -= header.length + 2))\n                  ? ((renderState.resets.image[key] = PRELOAD_NO_CREDS),\n                    resumableState.highImagePreloads &&\n                      (resumableState.highImagePreloads += \", \"),\n                    (resumableState.highImagePreloads += header))\n                  : ((resumableState = []),\n                    pushLinkImpl(\n                      resumableState,\n                      assign(\n                        {\n                          rel: \"preload\",\n                          href: imageSrcSet ? void 0 : href,\n                          as: as\n                        },\n                        options\n                      )\n                    ),\n                    \"high\" === fetchPriority\n                      ? renderState.highImagePreloads.add(resumableState)\n                      : (renderState.bulkPreloads.add(resumableState),\n                        renderState.preloads.images.set(key, resumableState)));\n                break;\n              case \"style\":\n                if (resumableState.styleResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.styleResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.stylesheets.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                break;\n              case \"script\":\n                if (resumableState.scriptResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                renderState.preloads.scripts.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.scriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                break;\n              default:\n                if (resumableState.unknownResources.hasOwnProperty(as)) {\n                  if (\n                    ((imageSrcSet = resumableState.unknownResources[as]),\n                    imageSrcSet.hasOwnProperty(href))\n                  )\n                    return;\n                } else\n                  (imageSrcSet = {}),\n                    (resumableState.unknownResources[as] = imageSrcSet);\n                imageSrcSet[href] = PRELOAD_NO_CREDS;\n                if (\n                  (resumableState = renderState.headers) &&\n                  0 < resumableState.remainingCapacity &&\n                  \"font\" === as &&\n                  ((key = getPreloadAsHeader(href, as, options)),\n                  0 <= (resumableState.remainingCapacity -= key.length + 2))\n                )\n                  (renderState.resets.font[href] = PRELOAD_NO_CREDS),\n                    resumableState.fontPreloads &&\n                      (resumableState.fontPreloads += \", \"),\n                    (resumableState.fontPreloads += key);\n                else\n                  switch (\n                    ((resumableState = []),\n                    (href = assign(\n                      { rel: \"preload\", href: href, as: as },\n                      options\n                    )),\n                    pushLinkImpl(resumableState, href),\n                    as)\n                  ) {\n                    case \"font\":\n                      renderState.fontPreloads.add(resumableState);\n                      break;\n                    default:\n                      renderState.bulkPreloads.add(resumableState);\n                  }\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.L(href, as, options);\n      },\n      m: function (href, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            var as =\n              options && \"string\" === typeof options.as ? options.as : \"script\";\n            switch (as) {\n              case \"script\":\n                if (resumableState.moduleScriptResources.hasOwnProperty(href))\n                  return;\n                as = [];\n                resumableState.moduleScriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.moduleScripts.set(href, as);\n                break;\n              default:\n                if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {\n                  var resources = resumableState.unknownResources[as];\n                  if (resources.hasOwnProperty(href)) return;\n                } else\n                  (resources = {}),\n                    (resumableState.moduleUnknownResources[as] = resources);\n                as = [];\n                resources[href] = PRELOAD_NO_CREDS;\n            }\n            pushLinkImpl(\n              as,\n              assign({ rel: \"modulepreload\", href: href }, options)\n            );\n            renderState.bulkPreloads.add(as);\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.m(href, options);\n      },\n      X: function (src, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState = resumableState.scriptResources.hasOwnProperty(\n              src\n            )\n              ? resumableState.scriptResources[src]\n              : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.scriptResources[src] = EXISTS),\n              (options = assign({ src: src, async: !0 }, options)),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.scripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.X(src, options);\n      },\n      S: function (href, precedence, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            precedence = precedence || \"default\";\n            var styleQueue = renderState.styles.get(precedence),\n              resourceState = resumableState.styleResources.hasOwnProperty(href)\n                ? resumableState.styleResources[href]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.styleResources[href] = EXISTS),\n              styleQueue ||\n                ((styleQueue = {\n                  precedence: escapeTextForBrowser(precedence),\n                  rules: [],\n                  hrefs: [],\n                  sheets: new Map()\n                }),\n                renderState.styles.set(precedence, styleQueue)),\n              (precedence = {\n                state: PENDING$1,\n                props: assign(\n                  {\n                    rel: \"stylesheet\",\n                    href: href,\n                    \"data-precedence\": precedence\n                  },\n                  options\n                )\n              }),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(precedence.props, resourceState),\n                (renderState = renderState.preloads.stylesheets.get(href)) &&\n                0 < renderState.length\n                  ? (renderState.length = 0)\n                  : (precedence.state = PRELOADED)),\n              styleQueue.sheets.set(href, precedence),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.S(href, precedence, options);\n      },\n      M: function (src, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState =\n              resumableState.moduleScriptResources.hasOwnProperty(src)\n                ? resumableState.moduleScriptResources[src]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.moduleScriptResources[src] = EXISTS),\n              (options = assign(\n                { src: src, type: \"module\", async: !0 },\n                options\n              )),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.moduleScripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.M(src, options);\n      }\n    };\n    var NothingSent = 0,\n      SentCompleteSegmentFunction = 1,\n      SentCompleteBoundaryFunction = 2,\n      SentClientRenderFunction = 4,\n      SentStyleInsertionFunction = 8,\n      EXISTS = null,\n      PRELOAD_NO_CREDS = [];\n    Object.freeze(PRELOAD_NO_CREDS);\n    var scriptRegex = /(<\\/|<)(s)(cript)/gi;\n    var didWarnForNewBooleanPropsWithEmptyValue = {};\n    var NoContribution = 0,\n      ROOT_HTML_MODE = 0,\n      HTML_HTML_MODE = 1,\n      HTML_MODE = 2,\n      HTML_HEAD_MODE = 3,\n      SVG_MODE = 4,\n      MATHML_MODE = 5,\n      HTML_TABLE_MODE = 6,\n      HTML_TABLE_BODY_MODE = 7,\n      HTML_TABLE_ROW_MODE = 8,\n      HTML_COLGROUP_MODE = 9,\n      styleNameCache = new Map(),\n      styleAttributeStart = ' style=\"',\n      styleAssign = \":\",\n      styleSeparator = \";\",\n      attributeSeparator = \" \",\n      attributeAssign = '=\"',\n      attributeEnd = '\"',\n      attributeEmptyString = '=\"\"',\n      actionJavaScriptURL = escapeTextForBrowser(\n        \"javascript:throw new Error('React form unexpectedly submitted.')\"\n      ),\n      endOfStartTag = \">\",\n      endOfStartTagSelfClosing = \"/>\",\n      didWarnDefaultInputValue = !1,\n      didWarnDefaultChecked = !1,\n      didWarnDefaultSelectValue = !1,\n      didWarnDefaultTextareaValue = !1,\n      didWarnInvalidOptionChildren = !1,\n      didWarnInvalidOptionInnerHTML = !1,\n      didWarnSelectedSetOnOption = !1,\n      didWarnFormActionType = !1,\n      didWarnFormActionName = !1,\n      didWarnFormActionTarget = !1,\n      didWarnFormActionMethod = !1,\n      formReplayingRuntimeScript =\n        'addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error(\\'React form unexpectedly submitted.\\')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});',\n      styleRegex = /(<\\/|<)(s)(tyle)/gi,\n      leadingNewline = \"\\n\",\n      VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/,\n      validatedTagCache = new Map(),\n      endTagCache = new Map(),\n      placeholder1 = '<template id=\"',\n      placeholder2 = '\"></template>',\n      startCompletedSuspenseBoundary = \"\\x3c!--$--\\x3e\",\n      startPendingSuspenseBoundary1 = '\\x3c!--$?--\\x3e<template id=\"',\n      startPendingSuspenseBoundary2 = '\"></template>',\n      startClientRenderedSuspenseBoundary = \"\\x3c!--$!--\\x3e\",\n      endSuspenseBoundary = \"\\x3c!--/$--\\x3e\",\n      clientRenderedSuspenseBoundaryError1 = \"<template\",\n      clientRenderedSuspenseBoundaryErrorAttrInterstitial = '\"',\n      clientRenderedSuspenseBoundaryError1A = ' data-dgst=\"',\n      clientRenderedSuspenseBoundaryError1B = ' data-msg=\"',\n      clientRenderedSuspenseBoundaryError1C = ' data-stck=\"',\n      clientRenderedSuspenseBoundaryError1D = ' data-cstck=\"',\n      clientRenderedSuspenseBoundaryError2 = \"></template>\",\n      boundaryPreambleContributionChunkStart = \"\\x3c!--\",\n      boundaryPreambleContributionChunkEnd = \"--\\x3e\",\n      startSegmentHTML = '<div hidden id=\"',\n      startSegmentHTML2 = '\">',\n      endSegmentHTML = \"</div>\",\n      startSegmentSVG = '<svg aria-hidden=\"true\" style=\"display:none\" id=\"',\n      startSegmentSVG2 = '\">',\n      endSegmentSVG = \"</svg>\",\n      startSegmentMathML = '<math aria-hidden=\"true\" style=\"display:none\" id=\"',\n      startSegmentMathML2 = '\">',\n      endSegmentMathML = \"</math>\",\n      startSegmentTable = '<table hidden id=\"',\n      startSegmentTable2 = '\">',\n      endSegmentTable = \"</table>\",\n      startSegmentTableBody = '<table hidden><tbody id=\"',\n      startSegmentTableBody2 = '\">',\n      endSegmentTableBody = \"</tbody></table>\",\n      startSegmentTableRow = '<table hidden><tr id=\"',\n      startSegmentTableRow2 = '\">',\n      endSegmentTableRow = \"</tr></table>\",\n      startSegmentColGroup = '<table hidden><colgroup id=\"',\n      startSegmentColGroup2 = '\">',\n      endSegmentColGroup = \"</colgroup></table>\",\n      completeSegmentScript1Full =\n        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(\"',\n      completeSegmentScript1Partial = '$RS(\"',\n      completeSegmentScript2 = '\",\"',\n      completeSegmentScriptEnd = '\")\\x3c/script>',\n      completeBoundaryScript1Full =\n        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RC(\"',\n      completeBoundaryScript1Partial = '$RC(\"',\n      completeBoundaryWithStylesScript1FullBoth =\n        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"',\n      completeBoundaryWithStylesScript1FullPartial =\n        '$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"',\n      completeBoundaryWithStylesScript1Partial = '$RR(\"',\n      completeBoundaryScript2 = '\",\"',\n      completeBoundaryScript3a = '\",',\n      completeBoundaryScript3b = '\"',\n      completeBoundaryScriptEnd = \")\\x3c/script>\",\n      clientRenderScript1Full =\n        '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX(\"',\n      clientRenderScript1Partial = '$RX(\"',\n      clientRenderScript1A = '\"',\n      clientRenderErrorScriptArgInterstitial = \",\",\n      clientRenderScriptEnd = \")\\x3c/script>\",\n      regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g,\n      regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g,\n      lateStyleTagResourceOpen1 = '<style media=\"not all\" data-precedence=\"',\n      lateStyleTagResourceOpen2 = '\" data-href=\"',\n      lateStyleTagResourceOpen3 = '\">',\n      lateStyleTagTemplateClose = \"</style>\",\n      currentlyRenderingBoundaryHasStylesToHoist = !1,\n      destinationHasCapacity = !0,\n      stylesheetFlushingQueue = [],\n      styleTagResourceOpen1 = '<style data-precedence=\"',\n      styleTagResourceOpen2 = '\" data-href=\"',\n      spaceSeparator = \" \",\n      styleTagResourceOpen3 = '\">',\n      styleTagResourceClose = \"</style>\",\n      arrayFirstOpenBracket = \"[\",\n      arraySubsequentOpenBracket = \",[\",\n      arrayInterstitial = \",\",\n      arrayCloseBracket = \"]\",\n      PENDING$1 = 0,\n      PRELOADED = 1,\n      PREAMBLE = 2,\n      LATE = 3,\n      regexForHrefInLinkHeaderURLContext = /[<>\\r\\n]/g,\n      regexForLinkHeaderQuotedParamValueContext = /[\"';,\\r\\n]/g,\n      doctypeChunk = \"\",\n      bind = Function.prototype.bind,\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var rendererSigil = {};\n    var currentActiveSnapshot = null,\n      didWarnAboutNoopUpdateForComponent = {},\n      didWarnAboutDeprecatedWillMount = {};\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    var classComponentUpdater = {\n        enqueueSetState: function (inst, payload, callback) {\n          var internals = inst._reactInternals;\n          null === internals.queue\n            ? warnNoop(inst, \"setState\")\n            : (internals.queue.push(payload),\n              void 0 !== callback &&\n                null !== callback &&\n                warnOnInvalidCallback(callback));\n        },\n        enqueueReplaceState: function (inst, payload, callback) {\n          inst = inst._reactInternals;\n          inst.replace = !0;\n          inst.queue = [payload];\n          void 0 !== callback &&\n            null !== callback &&\n            warnOnInvalidCallback(callback);\n        },\n        enqueueForceUpdate: function (inst, callback) {\n          null === inst._reactInternals.queue\n            ? warnNoop(inst, \"forceUpdate\")\n            : void 0 !== callback &&\n              null !== callback &&\n              warnOnInvalidCallback(callback);\n        }\n      },\n      emptyTreeContext = { id: 1, overflow: \"\" },\n      clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,\n      log = Math.log,\n      LN2 = Math.LN2,\n      SuspenseException = Error(\n        \"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.\"\n      ),\n      suspendedThenable = null,\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      currentlyRenderingComponent = null,\n      currentlyRenderingTask = null,\n      currentlyRenderingRequest = null,\n      currentlyRenderingKeyPath = null,\n      firstWorkInProgressHook = null,\n      workInProgressHook = null,\n      isReRender = !1,\n      didScheduleRenderPhaseUpdate = !1,\n      localIdCounter = 0,\n      actionStateCounter = 0,\n      actionStateMatchingIndex = -1,\n      thenableIndexCounter = 0,\n      thenableState = null,\n      renderPhaseUpdates = null,\n      numberOfReRenders = 0,\n      isInHookUserCodeInDev = !1,\n      currentHookNameInDev,\n      HooksDispatcher = {\n        readContext: readContext,\n        use: function (usable) {\n          if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then)\n              return unwrapThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE)\n              return readContext(usable);\n          }\n          throw Error(\n            \"An unsupported type was passed to use(): \" + String(usable)\n          );\n        },\n        useContext: function (context) {\n          currentHookNameInDev = \"useContext\";\n          resolveCurrentlyRenderingComponent();\n          return context._currentValue2;\n        },\n        useMemo: useMemo,\n        useReducer: useReducer,\n        useRef: function (initialValue) {\n          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n          workInProgressHook = createWorkInProgressHook();\n          var previousRef = workInProgressHook.memoizedState;\n          return null === previousRef\n            ? ((initialValue = { current: initialValue }),\n              Object.seal(initialValue),\n              (workInProgressHook.memoizedState = initialValue))\n            : previousRef;\n        },\n        useState: function (initialState) {\n          currentHookNameInDev = \"useState\";\n          return useReducer(basicStateReducer, initialState);\n        },\n        useInsertionEffect: noop$1,\n        useLayoutEffect: noop$1,\n        useCallback: function (callback, deps) {\n          return useMemo(function () {\n            return callback;\n          }, deps);\n        },\n        useImperativeHandle: noop$1,\n        useEffect: noop$1,\n        useDebugValue: noop$1,\n        useDeferredValue: function (value, initialValue) {\n          resolveCurrentlyRenderingComponent();\n          return void 0 !== initialValue ? initialValue : value;\n        },\n        useTransition: function () {\n          resolveCurrentlyRenderingComponent();\n          return [!1, unsupportedStartTransition];\n        },\n        useId: function () {\n          var treeId = currentlyRenderingTask.treeContext;\n          var overflow = treeId.overflow;\n          treeId = treeId.id;\n          treeId =\n            (treeId & ~(1 << (32 - clz32(treeId) - 1))).toString(32) + overflow;\n          var resumableState = currentResumableState;\n          if (null === resumableState)\n            throw Error(\n              \"Invalid hook call. Hooks can only be called inside of the body of a function component.\"\n            );\n          overflow = localIdCounter++;\n          treeId = \"\\u00ab\" + resumableState.idPrefix + \"R\" + treeId;\n          0 < overflow && (treeId += \"H\" + overflow.toString(32));\n          return treeId + \"\\u00bb\";\n        },\n        useSyncExternalStore: function (\n          subscribe,\n          getSnapshot,\n          getServerSnapshot\n        ) {\n          if (void 0 === getServerSnapshot)\n            throw Error(\n              \"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\"\n            );\n          return getServerSnapshot();\n        },\n        useOptimistic: function (passthrough) {\n          resolveCurrentlyRenderingComponent();\n          return [passthrough, unsupportedSetOptimisticState];\n        },\n        useActionState: useActionState,\n        useFormState: useActionState,\n        useHostTransitionStatus: function () {\n          resolveCurrentlyRenderingComponent();\n          return NotPending;\n        },\n        useMemoCache: function (size) {\n          for (var data = Array(size), i = 0; i < size; i++)\n            data[i] = REACT_MEMO_CACHE_SENTINEL;\n          return data;\n        },\n        useCacheRefresh: function () {\n          return unsupportedRefresh;\n        }\n      },\n      currentResumableState = null,\n      currentTaskInDEV = null,\n      DefaultAsyncDispatcher = {\n        getCacheForType: function () {\n          throw Error(\"Not implemented.\");\n        },\n        getOwner: function () {\n          return null === currentTaskInDEV\n            ? null\n            : currentTaskInDEV.componentStack;\n        }\n      },\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var callComponent = {\n        \"react-stack-bottom-frame\": function (Component, props, secondArg) {\n          return Component(props, secondArg);\n        }\n      },\n      callComponentInDEV =\n        callComponent[\"react-stack-bottom-frame\"].bind(callComponent),\n      callRender = {\n        \"react-stack-bottom-frame\": function (instance) {\n          return instance.render();\n        }\n      },\n      callRenderInDEV = callRender[\"react-stack-bottom-frame\"].bind(callRender),\n      callLazyInit = {\n        \"react-stack-bottom-frame\": function (lazy) {\n          var init = lazy._init;\n          return init(lazy._payload);\n        }\n      },\n      callLazyInitInDEV =\n        callLazyInit[\"react-stack-bottom-frame\"].bind(callLazyInit),\n      CLIENT_RENDERED = 4,\n      PENDING = 0,\n      COMPLETED = 1,\n      FLUSHED = 2,\n      POSTPONED = 5,\n      CLOSED = 14,\n      currentRequest = null,\n      didWarnAboutBadClass = {},\n      didWarnAboutContextTypes = {},\n      didWarnAboutContextTypeOnFunctionComponent = {},\n      didWarnAboutGetDerivedStateOnFunctionComponent = {},\n      didWarnAboutReassigningProps = !1,\n      didWarnAboutGenerators = !1,\n      didWarnAboutMaps = !1;\n    exports.renderToStaticMarkup = function (children, options) {\n      return renderToStringImpl(\n        children,\n        options,\n        !0,\n        'The server used \"renderToStaticMarkup\" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server'\n      );\n    };\n    exports.renderToString = function (children, options) {\n      return renderToStringImpl(\n        children,\n        options,\n        !1,\n        'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server'\n      );\n    };\n    exports.version = \"19.1.0-canary-029e8bd6-20250306\";\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLXNlcnZlci1sZWdhY3kubm9kZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkNBQTZDO0FBQ25FLHNCQUFzQiw0Q0FBNEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osaUJBQWlCO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKLGlCQUFpQixtREFBbUQsbUJBQW1CLFdBQVcsK0JBQStCO0FBQ25SO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixHQUFHO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEIsNEJBQTRCLFdBQVcsZUFBZSxtQkFBbUI7QUFDekUsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwyQkFBMkI7QUFDM0Isa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILDhCQUE4QjtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsWUFBWTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNmQUFzZixXQUFXLDBMQUEwTCxTQUFTLFdBQVcsRUFBRTtBQUNqdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxZQUFZO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHNCQUFzQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQ0FBb0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIscUJBQXFCLFdBQVcsZUFBZSxtQkFBbUI7QUFDbEUsbUJBQW1CO0FBQ25CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSx3QkFBd0IsV0FBVyxnQkFBZ0I7QUFDbkQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELHlCQUF5QixXQUFXLGlCQUFpQjtBQUNyRCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsMEJBQTBCLFdBQVcsa0JBQWtCO0FBQ3ZELG1DQUFtQyxXQUFXLDJCQUEyQjtBQUN6RSw2QkFBNkIsV0FBVyxxQkFBcUI7QUFDN0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQWlEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUNBQXFDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCLGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2QkFBNkI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkJBQTJCO0FBQzVELHdDQUF3QyxvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0NBQWdDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG1DQUFtQyxnQ0FBZ0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQ0FBcUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQTBCO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLGdHQUE4QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpQ0FBaUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0NBQW9DO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0NBQWtDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx3QkFBd0IsNENBQTRDLE1BQU0sbUNBQW1DLHNCQUFzQixrVkFBa1YsRUFBRTtBQUN0Z0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCLDZCQUE2QixnQ0FBZ0MsYUFBYSwyQ0FBMkMsNkJBQTZCO0FBQzFNO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZCQUE2Qiw0QkFBNEIsaUNBQWlDLE1BQU0sb0JBQW9CLCtDQUErQyxLQUFLLGVBQWUsZ0JBQWdCLFFBQVEsR0FBRyxzQkFBc0IsYUFBYSwyQkFBMkIsU0FBUyxxQ0FBcUMsZ0JBQWdCLGlCQUFpQixJQUFJLFNBQVMsS0FBSyxhQUFhLGdDQUFnQyxXQUFXLGlDQUFpQztBQUN2ZTtBQUNBO0FBQ0EsNkJBQTZCLDZCQUE2Qiw0QkFBNEIsaUNBQWlDLE1BQU0sb0JBQW9CLCtDQUErQyxLQUFLLGVBQWUsZ0JBQWdCLFFBQVEsR0FBRyxzQkFBc0IsYUFBYSwyQkFBMkIsU0FBUyxxQ0FBcUMsZ0JBQWdCLGlCQUFpQixJQUFJLFNBQVMsS0FBSyxhQUFhLGdDQUFnQyxXQUFXLGlDQUFpQyxZQUFZLHNCQUFzQixjQUFjLGFBQWEsSUFBSSwySEFBMkgsU0FBUyxxSUFBcUksSUFBSSxLQUFLLFFBQVEsVUFBVSxFQUFFLE1BQU0sYUFBYSxPQUFPLEtBQUssSUFBSSxTQUFTLGFBQWEsYUFBYSxlQUFlLFdBQVcsS0FBSyxLQUFLLDBCQUEwQixXQUFXLG1CQUFtQixrQ0FBa0MsU0FBUywwQkFBMEIsaUNBQWlDLHFCQUFxQixzQkFBc0IsRUFBRSxXQUFXLDBCQUEwQix5Q0FBeUMsY0FBYyxLQUFLLFNBQVMsWUFBWSxvQ0FBb0MsMkJBQTJCLGNBQWMsYUFBYSxXQUFXLHVGQUF1Rix1RkFBdUY7QUFDNWdEO0FBQ0EscUJBQXFCLHNCQUFzQixjQUFjLGFBQWEsSUFBSSwySEFBMkgsU0FBUyxxSUFBcUksSUFBSSxLQUFLLFFBQVEsVUFBVSxFQUFFLE1BQU0sYUFBYSxPQUFPLEtBQUssSUFBSSxTQUFTLGFBQWEsYUFBYSxlQUFlLFdBQVcsS0FBSyxLQUFLLDBCQUEwQixXQUFXLG1CQUFtQixrQ0FBa0MsU0FBUywwQkFBMEIsaUNBQWlDLHFCQUFxQixzQkFBc0IsRUFBRSxXQUFXLDBCQUEwQix5Q0FBeUMsY0FBYyxLQUFLLFNBQVMsWUFBWSxvQ0FBb0MsMkJBQTJCLGNBQWMsYUFBYSxXQUFXLHVGQUF1Rix1RkFBdUY7QUFDOWlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQ0FBaUMsMElBQTBJO0FBQzVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyxxREFBcUQ7QUFDckQseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLElBQUksNEJBQTRCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzQkFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkIsR0FBRyIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGNvbXBpbGVkXFxyZWFjdC1kb21cXGNqc1xccmVhY3QtZG9tLXNlcnZlci1sZWdhY3kubm9kZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kb20tc2VydmVyLWxlZ2FjeS5ub2RlLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vKlxuXG5cbiBKUyBJbXBsZW1lbnRhdGlvbiBvZiBNdXJtdXJIYXNoMyAocjEzNikgKGFzIG9mIE1heSAyMCwgMjAxMSlcblxuIENvcHlyaWdodCAoYykgMjAxMSBHYXJ5IENvdXJ0XG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gU09GVFdBUkUuXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBzdHlsZVJlcGxhY2VyKG1hdGNoLCBwcmVmaXgsIHMsIHN1ZmZpeCkge1xuICAgICAgcmV0dXJuIFwiXCIgKyBwcmVmaXggKyAoXCJzXCIgPT09IHMgPyBcIlxcXFw3MyBcIiA6IFwiXFxcXDUzIFwiKSArIHN1ZmZpeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NyaXB0UmVwbGFjZXIobWF0Y2gsIHByZWZpeCwgcywgc3VmZml4KSB7XG4gICAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIChcInNcIiA9PT0gcyA/IFwiXFxcXHUwMDczXCIgOiBcIlxcXFx1MDA1M1wiKSArIHN1ZmZpeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gb2JqZWN0TmFtZShvYmplY3QpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgICAgIC5jYWxsKG9iamVjdClcbiAgICAgICAgLnJlcGxhY2UoL15cXFtvYmplY3QgKC4qKVxcXSQvLCBmdW5jdGlvbiAobSwgcDApIHtcbiAgICAgICAgICByZXR1cm4gcDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZShrZXkpIHtcbiAgICAgIHZhciBlbmNvZGVkS2V5ID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgIHJldHVybiAnXCInICsga2V5ICsgJ1wiJyA9PT0gZW5jb2RlZEtleSA/IGtleSA6IGVuY29kZWRLZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UodmFsdWUpIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAxMCA+PSB2YWx1ZS5sZW5ndGggPyB2YWx1ZSA6IHZhbHVlLnNsaWNlKDAsIDEwKSArIFwiLi4uXCJcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKHZhbHVlKSkgcmV0dXJuIFwiWy4uLl1cIjtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gdmFsdWUgJiYgdmFsdWUuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHKVxuICAgICAgICAgICAgcmV0dXJuIFwiY2xpZW50XCI7XG4gICAgICAgICAgdmFsdWUgPSBvYmplY3ROYW1lKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdmFsdWUgPyBcInsuLi59XCIgOiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBDTElFTlRfUkVGRVJFTkNFX1RBR1xuICAgICAgICAgICAgPyBcImNsaWVudFwiXG4gICAgICAgICAgICA6ICh2YWx1ZSA9IHZhbHVlLmRpc3BsYXlOYW1lIHx8IHZhbHVlLm5hbWUpXG4gICAgICAgICAgICAgID8gXCJmdW5jdGlvbiBcIiArIHZhbHVlXG4gICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlLnJlbmRlcik7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlLnR5cGUpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKHBheWxvYWQpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShvYmplY3RPckFycmF5LCBleHBhbmRlZE5hbWUpIHtcbiAgICAgIHZhciBvYmpLaW5kID0gb2JqZWN0TmFtZShvYmplY3RPckFycmF5KTtcbiAgICAgIGlmIChcIk9iamVjdFwiICE9PSBvYmpLaW5kICYmIFwiQXJyYXlcIiAhPT0gb2JqS2luZCkgcmV0dXJuIG9iaktpbmQ7XG4gICAgICB2YXIgc3RhcnQgPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGlmIChpc0FycmF5SW1wbChvYmplY3RPckFycmF5KSlcbiAgICAgICAgaWYgKGpzeENoaWxkcmVuUGFyZW50cy5oYXMob2JqZWN0T3JBcnJheSkpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGpzeENoaWxkcmVuUGFyZW50cy5nZXQob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgb2JqS2luZCA9IFwiPFwiICsgZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKSArIFwiPlwiO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0T3JBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0T3JBcnJheVtpXTtcbiAgICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgICAgIDogXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmIG51bGwgIT09IHZhbHVlXG4gICAgICAgICAgICAgICAgICA/IFwie1wiICsgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCJ9XCJcbiAgICAgICAgICAgICAgICAgIDogXCJ7XCIgKyBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwifVwiO1xuICAgICAgICAgICAgXCJcIiArIGkgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gdmFsdWUpKVxuICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgIDE1ID4gdmFsdWUubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyB2YWx1ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCJ7Li4ufVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqS2luZCArPSBcIjwvXCIgKyBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpICsgXCI+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqS2luZCA9IFwiW1wiO1xuICAgICAgICAgIGZvciAodHlwZSA9IDA7IHR5cGUgPCBvYmplY3RPckFycmF5Lmxlbmd0aDsgdHlwZSsrKVxuICAgICAgICAgICAgMCA8IHR5cGUgJiYgKG9iaktpbmQgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgKGkgPSBvYmplY3RPckFycmF5W3R5cGVdKSxcbiAgICAgICAgICAgICAgKGkgPVxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBpICYmIG51bGwgIT09IGlcbiAgICAgICAgICAgICAgICAgID8gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoaSlcbiAgICAgICAgICAgICAgICAgIDogZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZShpKSksXG4gICAgICAgICAgICAgIFwiXCIgKyB0eXBlID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAobGVuZ3RoID0gaS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gaSkpXG4gICAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAgIDEwID4gaS5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIGkubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgaVxuICAgICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiLi4uXCIpO1xuICAgICAgICAgIG9iaktpbmQgKz0gXCJdXCI7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdE9yQXJyYXkuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSlcbiAgICAgICAgb2JqS2luZCA9IFwiPFwiICsgZGVzY3JpYmVFbGVtZW50VHlwZShvYmplY3RPckFycmF5LnR5cGUpICsgXCIvPlwiO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChvYmplY3RPckFycmF5LiQkdHlwZW9mID09PSBDTElFTlRfUkVGRVJFTkNFX1RBRykgcmV0dXJuIFwiY2xpZW50XCI7XG4gICAgICAgIGlmIChqc3hQcm9wc1BhcmVudHMuaGFzKG9iamVjdE9yQXJyYXkpKSB7XG4gICAgICAgICAgb2JqS2luZCA9IGpzeFByb3BzUGFyZW50cy5nZXQob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgb2JqS2luZCA9IFwiPFwiICsgKGRlc2NyaWJlRWxlbWVudFR5cGUob2JqS2luZCkgfHwgXCIuLi5cIik7XG4gICAgICAgICAgdHlwZSA9IE9iamVjdC5rZXlzKG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvYmpLaW5kICs9IFwiIFwiO1xuICAgICAgICAgICAgdmFsdWUgPSB0eXBlW2ldO1xuICAgICAgICAgICAgb2JqS2luZCArPSBkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIj1cIjtcbiAgICAgICAgICAgIHZhciBfdmFsdWUyID0gb2JqZWN0T3JBcnJheVt2YWx1ZV07XG4gICAgICAgICAgICB2YXIgX3N1YnN0cjIgPVxuICAgICAgICAgICAgICB2YWx1ZSA9PT0gZXhwYW5kZWROYW1lICYmXG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBfdmFsdWUyICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IF92YWx1ZTJcbiAgICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpXG4gICAgICAgICAgICAgICAgOiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpO1xuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIF92YWx1ZTIgJiYgKF9zdWJzdHIyID0gXCJ7XCIgKyBfc3Vic3RyMiArIFwifVwiKTtcbiAgICAgICAgICAgIHZhbHVlID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChsZW5ndGggPSBfc3Vic3RyMi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IF9zdWJzdHIyKSlcbiAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAxMCA+IF9zdWJzdHIyLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgX3N1YnN0cjIubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIF9zdWJzdHIyXG4gICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpLaW5kICs9IFwiPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iaktpbmQgPSBcIntcIjtcbiAgICAgICAgICB0eXBlID0gT2JqZWN0LmtleXMob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAwIDwgaSAmJiAob2JqS2luZCArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAodmFsdWUgPSB0eXBlW2ldKSxcbiAgICAgICAgICAgICAgKG9iaktpbmQgKz0gZGVzY3JpYmVLZXlGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCI6IFwiKSxcbiAgICAgICAgICAgICAgKF92YWx1ZTIgPSBvYmplY3RPckFycmF5W3ZhbHVlXSksXG4gICAgICAgICAgICAgIChfdmFsdWUyID1cbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgX3ZhbHVlMiAmJiBudWxsICE9PSBfdmFsdWUyXG4gICAgICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpXG4gICAgICAgICAgICAgICAgICA6IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMikpLFxuICAgICAgICAgICAgICB2YWx1ZSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKGxlbmd0aCA9IF92YWx1ZTIubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IF92YWx1ZTIpKVxuICAgICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgICAxMCA+IF92YWx1ZTIubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyBfdmFsdWUyLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIF92YWx1ZTJcbiAgICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcIi4uLlwiKTtcbiAgICAgICAgICBvYmpLaW5kICs9IFwifVwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgPyBvYmpLaW5kXG4gICAgICAgIDogLTEgPCBzdGFydCAmJiAwIDwgbGVuZ3RoXG4gICAgICAgICAgPyAoKG9iamVjdE9yQXJyYXkgPSBcIiBcIi5yZXBlYXQoc3RhcnQpICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpLFxuICAgICAgICAgICAgXCJcXG4gIFwiICsgb2JqS2luZCArIFwiXFxuICBcIiArIG9iamVjdE9yQXJyYXkpXG4gICAgICAgICAgOiBcIlxcbiAgXCIgKyBvYmpLaW5kO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtdXJtdXJoYXNoM18zMl9nYyhrZXksIHNlZWQpIHtcbiAgICAgIHZhciByZW1haW5kZXIgPSBrZXkubGVuZ3RoICYgMztcbiAgICAgIHZhciBieXRlcyA9IGtleS5sZW5ndGggLSByZW1haW5kZXI7XG4gICAgICB2YXIgaDEgPSBzZWVkO1xuICAgICAgZm9yIChzZWVkID0gMDsgc2VlZCA8IGJ5dGVzOyApIHtcbiAgICAgICAgdmFyIGsxID1cbiAgICAgICAgICAoa2V5LmNoYXJDb2RlQXQoc2VlZCkgJiAyNTUpIHxcbiAgICAgICAgICAoKGtleS5jaGFyQ29kZUF0KCsrc2VlZCkgJiAyNTUpIDw8IDgpIHxcbiAgICAgICAgICAoKGtleS5jaGFyQ29kZUF0KCsrc2VlZCkgJiAyNTUpIDw8IDE2KSB8XG4gICAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK3NlZWQpICYgMjU1KSA8PCAyNCk7XG4gICAgICAgICsrc2VlZDtcbiAgICAgICAgazEgPVxuICAgICAgICAgICgzNDMyOTE4MzUzICogKGsxICYgNjU1MzUpICtcbiAgICAgICAgICAgICgoKDM0MzI5MTgzNTMgKiAoazEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmXG4gICAgICAgICAgNDI5NDk2NzI5NTtcbiAgICAgICAgazEgPSAoazEgPDwgMTUpIHwgKGsxID4+PiAxNyk7XG4gICAgICAgIGsxID1cbiAgICAgICAgICAoNDYxODQ1OTA3ICogKGsxICYgNjU1MzUpICtcbiAgICAgICAgICAgICgoKDQ2MTg0NTkwNyAqIChrMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgICA0Mjk0OTY3Mjk1O1xuICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgaDEgPSAoaDEgPDwgMTMpIHwgKGgxID4+PiAxOSk7XG4gICAgICAgIGgxID1cbiAgICAgICAgICAoNSAqIChoMSAmIDY1NTM1KSArICgoKDUgKiAoaDEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmIDQyOTQ5NjcyOTU7XG4gICAgICAgIGgxID0gKGgxICYgNjU1MzUpICsgMjc0OTIgKyAoKCgoaDEgPj4+IDE2KSArIDU4OTY0KSAmIDY1NTM1KSA8PCAxNik7XG4gICAgICB9XG4gICAgICBrMSA9IDA7XG4gICAgICBzd2l0Y2ggKHJlbWFpbmRlcikge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgazEgXj0gKGtleS5jaGFyQ29kZUF0KHNlZWQgKyAyKSAmIDI1NSkgPDwgMTY7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBrMSBePSAoa2V5LmNoYXJDb2RlQXQoc2VlZCArIDEpICYgMjU1KSA8PCA4O1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgKGsxIF49IGtleS5jaGFyQ29kZUF0KHNlZWQpICYgMjU1KSxcbiAgICAgICAgICAgIChrMSA9XG4gICAgICAgICAgICAgICgzNDMyOTE4MzUzICogKGsxICYgNjU1MzUpICtcbiAgICAgICAgICAgICAgICAoKCgzNDMyOTE4MzUzICogKGsxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJlxuICAgICAgICAgICAgICA0Mjk0OTY3Mjk1KSxcbiAgICAgICAgICAgIChrMSA9IChrMSA8PCAxNSkgfCAoazEgPj4+IDE3KSksXG4gICAgICAgICAgICAoaDEgXj1cbiAgICAgICAgICAgICAgKDQ2MTg0NTkwNyAqIChrMSAmIDY1NTM1KSArXG4gICAgICAgICAgICAgICAgKCgoNDYxODQ1OTA3ICogKGsxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJlxuICAgICAgICAgICAgICA0Mjk0OTY3Mjk1KTtcbiAgICAgIH1cbiAgICAgIGgxIF49IGtleS5sZW5ndGg7XG4gICAgICBoMSBePSBoMSA+Pj4gMTY7XG4gICAgICBoMSA9XG4gICAgICAgICgyMjQ2ODIyNTA3ICogKGgxICYgNjU1MzUpICtcbiAgICAgICAgICAoKCgyMjQ2ODIyNTA3ICogKGgxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJlxuICAgICAgICA0Mjk0OTY3Mjk1O1xuICAgICAgaDEgXj0gaDEgPj4+IDEzO1xuICAgICAgaDEgPVxuICAgICAgICAoMzI2NjQ4OTkwOSAqIChoMSAmIDY1NTM1KSArXG4gICAgICAgICAgKCgoMzI2NjQ4OTkwOSAqIChoMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgNDI5NDk2NzI5NTtcbiAgICAgIHJldHVybiAoaDEgXiAoaDEgPj4+IDE2KSkgPj4+IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICBcIk9iamVjdFwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSksICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcHJvdmlkZWQgYCVzYCBhdHRyaWJ1dGUgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdHlwZU5hbWUodmFsdWUpXG4gICAgICAgICAgKSxcbiAgICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbih2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGAlc2AgQ1NTIHByb3BlcnR5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICB0eXBlTmFtZSh2YWx1ZSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIEhUTUwgbWFya3VwIHVzZXMgYSB2YWx1ZSBvZiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAgIHR5cGVOYW1lKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSlcbiAgICAgICAgcmV0dXJuICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSAhMCk7XG4gICAgICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gITA7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYFwiLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyh0YWdOYW1lLCBwcm9wcykge1xuICAgICAgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fFxuICAgICAgICBwcm9wcy5vbkNoYW5nZSB8fFxuICAgICAgICBwcm9wcy5vbklucHV0IHx8XG4gICAgICAgIHByb3BzLnJlYWRPbmx5IHx8XG4gICAgICAgIHByb3BzLmRpc2FibGVkIHx8XG4gICAgICAgIG51bGwgPT0gcHJvcHMudmFsdWUgfHxcbiAgICAgICAgKFwic2VsZWN0XCIgPT09IHRhZ05hbWVcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuIGBvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgdGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCBzZXQgYG9uQ2hhbmdlYC5cIlxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiB0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsIHNldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLlwiXG4gICAgICAgICAgICApKTtcbiAgICAgIHByb3BzLm9uQ2hhbmdlIHx8XG4gICAgICAgIHByb3BzLnJlYWRPbmx5IHx8XG4gICAgICAgIHByb3BzLmRpc2FibGVkIHx8XG4gICAgICAgIG51bGwgPT0gcHJvcHMuY2hlY2tlZCB8fFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiB0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSQxKHRhZ05hbWUsIG5hbWUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXVxuICAgICAgKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBpZiAockFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdGFnTmFtZSA9IFwiYXJpYS1cIiArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGFnTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHRhZ05hbWUpID8gdGFnTmFtZSA6IG51bGw7XG4gICAgICAgIGlmIChudWxsID09IHRhZ05hbWUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKG5hbWUgIT09IHRhZ05hbWUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD9cIixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgdGFnTmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSkge1xuICAgICAgICB0YWdOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0YWdOYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkgPyB0YWdOYW1lIDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgPT0gdGFnTmFtZSkgcmV0dXJuICh3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSAhMCksICExO1xuICAgICAgICBuYW1lICE9PSB0YWdOYW1lICYmXG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlVua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/XCIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdGFnTmFtZVxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzKSB7XG4gICAgICB2YXIgaW52YWxpZFByb3BzID0gW10sXG4gICAgICAgIGtleTtcbiAgICAgIGZvciAoa2V5IGluIHByb3BzKVxuICAgICAgICB2YWxpZGF0ZVByb3BlcnR5JDEodHlwZSwga2V5KSB8fCBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgICAgcHJvcHMgPSBpbnZhbGlkUHJvcHNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgIHJldHVybiBcImBcIiArIHByb3AgKyBcImBcIjtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oXCIsIFwiKTtcbiAgICAgIDEgPT09IGludmFsaWRQcm9wcy5sZW5ndGhcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtYXJpYS1wcm9wc1wiLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgKVxuICAgICAgICA6IDEgPCBpbnZhbGlkUHJvcHMubGVuZ3RoICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1hcmlhLXByb3BzXCIsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBldmVudFJlZ2lzdHJ5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoXCJvbmZvY3VzaW5cIiA9PT0gbG93ZXJDYXNlZE5hbWUgfHwgXCJvbmZvY3Vzb3V0XCIgPT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiBBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0IGFyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgKChcImZvcm1cIiA9PT0gdGFnTmFtZSAmJiBcImFjdGlvblwiID09PSBuYW1lKSB8fFxuICAgICAgICAgIChcImlucHV0XCIgPT09IHRhZ05hbWUgJiYgXCJmb3JtQWN0aW9uXCIgPT09IG5hbWUpIHx8XG4gICAgICAgICAgKFwiYnV0dG9uXCIgPT09IHRhZ05hbWUgJiYgXCJmb3JtQWN0aW9uXCIgPT09IG5hbWUpKVxuICAgICAgKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBpZiAobnVsbCAhPSBldmVudFJlZ2lzdHJ5KSB7XG4gICAgICAgIHRhZ05hbWUgPSBldmVudFJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM7XG4gICAgICAgIGlmIChldmVudFJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBldmVudFJlZ2lzdHJ5ID0gdGFnTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgICA/IHRhZ05hbWVbbG93ZXJDYXNlZE5hbWVdXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPSBldmVudFJlZ2lzdHJ5KVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD9cIixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgZXZlbnRSZWdpc3RyeVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIFJlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAockFSSUEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsLnRlc3QobmFtZSkpIHJldHVybiAhMDtcbiAgICAgIGlmIChcImlubmVyaHRtbFwiID09PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKFwiYXJpYVwiID09PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gUGFzcyBpbmRpdmlkdWFsIGBhcmlhLWAgYXR0cmlidXRlcyBpbnN0ZWFkLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBcImlzXCIgPT09IGxvd2VyQ2FzZWROYW1lICYmXG4gICAgICAgIG51bGwgIT09IHZhbHVlICYmXG4gICAgICAgIHZvaWQgMCAhPT0gdmFsdWUgJiZcbiAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHZhbHVlXG4gICAgICApXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCB0aGUgdmFsdWUgdG8gYSBzdHJpbmcuXCIsXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWVcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHZhbHVlICYmIGlzTmFOKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCB0aGUgdmFsdWUgdG8gYSBzdHJpbmcuXCIsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgobG93ZXJDYXNlZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdKSxcbiAgICAgICAgICBsb3dlckNhc2VkTmFtZSAhPT0gbmFtZSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgP1wiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBsb3dlckNhc2VkTmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91IGludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSBhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuIElmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuXCIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgbG93ZXJDYXNlZE5hbWVcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcInJlZlwiOlxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY2FzZSBcImlubmVyVGV4dFwiOlxuICAgICAgICBjYXNlIFwidGV4dENvbnRlbnRcIjpcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImF1dG9Gb2N1c1wiOlxuICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgY2FzZSBcIm11dGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjb250ZW50RWRpdGFibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzcGVsbENoZWNrXCI6XG4gICAgICAgICAgICBjYXNlIFwiZHJhZ2dhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJhdXRvUmV2ZXJzZVwiOlxuICAgICAgICAgICAgY2FzZSBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmb2N1c2FibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwcmVzZXJ2ZUFscGhhXCI6XG4gICAgICAgICAgICBjYXNlIFwiYWxsb3dGdWxsU2NyZWVuXCI6XG4gICAgICAgICAgICBjYXNlIFwiYXN5bmNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJhdXRvUGxheVwiOlxuICAgICAgICAgICAgY2FzZSBcImNvbnRyb2xzXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICAgICAgY2FzZSBcImRlZmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGlzYWJsZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiOlxuICAgICAgICAgICAgY2FzZSBcImRpc2FibGVSZW1vdGVQbGF5YmFja1wiOlxuICAgICAgICAgICAgY2FzZSBcImZvcm1Ob1ZhbGlkYXRlXCI6XG4gICAgICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgICBjYXNlIFwibG9vcFwiOlxuICAgICAgICAgICAgY2FzZSBcIm5vTW9kdWxlXCI6XG4gICAgICAgICAgICBjYXNlIFwibm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJwbGF5c0lubGluZVwiOlxuICAgICAgICAgICAgY2FzZSBcInJlYWRPbmx5XCI6XG4gICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyZXZlcnNlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInNjb3BlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInNlYW1sZXNzXCI6XG4gICAgICAgICAgICBjYXNlIFwiaXRlbVNjb3BlXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2FwdHVyZVwiOlxuICAgICAgICAgICAgY2FzZSBcImRvd25sb2FkXCI6XG4gICAgICAgICAgICBjYXNlIFwiaW5lcnRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgICAgIGlmIChcImRhdGEtXCIgPT09IGxvd2VyQ2FzZWROYW1lIHx8IFwiYXJpYS1cIiA9PT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAlcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAlcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbklmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCBwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgcmV0dXJuICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApLCAhMTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIGlmIChcImZhbHNlXCIgPT09IHZhbHVlIHx8IFwidHJ1ZVwiID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGVja2VkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm11dGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhbGxvd0Z1bGxTY3JlZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImFzeW5jXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhdXRvUGxheVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiY29udHJvbHNcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRlZmVyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRpc2FibGVSZW1vdGVQbGF5YmFja1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiZm9ybU5vVmFsaWRhdGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwibG9vcFwiOlxuICAgICAgICAgICAgICBjYXNlIFwibm9Nb2R1bGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm5vVmFsaWRhdGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcInBsYXlzSW5saW5lXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJyZWFkT25seVwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInJldmVyc2VkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzY29wZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNlYW1sZXNzXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJpdGVtU2NvcGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImluZXJ0XCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAlcyBEaWQgeW91IG1lYW4gJXM9eyVzfT9cIixcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIFwiZmFsc2VcIiA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICA/IFwiVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuXCJcbiAgICAgICAgICAgICAgICA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gICAgICB2YXIgdW5rbm93blByb3BzID0gW10sXG4gICAgICAgIGtleTtcbiAgICAgIGZvciAoa2V5IGluIHByb3BzKVxuICAgICAgICB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSwgcHJvcHNba2V5XSwgZXZlbnRSZWdpc3RyeSkgfHxcbiAgICAgICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgICAgcHJvcHMgPSB1bmtub3duUHJvcHNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgIHJldHVybiBcImBcIiArIHByb3AgKyBcImBcIjtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oXCIsIFwiKTtcbiAgICAgIDEgPT09IHVua25vd25Qcm9wcy5sZW5ndGhcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsIG9yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciBcIixcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIClcbiAgICAgICAgOiAxIDwgdW5rbm93blByb3BzLmxlbmd0aCAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsIG9yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yIFwiLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgICAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCkge1xuICAgICAgaWYgKFxuICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHRleHQgfHxcbiAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHRleHQgfHxcbiAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHRleHRcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiXCIgKyB0ZXh0O1xuICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24odGV4dCk7XG4gICAgICB0ZXh0ID0gXCJcIiArIHRleHQ7XG4gICAgICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyh0ZXh0KTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgaHRtbCA9IFwiXCIsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gMDtcbiAgICAgICAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHRleHQubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgc3dpdGNoICh0ZXh0LmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICBtYXRjaCA9IFwiJnF1b3Q7XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBcIiZhbXA7XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBcIiYjeDI3O1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjA6XG4gICAgICAgICAgICAgIG1hdGNoID0gXCImbHQ7XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBcIiZndDtcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdEluZGV4ICE9PSBpbmRleCAmJiAoaHRtbCArPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgaHRtbCArPSBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpIHtcbiAgICAgIHJldHVybiBpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KFwiXCIgKyB1cmwpXG4gICAgICAgID8gXCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcignUmVhY3QgaGFzIGJsb2NrZWQgYSBqYXZhc2NyaXB0OiBVUkwgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLicpXCJcbiAgICAgICAgOiB1cmw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUVudGlyZUlubGluZVNjcmlwdENvbnRlbnQoc2NyaXB0VGV4dCkge1xuICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oc2NyaXB0VGV4dCk7XG4gICAgICByZXR1cm4gKFwiXCIgKyBzY3JpcHRUZXh0KS5yZXBsYWNlKHNjcmlwdFJlZ2V4LCBzY3JpcHRSZXBsYWNlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlc3VtYWJsZVN0YXRlKFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZyxcbiAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgICBib290c3RyYXBTY3JpcHRzLFxuICAgICAgYm9vdHN0cmFwTW9kdWxlc1xuICAgICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWRQcmVmaXg6IHZvaWQgMCA9PT0gaWRlbnRpZmllclByZWZpeCA/IFwiXCIgOiBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgICBuZXh0Rm9ybUlEOiAwLFxuICAgICAgICBzdHJlYW1pbmdGb3JtYXQ6IDAsXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQ6IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHM6IGJvb3RzdHJhcFNjcmlwdHMsXG4gICAgICAgIGJvb3RzdHJhcE1vZHVsZXM6IGJvb3RzdHJhcE1vZHVsZXMsXG4gICAgICAgIGluc3RydWN0aW9uczogTm90aGluZ1NlbnQsXG4gICAgICAgIGhhc0JvZHk6ICExLFxuICAgICAgICBoYXNIdG1sOiAhMSxcbiAgICAgICAgdW5rbm93blJlc291cmNlczoge30sXG4gICAgICAgIGRuc1Jlc291cmNlczoge30sXG4gICAgICAgIGNvbm5lY3RSZXNvdXJjZXM6IHsgZGVmYXVsdDoge30sIGFub255bW91czoge30sIGNyZWRlbnRpYWxzOiB7fSB9LFxuICAgICAgICBpbWFnZVJlc291cmNlczoge30sXG4gICAgICAgIHN0eWxlUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgc2NyaXB0UmVzb3VyY2VzOiB7fSxcbiAgICAgICAgbW9kdWxlVW5rbm93blJlc291cmNlczoge30sXG4gICAgICAgIG1vZHVsZVNjcmlwdFJlc291cmNlczoge31cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVByZWFtYmxlU3RhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBodG1sQ2h1bmtzOiBudWxsLFxuICAgICAgICBoZWFkQ2h1bmtzOiBudWxsLFxuICAgICAgICBib2R5Q2h1bmtzOiBudWxsLFxuICAgICAgICBjb250cmlidXRpb246IE5vQ29udHJpYnV0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGb3JtYXRDb250ZXh0KGluc2VydGlvbk1vZGUsIHNlbGVjdGVkVmFsdWUsIHRhZ1Njb3BlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNlcnRpb25Nb2RlOiBpbnNlcnRpb25Nb2RlLFxuICAgICAgICBzZWxlY3RlZFZhbHVlOiBzZWxlY3RlZFZhbHVlLFxuICAgICAgICB0YWdTY29wZTogdGFnU2NvcGVcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENoaWxkRm9ybWF0Q29udGV4dChwYXJlbnRDb250ZXh0LCB0eXBlLCBwcm9wcykge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJub3NjcmlwdFwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgSFRNTF9NT0RFLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGUgfCAxXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgSFRNTF9NT0RFLFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy52YWx1ZSA/IHByb3BzLnZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJzdmdcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChTVkdfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gICAgICAgIGNhc2UgXCJwaWN0dXJlXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX01PREUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZSB8IDJcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwibWF0aFwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KE1BVEhNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcbiAgICAgICAgY2FzZSBcImZvcmVpZ25PYmplY3RcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuICAgICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfVEFCTEVfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgICAgICBjYXNlIFwidGZvb3RcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfVEFCTEVfQk9EWV9NT0RFLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGVcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfQ09MR1JPVVBfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX1RBQkxFX1JPV19NT0RFLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGVcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgICAgIGlmIChwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPCBIVE1MX01PREUpXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgICAgSFRNTF9IRUFEX01PREUsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgICAgaWYgKHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gUk9PVF9IVE1MX01PREUpXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgICAgSFRNTF9IVE1MX01PREUsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGVcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlID49IEhUTUxfVEFCTEVfTU9ERSB8fFxuICAgICAgICBwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPCBIVE1MX01PREVcbiAgICAgICAgPyBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSlcbiAgICAgICAgOiBwYXJlbnRDb250ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3R5bGVBdHRyaWJ1dGUodGFyZ2V0LCBzdHlsZSkge1xuICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBzdHlsZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiB1c2luZyBKU1guXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBpc0ZpcnN0ID0gITAsXG4gICAgICAgIHN0eWxlTmFtZTtcbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIHN0eWxlKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzdHlsZSwgc3R5bGVOYW1lKSkge1xuICAgICAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVbc3R5bGVOYW1lXTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsICE9IHN0eWxlVmFsdWUgJiZcbiAgICAgICAgICAgIFwiYm9vbGVhblwiICE9PSB0eXBlb2Ygc3R5bGVWYWx1ZSAmJlxuICAgICAgICAgICAgXCJcIiAhPT0gc3R5bGVWYWx1ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKDAgPT09IHN0eWxlTmFtZS5pbmRleE9mKFwiLS1cIikpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWVDaHVuayA9IGVzY2FwZVRleHRGb3JCcm93c2VyKHN0eWxlTmFtZSk7XG4gICAgICAgICAgICAgIGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbihzdHlsZVZhbHVlLCBzdHlsZU5hbWUpO1xuICAgICAgICAgICAgICBzdHlsZVZhbHVlID0gZXNjYXBlVGV4dEZvckJyb3dzZXIoKFwiXCIgKyBzdHlsZVZhbHVlKS50cmltKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmFtZUNodW5rID0gc3R5bGVOYW1lO1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVZhbHVlO1xuICAgICAgICAgICAgICBpZiAoLTEgPCBuYW1lQ2h1bmsuaW5kZXhPZihcIi1cIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVDaHVuaztcbiAgICAgICAgICAgICAgICAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkgfHxcbiAgICAgICAgICAgICAgICAgICgod2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz9cIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY2FtZWxpemUobmFtZS5yZXBsYWNlKG1zUGF0dGVybiQxLCBcIm1zLVwiKSlcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWVDaHVuaykpXG4gICAgICAgICAgICAgICAgKG5hbWUgPSBuYW1lQ2h1bmspLFxuICAgICAgICAgICAgICAgICAgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKCh3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gITApLFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/XCIsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVDaHVuaztcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUkanNjb21wJDAgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUkanNjb21wJDApICYmXG4gICAgICAgICAgICAgICAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZSRqc2NvbXAkMF0pIHx8XG4gICAgICAgICAgICAgICAgICAoKHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlJGpzY29tcCQwXSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkblxcJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgIChpc05hTih2YWx1ZSlcbiAgICAgICAgICAgICAgICAgID8gd2FybmVkRm9yTmFOVmFsdWUgfHxcbiAgICAgICAgICAgICAgICAgICAgKCh3YXJuZWRGb3JOYU5WYWx1ZSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImBOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS5cIixcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgIDogaXNGaW5pdGUodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIHdhcm5lZEZvckluZmluaXR5VmFsdWUgfHxcbiAgICAgICAgICAgICAgICAgICAgKCh3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gITApLFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZUNodW5rXG4gICAgICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgICAgICAgbmFtZUNodW5rID0gc3R5bGVOYW1lO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHN0eWxlTmFtZUNhY2hlLmdldChuYW1lQ2h1bmspO1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IHZhbHVlXG4gICAgICAgICAgICAgICAgPyAobmFtZUNodW5rID0gdmFsdWUpXG4gICAgICAgICAgICAgICAgOiAoKHZhbHVlID0gZXNjYXBlVGV4dEZvckJyb3dzZXIoXG4gICAgICAgICAgICAgICAgICAgIG5hbWVDaHVua1xuICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sIFwiLSQxXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShtc1BhdHRlcm4sIFwiLW1zLVwiKVxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICBzdHlsZU5hbWVDYWNoZS5zZXQobmFtZUNodW5rLCB2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAobmFtZUNodW5rID0gdmFsdWUpKTtcbiAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHN0eWxlVmFsdWVcbiAgICAgICAgICAgICAgICA/IChzdHlsZVZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gc3R5bGVWYWx1ZSB8fCB1bml0bGVzc051bWJlcnMuaGFzKHN0eWxlTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiXCIgKyBzdHlsZVZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgOiBzdHlsZVZhbHVlICsgXCJweFwiKVxuICAgICAgICAgICAgICAgIDogKGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbihzdHlsZVZhbHVlLCBzdHlsZU5hbWUpLFxuICAgICAgICAgICAgICAgICAgKHN0eWxlVmFsdWUgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcihcbiAgICAgICAgICAgICAgICAgICAgKFwiXCIgKyBzdHlsZVZhbHVlKS50cmltKClcbiAgICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzRmlyc3RcbiAgICAgICAgICAgICAgPyAoKGlzRmlyc3QgPSAhMSksXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgICAgICBzdHlsZUF0dHJpYnV0ZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgbmFtZUNodW5rLFxuICAgICAgICAgICAgICAgICAgc3R5bGVBc3NpZ24sXG4gICAgICAgICAgICAgICAgICBzdHlsZVZhbHVlXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgOiB0YXJnZXQucHVzaChzdHlsZVNlcGFyYXRvciwgbmFtZUNodW5rLCBzdHlsZUFzc2lnbiwgc3R5bGVWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBpc0ZpcnN0IHx8IHRhcmdldC5wdXNoKGF0dHJpYnV0ZUVuZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhbHVlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIG5hbWUsIGF0dHJpYnV0ZUVtcHR5U3RyaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgXCJib29sZWFuXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpLFxuICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCh2YWx1ZSwga2V5KSB7XG4gICAgICB0aGlzLnB1c2goJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCInKTtcbiAgICAgIHZhbGlkYXRlQWRkaXRpb25hbEZvcm1GaWVsZCh2YWx1ZSk7XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRoaXMsIFwibmFtZVwiLCBrZXkpO1xuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0aGlzLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgIHRoaXMucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxGb3JtRmllbGQodmFsdWUpIHtcbiAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2YgdmFsdWUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRmlsZS9CbG9iIGZpZWxkcyBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gcHJvZ3Jlc3NpdmUgZm9ybXMuIFdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IGh5ZHJhdGlvbi5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXN0b21Gb3JtRmllbGRzKHJlc3VtYWJsZVN0YXRlLCBmb3JtQWN0aW9uKSB7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm9ybUFjdGlvbi4kJEZPUk1fQUNUSU9OKSB7XG4gICAgICAgIHZhciBpZCA9IHJlc3VtYWJsZVN0YXRlLm5leHRGb3JtSUQrKztcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZXN1bWFibGVTdGF0ZS5pZFByZWZpeCArIGlkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBmb3JtQWN0aW9uLiQkRk9STV9BQ1RJT04ocmVzdW1hYmxlU3RhdGUpO1xuICAgICAgICAgIGlmIChjdXN0b21GaWVsZHMpIHtcbiAgICAgICAgICAgIHZhciBmb3JtRGF0YSA9IGN1c3RvbUZpZWxkcy5kYXRhO1xuICAgICAgICAgICAgbnVsbCAhPSBmb3JtRGF0YSAmJiBmb3JtRGF0YS5mb3JFYWNoKHZhbGlkYXRlQWRkaXRpb25hbEZvcm1GaWVsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjdXN0b21GaWVsZHM7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0geCAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeC50aGVuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdGhyb3cgeDtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJGYWlsZWQgdG8gc2VyaWFsaXplIGFuIGFjdGlvbiBmb3IgcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQ6XFxuJXNcIixcbiAgICAgICAgICAgIHhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUoXG4gICAgICB0YXJnZXQsXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1UYXJnZXQsXG4gICAgICBuYW1lXG4gICAgKSB7XG4gICAgICB2YXIgZm9ybURhdGEgPSBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZvcm1BY3Rpb24pIHtcbiAgICAgICAgbnVsbCA9PT0gbmFtZSB8fFxuICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSB8fFxuICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25OYW1lID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQ2Fubm90IHNwZWNpZnkgYSBcIm5hbWVcIiBwcm9wIGZvciBhIGJ1dHRvbiB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIGEgZm9ybUFjdGlvbi4gUmVhY3QgbmVlZHMgaXQgdG8gZW5jb2RlIHdoaWNoIGFjdGlvbiBzaG91bGQgYmUgaW52b2tlZC4gSXQgd2lsbCBnZXQgb3ZlcnJpZGRlbi4nXG4gICAgICAgICAgKSk7XG4gICAgICAgIChudWxsID09PSBmb3JtRW5jVHlwZSAmJiBudWxsID09PSBmb3JtTWV0aG9kKSB8fFxuICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kIHx8XG4gICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIGZvcm1FbmNUeXBlIG9yIGZvcm1NZXRob2QgZm9yIGEgYnV0dG9uIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiBSZWFjdCBwcm92aWRlcyB0aG9zZSBhdXRvbWF0aWNhbGx5LiBUaGV5IHdpbGwgZ2V0IG92ZXJyaWRkZW4uXCJcbiAgICAgICAgICApKTtcbiAgICAgICAgbnVsbCA9PT0gZm9ybVRhcmdldCB8fFxuICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0IHx8XG4gICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvblRhcmdldCA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIGZvcm1UYXJnZXQgZm9yIGEgYnV0dG9uIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiBUaGUgZnVuY3Rpb24gd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgd2luZG93LlwiXG4gICAgICAgICAgKSk7XG4gICAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBnZXRDdXN0b21Gb3JtRmllbGRzKHJlc3VtYWJsZVN0YXRlLCBmb3JtQWN0aW9uKTtcbiAgICAgICAgbnVsbCAhPT0gY3VzdG9tRmllbGRzXG4gICAgICAgICAgPyAoKG5hbWUgPSBjdXN0b21GaWVsZHMubmFtZSksXG4gICAgICAgICAgICAoZm9ybUFjdGlvbiA9IGN1c3RvbUZpZWxkcy5hY3Rpb24gfHwgXCJcIiksXG4gICAgICAgICAgICAoZm9ybUVuY1R5cGUgPSBjdXN0b21GaWVsZHMuZW5jVHlwZSksXG4gICAgICAgICAgICAoZm9ybU1ldGhvZCA9IGN1c3RvbUZpZWxkcy5tZXRob2QpLFxuICAgICAgICAgICAgKGZvcm1UYXJnZXQgPSBjdXN0b21GaWVsZHMudGFyZ2V0KSxcbiAgICAgICAgICAgIChmb3JtRGF0YSA9IGN1c3RvbUZpZWxkcy5kYXRhKSlcbiAgICAgICAgICA6ICh0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICBcImZvcm1BY3Rpb25cIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICBhY3Rpb25KYXZhU2NyaXB0VVJMLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZm9ybVRhcmdldCA9IGZvcm1NZXRob2QgPSBmb3JtRW5jVHlwZSA9IGZvcm1BY3Rpb24gPSBuYW1lID0gbnVsbCksXG4gICAgICAgICAgICBpbmplY3RGb3JtUmVwbGF5aW5nUnVudGltZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpKTtcbiAgICAgIH1cbiAgICAgIG51bGwgIT0gbmFtZSAmJiBwdXNoQXR0cmlidXRlKHRhcmdldCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgbnVsbCAhPSBmb3JtQWN0aW9uICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcImZvcm1BY3Rpb25cIiwgZm9ybUFjdGlvbik7XG4gICAgICBudWxsICE9IGZvcm1FbmNUeXBlICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcImZvcm1FbmNUeXBlXCIsIGZvcm1FbmNUeXBlKTtcbiAgICAgIG51bGwgIT0gZm9ybU1ldGhvZCAmJiBwdXNoQXR0cmlidXRlKHRhcmdldCwgXCJmb3JtTWV0aG9kXCIsIGZvcm1NZXRob2QpO1xuICAgICAgbnVsbCAhPSBmb3JtVGFyZ2V0ICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcImZvcm1UYXJnZXRcIiwgZm9ybVRhcmdldCk7XG4gICAgICByZXR1cm4gZm9ybURhdGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJjbGFzc05hbWVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJjbGFzc1wiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0YWJJbmRleFwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInRhYmluZGV4XCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRpclwiOlxuICAgICAgICBjYXNlIFwicm9sZVwiOlxuICAgICAgICBjYXNlIFwidmlld0JveFwiOlxuICAgICAgICBjYXNlIFwid2lkdGhcIjpcbiAgICAgICAgY2FzZSBcImhlaWdodFwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNyY1wiOlxuICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgIGlmIChcIlwiID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgXCJzcmNcIiA9PT0gbmFtZVxuICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnQW4gZW1wdHkgc3RyaW5nIChcIlwiKSB3YXMgcGFzc2VkIHRvIHRoZSAlcyBhdHRyaWJ1dGUuIFRoaXMgbWF5IGNhdXNlIHRoZSBicm93c2VyIHRvIGRvd25sb2FkIHRoZSB3aG9sZSBwYWdlIGFnYWluIG92ZXIgdGhlIG5ldHdvcmsuIFRvIGZpeCB0aGlzLCBlaXRoZXIgZG8gbm90IHJlbmRlciB0aGUgZWxlbWVudCBhdCBhbGwgb3IgcGFzcyBudWxsIHRvICVzIGluc3RlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ0FuIGVtcHR5IHN0cmluZyAoXCJcIikgd2FzIHBhc3NlZCB0byB0aGUgJXMgYXR0cmlidXRlLiBUbyBmaXggdGhpcywgZWl0aGVyIGRvIG5vdCByZW5kZXIgdGhlIGVsZW1lbnQgYXQgYWxsIG9yIHBhc3MgbnVsbCB0byAlcyBpbnN0ZWFkIG9mIGFuIGVtcHR5IHN0cmluZy4nLFxuICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYWN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJmb3JtQWN0aW9uXCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCA9PSB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIG5hbWUpO1xuICAgICAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSksXG4gICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgICAgICBjYXNlIFwiaW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwicmVmXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhdXRvRm9jdXNcIjpcbiAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgIGNhc2UgXCJtdXRlZFwiOlxuICAgICAgICAgIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua0hyZWZcIjpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTChcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgXCJ4bGluazpocmVmXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSksXG4gICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY29udGVudEVkaXRhYmxlXCI6XG4gICAgICAgIGNhc2UgXCJzcGVsbENoZWNrXCI6XG4gICAgICAgIGNhc2UgXCJkcmFnZ2FibGVcIjpcbiAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJhdXRvUmV2ZXJzZVwiOlxuICAgICAgICBjYXNlIFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiOlxuICAgICAgICBjYXNlIFwiZm9jdXNhYmxlXCI6XG4gICAgICAgIGNhc2UgXCJwcmVzZXJ2ZUFscGhhXCI6XG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImluZXJ0XCI6XG4gICAgICAgICAgXCJcIiAhPT0gdmFsdWUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JOZXdCb29sZWFuUHJvcHNXaXRoRW1wdHlWYWx1ZVtuYW1lXSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuRm9yTmV3Qm9vbGVhblByb3BzV2l0aEVtcHR5VmFsdWVbbmFtZV0gPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIGVtcHR5IHN0cmluZyBmb3IgYSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiBUaGlzIHdpbGwgdHJlYXQgdGhlIGF0dHJpYnV0ZSBhcyBpZiBpdCB3ZXJlIGZhbHNlLiBFaXRoZXIgcGFzcyBgZmFsc2VgIHRvIHNpbGVuY2UgdGhpcyB3YXJuaW5nLCBvciBwYXNzIGB0cnVlYCBpZiB5b3UgdXNlZCBhbiBlbXB0eSBzdHJpbmcgaW4gZWFybGllciB2ZXJzaW9ucyBvZiBSZWFjdCB0byBpbmRpY2F0ZSB0aGlzIGF0dHJpYnV0ZSBpcyB0cnVlLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApKTtcbiAgICAgICAgY2FzZSBcImFsbG93RnVsbFNjcmVlblwiOlxuICAgICAgICBjYXNlIFwiYXN5bmNcIjpcbiAgICAgICAgY2FzZSBcImF1dG9QbGF5XCI6XG4gICAgICAgIGNhc2UgXCJjb250cm9sc1wiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICBjYXNlIFwiZGVmZXJcIjpcbiAgICAgICAgY2FzZSBcImRpc2FibGVkXCI6XG4gICAgICAgIGNhc2UgXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiOlxuICAgICAgICBjYXNlIFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCI6XG4gICAgICAgIGNhc2UgXCJmb3JtTm9WYWxpZGF0ZVwiOlxuICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgIGNhc2UgXCJsb29wXCI6XG4gICAgICAgIGNhc2UgXCJub01vZHVsZVwiOlxuICAgICAgICBjYXNlIFwibm9WYWxpZGF0ZVwiOlxuICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICBjYXNlIFwicGxheXNJbmxpbmVcIjpcbiAgICAgICAgY2FzZSBcInJlYWRPbmx5XCI6XG4gICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICBjYXNlIFwicmV2ZXJzZWRcIjpcbiAgICAgICAgY2FzZSBcInNjb3BlZFwiOlxuICAgICAgICBjYXNlIFwic2VhbWxlc3NcIjpcbiAgICAgICAgY2FzZSBcIml0ZW1TY29wZVwiOlxuICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIG5hbWUsIGF0dHJpYnV0ZUVtcHR5U3RyaW5nKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhcHR1cmVcIjpcbiAgICAgICAgY2FzZSBcImRvd25sb2FkXCI6XG4gICAgICAgICAgITAgPT09IHZhbHVlXG4gICAgICAgICAgICA/IHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgbmFtZSwgYXR0cmlidXRlRW1wdHlTdHJpbmcpXG4gICAgICAgICAgICA6ICExICE9PSB2YWx1ZSAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNvbHNcIjpcbiAgICAgICAgY2FzZSBcInJvd3NcIjpcbiAgICAgICAgY2FzZSBcInNpemVcIjpcbiAgICAgICAgY2FzZSBcInNwYW5cIjpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAhaXNOYU4odmFsdWUpICYmXG4gICAgICAgICAgICAxIDw9IHZhbHVlICYmXG4gICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicm93U3BhblwiOlxuICAgICAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBpc05hTih2YWx1ZSkgfHxcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua0FjdHVhdGVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bGluazphY3R1YXRlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rQXJjcm9sZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhsaW5rOmFyY3JvbGVcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtSb2xlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6cm9sZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua1Nob3dcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bGluazpzaG93XCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rVGl0bGVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bGluazp0aXRsZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua1R5cGVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bGluazp0eXBlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhtbEJhc2VcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bWw6YmFzZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bWxMYW5nXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieG1sOmxhbmdcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieG1sU3BhY2VcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bWw6c3BhY2VcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEoMiA8IG5hbWUubGVuZ3RoKSB8fFxuICAgICAgICAgICAgKFwib1wiICE9PSBuYW1lWzBdICYmIFwiT1wiICE9PSBuYW1lWzBdKSB8fFxuICAgICAgICAgICAgKFwiblwiICE9PSBuYW1lWzFdICYmIFwiTlwiICE9PSBuYW1lWzFdKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChuYW1lID0gYWxpYXNlcy5nZXQobmFtZSkgfHwgbmFtZSksIGlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJkYXRhLVwiICE9PSBwcmVmaXggJiYgXCJhcmlhLVwiICE9PSBwcmVmaXgpIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbikge1xuICAgICAgaWYgKG51bGwgIT0gaW5uZXJIVE1MKSB7XG4gICAgICAgIGlmIChudWxsICE9IGNoaWxkcmVuKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgaW5uZXJIVE1MIHx8ICEoXCJfX2h0bWxcIiBpbiBpbm5lckhUTUwpKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGlubmVySFRNTCA9IGlubmVySFRNTC5fX2h0bWw7XG4gICAgICAgIG51bGwgIT09IGlubmVySFRNTCAmJlxuICAgICAgICAgIHZvaWQgMCAhPT0gaW5uZXJIVE1MICYmXG4gICAgICAgICAgKGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGlubmVySFRNTCksIHRhcmdldC5wdXNoKFwiXCIgKyBpbm5lckhUTUwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wKHByb3BzLCBwcm9wTmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAoKHZhbHVlID0gaXNBcnJheUltcGwodmFsdWUpKSxcbiAgICAgICAgcHJvcHMubXVsdGlwbGUgJiYgIXZhbHVlXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiBgbXVsdGlwbGVgIGlzIHRydWUuXCIsXG4gICAgICAgICAgICAgIHByb3BOYW1lXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiAhcHJvcHMubXVsdGlwbGUgJiZcbiAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciB2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLlwiLFxuICAgICAgICAgICAgICBwcm9wTmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5PcHRpb25DaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIG51bGwgIT0gY2hpbGQgJiZcbiAgICAgICAgICAoKGNvbnRlbnQgKz0gY2hpbGQpLFxuICAgICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gfHxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZCB8fFxuICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNoaWxkIHx8XG4gICAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgY2hpbGQgfHxcbiAgICAgICAgICAgICgoZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IGluZmVyIHRoZSBvcHRpb24gdmFsdWUgb2YgY29tcGxleCBjaGlsZHJlbi4gUGFzcyBhIGB2YWx1ZWAgcHJvcCBvciB1c2UgYSBwbGFpbiBzdHJpbmcgYXMgY2hpbGRyZW4gdG8gPG9wdGlvbj4uXCJcbiAgICAgICAgICAgICkpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICAgICAgKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIDE2KSA9PT0gTm90aGluZ1NlbnQgJiZcbiAgICAgICAgKChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gMTYpLFxuICAgICAgICByZW5kZXJTdGF0ZS5ib290c3RyYXBDaHVua3MudW5zaGlmdChcbiAgICAgICAgICByZW5kZXJTdGF0ZS5zdGFydElubGluZVNjcmlwdCxcbiAgICAgICAgICBmb3JtUmVwbGF5aW5nUnVudGltZVNjcmlwdCxcbiAgICAgICAgICBcIlxceDNjL3NjcmlwdD5cIlxuICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaExpbmtJbXBsKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJsaW5rXCIpKTtcbiAgICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJsaW5rIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZVN0eWxlVGV4dENvbnRlbnQoc3R5bGVUZXh0KSB7XG4gICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihzdHlsZVRleHQpO1xuICAgICAgcmV0dXJuIChcIlwiICsgc3R5bGVUZXh0KS5yZXBsYWNlKHN0eWxlUmVnZXgsIHN0eWxlUmVwbGFjZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICAgICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICB0YWcgK1xuICAgICAgICAgICAgICAgICAgICBcIiBpcyBhIHNlbGYtY2xvc2luZyB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVGl0bGVJbXBsKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJ0aXRsZVwiKSk7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBudWxsLFxuICAgICAgICBpbm5lckhUTUwgPSBudWxsLFxuICAgICAgICBwcm9wS2V5O1xuICAgICAgZm9yIChwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgcHJvcHMgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgICA/IDIgPiBjaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICA/IGNoaWxkcmVuWzBdXG4gICAgICAgICAgOiBudWxsXG4gICAgICAgIDogY2hpbGRyZW47XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwcm9wcyAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgcHJvcHMgJiZcbiAgICAgICAgbnVsbCAhPT0gcHJvcHMgJiZcbiAgICAgICAgdm9pZCAwICE9PSBwcm9wcyAmJlxuICAgICAgICB0YXJnZXQucHVzaChlc2NhcGVUZXh0Rm9yQnJvd3NlcihcIlwiICsgcHJvcHMpKTtcbiAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgICAgIHRhcmdldC5wdXNoKGVuZENodW5rRm9yVGFnKFwidGl0bGVcIikpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTY3JpcHRJbXBsKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJzY3JpcHRcIikpO1xuICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbCxcbiAgICAgICAgaW5uZXJIVE1MID0gbnVsbCxcbiAgICAgICAgcHJvcEtleTtcbiAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgIG51bGwgIT0gY2hpbGRyZW4gJiZcbiAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGNoaWxkcmVuICYmXG4gICAgICAgICgocHJvcHMgPVxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjaGlsZHJlblxuICAgICAgICAgICAgPyBcImEgbnVtYmVyIGZvciBjaGlsZHJlblwiXG4gICAgICAgICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgICAgICAgID8gXCJhbiBhcnJheSBmb3IgY2hpbGRyZW5cIlxuICAgICAgICAgICAgICA6IFwic29tZXRoaW5nIHVuZXhwZWN0ZWQgZm9yIGNoaWxkcmVuXCIpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSBzY3JpcHQgZWxlbWVudCB3YXMgcmVuZGVyZWQgd2l0aCAlcy4gSWYgc2NyaXB0IGVsZW1lbnQgaGFzIGNoaWxkcmVuIGl0IG11c3QgYmUgYSBzaW5nbGUgc3RyaW5nLiBDb25zaWRlciB1c2luZyBkYW5nZXJvdXNseVNldElubmVySFRNTCBvciBwYXNzaW5nIGEgcGxhaW4gc3RyaW5nIGFzIGNoaWxkcmVuLlwiLFxuICAgICAgICAgIHByb3BzXG4gICAgICAgICkpO1xuICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNoaWxkcmVuICYmXG4gICAgICAgIHRhcmdldC5wdXNoKGVzY2FwZUVudGlyZUlubGluZVNjcmlwdENvbnRlbnQoY2hpbGRyZW4pKTtcbiAgICAgIHRhcmdldC5wdXNoKGVuZENodW5rRm9yVGFnKFwic2NyaXB0XCIpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3RhcnRTaW5nbGV0b25FbGVtZW50KHRhcmdldCwgcHJvcHMsIHRhZykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyh0YWcpKTtcbiAgICAgIHZhciBpbm5lckhUTUwgPSAodGFnID0gbnVsbCksXG4gICAgICAgIHByb3BLZXk7XG4gICAgICBmb3IgKHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgdGFnID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgdGFnKTtcbiAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHRhcmdldCwgcHJvcHMsIHRhZykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyh0YWcpKTtcbiAgICAgIHZhciBpbm5lckhUTUwgPSAodGFnID0gbnVsbCksXG4gICAgICAgIHByb3BLZXk7XG4gICAgICBmb3IgKHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgdGFnID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgdGFnKTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiID09PSB0eXBlb2YgdGFnXG4gICAgICAgID8gKHRhcmdldC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKHRhZykpLCBudWxsKVxuICAgICAgICA6IHRhZztcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRDaHVua0ZvclRhZyh0YWcpIHtcbiAgICAgIHZhciB0YWdTdGFydENodW5rID0gdmFsaWRhdGVkVGFnQ2FjaGUuZ2V0KHRhZyk7XG4gICAgICBpZiAodm9pZCAwID09PSB0YWdTdGFydENodW5rKSB7XG4gICAgICAgIGlmICghVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHRhZzogXCIgKyB0YWcpO1xuICAgICAgICB0YWdTdGFydENodW5rID0gXCI8XCIgKyB0YWc7XG4gICAgICAgIHZhbGlkYXRlZFRhZ0NhY2hlLnNldCh0YWcsIHRhZ1N0YXJ0Q2h1bmspO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhZ1N0YXJ0Q2h1bms7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdGFydEluc3RhbmNlKFxuICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIHByZWFtYmxlU3RhdGUsXG4gICAgICBob2lzdGFibGVTdGF0ZSxcbiAgICAgIGZvcm1hdENvbnRleHQsXG4gICAgICB0ZXh0RW1iZWRkZWQsXG4gICAgICBpc0ZhbGxiYWNrXG4gICAgKSB7XG4gICAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcyk7XG4gICAgICAoXCJpbnB1dFwiICE9PSB0eXBlICYmIFwidGV4dGFyZWFcIiAhPT0gdHlwZSAmJiBcInNlbGVjdFwiICE9PSB0eXBlKSB8fFxuICAgICAgICBudWxsID09IHByb3BzIHx8XG4gICAgICAgIG51bGwgIT09IHByb3BzLnZhbHVlIHx8XG4gICAgICAgIGRpZFdhcm5WYWx1ZU51bGwgfHxcbiAgICAgICAgKChkaWRXYXJuVmFsdWVOdWxsID0gITApLFxuICAgICAgICBcInNlbGVjdFwiID09PSB0eXBlICYmIHByb3BzLm11bHRpcGxlXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImB2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuXCIsXG4gICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiBDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuXCIsXG4gICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgICkpO1xuICAgICAgYjogaWYgKC0xID09PSB0eXBlLmluZGV4T2YoXCItXCIpKSB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICBlbHNlXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uLXhtbFwiOlxuICAgICAgICAgIGNhc2UgXCJjb2xvci1wcm9maWxlXCI6XG4gICAgICAgICAgY2FzZSBcImZvbnQtZmFjZVwiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2Utc3JjXCI6XG4gICAgICAgICAgY2FzZSBcImZvbnQtZmFjZS11cmlcIjpcbiAgICAgICAgICBjYXNlIFwiZm9udC1mYWNlLWZvcm1hdFwiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2UtbmFtZVwiOlxuICAgICAgICAgIGNhc2UgXCJtaXNzaW5nLWdseXBoXCI6XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgICB9XG4gICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgfHxcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmlzIHx8XG4gICAgICAgIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgbnVsbCk7XG4gICAgICAhcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmXG4gICAgICAgIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJlxuICAgICAgICBudWxsICE9IHByb3BzLmNoaWxkcmVuICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5IFJlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mIHRob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyBwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuXCJcbiAgICAgICAgKTtcbiAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSAhPT0gU1ZHX01PREUgJiZcbiAgICAgICAgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlICE9PSBNQVRITUxfTU9ERSAmJlxuICAgICAgICAtMSA9PT0gdHlwZS5pbmRleE9mKFwiLVwiKSAmJlxuICAgICAgICB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IHR5cGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIjwlcyAvPiBpcyB1c2luZyBpbmNvcnJlY3QgY2FzaW5nLiBVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLlwiLFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiZGl2XCI6XG4gICAgICAgIGNhc2UgXCJzcGFuXCI6XG4gICAgICAgIGNhc2UgXCJzdmdcIjpcbiAgICAgICAgY2FzZSBcInBhdGhcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwiYVwiKSk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTCA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5O1xuICAgICAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICAgICAgICAgICAgICAgIFwiXCIgPT09IHByb3BWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgID8gcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiaHJlZlwiLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgIDogcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0JGpzY29tcCQwLCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlc2NhcGVUZXh0Rm9yQnJvd3NlcihjaGlsZHJlbikpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IGNoaWxkcmVuO1xuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDA7XG4gICAgICAgIGNhc2UgXCJnXCI6XG4gICAgICAgIGNhc2UgXCJwXCI6XG4gICAgICAgIGNhc2UgXCJsaVwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyhcInNlbGVjdFwiLCBwcm9wcyk7XG4gICAgICAgICAgY2hlY2tTZWxlY3RQcm9wKHByb3BzLCBcInZhbHVlXCIpO1xuICAgICAgICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgXCJkZWZhdWx0VmFsdWVcIik7XG4gICAgICAgICAgdm9pZCAwID09PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICAgICAgdm9pZCAwID09PSBwcm9wcy5kZWZhdWx0VmFsdWUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgfHxcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlNlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCBib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0LmRldi9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50c1wiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSAhMCkpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJzZWxlY3RcIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMDtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDAgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMCkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMCA9IHByb3BzW3Byb3BLZXkkanNjb21wJDBdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDApXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MJGpzY29tcCQwLCBjaGlsZHJlbiRqc2NvbXAkMCk7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkcmVuJGpzY29tcCQwO1xuICAgICAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICAgICAgdmFyIHNlbGVjdGVkVmFsdWUgPSBmb3JtYXRDb250ZXh0LnNlbGVjdGVkVmFsdWU7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcIm9wdGlvblwiKSk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGVkID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxO1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMSBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQxKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQxID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkMV07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDEpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBwcm9wVmFsdWUkanNjb21wJDE7XG4gICAgICAgICAgICAgICAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlVzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mIHNldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi5cIlxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgKGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gITApKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BWYWx1ZSRqc2NvbXAkMTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQxXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChudWxsICE9IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgbnVsbCA9PT0gaW5uZXJIVE1MJGpzY29tcCQxIHx8XG4gICAgICAgICAgICAgICAgZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwgfHxcbiAgICAgICAgICAgICAgICAoKGRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MID0gITApLFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlBhc3MgYSBgdmFsdWVgIHByb3AgaWYgeW91IHNldCBkYW5nZXJvdXNseUlubmVySFRNTCBzbyBSZWFjdCBrbm93cyB3aGljaCB2YWx1ZSBzaG91bGQgYmUgc2VsZWN0ZWQuXCJcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoc3RyaW5nVmFsdWUgPSBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4kanNjb21wJDEpKTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5SW1wbChzZWxlY3RlZFZhbHVlKSlcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oc2VsZWN0ZWRWYWx1ZVtpXSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgICAgICAgICAgIFwiXCIgKyBzZWxlY3RlZFZhbHVlW2ldID09PSBzdHJpbmdWYWx1ZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKCcgc2VsZWN0ZWQ9XCJcIicpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oc2VsZWN0ZWRWYWx1ZSwgXCJzZWxlY3QudmFsdWVcIiksXG4gICAgICAgICAgICAgICAgXCJcIiArIHNlbGVjdGVkVmFsdWUgPT09IHN0cmluZ1ZhbHVlICYmXG4gICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaCgnIHNlbGVjdGVkPVwiXCInKTtcbiAgICAgICAgICB9IGVsc2Ugc2VsZWN0ZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2goJyBzZWxlY3RlZD1cIlwiJyk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMSwgY2hpbGRyZW4kanNjb21wJDEpO1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbiRqc2NvbXAkMTtcbiAgICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyhcInRleHRhcmVhXCIsIHByb3BzKTtcbiAgICAgICAgICB2b2lkIDAgPT09IHByb3BzLnZhbHVlIHx8XG4gICAgICAgICAgICB2b2lkIDAgPT09IHByb3BzLmRlZmF1bHRWYWx1ZSB8fFxuICAgICAgICAgICAgZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCBib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0LmRldi9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50c1wiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9ICEwKSk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcInRleHRhcmVhXCIpKTtcbiAgICAgICAgICB2YXIgdmFsdWUkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gbnVsbCxcbiAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQyID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDI7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQyIGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDIpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDIgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQyXTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQyKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkMikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQyID0gcHJvcFZhbHVlJGpzY29tcCQyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHByb3BWYWx1ZSRqc2NvbXAkMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMixcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgbnVsbCA9PT0gdmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGRlZmF1bHRWYWx1ZSAmJlxuICAgICAgICAgICAgKHZhbHVlJGpzY29tcCQwID0gZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBjaGlsZHJlbiRqc2NvbXAkMikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nIGNoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSB2YWx1ZSRqc2NvbXAkMClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbiRqc2NvbXAkMikpIHtcbiAgICAgICAgICAgICAgaWYgKDEgPCBjaGlsZHJlbiRqc2NvbXAkMi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCI8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuXCIpO1xuICAgICAgICAgICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihjaGlsZHJlbiRqc2NvbXAkMlswXSk7XG4gICAgICAgICAgICAgIHZhbHVlJGpzY29tcCQwID0gXCJcIiArIGNoaWxkcmVuJGpzY29tcCQyWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oY2hpbGRyZW4kanNjb21wJDIpO1xuICAgICAgICAgICAgdmFsdWUkanNjb21wJDAgPSBcIlwiICsgY2hpbGRyZW4kanNjb21wJDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgXCJcXG5cIiA9PT0gdmFsdWUkanNjb21wJDBbMF0gJiZcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGxlYWRpbmdOZXdsaW5lKTtcbiAgICAgICAgICBudWxsICE9PSB2YWx1ZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUkanNjb21wJDAsIFwidmFsdWVcIiksXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlc2NhcGVUZXh0Rm9yQnJvd3NlcihcIlwiICsgdmFsdWUkanNjb21wJDApKSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJpbnB1dFwiLCBwcm9wcyk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcImlucHV0XCIpKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1NZXRob2QgPSBudWxsLFxuICAgICAgICAgICAgZm9ybVRhcmdldCA9IG51bGwsXG4gICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWUkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgY2hlY2tlZCA9IG51bGwsXG4gICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQzO1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMyBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQzKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQzID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkM107XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMylcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDMpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiaW5wdXQgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybUFjdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtQWN0aW9uID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtRW5jVHlwZVwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtRW5jVHlwZSA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybU1ldGhvZFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtTWV0aG9kID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtVGFyZ2V0XCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1UYXJnZXQgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlJGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDMsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgPT09IGZvcm1BY3Rpb24gfHxcbiAgICAgICAgICAgIFwiaW1hZ2VcIiA9PT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgXCJzdWJtaXRcIiA9PT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdBbiBpbnB1dCBjYW4gb25seSBzcGVjaWZ5IGEgZm9ybUFjdGlvbiBhbG9uZyB3aXRoIHR5cGU9XCJzdWJtaXRcIiBvciB0eXBlPVwiaW1hZ2VcIi4nXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB2YXIgZm9ybURhdGEgPSBwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZShcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgICAgZm9ybVRhcmdldCxcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIG51bGwgPT09IGNoZWNrZWQgfHxcbiAgICAgICAgICAgIG51bGwgPT09IGRlZmF1bHRDaGVja2VkIHx8XG4gICAgICAgICAgICBkaWRXYXJuRGVmYXVsdENoZWNrZWQgfHxcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiBJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0LmRldi9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50c1wiLFxuICAgICAgICAgICAgICBcIkEgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIHByb3BzLnR5cGVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZGlkV2FybkRlZmF1bHRDaGVja2VkID0gITApKTtcbiAgICAgICAgICBudWxsID09PSB2YWx1ZSRqc2NvbXAkMSB8fFxuICAgICAgICAgICAgbnVsbCA9PT0gZGVmYXVsdFZhbHVlJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgfHxcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuIElucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIChzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90IGJvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0IGVsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIixcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICBwcm9wcy50eXBlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9ICEwKSk7XG4gICAgICAgICAgbnVsbCAhPT0gY2hlY2tlZFxuICAgICAgICAgICAgPyBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiY2hlY2tlZFwiLCBjaGVja2VkKVxuICAgICAgICAgICAgOiBudWxsICE9PSBkZWZhdWx0Q2hlY2tlZCAmJlxuICAgICAgICAgICAgICBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiY2hlY2tlZFwiLCBkZWZhdWx0Q2hlY2tlZCk7XG4gICAgICAgICAgbnVsbCAhPT0gdmFsdWUkanNjb21wJDFcbiAgICAgICAgICAgID8gcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwidmFsdWVcIiwgdmFsdWUkanNjb21wJDEpXG4gICAgICAgICAgICA6IG51bGwgIT09IGRlZmF1bHRWYWx1ZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCRqc2NvbXAkMCwgXCJ2YWx1ZVwiLCBkZWZhdWx0VmFsdWUkanNjb21wJDApO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtRGF0YSAmJlxuICAgICAgICAgICAgZm9ybURhdGEuZm9yRWFjaChwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCwgdGFyZ2V0JGpzY29tcCQwKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcImJ1dHRvblwiOlxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJidXR0b25cIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMyA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDIgPSBudWxsLFxuICAgICAgICAgICAgbmFtZSRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ0O1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkNCBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQ0KSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ0ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkNF07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkNClcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDQpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMyA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQyID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIG5hbWUkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1BY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybUVuY1R5cGVcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUVuY1R5cGUkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1NZXRob2RcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybVRhcmdldFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtVGFyZ2V0JGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDQsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQ0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgPT09IGZvcm1BY3Rpb24kanNjb21wJDAgfHxcbiAgICAgICAgICAgIG51bGwgPT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgXCJzdWJtaXRcIiA9PT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdBIGJ1dHRvbiBjYW4gb25seSBzcGVjaWZ5IGEgZm9ybUFjdGlvbiBhbG9uZyB3aXRoIHR5cGU9XCJzdWJtaXRcIiBvciBubyB0eXBlLidcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIHZhciBmb3JtRGF0YSRqc2NvbXAkMCA9IHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKFxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDAsXG4gICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMCxcbiAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDAsXG4gICAgICAgICAgICBmb3JtVGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgbmFtZSRqc2NvbXAkMFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtRGF0YSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgZm9ybURhdGEkanNjb21wJDAuZm9yRWFjaChwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCwgdGFyZ2V0JGpzY29tcCQwKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MJGpzY29tcCQyLCBjaGlsZHJlbiRqc2NvbXAkMyk7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbiRqc2NvbXAkMykge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIoY2hpbGRyZW4kanNjb21wJDMpKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDEgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDEgPSBjaGlsZHJlbiRqc2NvbXAkMztcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxO1xuICAgICAgICBjYXNlIFwiZm9ybVwiOlxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJmb3JtXCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDQgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQzID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGUkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZm9ybU1ldGhvZCRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtVGFyZ2V0JGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDU7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQ1IGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDUpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDUgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ1XTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ1KVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkNSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ0ID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDMgPSBwcm9wVmFsdWUkanNjb21wJDU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImFjdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmNUeXBlXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXRob2RcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidGFyZ2V0XCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1UYXJnZXQkanNjb21wJDEgPSBwcm9wVmFsdWUkanNjb21wJDU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZvcm1EYXRhJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1BY3Rpb25OYW1lID0gbnVsbDtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm9ybUFjdGlvbiRqc2NvbXAkMSkge1xuICAgICAgICAgICAgKG51bGwgPT09IGZvcm1FbmNUeXBlJGpzY29tcCQxICYmIG51bGwgPT09IGZvcm1NZXRob2QkanNjb21wJDEpIHx8XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kIHx8XG4gICAgICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIGVuY1R5cGUgb3IgbWV0aG9kIGZvciBhIGZvcm0gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyB0aGUgYWN0aW9uLiBSZWFjdCBwcm92aWRlcyB0aG9zZSBhdXRvbWF0aWNhbGx5LiBUaGV5IHdpbGwgZ2V0IG92ZXJyaWRkZW4uXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBudWxsID09PSBmb3JtVGFyZ2V0JGpzY29tcCQxIHx8XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0IHx8XG4gICAgICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIHRhcmdldCBmb3IgYSBmb3JtIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgdGhlIGFjdGlvbi4gVGhlIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIHdpbmRvdy5cIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBnZXRDdXN0b21Gb3JtRmllbGRzKFxuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG51bGwgIT09IGN1c3RvbUZpZWxkc1xuICAgICAgICAgICAgICA/ICgoZm9ybUFjdGlvbiRqc2NvbXAkMSA9IGN1c3RvbUZpZWxkcy5hY3Rpb24gfHwgXCJcIiksXG4gICAgICAgICAgICAgICAgKGZvcm1FbmNUeXBlJGpzY29tcCQxID0gY3VzdG9tRmllbGRzLmVuY1R5cGUpLFxuICAgICAgICAgICAgICAgIChmb3JtTWV0aG9kJGpzY29tcCQxID0gY3VzdG9tRmllbGRzLm1ldGhvZCksXG4gICAgICAgICAgICAgICAgKGZvcm1UYXJnZXQkanNjb21wJDEgPSBjdXN0b21GaWVsZHMudGFyZ2V0KSxcbiAgICAgICAgICAgICAgICAoZm9ybURhdGEkanNjb21wJDEgPSBjdXN0b21GaWVsZHMuZGF0YSksXG4gICAgICAgICAgICAgICAgKGZvcm1BY3Rpb25OYW1lID0gY3VzdG9tRmllbGRzLm5hbWUpKVxuICAgICAgICAgICAgICA6ICh0YXJnZXQkanNjb21wJDAucHVzaChcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgICAgICBhY3Rpb25KYXZhU2NyaXB0VVJMLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZm9ybVRhcmdldCRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgICBmb3JtTWV0aG9kJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDEgPVxuICAgICAgICAgICAgICAgICAgICBudWxsKSxcbiAgICAgICAgICAgICAgICBpbmplY3RGb3JtUmVwbGF5aW5nUnVudGltZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVsbCAhPSBmb3JtQWN0aW9uJGpzY29tcCQxICYmXG4gICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCRqc2NvbXAkMCwgXCJhY3Rpb25cIiwgZm9ybUFjdGlvbiRqc2NvbXAkMSk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtRW5jVHlwZSRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiZW5jVHlwZVwiLCBmb3JtRW5jVHlwZSRqc2NvbXAkMSk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtTWV0aG9kJGpzY29tcCQxICYmXG4gICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCRqc2NvbXAkMCwgXCJtZXRob2RcIiwgZm9ybU1ldGhvZCRqc2NvbXAkMSk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtVGFyZ2V0JGpzY29tcCQxICYmXG4gICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCRqc2NvbXAkMCwgXCJ0YXJnZXRcIiwgZm9ybVRhcmdldCRqc2NvbXAkMSk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgbnVsbCAhPT0gZm9ybUFjdGlvbk5hbWUgJiZcbiAgICAgICAgICAgICh0YXJnZXQkanNjb21wJDAucHVzaCgnPGlucHV0IHR5cGU9XCJoaWRkZW5cIicpLFxuICAgICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwibmFtZVwiLCBmb3JtQWN0aW9uTmFtZSksXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpLFxuICAgICAgICAgICAgbnVsbCAhPSBmb3JtRGF0YSRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICBmb3JtRGF0YSRqc2NvbXAkMS5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkLFxuICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MJGpzY29tcCQzLCBjaGlsZHJlbiRqc2NvbXAkNCk7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbiRqc2NvbXAkNCkge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIoY2hpbGRyZW4kanNjb21wJDQpKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDIgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDIgPSBjaGlsZHJlbiRqc2NvbXAkNDtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyO1xuICAgICAgICBjYXNlIFwibWVudWl0ZW1cIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwibWVudWl0ZW1cIikpO1xuICAgICAgICAgIGZvciAodmFyIHByb3BLZXkkanNjb21wJDYgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkNikpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkNiA9IHByb3BzW3Byb3BLZXkkanNjb21wJDZdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDYpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ2KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIm1lbnVpdGVtcyBjYW5ub3QgaGF2ZSBgY2hpbGRyZW5gIG5vciBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ2LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkNlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJvYmplY3RcIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkNSA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDQgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNztcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDcgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkNykpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkNyA9IHByb3BzW3Byb3BLZXkkanNjb21wJDddO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDcpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ3KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDUgPSBwcm9wVmFsdWUkanNjb21wJDc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNCA9IHByb3BWYWx1ZSRqc2NvbXAkNztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHByb3BWYWx1ZSRqc2NvbXAkNywgXCJkYXRhXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FuaXRpemVkVmFsdWUgPSBzYW5pdGl6ZVVSTChcIlwiICsgcHJvcFZhbHVlJGpzY29tcCQ3KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgPT09IHNhbml0aXplZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdBbiBlbXB0eSBzdHJpbmcgKFwiXCIpIHdhcyBwYXNzZWQgdG8gdGhlICVzIGF0dHJpYnV0ZS4gVG8gZml4IHRoaXMsIGVpdGhlciBkbyBub3QgcmVuZGVyIHRoZSBlbGVtZW50IGF0IGFsbCBvciBwYXNzIG51bGwgdG8gJXMgaW5zdGVhZCBvZiBhbiBlbXB0eSBzdHJpbmcuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ3XG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgXCJkYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHNhbml0aXplZFZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ3LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkN1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MJGpzY29tcCQ0LCBjaGlsZHJlbiRqc2NvbXAkNSk7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbiRqc2NvbXAkNSkge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIoY2hpbGRyZW4kanNjb21wJDUpKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDMgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDMgPSBjaGlsZHJlbiRqc2NvbXAkNTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQzO1xuICAgICAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgICAgICB2YXIgaW5zZXJ0aW9uTW9kZSA9IGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSA9ICEhKGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxKTtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgXCJjaGlsZHJlblwiKSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQ2ID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIGNoaWxkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbiRqc2NvbXAkNilcbiAgICAgICAgICAgICAgICA/IDIgPiBjaGlsZHJlbiRqc2NvbXAkNi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gY2hpbGRyZW4kanNjb21wJDZbMF1cbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICAgIDogY2hpbGRyZW4kanNjb21wJDY7XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ2KSAmJiAxIDwgY2hpbGRyZW4kanNjb21wJDYubGVuZ3RoXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIEFycmF5IHdpdGggbGVuZ3RoICVzIGluc3RlYWQuIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvIGJlIGFibGUgdG8gY29udmVydCBgY2hpbGRyZW5gIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUgd2hpY2ggaXMgd2h5IEFycmF5cyBvZiBsZW5ndGggZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCBzdXBwb3J0ZWQuIFdoZW4gdXNpbmcgSlNYIGl0IGNhbiBiZSBjb21tb24gdG8gY29tYmluZSB0ZXh0IG5vZGVzIGFuZCB2YWx1ZSBub2Rlcy4gRm9yIGV4YW1wbGU6IDx0aXRsZT5oZWxsbyB7bmFtZU9mVXNlcn08L3RpdGxlPi4gV2hpbGUgbm90IGltbWVkaWF0ZWx5IGFwcGFyZW50LCBgY2hpbGRyZW5gIGluIHRoaXMgY2FzZSBpcyBhbiBBcnJheSB3aXRoIGxlbmd0aCAyLiBJZiB5b3VyIGBjaGlsZHJlbmAgcHJvcCBpcyB1c2luZyB0aGlzIGZvcm0gdHJ5IHJld3JpdGluZyBpdCB1c2luZyBhIHRlbXBsYXRlIHN0cmluZzogPHRpdGxlPntgaGVsbG8gJHtuYW1lT2ZVc2VyfWB9PC90aXRsZT4uXCIsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkNi5sZW5ndGhcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2hpbGQgfHwgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIGNoaWxkXG4gICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlJlYWN0IGV4cGVjdCBjaGlsZHJlbiBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgYmlnaW50LCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCAlcyBpbnN0ZWFkLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZS5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2hpbGQgPyBcImEgRnVuY3Rpb25cIiA6IFwiYSBTeWJtb2xcIlxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogY2hpbGQgJiZcbiAgICAgICAgICAgICAgICAgIGNoaWxkLnRvU3RyaW5nID09PSB7fS50b1N0cmluZyAmJlxuICAgICAgICAgICAgICAgICAgKG51bGwgIT0gY2hpbGQuJCR0eXBlb2ZcbiAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3RzIHRoZSBgY2hpbGRyZW5gIHByb3Agb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgYW4gb2JqZWN0IHRoYXQgYXBwZWFycyB0byBiZSBhIFJlYWN0IGVsZW1lbnQgd2hpY2ggbmV2ZXIgaW1wbGVtZW50cyBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZSB3aGljaCBpcyB3aHkgcmVuZGVyaW5nIFJlYWN0IGVsZW1lbnRzIGlzIG5vdCBzdXBwb3J0ZWQuIElmIHRoZSBgY2hpbGRyZW5gIG9mIDx0aXRsZT4gaXMgYSBSZWFjdCBDb21wb25lbnQgdHJ5IG1vdmluZyB0aGUgPHRpdGxlPiB0YWcgaW50byB0aGF0IGNvbXBvbmVudC4gSWYgdGhlIGBjaGlsZHJlbmAgb2YgPHRpdGxlPiBpcyBzb21lIEhUTUwgbWFya3VwIGNoYW5nZSBpdCB0byBiZSBUZXh0IG9ubHkgdG8gYmUgdmFsaWQgSFRNTC5cIlxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3RzIHRoZSBgY2hpbGRyZW5gIHByb3Agb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgYW4gb2JqZWN0IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IGEgc3VpdGFibGUgYHRvU3RyaW5nYCBtZXRob2QuIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvIGJlIGFibGUgdG8gY29udmVydCBjaGlsZHJlbiBvZiA8dGl0bGU+IHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlLiBVc2luZyB0aGUgZGVmYXVsdCBgdG9TdHJpbmdgIG1ldGhvZCBhdmFpbGFibGUgb24gZXZlcnkgb2JqZWN0IGlzIGFsbW9zdCBjZXJ0YWlubHkgYW4gZXJyb3IuIENvbnNpZGVyIHdoZXRoZXIgdGhlIGBjaGlsZHJlbmAgb2YgdGhpcyA8dGl0bGU+IGlzIGFuIG9iamVjdCBpbiBlcnJvciBhbmQgY2hhbmdlIGl0IHRvIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSBpZiBzby4gT3RoZXJ3aXNlIGltcGxlbWVudCBhIGB0b1N0cmluZ2AgbWV0aG9kIHRoYXQgUmVhY3QgY2FuIHVzZSB0byBwcm9kdWNlIGEgdmFsaWQgPHRpdGxlPi5cIlxuICAgICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpbnNlcnRpb25Nb2RlID09PSBTVkdfTU9ERSB8fFxuICAgICAgICAgICAgbm9zY3JpcHRUYWdJblNjb3BlIHx8XG4gICAgICAgICAgICBudWxsICE9IHByb3BzLml0ZW1Qcm9wXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNCA9IHB1c2hUaXRsZUltcGwoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaXNGYWxsYmFja1xuICAgICAgICAgICAgICA/IChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDQgPSBudWxsKVxuICAgICAgICAgICAgICA6IChwdXNoVGl0bGVJbXBsKHJlbmRlclN0YXRlLmhvaXN0YWJsZUNodW5rcywgcHJvcHMpLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDQgPSB2b2lkIDApKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0O1xuICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgIHZhciByZWwgPSBwcm9wcy5yZWwsXG4gICAgICAgICAgICBocmVmID0gcHJvcHMuaHJlZixcbiAgICAgICAgICAgIHByZWNlZGVuY2UgPSBwcm9wcy5wcmVjZWRlbmNlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxIHx8XG4gICAgICAgICAgICBudWxsICE9IHByb3BzLml0ZW1Qcm9wIHx8XG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcmVsIHx8XG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgaHJlZiB8fFxuICAgICAgICAgICAgXCJcIiA9PT0gaHJlZlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgXCJzdHlsZXNoZWV0XCIgPT09IHJlbCAmJlxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMucHJlY2VkZW5jZSAmJlxuICAgICAgICAgICAgICAoKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWYpIHx8XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdSZWFjdCBlbmNvdW50ZXJlZCBhIGA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uLz5gIHdpdGggYSBgcHJlY2VkZW5jZWAgcHJvcCBhbmQgZXhwZWN0ZWQgdGhlIGBocmVmYCBwcm9wIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZyBidXQgZWNvdW50ZXJlZCAlcyBpbnN0ZWFkLiBJZiB5b3VyIGludGVudCB3YXMgdG8gaGF2ZSBSZWFjdCBob2lzdCBhbmQgZGVkdXBsY2lhdGUgdGhpcyBzdHlsZXNoZWV0IHVzaW5nIHRoZSBgcHJlY2VkZW5jZWAgcHJvcCBlbnN1cmUgdGhlcmUgaXMgYSBub24tZW1wdHkgc3RyaW5nIGBocmVmYCBwcm9wIGFzIHdlbGwsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicsXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBocmVmXG4gICAgICAgICAgICAgICAgICAgID8gXCJgbnVsbGBcIlxuICAgICAgICAgICAgICAgICAgICA6IHZvaWQgMCA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICAgID8gXCJgdW5kZWZpbmVkYFwiXG4gICAgICAgICAgICAgICAgICAgICAgOiBcIlwiID09PSBocmVmXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiYW4gZW1wdHkgc3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ3NvbWV0aGluZyB3aXRoIHR5cGUgXCInICsgdHlwZW9mIGhyZWYgKyAnXCInXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBwdXNoTGlua0ltcGwodGFyZ2V0JGpzY29tcCQwLCBwcm9wcyk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKFwic3R5bGVzaGVldFwiID09PSBwcm9wcy5yZWwpXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBwcmVjZWRlbmNlIHx8XG4gICAgICAgICAgICAgIG51bGwgIT0gcHJvcHMuZGlzYWJsZWQgfHxcbiAgICAgICAgICAgICAgcHJvcHMub25Mb2FkIHx8XG4gICAgICAgICAgICAgIHByb3BzLm9uRXJyb3JcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByZWNlZGVuY2UpXG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcHMuZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kIGEgYGRpc2FibGVkYCBwcm9wLiBUaGUgcHJlc2VuY2Ugb2YgdGhlIGBkaXNhYmxlZGAgcHJvcCBpbmRpY2F0ZXMgYW4gaW50ZW50IHRvIG1hbmFnZSB0aGUgc3R5bGVzaGVldCBhY3RpdmUgc3RhdGUgZnJvbSB5b3VyIGZyb20geW91ciBDb21wb25lbnQgY29kZSBhbmQgUmVhY3Qgd2lsbCBub3QgaG9pc3Qgb3IgZGVkdXBsaWNhdGUgdGhpcyBzdHlsZXNoZWV0LiBJZiB5b3VyIGludGVudCB3YXMgdG8gaGF2ZSBSZWFjdCBob2lzdCBhbmQgZGVkdXBsY2lhdGUgdGhpcyBzdHlsZXNoZWV0IHVzaW5nIHRoZSBgcHJlY2VkZW5jZWAgcHJvcCByZW1vdmUgdGhlIGBkaXNhYmxlZGAgcHJvcCwgb3RoZXJ3aXNlIHJlbW92ZSB0aGUgYHByZWNlZGVuY2VgIHByb3AuJ1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wcy5vbkxvYWQgfHwgcHJvcHMub25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgdmFyIHByb3BEZXNjcmlwdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLm9uTG9hZCAmJiBwcm9wcy5vbkVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgPyBcImBvbkxvYWRgIGFuZCBgb25FcnJvcmAgcHJvcHNcIlxuICAgICAgICAgICAgICAgICAgICAgIDogcHJvcHMub25Mb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiYG9uTG9hZGAgcHJvcFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiYG9uRXJyb3JgIHByb3BcIjtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdSZWFjdCBlbmNvdW50ZXJlZCBhIGA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uLz5gIHdpdGggYSBgcHJlY2VkZW5jZWAgcHJvcCBhbmQgJXMuIFRoZSBwcmVzZW5jZSBvZiBsb2FkaW5nIGFuZCBlcnJvciBoYW5kbGVycyBpbmRpY2F0ZXMgYW4gaW50ZW50IHRvIG1hbmFnZSB0aGUgc3R5bGVzaGVldCBsb2FkaW5nIHN0YXRlIGZyb20geW91ciBmcm9tIHlvdXIgQ29tcG9uZW50IGNvZGUgYW5kIFJlYWN0IHdpbGwgbm90IGhvaXN0IG9yIGRlZHVwbGljYXRlIHRoaXMgc3R5bGVzaGVldC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgcmVtb3ZlIHRoZSAlcywgb3RoZXJ3aXNlIHJlbW92ZSB0aGUgYHByZWNlZGVuY2VgIHByb3AuJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcERlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBwcm9wRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDUgPSBwdXNoTGlua0ltcGwoXG4gICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc3R5bGVRdWV1ZSA9IHJlbmRlclN0YXRlLnN0eWxlcy5nZXQocHJlY2VkZW5jZSksXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSA9IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgaHJlZlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgID8gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNbaHJlZl1cbiAgICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgICBpZiAocmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTKSB7XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNbaHJlZl0gPSBFWElTVFM7XG4gICAgICAgICAgICAgICAgc3R5bGVRdWV1ZSB8fFxuICAgICAgICAgICAgICAgICAgKChzdHlsZVF1ZXVlID0ge1xuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBocmVmczogW10sXG4gICAgICAgICAgICAgICAgICAgIHNoZWV0czogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5zZXQocHJlY2VkZW5jZSwgc3R5bGVRdWV1ZSkpO1xuICAgICAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBQRU5ESU5HJDEsXG4gICAgICAgICAgICAgICAgICBwcm9wczogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICAgICAgICBcImRhdGEtcHJlY2VkZW5jZVwiOiBwcm9wcy5wcmVjZWRlbmNlLFxuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBudWxsXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIDIgPT09IHJlc291cmNlU3RhdGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHJlc291cmNlLnByb3BzLCByZXNvdXJjZVN0YXRlKTtcbiAgICAgICAgICAgICAgICAgIHZhciBwcmVsb2FkUmVzb3VyY2UgPVxuICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zdHlsZXNoZWV0cy5nZXQoaHJlZik7XG4gICAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2UgJiYgMCA8IHByZWxvYWRSZXNvdXJjZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyAocHJlbG9hZFJlc291cmNlLmxlbmd0aCA9IDApXG4gICAgICAgICAgICAgICAgICAgIDogKHJlc291cmNlLnN0YXRlID0gUFJFTE9BREVEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuc2V0KGhyZWYsIHJlc291cmNlKTtcbiAgICAgICAgICAgICAgICBob2lzdGFibGVTdGF0ZSAmJiBob2lzdGFibGVTdGF0ZS5zdHlsZXNoZWV0cy5hZGQocmVzb3VyY2UpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlUXVldWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc291cmNlID0gc3R5bGVRdWV1ZS5zaGVldHMuZ2V0KGhyZWYpO1xuICAgICAgICAgICAgICAgIF9yZXNvdXJjZSAmJlxuICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlLnN0eWxlc2hlZXRzLmFkZChfcmVzb3VyY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRleHRFbWJlZGRlZCAmJiB0YXJnZXQkanNjb21wJDAucHVzaChcIlxceDNjIS0tIC0tXFx4M2VcIik7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3JcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6ICh0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2goXCJcXHgzYyEtLSAtLVxceDNlXCIpLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDUgPSBpc0ZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgIDogcHVzaExpbmtJbXBsKHJlbmRlclN0YXRlLmhvaXN0YWJsZUNodW5rcywgcHJvcHMpKSk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNTtcbiAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgIHZhciBhc3luY1Byb3AgPSBwcm9wcy5hc3luYztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJvcHMuc3JjIHx8XG4gICAgICAgICAgICAhcHJvcHMuc3JjIHx8XG4gICAgICAgICAgICAhYXN5bmNQcm9wIHx8XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhc3luY1Byb3AgfHxcbiAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBhc3luY1Byb3AgfHxcbiAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fFxuICAgICAgICAgICAgcHJvcHMub25FcnJvciB8fFxuICAgICAgICAgICAgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBTVkdfTU9ERSB8fFxuICAgICAgICAgICAgZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDEgfHxcbiAgICAgICAgICAgIG51bGwgIT0gcHJvcHMuaXRlbVByb3BcbiAgICAgICAgICApXG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ2ID0gcHVzaFNjcmlwdEltcGwoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gcHJvcHMuc3JjO1xuICAgICAgICAgICAgaWYgKFwibW9kdWxlXCIgPT09IHByb3BzLnR5cGUpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc291cmNlcyA9IHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlcztcbiAgICAgICAgICAgICAgdmFyIHByZWxvYWRzID0gcmVuZGVyU3RhdGUucHJlbG9hZHMubW9kdWxlU2NyaXB0cztcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAocmVzb3VyY2VzID0gcmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzKSxcbiAgICAgICAgICAgICAgICAocHJlbG9hZHMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zY3JpcHRzKTtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZVN0YXRlJGpzY29tcCQwID0gcmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSlcbiAgICAgICAgICAgICAgPyByZXNvdXJjZXNba2V5XVxuICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlJGpzY29tcCQwICE9PSBFWElTVFMpIHtcbiAgICAgICAgICAgICAgcmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG4gICAgICAgICAgICAgIHZhciBzY3JpcHRQcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgICBpZiAocmVzb3VyY2VTdGF0ZSRqc2NvbXAkMCkge1xuICAgICAgICAgICAgICAgIDIgPT09IHJlc291cmNlU3RhdGUkanNjb21wJDAubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAoKHNjcmlwdFByb3BzID0gYXNzaWduKHt9LCBwcm9wcykpLFxuICAgICAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMoc2NyaXB0UHJvcHMsIHJlc291cmNlU3RhdGUkanNjb21wJDApKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlJGpzY29tcCQwID0gcHJlbG9hZHMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICAocHJlbG9hZFJlc291cmNlJGpzY29tcCQwLmxlbmd0aCA9IDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciByZXNvdXJjZSRqc2NvbXAkMCA9IFtdO1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmFkZChyZXNvdXJjZSRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgIHB1c2hTY3JpcHRJbXBsKHJlc291cmNlJGpzY29tcCQwLCBzY3JpcHRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2goXCJcXHgzYyEtLSAtLVxceDNlXCIpO1xuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ2ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNjtcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgdmFyIGluc2VydGlvbk1vZGUkanNjb21wJDAgPSBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUsXG4gICAgICAgICAgICBub3NjcmlwdFRhZ0luU2NvcGUkanNjb21wJDAgPSAhIShmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMSk7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIFwiY2hpbGRyZW5cIikpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkNyA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBjaGlsZCRqc2NvbXAkMCA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4kanNjb21wJDcpXG4gICAgICAgICAgICAgICAgPyAyID4gY2hpbGRyZW4kanNjb21wJDcubGVuZ3RoXG4gICAgICAgICAgICAgICAgICA/IGNoaWxkcmVuJGpzY29tcCQ3WzBdXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgICA6IGNoaWxkcmVuJGpzY29tcCQ3O1xuICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkJGpzY29tcCQwIHx8XG4gICAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGNoaWxkJGpzY29tcCQwKSkgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlJlYWN0IGV4cGVjdCBjaGlsZHJlbiBvZiA8c3R5bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgb3Igb2JqZWN0IHdpdGggYSBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgJXMgaW5zdGVhZC4gSW4gYnJvd3NlcnMgc3R5bGUgRWxlbWVudHMgY2FuIG9ubHkgaGF2ZSBgVGV4dGAgTm9kZXMgYXMgY2hpbGRyZW4uXCIsXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2hpbGQkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgID8gXCJhIEZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgIDogXCJzeW1ib2xcIiA9PT0gdHlwZW9mIGNoaWxkJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgID8gXCJhIFN5Ym1vbFwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJhbiBBcnJheVwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwcmVjZWRlbmNlJGpzY29tcCQwID0gcHJvcHMucHJlY2VkZW5jZSxcbiAgICAgICAgICAgIGhyZWYkanNjb21wJDAgPSBwcm9wcy5ocmVmO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGluc2VydGlvbk1vZGUkanNjb21wJDAgPT09IFNWR19NT0RFIHx8XG4gICAgICAgICAgICBub3NjcmlwdFRhZ0luU2NvcGUkanNjb21wJDAgfHxcbiAgICAgICAgICAgIG51bGwgIT0gcHJvcHMuaXRlbVByb3AgfHxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBwcmVjZWRlbmNlJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgaHJlZiRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgXCJcIiA9PT0gaHJlZiRqc2NvbXAkMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcInN0eWxlXCIpKTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkOCA9IG51bGwsXG4gICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNSA9IG51bGwsXG4gICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDg7XG4gICAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDggaW4gcHJvcHMpXG4gICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQ4KSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDggPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ4XTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDgpXG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDggPSBwcm9wVmFsdWUkanNjb21wJDg7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNSA9IHByb3BWYWx1ZSRqc2NvbXAkODtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkOCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkOFxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgICAgdmFyIGNoaWxkJGpzY29tcCQxID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbiRqc2NvbXAkOClcbiAgICAgICAgICAgICAgPyAyID4gY2hpbGRyZW4kanNjb21wJDgubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBjaGlsZHJlbiRqc2NvbXAkOFswXVxuICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICA6IGNoaWxkcmVuJGpzY29tcCQ4O1xuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2hpbGQkanNjb21wJDEgJiZcbiAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIGNoaWxkJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGNoaWxkJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gY2hpbGQkanNjb21wJDEgJiZcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZXNjYXBlU3R5bGVUZXh0Q29udGVudChjaGlsZCRqc2NvbXAkMSkpO1xuICAgICAgICAgICAgcHVzaElubmVySFRNTChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDUsXG4gICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ4XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kQ2h1bmtGb3JUYWcoXCJzdHlsZVwiKSk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ3ID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHJlZiRqc2NvbXAkMC5pbmNsdWRlcyhcIiBcIikgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnUmVhY3QgZXhwZWN0ZWQgdGhlIGBocmVmYCBwcm9wIGZvciBhIDxzdHlsZT4gdGFnIG9wdGluZyBpbnRvIGhvaXN0aW5nIHNlbWFudGljcyB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgdG8gbm90IGhhdmUgYW55IHNwYWNlcyBidXQgZWNvdW50ZXJlZCBzcGFjZXMgaW5zdGVhZC4gdXNpbmcgc3BhY2VzIGluIHRoaXMgcHJvcCB3aWxsIGNhdXNlIGh5ZHJhdGlvbiBvZiB0aGlzIHN0eWxlIHRvIGZhaWwgb24gdGhlIGNsaWVudC4gVGhlIGhyZWYgZm9yIHRoZSA8c3R5bGU+IHdoZXJlIHRoaXMgb2N1cnJlZCBpcyBcIiVzXCIuJyxcbiAgICAgICAgICAgICAgICBocmVmJGpzY29tcCQwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgc3R5bGVRdWV1ZSRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc3R5bGVzLmdldChwcmVjZWRlbmNlJGpzY29tcCQwKSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZiRqc2NvbXAkMClcbiAgICAgICAgICAgICAgICAgID8gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNbaHJlZiRqc2NvbXAkMF1cbiAgICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUkanNjb21wJDEgIT09IEVYSVNUUykge1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tocmVmJGpzY29tcCQwXSA9IEVYSVNUUztcbiAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBob2lzdGFibGUgc3R5bGUgdGFnIGZvciB0aGUgc2FtZSBocmVmIGFzIGEgcHJlbG9hZDogXCIlc1wiLiBXaGVuIHVzaW5nIGEgc3R5bGUgdGFnIHRvIGlubGluZSBzdHlsZXMgeW91IHNob3VsZCBub3QgYWxzbyBwcmVsb2FkIGl0IGFzIGEgc3R5bHNoZWV0LicsXG4gICAgICAgICAgICAgICAgICBocmVmJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgc3R5bGVRdWV1ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgID8gc3R5bGVRdWV1ZSRqc2NvbXAkMC5ocmVmcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcihocmVmJGpzY29tcCQwKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogKChzdHlsZVF1ZXVlJGpzY29tcCQwID0ge1xuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlJGpzY29tcCQwKSxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBocmVmczogW2VzY2FwZVRleHRGb3JCcm93c2VyKGhyZWYkanNjb21wJDApXSxcbiAgICAgICAgICAgICAgICAgICAgc2hlZXRzOiBuZXcgTWFwKClcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc3R5bGVzLnNldChcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVRdWV1ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBzdHlsZVF1ZXVlJGpzY29tcCQwLnJ1bGVzLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ5ID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDYgPSBudWxsLFxuICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDk7XG4gICAgICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkOSBpbiBwcm9wcylcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkOSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDkgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ5XTtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkOSlcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkOSA9IHByb3BWYWx1ZSRqc2NvbXAkOTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ2ID0gcHJvcFZhbHVlJGpzY29tcCQ5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgY2hpbGQkanNjb21wJDIgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ5KVxuICAgICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ5Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyBjaGlsZHJlbiRqc2NvbXAkOVswXVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkOTtcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjaGlsZCRqc2NvbXAkMiAmJlxuICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChlc2NhcGVTdHlsZVRleHRDb250ZW50KGNoaWxkJGpzY29tcCQyKSk7XG4gICAgICAgICAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwkanNjb21wJDYsIGNoaWxkcmVuJGpzY29tcCQ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlUXVldWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgaG9pc3RhYmxlU3RhdGUgJiZcbiAgICAgICAgICAgICAgaG9pc3RhYmxlU3RhdGUuc3R5bGVzLmFkZChzdHlsZVF1ZXVlJGpzY29tcCQwKTtcbiAgICAgICAgICAgIHRleHRFbWJlZGRlZCAmJiB0YXJnZXQkanNjb21wJDAucHVzaChcIlxceDNjIS0tIC0tXFx4M2VcIik7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDcgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDc7XG4gICAgICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBTVkdfTU9ERSB8fFxuICAgICAgICAgICAgZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDEgfHxcbiAgICAgICAgICAgIG51bGwgIT0gcHJvcHMuaXRlbVByb3BcbiAgICAgICAgICApXG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ4ID0gcHVzaFNlbGZDbG9zaW5nKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcIm1ldGFcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2goXCJcXHgzYyEtLSAtLVxceDNlXCIpLFxuICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ4ID0gaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmNoYXJTZXRcbiAgICAgICAgICAgICAgICAgID8gcHVzaFNlbGZDbG9zaW5nKHJlbmRlclN0YXRlLmNoYXJzZXRDaHVua3MsIHByb3BzLCBcIm1ldGFcIilcbiAgICAgICAgICAgICAgICAgIDogXCJ2aWV3cG9ydFwiID09PSBwcm9wcy5uYW1lXG4gICAgICAgICAgICAgICAgICAgID8gcHVzaFNlbGZDbG9zaW5nKHJlbmRlclN0YXRlLnZpZXdwb3J0Q2h1bmtzLCBwcm9wcywgXCJtZXRhXCIpXG4gICAgICAgICAgICAgICAgICAgIDogcHVzaFNlbGZDbG9zaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1ldGFcIlxuICAgICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDg7XG4gICAgICAgIGNhc2UgXCJsaXN0aW5nXCI6XG4gICAgICAgIGNhc2UgXCJwcmVcIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKHR5cGUpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDEwID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNyA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxMDtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDEwIGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDEwKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQxMCA9IHByb3BzW3Byb3BLZXkkanNjb21wJDEwXTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQxMClcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDEwKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDEwID0gcHJvcFZhbHVlJGpzY29tcCQxMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ3ID0gcHJvcFZhbHVlJGpzY29tcCQxMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDEwXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIGlmIChudWxsICE9IGlubmVySFRNTCRqc2NvbXAkNykge1xuICAgICAgICAgICAgaWYgKG51bGwgIT0gY2hpbGRyZW4kanNjb21wJDEwKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBpbm5lckhUTUwkanNjb21wJDcgfHxcbiAgICAgICAgICAgICAgIShcIl9faHRtbFwiIGluIGlubmVySFRNTCRqc2NvbXAkNylcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGh0bWwgPSBpbm5lckhUTUwkanNjb21wJDcuX19odG1sO1xuICAgICAgICAgICAgbnVsbCAhPT0gaHRtbCAmJlxuICAgICAgICAgICAgICB2b2lkIDAgIT09IGh0bWwgJiZcbiAgICAgICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBodG1sICYmIDAgPCBodG1sLmxlbmd0aCAmJiBcIlxcblwiID09PSBodG1sWzBdXG4gICAgICAgICAgICAgICAgPyB0YXJnZXQkanNjb21wJDAucHVzaChsZWFkaW5nTmV3bGluZSwgaHRtbClcbiAgICAgICAgICAgICAgICA6IChjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihodG1sKSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKFwiXCIgKyBodG1sKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDEwICYmXG4gICAgICAgICAgICBcIlxcblwiID09PSBjaGlsZHJlbiRqc2NvbXAkMTBbMF0gJiZcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGxlYWRpbmdOZXdsaW5lKTtcbiAgICAgICAgICByZXR1cm4gY2hpbGRyZW4kanNjb21wJDEwO1xuICAgICAgICBjYXNlIFwiaW1nXCI6XG4gICAgICAgICAgdmFyIHNyYyA9IHByb3BzLnNyYyxcbiAgICAgICAgICAgIHNyY1NldCA9IHByb3BzLnNyY1NldDtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICBcImxhenlcIiA9PT0gcHJvcHMubG9hZGluZyB8fFxuICAgICAgICAgICAgICAoIXNyYyAmJiAhc3JjU2V0KSB8fFxuICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHNyYyAmJiBudWxsICE9IHNyYykgfHxcbiAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBzcmNTZXQgJiYgbnVsbCAhPSBzcmNTZXQpXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICBcImxvd1wiICE9PSBwcm9wcy5mZXRjaFByaW9yaXR5ICYmXG4gICAgICAgICAgICAhMSA9PT0gISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDMpICYmXG4gICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHNyYyB8fFxuICAgICAgICAgICAgICBcIjpcIiAhPT0gc3JjWzRdIHx8XG4gICAgICAgICAgICAgIChcImRcIiAhPT0gc3JjWzBdICYmIFwiRFwiICE9PSBzcmNbMF0pIHx8XG4gICAgICAgICAgICAgIChcImFcIiAhPT0gc3JjWzFdICYmIFwiQVwiICE9PSBzcmNbMV0pIHx8XG4gICAgICAgICAgICAgIChcInRcIiAhPT0gc3JjWzJdICYmIFwiVFwiICE9PSBzcmNbMl0pIHx8XG4gICAgICAgICAgICAgIChcImFcIiAhPT0gc3JjWzNdICYmIFwiQVwiICE9PSBzcmNbM10pKSAmJlxuICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBzcmNTZXQgfHxcbiAgICAgICAgICAgICAgXCI6XCIgIT09IHNyY1NldFs0XSB8fFxuICAgICAgICAgICAgICAoXCJkXCIgIT09IHNyY1NldFswXSAmJiBcIkRcIiAhPT0gc3JjU2V0WzBdKSB8fFxuICAgICAgICAgICAgICAoXCJhXCIgIT09IHNyY1NldFsxXSAmJiBcIkFcIiAhPT0gc3JjU2V0WzFdKSB8fFxuICAgICAgICAgICAgICAoXCJ0XCIgIT09IHNyY1NldFsyXSAmJiBcIlRcIiAhPT0gc3JjU2V0WzJdKSB8fFxuICAgICAgICAgICAgICAoXCJhXCIgIT09IHNyY1NldFszXSAmJiBcIkFcIiAhPT0gc3JjU2V0WzNdKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBzaXplcyA9IFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5zaXplcyA/IHByb3BzLnNpemVzIDogdm9pZCAwLFxuICAgICAgICAgICAgICBrZXkkanNjb21wJDAgPSBzcmNTZXQgPyBzcmNTZXQgKyBcIlxcblwiICsgKHNpemVzIHx8IFwiXCIpIDogc3JjLFxuICAgICAgICAgICAgICBwcm9tb3RhYmxlUHJlbG9hZHMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5pbWFnZXMsXG4gICAgICAgICAgICAgIHJlc291cmNlJGpzY29tcCQxID0gcHJvbW90YWJsZVByZWxvYWRzLmdldChrZXkkanNjb21wJDApO1xuICAgICAgICAgICAgaWYgKHJlc291cmNlJGpzY29tcCQxKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcImhpZ2hcIiA9PT0gcHJvcHMuZmV0Y2hQcmlvcml0eSB8fFxuICAgICAgICAgICAgICAgIDEwID4gcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuc2l6ZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcHJvbW90YWJsZVByZWxvYWRzLmRlbGV0ZShrZXkkanNjb21wJDApLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc291cmNlJGpzY29tcCQxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICFyZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkkanNjb21wJDApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXNba2V5JGpzY29tcCQwXSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgICAgIHZhciBpbnB1dCA9IHByb3BzLmNyb3NzT3JpZ2luO1xuICAgICAgICAgICAgICB2YXIgY3Jvc3NPcmlnaW4gPVxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnB1dFxuICAgICAgICAgICAgICAgICAgPyBcInVzZS1jcmVkZW50aWFsc1wiID09PSBpbnB1dFxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0XG4gICAgICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIHZhciBoZWFkZXJzID0gcmVuZGVyU3RhdGUuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBoZWFkZXI7XG4gICAgICAgICAgICAgIGhlYWRlcnMgJiZcbiAgICAgICAgICAgICAgMCA8IGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgJiZcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnNyY1NldCAmJlxuICAgICAgICAgICAgICAoXCJoaWdoXCIgPT09IHByb3BzLmZldGNoUHJpb3JpdHkgfHxcbiAgICAgICAgICAgICAgICA1MDAgPiBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgKChoZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoc3JjLCBcImltYWdlXCIsIHtcbiAgICAgICAgICAgICAgICBpbWFnZVNyY1NldDogcHJvcHMuc3JjU2V0LFxuICAgICAgICAgICAgICAgIGltYWdlU2l6ZXM6IHByb3BzLnNpemVzLFxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICAgICAgICAgICAgICBub25jZTogcHJvcHMubm9uY2UsXG4gICAgICAgICAgICAgICAgdHlwZTogcHJvcHMudHlwZSxcbiAgICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBwcm9wcy5mZXRjaFByaW9yaXR5LFxuICAgICAgICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcmVyUG9saWN5XG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgMCA8PSAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpXG4gICAgICAgICAgICAgICAgPyAoKHJlbmRlclN0YXRlLnJlc2V0cy5pbWFnZVtrZXkkanNjb21wJDBdID0gUFJFTE9BRF9OT19DUkVEUyksXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICYmXG4gICAgICAgICAgICAgICAgICAgIChoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAoaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcyArPSBoZWFkZXIpKVxuICAgICAgICAgICAgICAgIDogKChyZXNvdXJjZSRqc2NvbXAkMSA9IFtdKSxcbiAgICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChyZXNvdXJjZSRqc2NvbXAkMSwge1xuICAgICAgICAgICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgICAgICAgICBhczogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICBocmVmOiBzcmNTZXQgPyB2b2lkIDAgOiBzcmMsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0OiBzcmNTZXQsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU2l6ZXM6IHNpemVzLFxuICAgICAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBwcm9wcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBwcm9wcy5mZXRjaFByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICByZWZlcnJlclBvbGljeTogcHJvcHMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgXCJoaWdoXCIgPT09IHByb3BzLmZldGNoUHJpb3JpdHkgfHxcbiAgICAgICAgICAgICAgICAgIDEwID4gcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuc2l6ZVxuICAgICAgICAgICAgICAgICAgICA/IHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmFkZChyZXNvdXJjZSRqc2NvbXAkMSlcbiAgICAgICAgICAgICAgICAgICAgOiAocmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChyZXNvdXJjZSRqc2NvbXAkMSksXG4gICAgICAgICAgICAgICAgICAgICAgcHJvbW90YWJsZVByZWxvYWRzLnNldChrZXkkanNjb21wJDAsIHJlc291cmNlJGpzY29tcCQxKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCRqc2NvbXAkMCwgcHJvcHMsIFwiaW1nXCIpO1xuICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICBjYXNlIFwiYXJlYVwiOlxuICAgICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICAgICAgY2FzZSBcImhyXCI6XG4gICAgICAgIGNhc2UgXCJrZXlnZW5cIjpcbiAgICAgICAgY2FzZSBcInBhcmFtXCI6XG4gICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgY2FzZSBcInRyYWNrXCI6XG4gICAgICAgIGNhc2UgXCJ3YnJcIjpcbiAgICAgICAgICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCRqc2NvbXAkMCwgcHJvcHMsIHR5cGUpO1xuICAgICAgICBjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpcbiAgICAgICAgY2FzZSBcImNvbG9yLXByb2ZpbGVcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZVwiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlLXNyY1wiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlLXVyaVwiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlLWZvcm1hdFwiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpcbiAgICAgICAgY2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFKSB7XG4gICAgICAgICAgICB2YXIgcHJlYW1ibGUgPSBwcmVhbWJsZVN0YXRlIHx8IHJlbmRlclN0YXRlLnByZWFtYmxlO1xuICAgICAgICAgICAgaWYgKHByZWFtYmxlLmhlYWRDaHVua3MpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIGA8aGVhZD5gIHRhZyBtYXkgb25seSBiZSByZW5kZXJlZCBvbmNlLlwiKTtcbiAgICAgICAgICAgIHByZWFtYmxlLmhlYWRDaHVua3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDkgPSBwdXNoU3RhcnRTaW5nbGV0b25FbGVtZW50KFxuICAgICAgICAgICAgICBwcmVhbWJsZS5oZWFkQ2h1bmtzLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJoZWFkXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDkgPSBwdXNoU3RhcnRHZW5lcmljRWxlbWVudChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJoZWFkXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOTtcbiAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFKSB7XG4gICAgICAgICAgICB2YXIgcHJlYW1ibGUkanNjb21wJDAgPSBwcmVhbWJsZVN0YXRlIHx8IHJlbmRlclN0YXRlLnByZWFtYmxlO1xuICAgICAgICAgICAgaWYgKHByZWFtYmxlJGpzY29tcCQwLmJvZHlDaHVua3MpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIGA8Ym9keT5gIHRhZyBtYXkgb25seSBiZSByZW5kZXJlZCBvbmNlLlwiKTtcbiAgICAgICAgICAgIHByZWFtYmxlJGpzY29tcCQwLmJvZHlDaHVua3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDEwID0gcHVzaFN0YXJ0U2luZ2xldG9uRWxlbWVudChcbiAgICAgICAgICAgICAgcHJlYW1ibGUkanNjb21wJDAuYm9keUNodW5rcyxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIFwiYm9keVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMCA9IHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImJvZHlcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMDtcbiAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSkge1xuICAgICAgICAgICAgdmFyIHByZWFtYmxlJGpzY29tcCQxID0gcHJlYW1ibGVTdGF0ZSB8fCByZW5kZXJTdGF0ZS5wcmVhbWJsZTtcbiAgICAgICAgICAgIGlmIChwcmVhbWJsZSRqc2NvbXAkMS5odG1sQ2h1bmtzKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBgPGh0bWw+YCB0YWcgbWF5IG9ubHkgYmUgcmVuZGVyZWQgb25jZS5cIik7XG4gICAgICAgICAgICBwcmVhbWJsZSRqc2NvbXAkMS5odG1sQ2h1bmtzID0gW2RvY3R5cGVDaHVua107XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMSA9IHB1c2hTdGFydFNpbmdsZXRvbkVsZW1lbnQoXG4gICAgICAgICAgICAgIHByZWFtYmxlJGpzY29tcCQxLmh0bWxDaHVua3MsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImh0bWxcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTEgPSBwdXNoU3RhcnRHZW5lcmljRWxlbWVudChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJodG1sXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTE7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKC0xICE9PSB0eXBlLmluZGV4T2YoXCItXCIpKSB7XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKHR5cGUpKTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMTEgPSBudWxsLFxuICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDggPSBudWxsLFxuICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxMTtcbiAgICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMTEgaW4gcHJvcHMpXG4gICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQxMSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQxMSA9IHByb3BzW3Byb3BLZXkkanNjb21wJDExXTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDExKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BLZXkkanNjb21wJDExO1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQxMSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMTEgPSBwcm9wVmFsdWUkanNjb21wJDExO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDggPSBwcm9wVmFsdWUkanNjb21wJDExO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICBwdXNoU3R5bGVBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBwcm9wVmFsdWUkanNjb21wJDExKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsYXNzTmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBcImNsYXNzXCI7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBdHRyaWJ1dGVOYW1lU2FmZShwcm9wS2V5JGpzY29tcCQxMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHByb3BWYWx1ZSRqc2NvbXAkMTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBwcm9wVmFsdWUkanNjb21wJDExICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhMSAhPT0gcHJvcFZhbHVlJGpzY29tcCQxMVxuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSBwcm9wVmFsdWUkanNjb21wJDExKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDExID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9wVmFsdWUkanNjb21wJDExKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIocHJvcFZhbHVlJGpzY29tcCQxMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICAgIHB1c2hJbm5lckhUTUwoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ4LFxuICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMTFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW4kanNjb21wJDExO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudCh0YXJnZXQkanNjb21wJDAsIHByb3BzLCB0eXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5kQ2h1bmtGb3JUYWcodGFnKSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbmRUYWdDYWNoZS5nZXQodGFnKTtcbiAgICAgIHZvaWQgMCA9PT0gY2h1bmsgJiZcbiAgICAgICAgKChjaHVuayA9IFwiPC9cIiArIHRhZyArIFwiPlwiKSwgZW5kVGFnQ2FjaGUuc2V0KHRhZywgY2h1bmspKTtcbiAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgZnVuY3Rpb24gaG9pc3RQcmVhbWJsZVN0YXRlKHJlbmRlclN0YXRlLCBwcmVhbWJsZVN0YXRlKSB7XG4gICAgICByZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlLnByZWFtYmxlO1xuICAgICAgbnVsbCA9PT0gcmVuZGVyU3RhdGUuaHRtbENodW5rcyAmJlxuICAgICAgICBwcmVhbWJsZVN0YXRlLmh0bWxDaHVua3MgJiZcbiAgICAgICAgKChyZW5kZXJTdGF0ZS5odG1sQ2h1bmtzID0gcHJlYW1ibGVTdGF0ZS5odG1sQ2h1bmtzKSxcbiAgICAgICAgKHByZWFtYmxlU3RhdGUuY29udHJpYnV0aW9uIHw9IDEpKTtcbiAgICAgIG51bGwgPT09IHJlbmRlclN0YXRlLmhlYWRDaHVua3MgJiZcbiAgICAgICAgcHJlYW1ibGVTdGF0ZS5oZWFkQ2h1bmtzICYmXG4gICAgICAgICgocmVuZGVyU3RhdGUuaGVhZENodW5rcyA9IHByZWFtYmxlU3RhdGUuaGVhZENodW5rcyksXG4gICAgICAgIChwcmVhbWJsZVN0YXRlLmNvbnRyaWJ1dGlvbiB8PSA0KSk7XG4gICAgICBudWxsID09PSByZW5kZXJTdGF0ZS5ib2R5Q2h1bmtzICYmXG4gICAgICAgIHByZWFtYmxlU3RhdGUuYm9keUNodW5rcyAmJlxuICAgICAgICAoKHJlbmRlclN0YXRlLmJvZHlDaHVua3MgPSBwcmVhbWJsZVN0YXRlLmJvZHlDaHVua3MpLFxuICAgICAgICAocHJlYW1ibGVTdGF0ZS5jb250cmlidXRpb24gfD0gMikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUpIHtcbiAgICAgIHJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGUuYm9vdHN0cmFwQ2h1bmtzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW5kZXJTdGF0ZS5sZW5ndGggLSAxOyBpKyspXG4gICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGVbaV0pO1xuICAgICAgcmV0dXJuIGkgPCByZW5kZXJTdGF0ZS5sZW5ndGhcbiAgICAgICAgPyAoKGkgPSByZW5kZXJTdGF0ZVtpXSksIChyZW5kZXJTdGF0ZS5sZW5ndGggPSAwKSwgZGVzdGluYXRpb24ucHVzaChpKSlcbiAgICAgICAgOiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSwgaWQpIHtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTEpO1xuICAgICAgaWYgKG51bGwgPT09IGlkKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkFuIElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJlZm9yZSB3ZSBjYW4gY29tcGxldGUgdGhlIGJvdW5kYXJ5LlwiXG4gICAgICAgICk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlLmJvdW5kYXJ5UHJlZml4KTtcbiAgICAgIHJlbmRlclN0YXRlID0gaWQudG9TdHJpbmcoMTYpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZSk7XG4gICAgICByZXR1cm4gZGVzdGluYXRpb24ucHVzaChzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlUHJlYW1ibGVDb250cmlidXRpb24oZGVzdGluYXRpb24sIHByZWFtYmxlU3RhdGUpIHtcbiAgICAgIHByZWFtYmxlU3RhdGUgPSBwcmVhbWJsZVN0YXRlLmNvbnRyaWJ1dGlvbjtcbiAgICAgIHByZWFtYmxlU3RhdGUgIT09IE5vQ29udHJpYnV0aW9uICYmXG4gICAgICAgIChkZXN0aW5hdGlvbi5wdXNoKGJvdW5kYXJ5UHJlYW1ibGVDb250cmlidXRpb25DaHVua1N0YXJ0KSxcbiAgICAgICAgZGVzdGluYXRpb24ucHVzaChcIlwiICsgcHJlYW1ibGVTdGF0ZSksXG4gICAgICAgIGRlc3RpbmF0aW9uLnB1c2goYm91bmRhcnlQcmVhbWJsZUNvbnRyaWJ1dGlvbkNodW5rRW5kKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlU3RhcnRTZWdtZW50KGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSwgZm9ybWF0Q29udGV4dCwgaWQpIHtcbiAgICAgIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgICAgIGNhc2UgUk9PVF9IVE1MX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9IVE1MX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9IRUFEX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudEhUTUwpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIChyZW5kZXJTdGF0ZSA9IGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50SFRNTDIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBTVkdfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRTVkcpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIChyZW5kZXJTdGF0ZSA9IGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50U1ZHMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIE1BVEhNTF9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudE1hdGhNTCksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgKHJlbmRlclN0YXRlID0gaWQudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRNYXRoTUwyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudFRhYmxlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICAocmVuZGVyU3RhdGUgPSBpZC50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudFRhYmxlMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfQk9EWV9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudFRhYmxlQm9keSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgKHJlbmRlclN0YXRlID0gaWQudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRUYWJsZUJvZHkyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9ST1dfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRUYWJsZVJvdyksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgKHJlbmRlclN0YXRlID0gaWQudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRUYWJsZVJvdzIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBIVE1MX0NPTEdST1VQX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50Q29sR3JvdXApLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIChyZW5kZXJTdGF0ZSA9IGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50Q29sR3JvdXAyKVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIGluc2VydGlvbiBtb2RlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVFbmRTZWdtZW50KGRlc3RpbmF0aW9uLCBmb3JtYXRDb250ZXh0KSB7XG4gICAgICBzd2l0Y2ggKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSkge1xuICAgICAgICBjYXNlIFJPT1RfSFRNTF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfSFRNTF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfSEVBRF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfTU9ERTpcbiAgICAgICAgICByZXR1cm4gZGVzdGluYXRpb24ucHVzaChlbmRTZWdtZW50SFRNTCk7XG4gICAgICAgIGNhc2UgU1ZHX01PREU6XG4gICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uLnB1c2goZW5kU2VnbWVudFNWRyk7XG4gICAgICAgIGNhc2UgTUFUSE1MX01PREU6XG4gICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uLnB1c2goZW5kU2VnbWVudE1hdGhNTCk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAgICAgIHJldHVybiBkZXN0aW5hdGlvbi5wdXNoKGVuZFNlZ21lbnRUYWJsZSk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9CT0RZX01PREU6XG4gICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uLnB1c2goZW5kU2VnbWVudFRhYmxlQm9keSk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9ST1dfTU9ERTpcbiAgICAgICAgICByZXR1cm4gZGVzdGluYXRpb24ucHVzaChlbmRTZWdtZW50VGFibGVSb3cpO1xuICAgICAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgICAgICByZXR1cm4gZGVzdGluYXRpb24ucHVzaChlbmRTZWdtZW50Q29sR3JvdXApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biBpbnNlcnRpb24gbW9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGlucHV0KS5yZXBsYWNlKFxuICAgICAgICByZWdleEZvckpTU3RyaW5nc0luSW5zdHJ1Y3Rpb25TY3JpcHRzLFxuICAgICAgICBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2NcIjtcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI4XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MjAyOFwiO1xuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3RcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbnB1dCkucmVwbGFjZShcbiAgICAgICAgcmVnZXhGb3JKU1N0cmluZ3NJblNjcmlwdHMsXG4gICAgICAgIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNhc2UgXCImXCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MDAyNlwiO1xuICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDNlXCI7XG4gICAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2NcIjtcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI4XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MjAyOFwiO1xuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN0eWxlVGFnc0xhdGVGb3JCb3VuZGFyeShzdHlsZVF1ZXVlKSB7XG4gICAgICB2YXIgcnVsZXMgPSBzdHlsZVF1ZXVlLnJ1bGVzLFxuICAgICAgICBocmVmcyA9IHN0eWxlUXVldWUuaHJlZnM7XG4gICAgICAwIDwgcnVsZXMubGVuZ3RoICYmXG4gICAgICAgIDAgPT09IGhyZWZzLmxlbmd0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3QgZXhwZWN0ZWQgdG8gaGF2ZSBhdCBsZWFzdCBvbmUgaHJlZiBmb3IgYW4gYSBob2lzdGFibGUgc3R5bGUgYnV0IGZvdW5kIG5vbmUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGlmIChocmVmcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wdXNoKGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjEpO1xuICAgICAgICB0aGlzLnB1c2goc3R5bGVRdWV1ZS5wcmVjZWRlbmNlKTtcbiAgICAgICAgZm9yICh0aGlzLnB1c2gobGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMik7IGkgPCBocmVmcy5sZW5ndGggLSAxOyBpKyspXG4gICAgICAgICAgdGhpcy5wdXNoKGhyZWZzW2ldKSwgdGhpcy5wdXNoKHNwYWNlU2VwYXJhdG9yKTtcbiAgICAgICAgdGhpcy5wdXNoKGhyZWZzW2ldKTtcbiAgICAgICAgdGhpcy5wdXNoKGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHRoaXMucHVzaChydWxlc1tpXSk7XG4gICAgICAgIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSB0aGlzLnB1c2gobGF0ZVN0eWxlVGFnVGVtcGxhdGVDbG9zZSk7XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9ICEwO1xuICAgICAgICBydWxlcy5sZW5ndGggPSAwO1xuICAgICAgICBocmVmcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNTdHlsZXNUb0hvaXN0KHN0eWxlc2hlZXQpIHtcbiAgICAgIHJldHVybiBzdHlsZXNoZWV0LnN0YXRlICE9PSBQUkVBTUJMRVxuICAgICAgICA/IChjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSAhMClcbiAgICAgICAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVIb2lzdGFibGVzRm9yQm91bmRhcnkoXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIGhvaXN0YWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9ICExO1xuICAgICAgZGVzdGluYXRpb25IYXNDYXBhY2l0eSA9ICEwO1xuICAgICAgaG9pc3RhYmxlU3RhdGUuc3R5bGVzLmZvckVhY2goZmx1c2hTdHlsZVRhZ3NMYXRlRm9yQm91bmRhcnksIGRlc3RpbmF0aW9uKTtcbiAgICAgIGhvaXN0YWJsZVN0YXRlLnN0eWxlc2hlZXRzLmZvckVhY2goaGFzU3R5bGVzVG9Ib2lzdCk7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgJiZcbiAgICAgICAgKHJlbmRlclN0YXRlLnN0eWxlc1RvSG9pc3QgPSAhMCk7XG4gICAgICByZXR1cm4gZGVzdGluYXRpb25IYXNDYXBhY2l0eTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hSZXNvdXJjZShyZXNvdXJjZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvdXJjZS5sZW5ndGg7IGkrKykgdGhpcy5wdXNoKHJlc291cmNlW2ldKTtcbiAgICAgIHJlc291cmNlLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3R5bGVJblByZWFtYmxlKHN0eWxlc2hlZXQpIHtcbiAgICAgIHB1c2hMaW5rSW1wbChzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZSwgc3R5bGVzaGVldC5wcm9wcyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzLnB1c2goc3R5bGVzaGVldEZsdXNoaW5nUXVldWVbaV0pO1xuICAgICAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoID0gMDtcbiAgICAgIHN0eWxlc2hlZXQuc3RhdGUgPSBQUkVBTUJMRTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTdHlsZXNJblByZWFtYmxlKHN0eWxlUXVldWUpIHtcbiAgICAgIHZhciBoYXNTdHlsZXNoZWV0cyA9IDAgPCBzdHlsZVF1ZXVlLnNoZWV0cy5zaXplO1xuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuZm9yRWFjaChmbHVzaFN0eWxlSW5QcmVhbWJsZSwgdGhpcyk7XG4gICAgICBzdHlsZVF1ZXVlLnNoZWV0cy5jbGVhcigpO1xuICAgICAgdmFyIHJ1bGVzID0gc3R5bGVRdWV1ZS5ydWxlcyxcbiAgICAgICAgaHJlZnMgPSBzdHlsZVF1ZXVlLmhyZWZzO1xuICAgICAgaWYgKCFoYXNTdHlsZXNoZWV0cyB8fCBocmVmcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wdXNoKHN0eWxlVGFnUmVzb3VyY2VPcGVuMSk7XG4gICAgICAgIHRoaXMucHVzaChzdHlsZVF1ZXVlLnByZWNlZGVuY2UpO1xuICAgICAgICBzdHlsZVF1ZXVlID0gMDtcbiAgICAgICAgaWYgKGhyZWZzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICB0aGlzLnB1c2goc3R5bGVUYWdSZXNvdXJjZU9wZW4yKTtcbiAgICAgICAgICAgIHN0eWxlUXVldWUgPCBocmVmcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgc3R5bGVRdWV1ZSsrXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdGhpcy5wdXNoKGhyZWZzW3N0eWxlUXVldWVdKSwgdGhpcy5wdXNoKHNwYWNlU2VwYXJhdG9yKTtcbiAgICAgICAgICB0aGlzLnB1c2goaHJlZnNbc3R5bGVRdWV1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVzaChzdHlsZVRhZ1Jlc291cmNlT3BlbjMpO1xuICAgICAgICBmb3IgKHN0eWxlUXVldWUgPSAwOyBzdHlsZVF1ZXVlIDwgcnVsZXMubGVuZ3RoOyBzdHlsZVF1ZXVlKyspXG4gICAgICAgICAgdGhpcy5wdXNoKHJ1bGVzW3N0eWxlUXVldWVdKTtcbiAgICAgICAgdGhpcy5wdXNoKHN0eWxlVGFnUmVzb3VyY2VDbG9zZSk7XG4gICAgICAgIHJ1bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGhyZWZzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWxvYWRMYXRlU3R5bGUoc3R5bGVzaGVldCkge1xuICAgICAgaWYgKHN0eWxlc2hlZXQuc3RhdGUgPT09IFBFTkRJTkckMSkge1xuICAgICAgICBzdHlsZXNoZWV0LnN0YXRlID0gUFJFTE9BREVEO1xuICAgICAgICB2YXIgcHJvcHMgPSBzdHlsZXNoZWV0LnByb3BzO1xuICAgICAgICBwdXNoTGlua0ltcGwoc3R5bGVzaGVldEZsdXNoaW5nUXVldWUsIHtcbiAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgIGFzOiBcInN0eWxlXCIsXG4gICAgICAgICAgaHJlZjogc3R5bGVzaGVldC5wcm9wcy5ocmVmLFxuICAgICAgICAgIGNyb3NzT3JpZ2luOiBwcm9wcy5jcm9zc09yaWdpbixcbiAgICAgICAgICBmZXRjaFByaW9yaXR5OiBwcm9wcy5mZXRjaFByaW9yaXR5LFxuICAgICAgICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICAgIG1lZGlhOiBwcm9wcy5tZWRpYSxcbiAgICAgICAgICBocmVmTGFuZzogcHJvcHMuaHJlZkxhbmcsXG4gICAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHByb3BzLnJlZmVycmVyUG9saWN5XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHN0eWxlc2hlZXQgPSAwO1xuICAgICAgICAgIHN0eWxlc2hlZXQgPCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZS5sZW5ndGg7XG4gICAgICAgICAgc3R5bGVzaGVldCsrXG4gICAgICAgIClcbiAgICAgICAgICB0aGlzLnB1c2goc3R5bGVzaGVldEZsdXNoaW5nUXVldWVbc3R5bGVzaGVldF0pO1xuICAgICAgICBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkTGF0ZVN0eWxlcyhzdHlsZVF1ZXVlKSB7XG4gICAgICBzdHlsZVF1ZXVlLnNoZWV0cy5mb3JFYWNoKHByZWxvYWRMYXRlU3R5bGUsIHRoaXMpO1xuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuY2xlYXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5KUyhkZXN0aW5hdGlvbiwgaG9pc3RhYmxlU3RhdGUpIHtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goYXJyYXlGaXJzdE9wZW5CcmFja2V0KTtcbiAgICAgIHZhciBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5Rmlyc3RPcGVuQnJhY2tldDtcbiAgICAgIGhvaXN0YWJsZVN0YXRlLnN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgICAgIGlmIChyZXNvdXJjZS5zdGF0ZSAhPT0gUFJFQU1CTEUpXG4gICAgICAgICAgaWYgKHJlc291cmNlLnN0YXRlID09PSBMQVRFKVxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayksXG4gICAgICAgICAgICAgIChyZXNvdXJjZSA9IHJlc291cmNlLnByb3BzLmhyZWYpLFxuICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHJlc291cmNlLCBcImhyZWZcIiksXG4gICAgICAgICAgICAgIChyZXNvdXJjZSA9IGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKFwiXCIgKyByZXNvdXJjZSkpLFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlc291cmNlKSxcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChhcnJheUNsb3NlQnJhY2tldCksXG4gICAgICAgICAgICAgIChuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0KTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gobmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspO1xuICAgICAgICAgICAgdmFyIHByZWNlZGVuY2UgPSByZXNvdXJjZS5wcm9wc1tcImRhdGEtcHJlY2VkZW5jZVwiXSxcbiAgICAgICAgICAgICAgcHJvcHMgPSByZXNvdXJjZS5wcm9wcyxcbiAgICAgICAgICAgICAgY29lcmNlZEhyZWYgPSBzYW5pdGl6ZVVSTChcIlwiICsgcmVzb3VyY2UucHJvcHMuaHJlZik7XG4gICAgICAgICAgICBjb2VyY2VkSHJlZiA9IGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGNvZXJjZWRIcmVmKTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29lcmNlZEhyZWYpO1xuICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihwcmVjZWRlbmNlLCBcInByZWNlZGVuY2VcIik7XG4gICAgICAgICAgICBwcmVjZWRlbmNlID0gXCJcIiArIHByZWNlZGVuY2U7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgIHByZWNlZGVuY2UgPSBlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhwcmVjZWRlbmNlKTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocHJlY2VkZW5jZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkgJiZcbiAgICAgICAgICAgICAgICAoKHByZWNlZGVuY2UgPSBwcm9wc1twcm9wS2V5XSksIG51bGwgIT0gcHJlY2VkZW5jZSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImhyZWZcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWxcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJwcmVjZWRlbmNlXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YS1wcmVjZWRlbmNlXCI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJsaW5rIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMoXG4gICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICAgICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgICAgICAgICAgcmVzb3VyY2Uuc3RhdGUgPSBMQVRFO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMoZGVzdGluYXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgY2FzZSBcInJlZlwiOlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcImNsYXNzTmFtZVwiOlxuICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBcImNsYXNzXCI7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgbmFtZSA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgIGlmICghMSA9PT0gdmFsdWUpIHJldHVybjtcbiAgICAgICAgICBuYW1lID0gXCJcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNyY1wiOlxuICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwodmFsdWUpO1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIG5hbWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKDIgPCBuYW1lLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAoXCJvXCIgPT09IG5hbWVbMF0gfHwgXCJPXCIgPT09IG5hbWVbMF0pICYmXG4gICAgICAgICAgICAgIChcIm5cIiA9PT0gbmFtZVsxXSB8fCBcIk5cIiA9PT0gbmFtZVsxXSkpIHx8XG4gICAgICAgICAgICAhaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBuYW1lID0gXCJcIiArIHZhbHVlO1xuICAgICAgfVxuICAgICAgZGVzdGluYXRpb24ucHVzaChhcnJheUludGVyc3RpdGlhbCk7XG4gICAgICBhdHRyaWJ1dGVOYW1lID0gZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoYXR0cmlidXRlTmFtZSk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChhcnJheUludGVyc3RpdGlhbCk7XG4gICAgICBhdHRyaWJ1dGVOYW1lID0gZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMobmFtZSk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVIb2lzdGFibGVTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7IHN0eWxlczogbmV3IFNldCgpLCBzdHlsZXNoZWV0czogbmV3IFNldCgpIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICBocmVmLFxuICAgICAgcHJvcHNcbiAgICApIHtcbiAgICAgIChyZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikgfHxcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdJbnRlcm5hbCBSZWFjdCBFcnJvcjogUmVhY3QgZXhwZWN0ZWQgYm9vdHN0cmFwIHNjcmlwdCBvciBtb2R1bGUgd2l0aCBzcmMgXCIlc1wiIHRvIG5vdCBoYXZlIGJlZW4gcHJlbG9hZGVkIGFscmVhZHkuIHBsZWFzZSBmaWxlIGFuIGlzc3VlJyxcbiAgICAgICAgICBocmVmXG4gICAgICAgICk7XG4gICAgICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNbaHJlZl0gPSBFWElTVFM7XG4gICAgICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXNbaHJlZl0gPSBFWElTVFM7XG4gICAgICByZXN1bWFibGVTdGF0ZSA9IFtdO1xuICAgICAgcHVzaExpbmtJbXBsKHJlc3VtYWJsZVN0YXRlLCBwcm9wcyk7XG4gICAgICByZW5kZXJTdGF0ZS5ib290c3RyYXBTY3JpcHRzLmFkZChyZXN1bWFibGVTdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHRhcmdldCwgcHJlbG9hZFN0YXRlKSB7XG4gICAgICBudWxsID09IHRhcmdldC5jcm9zc09yaWdpbiAmJiAodGFyZ2V0LmNyb3NzT3JpZ2luID0gcHJlbG9hZFN0YXRlWzBdKTtcbiAgICAgIG51bGwgPT0gdGFyZ2V0LmludGVncml0eSAmJiAodGFyZ2V0LmludGVncml0eSA9IHByZWxvYWRTdGF0ZVsxXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFByZWxvYWRBc0hlYWRlcihocmVmLCBhcywgcGFyYW1zKSB7XG4gICAgICBocmVmID0gZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0KGhyZWYpO1xuICAgICAgYXMgPSBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQoYXMsIFwiYXNcIik7XG4gICAgICBhcyA9IFwiPFwiICsgaHJlZiArICc+OyByZWw9cHJlbG9hZDsgYXM9XCInICsgYXMgKyAnXCInO1xuICAgICAgZm9yICh2YXIgcGFyYW1OYW1lIGluIHBhcmFtcylcbiAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIHBhcmFtTmFtZSkgJiZcbiAgICAgICAgICAoKGhyZWYgPSBwYXJhbXNbcGFyYW1OYW1lXSksXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiZcbiAgICAgICAgICAgIChhcyArPVxuICAgICAgICAgICAgICBcIjsgXCIgK1xuICAgICAgICAgICAgICBwYXJhbU5hbWUudG9Mb3dlckNhc2UoKSArXG4gICAgICAgICAgICAgICc9XCInICtcbiAgICAgICAgICAgICAgZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KFxuICAgICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lXG4gICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAnXCInKSk7XG4gICAgICByZXR1cm4gYXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmSW5wdXQpIHtcbiAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oaHJlZklucHV0LCBcImhyZWZcIik7XG4gICAgICByZXR1cm4gKFwiXCIgKyBocmVmSW5wdXQpLnJlcGxhY2UoXG4gICAgICAgIHJlZ2V4Rm9ySHJlZkluTGlua0hlYWRlclVSTENvbnRleHQsXG4gICAgICAgIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dFJlcGxhY2VyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHRSZXBsYWNlcihtYXRjaCkge1xuICAgICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgIHJldHVybiBcIiUzQ1wiO1xuICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgIHJldHVybiBcIiUzRVwiO1xuICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTBBXCI7XG4gICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICByZXR1cm4gXCIlMERcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiZXNjYXBlTGlua0hyZWZGb3JIZWFkZXJDb250ZXh0UmVwbGFjZXIgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0XCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQodmFsdWUsIG5hbWUpIHtcbiAgICAgIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSAmJlxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBgJXNgIG9wdGlvbiBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHR5cGVOYW1lKHZhbHVlKVxuICAgICAgICApLFxuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpKTtcbiAgICAgIHJldHVybiAoXCJcIiArIHZhbHVlKS5yZXBsYWNlKFxuICAgICAgICByZWdleEZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCxcbiAgICAgICAgZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0UmVwbGFjZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyKG1hdGNoKSB7XG4gICAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICByZXR1cm4gXCIlMjJcIjtcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICByZXR1cm4gXCIlMjdcIjtcbiAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICByZXR1cm4gXCIlM0JcIjtcbiAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICByZXR1cm4gXCIlMkNcIjtcbiAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgIHJldHVybiBcIiUwQVwiO1xuICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTBEXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcImVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdFwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaG9pc3RTdHlsZVF1ZXVlRGVwZW5kZW5jeShzdHlsZVF1ZXVlKSB7XG4gICAgICB0aGlzLnN0eWxlcy5hZGQoc3R5bGVRdWV1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvaXN0U3R5bGVzaGVldERlcGVuZGVuY3koc3R5bGVzaGVldCkge1xuICAgICAgdGhpcy5zdHlsZXNoZWV0cy5hZGQoc3R5bGVzaGVldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbmRlclN0YXRlKHJlc3VtYWJsZVN0YXRlLCBnZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgICAgdmFyIGlkUHJlZml4ID0gcmVzdW1hYmxlU3RhdGUuaWRQcmVmaXgsXG4gICAgICAgIGJvb3RzdHJhcENodW5rcyA9IFtdLFxuICAgICAgICBib290c3RyYXBTY3JpcHRDb250ZW50ID0gcmVzdW1hYmxlU3RhdGUuYm9vdHN0cmFwU2NyaXB0Q29udGVudCxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0cyA9IHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcFNjcmlwdHMsXG4gICAgICAgIGJvb3RzdHJhcE1vZHVsZXMgPSByZXN1bWFibGVTdGF0ZS5ib290c3RyYXBNb2R1bGVzO1xuICAgICAgdm9pZCAwICE9PSBib290c3RyYXBTY3JpcHRDb250ZW50ICYmXG4gICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKFxuICAgICAgICAgIFwiPHNjcmlwdD5cIixcbiAgICAgICAgICBlc2NhcGVFbnRpcmVJbmxpbmVTY3JpcHRDb250ZW50KGJvb3RzdHJhcFNjcmlwdENvbnRlbnQpLFxuICAgICAgICAgIFwiXFx4M2Mvc2NyaXB0PlwiXG4gICAgICAgICk7XG4gICAgICBpZFByZWZpeCA9IHtcbiAgICAgICAgcGxhY2Vob2xkZXJQcmVmaXg6IGlkUHJlZml4ICsgXCJQOlwiLFxuICAgICAgICBzZWdtZW50UHJlZml4OiBpZFByZWZpeCArIFwiUzpcIixcbiAgICAgICAgYm91bmRhcnlQcmVmaXg6IGlkUHJlZml4ICsgXCJCOlwiLFxuICAgICAgICBzdGFydElubGluZVNjcmlwdDogXCI8c2NyaXB0PlwiLFxuICAgICAgICBwcmVhbWJsZTogY3JlYXRlUHJlYW1ibGVTdGF0ZSgpLFxuICAgICAgICBleHRlcm5hbFJ1bnRpbWVTY3JpcHQ6IG51bGwsXG4gICAgICAgIGJvb3RzdHJhcENodW5rczogYm9vdHN0cmFwQ2h1bmtzLFxuICAgICAgICBpbXBvcnRNYXBDaHVua3M6IFtdLFxuICAgICAgICBvbkhlYWRlcnM6IHZvaWQgMCxcbiAgICAgICAgaGVhZGVyczogbnVsbCxcbiAgICAgICAgcmVzZXRzOiB7XG4gICAgICAgICAgZm9udDoge30sXG4gICAgICAgICAgZG5zOiB7fSxcbiAgICAgICAgICBjb25uZWN0OiB7IGRlZmF1bHQ6IHt9LCBhbm9ueW1vdXM6IHt9LCBjcmVkZW50aWFsczoge30gfSxcbiAgICAgICAgICBpbWFnZToge30sXG4gICAgICAgICAgc3R5bGU6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIGNoYXJzZXRDaHVua3M6IFtdLFxuICAgICAgICB2aWV3cG9ydENodW5rczogW10sXG4gICAgICAgIGhvaXN0YWJsZUNodW5rczogW10sXG4gICAgICAgIHByZWNvbm5lY3RzOiBuZXcgU2V0KCksXG4gICAgICAgIGZvbnRQcmVsb2FkczogbmV3IFNldCgpLFxuICAgICAgICBoaWdoSW1hZ2VQcmVsb2FkczogbmV3IFNldCgpLFxuICAgICAgICBzdHlsZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0czogbmV3IFNldCgpLFxuICAgICAgICBzY3JpcHRzOiBuZXcgU2V0KCksXG4gICAgICAgIGJ1bGtQcmVsb2FkczogbmV3IFNldCgpLFxuICAgICAgICBwcmVsb2Fkczoge1xuICAgICAgICAgIGltYWdlczogbmV3IE1hcCgpLFxuICAgICAgICAgIHN0eWxlc2hlZXRzOiBuZXcgTWFwKCksXG4gICAgICAgICAgc2NyaXB0czogbmV3IE1hcCgpLFxuICAgICAgICAgIG1vZHVsZVNjcmlwdHM6IG5ldyBNYXAoKVxuICAgICAgICB9LFxuICAgICAgICBub25jZTogdm9pZCAwLFxuICAgICAgICBob2lzdGFibGVTdGF0ZTogbnVsbCxcbiAgICAgICAgc3R5bGVzVG9Ib2lzdDogITFcbiAgICAgIH07XG4gICAgICBpZiAodm9pZCAwICE9PSBib290c3RyYXBTY3JpcHRzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgPSAwO1xuICAgICAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgPCBib290c3RyYXBTY3JpcHRzLmxlbmd0aDtcbiAgICAgICAgICBib290c3RyYXBTY3JpcHRDb250ZW50KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHNjcmlwdENvbmZpZyA9IGJvb3RzdHJhcFNjcmlwdHNbYm9vdHN0cmFwU2NyaXB0Q29udGVudF0sXG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICBjcm9zc09yaWdpbiA9IHZvaWQgMCxcbiAgICAgICAgICAgIGludGVncml0eSA9IHZvaWQgMCxcbiAgICAgICAgICAgIHByb3BzID0ge1xuICAgICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgICBhczogXCJzY3JpcHRcIixcbiAgICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogXCJsb3dcIixcbiAgICAgICAgICAgICAgbm9uY2U6IHZvaWQgMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2NyaXB0Q29uZmlnXG4gICAgICAgICAgICA/IChwcm9wcy5ocmVmID0gc3JjID0gc2NyaXB0Q29uZmlnKVxuICAgICAgICAgICAgOiAoKHByb3BzLmhyZWYgPSBzcmMgPSBzY3JpcHRDb25maWcuc3JjKSxcbiAgICAgICAgICAgICAgKHByb3BzLmludGVncml0eSA9IGludGVncml0eSA9XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNjcmlwdENvbmZpZy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgID8gc2NyaXB0Q29uZmlnLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgOiB2b2lkIDApLFxuICAgICAgICAgICAgICAocHJvcHMuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbiA9XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNjcmlwdENvbmZpZyB8fFxuICAgICAgICAgICAgICAgIG51bGwgPT0gc2NyaXB0Q29uZmlnLmNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgOiBcInVzZS1jcmVkZW50aWFsc1wiID09PSBzY3JpcHRDb25maWcuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgPyBcInVzZS1jcmVkZW50aWFsc1wiXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIikpO1xuICAgICAgICAgIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShyZXN1bWFibGVTdGF0ZSwgaWRQcmVmaXgsIHNyYywgcHJvcHMpO1xuICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKCc8c2NyaXB0IHNyYz1cIicsIGVzY2FwZVRleHRGb3JCcm93c2VyKHNyYykpO1xuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnRlZ3JpdHkgJiZcbiAgICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKFxuICAgICAgICAgICAgICAnXCIgaW50ZWdyaXR5PVwiJyxcbiAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoaW50ZWdyaXR5KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKFxuICAgICAgICAgICAgICAnXCIgY3Jvc3NvcmlnaW49XCInLFxuICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihjcm9zc09yaWdpbilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goJ1wiIGFzeW5jPVwiXCI+XFx4M2Mvc2NyaXB0PicpO1xuICAgICAgICB9XG4gICAgICBpZiAodm9pZCAwICE9PSBib290c3RyYXBNb2R1bGVzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGJvb3RzdHJhcFNjcmlwdHMgPSAwO1xuICAgICAgICAgIGJvb3RzdHJhcFNjcmlwdHMgPCBib290c3RyYXBNb2R1bGVzLmxlbmd0aDtcbiAgICAgICAgICBib290c3RyYXBTY3JpcHRzKytcbiAgICAgICAgKVxuICAgICAgICAgIChib290c3RyYXBTY3JpcHRDb250ZW50ID0gYm9vdHN0cmFwTW9kdWxlc1tib290c3RyYXBTY3JpcHRzXSksXG4gICAgICAgICAgICAoY3Jvc3NPcmlnaW4gPSBzcmMgPSB2b2lkIDApLFxuICAgICAgICAgICAgKGludGVncml0eSA9IHtcbiAgICAgICAgICAgICAgcmVsOiBcIm1vZHVsZXByZWxvYWRcIixcbiAgICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogXCJsb3dcIixcbiAgICAgICAgICAgICAgbm9uY2U6IHZvaWQgMFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgYm9vdHN0cmFwU2NyaXB0Q29udGVudFxuICAgICAgICAgICAgICA/IChpbnRlZ3JpdHkuaHJlZiA9IHNjcmlwdENvbmZpZyA9IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQpXG4gICAgICAgICAgICAgIDogKChpbnRlZ3JpdHkuaHJlZiA9IHNjcmlwdENvbmZpZyA9IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQuc3JjKSxcbiAgICAgICAgICAgICAgICAoaW50ZWdyaXR5LmludGVncml0eSA9IGNyb3NzT3JpZ2luID1cbiAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBib290c3RyYXBTY3JpcHRDb250ZW50LmludGVncml0eVxuICAgICAgICAgICAgICAgICAgICA/IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICAgIDogdm9pZCAwKSxcbiAgICAgICAgICAgICAgICAoaW50ZWdyaXR5LmNyb3NzT3JpZ2luID0gc3JjID1cbiAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBib290c3RyYXBTY3JpcHRDb250ZW50IHx8XG4gICAgICAgICAgICAgICAgICBudWxsID09IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgOiBcInVzZS1jcmVkZW50aWFsc1wiID09PSBib290c3RyYXBTY3JpcHRDb250ZW50LmNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICAgICAgPyBcInVzZS1jcmVkZW50aWFsc1wiXG4gICAgICAgICAgICAgICAgICAgICAgOiBcIlwiKSksXG4gICAgICAgICAgICBwcmVsb2FkQm9vdHN0cmFwU2NyaXB0T3JNb2R1bGUoXG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgICBpZFByZWZpeCxcbiAgICAgICAgICAgICAgc2NyaXB0Q29uZmlnLFxuICAgICAgICAgICAgICBpbnRlZ3JpdHlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChcbiAgICAgICAgICAgICAgJzxzY3JpcHQgdHlwZT1cIm1vZHVsZVwiIHNyYz1cIicsXG4gICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHNjcmlwdENvbmZpZylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goXG4gICAgICAgICAgICAgICAgJ1wiIGludGVncml0eT1cIicsXG4gICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoY3Jvc3NPcmlnaW4pXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygc3JjICYmXG4gICAgICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKFxuICAgICAgICAgICAgICAgICdcIiBjcm9zc29yaWdpbj1cIicsXG4gICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoc3JjKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goJ1wiIGFzeW5jPVwiXCI+XFx4M2Mvc2NyaXB0PicpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGxhY2Vob2xkZXJQcmVmaXg6IGlkUHJlZml4LnBsYWNlaG9sZGVyUHJlZml4LFxuICAgICAgICBzZWdtZW50UHJlZml4OiBpZFByZWZpeC5zZWdtZW50UHJlZml4LFxuICAgICAgICBib3VuZGFyeVByZWZpeDogaWRQcmVmaXguYm91bmRhcnlQcmVmaXgsXG4gICAgICAgIHN0YXJ0SW5saW5lU2NyaXB0OiBpZFByZWZpeC5zdGFydElubGluZVNjcmlwdCxcbiAgICAgICAgcHJlYW1ibGU6IGlkUHJlZml4LnByZWFtYmxlLFxuICAgICAgICBleHRlcm5hbFJ1bnRpbWVTY3JpcHQ6IGlkUHJlZml4LmV4dGVybmFsUnVudGltZVNjcmlwdCxcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzOiBpZFByZWZpeC5ib290c3RyYXBDaHVua3MsXG4gICAgICAgIGltcG9ydE1hcENodW5rczogaWRQcmVmaXguaW1wb3J0TWFwQ2h1bmtzLFxuICAgICAgICBvbkhlYWRlcnM6IGlkUHJlZml4Lm9uSGVhZGVycyxcbiAgICAgICAgaGVhZGVyczogaWRQcmVmaXguaGVhZGVycyxcbiAgICAgICAgcmVzZXRzOiBpZFByZWZpeC5yZXNldHMsXG4gICAgICAgIGNoYXJzZXRDaHVua3M6IGlkUHJlZml4LmNoYXJzZXRDaHVua3MsXG4gICAgICAgIHZpZXdwb3J0Q2h1bmtzOiBpZFByZWZpeC52aWV3cG9ydENodW5rcyxcbiAgICAgICAgaG9pc3RhYmxlQ2h1bmtzOiBpZFByZWZpeC5ob2lzdGFibGVDaHVua3MsXG4gICAgICAgIHByZWNvbm5lY3RzOiBpZFByZWZpeC5wcmVjb25uZWN0cyxcbiAgICAgICAgZm9udFByZWxvYWRzOiBpZFByZWZpeC5mb250UHJlbG9hZHMsXG4gICAgICAgIGhpZ2hJbWFnZVByZWxvYWRzOiBpZFByZWZpeC5oaWdoSW1hZ2VQcmVsb2FkcyxcbiAgICAgICAgc3R5bGVzOiBpZFByZWZpeC5zdHlsZXMsXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHM6IGlkUHJlZml4LmJvb3RzdHJhcFNjcmlwdHMsXG4gICAgICAgIHNjcmlwdHM6IGlkUHJlZml4LnNjcmlwdHMsXG4gICAgICAgIGJ1bGtQcmVsb2FkczogaWRQcmVmaXguYnVsa1ByZWxvYWRzLFxuICAgICAgICBwcmVsb2FkczogaWRQcmVmaXgucHJlbG9hZHMsXG4gICAgICAgIHN0eWxlc1RvSG9pc3Q6IGlkUHJlZml4LnN0eWxlc1RvSG9pc3QsXG4gICAgICAgIGdlbmVyYXRlU3RhdGljTWFya3VwOiBnZW5lcmF0ZVN0YXRpY01hcmt1cFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRleHRJbnN0YW5jZSh0YXJnZXQsIHRleHQsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQpIHtcbiAgICAgIGlmIChyZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cClcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpKSwgITE7XG4gICAgICBcIlwiID09PSB0ZXh0XG4gICAgICAgID8gKHRhcmdldCA9IHRleHRFbWJlZGRlZClcbiAgICAgICAgOiAodGV4dEVtYmVkZGVkICYmIHRhcmdldC5wdXNoKFwiXFx4M2MhLS0gLS1cXHgzZVwiKSxcbiAgICAgICAgICB0YXJnZXQucHVzaChlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSksXG4gICAgICAgICAgKHRhcmdldCA9ICEwKSk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU2VnbWVudEZpbmFsZShcbiAgICAgIHRhcmdldCxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgbGFzdFB1c2hlZFRleHQsXG4gICAgICB0ZXh0RW1iZWRkZWRcbiAgICApIHtcbiAgICAgIHJlbmRlclN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwIHx8XG4gICAgICAgIChsYXN0UHVzaGVkVGV4dCAmJiB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0LnB1c2goXCJcXHgzYyEtLSAtLVxceDNlXCIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpIHtcbiAgICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXYucGFyZW50VmFsdWU7XG4gICAgICAgIHByZXYgPSBwcmV2LnBhcmVudDtcbiAgICAgICAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcbiAgICAgICAgaWYgKG51bGwgPT09IHByZXYpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gcGFyZW50TmV4dClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChudWxsID09PSBwYXJlbnROZXh0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlIHN0YWNrcyBtdXN0IHJlYWNoIHRoZSByb290IGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgcGFyZW50TmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wQWxsUHJldmlvdXMocHJldikge1xuICAgICAgcHJldi5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gcHJldi5wYXJlbnRWYWx1ZTtcbiAgICAgIHByZXYgPSBwcmV2LnBhcmVudDtcbiAgICAgIG51bGwgIT09IHByZXYgJiYgcG9wQWxsUHJldmlvdXMocHJldik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hBbGxOZXh0KG5leHQpIHtcbiAgICAgIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG4gICAgICBudWxsICE9PSBwYXJlbnROZXh0ICYmIHB1c2hBbGxOZXh0KHBhcmVudE5leHQpO1xuICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dC52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpIHtcbiAgICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXYucGFyZW50VmFsdWU7XG4gICAgICBwcmV2ID0gcHJldi5wYXJlbnQ7XG4gICAgICBpZiAobnVsbCA9PT0gcHJldilcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUaGUgZGVwdGggbXVzdCBlcXVhbCBhdCBsZWFzdCBhdCB6ZXJvIGJlZm9yZSByZWFjaGluZyB0aGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgcHJldi5kZXB0aCA9PT0gbmV4dC5kZXB0aFxuICAgICAgICA/IHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpXG4gICAgICAgIDogcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBuZXh0KSB7XG4gICAgICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuICAgICAgaWYgKG51bGwgPT09IHBhcmVudE5leHQpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHByZXYuZGVwdGggPT09IHBhcmVudE5leHQuZGVwdGhcbiAgICAgICAgPyBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBwYXJlbnROZXh0KVxuICAgICAgICA6IHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIHBhcmVudE5leHQpO1xuICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dC52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3dpdGNoQ29udGV4dChuZXdTbmFwc2hvdCkge1xuICAgICAgdmFyIHByZXYgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG4gICAgICBwcmV2ICE9PSBuZXdTbmFwc2hvdCAmJlxuICAgICAgICAobnVsbCA9PT0gcHJldlxuICAgICAgICAgID8gcHVzaEFsbE5leHQobmV3U25hcHNob3QpXG4gICAgICAgICAgOiBudWxsID09PSBuZXdTbmFwc2hvdFxuICAgICAgICAgICAgPyBwb3BBbGxQcmV2aW91cyhwcmV2KVxuICAgICAgICAgICAgOiBwcmV2LmRlcHRoID09PSBuZXdTbmFwc2hvdC5kZXB0aFxuICAgICAgICAgICAgICA/IHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5ld1NuYXBzaG90KVxuICAgICAgICAgICAgICA6IHByZXYuZGVwdGggPiBuZXdTbmFwc2hvdC5kZXB0aFxuICAgICAgICAgICAgICAgID8gcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5ld1NuYXBzaG90KVxuICAgICAgICAgICAgICAgIDogcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgbmV3U25hcHNob3QpLFxuICAgICAgICAoY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV3U25hcHNob3QpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICBpZiAobnVsbCAhPT0gY2FsbGJhY2sgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGtleSA9IFN0cmluZyhjYWxsYmFjayk7XG4gICAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSB8fFxuICAgICAgICAgIChkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gICAgICBwdWJsaWNJbnN0YW5jZSA9XG4gICAgICAgICgocHVibGljSW5zdGFuY2UgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcikgJiZcbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocHVibGljSW5zdGFuY2UpKSB8fFxuICAgICAgICBcIlJlYWN0Q2xhc3NcIjtcbiAgICAgIHZhciB3YXJuaW5nS2V5ID0gcHVibGljSW5zdGFuY2UgKyBcIi5cIiArIGNhbGxlck5hbWU7XG4gICAgICBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldIHx8XG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRpbmcgY29tcG9uZW50LiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC5cIixcbiAgICAgICAgICBjYWxsZXJOYW1lLFxuICAgICAgICAgIHB1YmxpY0luc3RhbmNlXG4gICAgICAgICksXG4gICAgICAgIChkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldID0gITApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRyZWVDb250ZXh0KGJhc2VDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICAgICAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gYmFzZUNvbnRleHQuaWQ7XG4gICAgICBiYXNlQ29udGV4dCA9IGJhc2VDb250ZXh0Lm92ZXJmbG93O1xuICAgICAgdmFyIGJhc2VMZW5ndGggPSAzMiAtIGNsejMyKGJhc2VJZFdpdGhMZWFkaW5nQml0KSAtIDE7XG4gICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmPSB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgdmFyIGxlbmd0aCA9IDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoO1xuICAgICAgaWYgKDMwIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSAoYmFzZUxlbmd0aCAlIDUpO1xuICAgICAgICBsZW5ndGggPSAoXG4gICAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJlxuICAgICAgICAgICgoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxKVxuICAgICAgICApLnRvU3RyaW5nKDMyKTtcbiAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgPj49IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICBiYXNlTGVuZ3RoIC09IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOlxuICAgICAgICAgICAgKDEgPDwgKDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoKSkgfFxuICAgICAgICAgICAgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHxcbiAgICAgICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0LFxuICAgICAgICAgIG92ZXJmbG93OiBsZW5ndGggKyBiYXNlQ29udGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6ICgxIDw8IGxlbmd0aCkgfCAoaW5kZXggPDwgYmFzZUxlbmd0aCkgfCBiYXNlSWRXaXRoTGVhZGluZ0JpdCxcbiAgICAgICAgb3ZlcmZsb3c6IGJhc2VDb250ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpIHtcbiAgICAgIHggPj4+PSAwO1xuICAgICAgcmV0dXJuIDAgPT09IHggPyAzMiA6ICgzMSAtICgobG9nKHgpIC8gTE4yKSB8IDApKSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AkMigpIHt9XG4gICAgZnVuY3Rpb24gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KSB7XG4gICAgICBpbmRleCA9IHRoZW5hYmxlU3RhdGVbaW5kZXhdO1xuICAgICAgdm9pZCAwID09PSBpbmRleFxuICAgICAgICA/IHRoZW5hYmxlU3RhdGUucHVzaCh0aGVuYWJsZSlcbiAgICAgICAgOiBpbmRleCAhPT0gdGhlbmFibGUgJiZcbiAgICAgICAgICAodGhlbmFibGUudGhlbihub29wJDIsIG5vb3AkMiksICh0aGVuYWJsZSA9IGluZGV4KSk7XG4gICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICB0aHJvdyB0aGVuYWJsZS5yZWFzb247XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoZW5hYmxlLnN0YXR1c1xuICAgICAgICAgICAgPyB0aGVuYWJsZS50aGVuKG5vb3AkMiwgbm9vcCQyKVxuICAgICAgICAgICAgOiAoKHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZSksXG4gICAgICAgICAgICAgICh0aGVuYWJsZVN0YXRlLnN0YXR1cyA9IFwicGVuZGluZ1wiKSxcbiAgICAgICAgICAgICAgdGhlbmFibGVTdGF0ZS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgICAgIHRocm93IHRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICB0aHJvdyBTdXNwZW5zZUV4Y2VwdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSB7XG4gICAgICBpZiAobnVsbCA9PT0gc3VzcGVuZGVkVGhlbmFibGUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgYSBzdXNwZW5kZWQgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgdGhlbmFibGUgPSBzdXNwZW5kZWRUaGVuYWJsZTtcbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgICAgcmV0dXJuICh4ID09PSB5ICYmICgwICE9PSB4IHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCJcbiAgICAgICAgKTtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiBZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ydWxlcy1vZi1ob29rc1wiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVIb29rKCkge1xuICAgICAgaWYgKDAgPCBudW1iZXJPZlJlUmVuZGVycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXJcIik7XG4gICAgICByZXR1cm4geyBtZW1vaXplZFN0YXRlOiBudWxsLCBxdWV1ZTogbnVsbCwgbmV4dDogbnVsbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgPyBudWxsID09PSBmaXJzdFdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gKChpc1JlUmVuZGVyID0gITEpLFxuICAgICAgICAgICAgKGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlSG9vaygpKSlcbiAgICAgICAgICA6ICgoaXNSZVJlbmRlciA9ICEwKSwgKHdvcmtJblByb2dyZXNzSG9vayA9IGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rKSlcbiAgICAgICAgOiBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dFxuICAgICAgICAgID8gKChpc1JlUmVuZGVyID0gITEpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gY3JlYXRlSG9vaygpKSlcbiAgICAgICAgICA6ICgoaXNSZVJlbmRlciA9ICEwKSwgKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0KSk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhlbmFibGVTdGF0ZTtcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldEhvb2tzU3RhdGUoKSB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGggPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0ID1cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMTtcbiAgICAgIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICAgIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICByZWR1Y2VyICE9PSBiYXNpY1N0YXRlUmVkdWNlciAmJiAoY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIik7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmIChpc1JlUmVuZGVyKSB7XG4gICAgICAgIGluaXQgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWU7XG4gICAgICAgIGluaXRpYWxBcmcgPSBpbml0LmRpc3BhdGNoO1xuICAgICAgICBpZiAobnVsbCAhPT0gcmVuZGVyUGhhc2VVcGRhdGVzKSB7XG4gICAgICAgICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KGluaXQpO1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAgICAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5kZWxldGUoaW5pdCk7XG4gICAgICAgICAgICBpbml0ID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlLmFjdGlvbjtcbiAgICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITA7XG4gICAgICAgICAgICAgIGluaXQgPSByZWR1Y2VyKGluaXQsIGFjdGlvbik7XG4gICAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgICAgICAgICBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgICAgICAgfSB3aGlsZSAobnVsbCAhPT0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXQ7XG4gICAgICAgICAgICByZXR1cm4gW2luaXQsIGluaXRpYWxBcmddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBpbml0aWFsQXJnXTtcbiAgICAgIH1cbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICEwO1xuICAgICAgcmVkdWNlciA9XG4gICAgICAgIHJlZHVjZXIgPT09IGJhc2ljU3RhdGVSZWR1Y2VyXG4gICAgICAgICAgPyBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbml0aWFsQXJnXG4gICAgICAgICAgICA/IGluaXRpYWxBcmcoKVxuICAgICAgICAgICAgOiBpbml0aWFsQXJnXG4gICAgICAgICAgOiB2b2lkIDAgIT09IGluaXRcbiAgICAgICAgICAgID8gaW5pdChpbml0aWFsQXJnKVxuICAgICAgICAgICAgOiBpbml0aWFsQXJnO1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZHVjZXI7XG4gICAgICByZWR1Y2VyID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlID0geyBsYXN0OiBudWxsLCBkaXNwYXRjaDogbnVsbCB9O1xuICAgICAgcmVkdWNlciA9IHJlZHVjZXIuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgICk7XG4gICAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCByZWR1Y2VyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzc0hvb2spIHtcbiAgICAgICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gcHJldlN0YXRlICYmIG51bGwgIT09IGRlcHMpIHtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcHJldlN0YXRlWzFdO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdClcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsIGl0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLlwiLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBkZXBzLmxlbmd0aCAhPT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlIG9yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuUHJldmlvdXM6ICVzXFxuSW5jb21pbmc6ICVzXCIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldixcbiAgICAgICAgICAgICAgICAgIFwiW1wiICsgZGVwcy5qb2luKFwiLCBcIikgKyBcIl1cIixcbiAgICAgICAgICAgICAgICAgIFwiW1wiICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmpvaW4oXCIsIFwiKSArIFwiXVwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgaSA8IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5sZW5ndGggJiYgaSA8IGRlcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgaWYgKCFvYmplY3RJcyhkZXBzW2ldLCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITA7XG4gICAgICBuZXh0Q3JlYXRlID0gbmV4dENyZWF0ZSgpO1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0Q3JlYXRlLCBkZXBzXTtcbiAgICAgIHJldHVybiBuZXh0Q3JlYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihjb21wb25lbnRJZGVudGl0eSwgcXVldWUsIGFjdGlvbikge1xuICAgICAgaWYgKDI1IDw9IG51bWJlck9mUmVSZW5kZXJzKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlwiXG4gICAgICAgICk7XG4gICAgICBpZiAoY29tcG9uZW50SWRlbnRpdHkgPT09IGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudClcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICEwKSxcbiAgICAgICAgICAoY29tcG9uZW50SWRlbnRpdHkgPSB7IGFjdGlvbjogYWN0aW9uLCBuZXh0OiBudWxsIH0pLFxuICAgICAgICAgIG51bGwgPT09IHJlbmRlclBoYXNlVXBkYXRlcyAmJiAocmVuZGVyUGhhc2VVcGRhdGVzID0gbmV3IE1hcCgpKSxcbiAgICAgICAgICAoYWN0aW9uID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSkpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gYWN0aW9uKVxuICAgICAgICApXG4gICAgICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLnNldChxdWV1ZSwgY29tcG9uZW50SWRlbnRpdHkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmb3IgKHF1ZXVlID0gYWN0aW9uOyBudWxsICE9PSBxdWV1ZS5uZXh0OyApIHF1ZXVlID0gcXVldWUubmV4dDtcbiAgICAgICAgICBxdWV1ZS5uZXh0ID0gY29tcG9uZW50SWRlbnRpdHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb24oKSB7XG4gICAgICB0aHJvdyBFcnJvcihcInN0YXJ0VHJhbnNpdGlvbiBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdXBwb3J0ZWRTZXRPcHRpbWlzdGljU3RhdGUoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgb3B0aW1pc3RpYyBzdGF0ZSB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB2YXIgYWN0aW9uU3RhdGVIb29rSW5kZXggPSBhY3Rpb25TdGF0ZUNvdW50ZXIrKyxcbiAgICAgICAgcmVxdWVzdCA9IGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3Q7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uLiQkRk9STV9BQ1RJT04pIHtcbiAgICAgICAgdmFyIG5leHRQb3N0YmFja1N0YXRlS2V5ID0gbnVsbCxcbiAgICAgICAgICBjb21wb25lbnRLZXlQYXRoID0gY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aDtcbiAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QuZm9ybVN0YXRlO1xuICAgICAgICB2YXIgaXNTaWduYXR1cmVFcXVhbCA9IGFjdGlvbi4kJElTX1NJR05BVFVSRV9FUVVBTDtcbiAgICAgICAgaWYgKG51bGwgIT09IHJlcXVlc3QgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaXNTaWduYXR1cmVFcXVhbCkge1xuICAgICAgICAgIHZhciBwb3N0YmFja0tleSA9IHJlcXVlc3RbMV07XG4gICAgICAgICAgaXNTaWduYXR1cmVFcXVhbC5jYWxsKGFjdGlvbiwgcmVxdWVzdFsyXSwgcmVxdWVzdFszXSkgJiZcbiAgICAgICAgICAgICgobmV4dFBvc3RiYWNrU3RhdGVLZXkgPVxuICAgICAgICAgICAgICB2b2lkIDAgIT09IHBlcm1hbGlua1xuICAgICAgICAgICAgICAgID8gXCJwXCIgKyBwZXJtYWxpbmtcbiAgICAgICAgICAgICAgICA6IFwia1wiICtcbiAgICAgICAgICAgICAgICAgIG11cm11cmhhc2gzXzMyX2djKFxuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50S2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlSG9va0luZGV4XG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHBvc3RiYWNrS2V5ID09PSBuZXh0UG9zdGJhY2tTdGF0ZUtleSAmJlxuICAgICAgICAgICAgICAoKGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCA9IGFjdGlvblN0YXRlSG9va0luZGV4KSxcbiAgICAgICAgICAgICAgKGluaXRpYWxTdGF0ZSA9IHJlcXVlc3RbMF0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvdW5kQWN0aW9uID0gYWN0aW9uLmJpbmQobnVsbCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgYWN0aW9uID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICBib3VuZEFjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYm91bmRBY3Rpb24uJCRGT1JNX0FDVElPTiAmJlxuICAgICAgICAgIChhY3Rpb24uJCRGT1JNX0FDVElPTiA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IGJvdW5kQWN0aW9uLiQkRk9STV9BQ1RJT04ocHJlZml4KTtcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gcGVybWFsaW5rICYmXG4gICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHBlcm1hbGluaywgXCJ0YXJnZXRcIiksXG4gICAgICAgICAgICAgIChwZXJtYWxpbmsgKz0gXCJcIiksXG4gICAgICAgICAgICAgIChwcmVmaXguYWN0aW9uID0gcGVybWFsaW5rKSk7XG4gICAgICAgICAgICB2YXIgZm9ybURhdGEgPSBwcmVmaXguZGF0YTtcbiAgICAgICAgICAgIGZvcm1EYXRhICYmXG4gICAgICAgICAgICAgIChudWxsID09PSBuZXh0UG9zdGJhY2tTdGF0ZUtleSAmJlxuICAgICAgICAgICAgICAgIChuZXh0UG9zdGJhY2tTdGF0ZUtleSA9XG4gICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHBlcm1hbGlua1xuICAgICAgICAgICAgICAgICAgICA/IFwicFwiICsgcGVybWFsaW5rXG4gICAgICAgICAgICAgICAgICAgIDogXCJrXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIG11cm11cmhhc2gzXzMyX2djKFxuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRLZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZUhvb2tJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIiRBQ1RJT05fS0VZXCIsIG5leHRQb3N0YmFja1N0YXRlS2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW2luaXRpYWxTdGF0ZSwgYWN0aW9uLCAhMV07XG4gICAgICB9XG4gICAgICB2YXIgX2JvdW5kQWN0aW9uID0gYWN0aW9uLmJpbmQobnVsbCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgICAgZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICBfYm91bmRBY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgIH0sXG4gICAgICAgICExXG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXI7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciArPSAxO1xuICAgICAgbnVsbCA9PT0gdGhlbmFibGVTdGF0ZSAmJiAodGhlbmFibGVTdGF0ZSA9IFtdKTtcbiAgICAgIHJldHVybiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN1cHBvcnRlZFJlZnJlc2goKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNhY2hlIGNhbm5vdCBiZSByZWZyZXNoZWQgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wJDEoKSB7fVxuICAgIGZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cbiAgICBmdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRpc2FibGVkRGVwdGgrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICAgICAgZGlzYWJsZWREZXB0aC0tO1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgdmFyIHByb3BzID0geyBjb25maWd1cmFibGU6ICEwLCBlbnVtZXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZMb2cgfSksXG4gICAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkluZm8gfSksXG4gICAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldldhcm4gfSksXG4gICAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZFcnJvciB9KSxcbiAgICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwIH0pLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWQgfSksXG4gICAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cEVuZCB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIDAgPiBkaXNhYmxlZERlcHRoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gcHJlZml4KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgIHByZWZpeCA9IChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgXCJcIjtcbiAgICAgICAgICBzdWZmaXggPVxuICAgICAgICAgICAgLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJcXG4gICAgYXRcIilcbiAgICAgICAgICAgICAgPyBcIiAoPGFub255bW91cz4pXCJcbiAgICAgICAgICAgICAgOiAtMSA8IHguc3RhY2suaW5kZXhPZihcIkBcIilcbiAgICAgICAgICAgICAgICA/IFwiQHVua25vd246MDowXCJcbiAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlxcblwiICsgcHJlZml4ICsgbmFtZSArIHN1ZmZpeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gICAgICBpZiAoIWZuIHx8IHJlZW50cnkpIHJldHVybiBcIlwiO1xuICAgICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gZnJhbWUpIHJldHVybiBmcmFtZTtcbiAgICAgIHJlZW50cnkgPSAhMDtcbiAgICAgIGZyYW1lID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBudWxsO1xuICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBudWxsO1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICAgICAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0geDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQxKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sID0geCQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoRmFrZSA9IGZuKCkpICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBGYWtlLmNhdGNoICYmXG4gICAgICAgICAgICAgICAgICBGYWtlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2FtcGxlLnN0YWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPVxuICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCI7XG4gICAgICAgIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICBcIm5hbWVcIlxuICAgICAgICApO1xuICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgICB7IHZhbHVlOiBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiIH1cbiAgICAgICAgICApO1xuICAgICAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID1cbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcbiAgICAgICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICAgICAgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBuYW1lUHJvcERlc2NyaXB0b3IgPSAwO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvcisrO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPCBjb250cm9sTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIrKztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID09PSBjb250cm9sTGluZXMubGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICAgICAgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgJiZcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXTtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXI7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3ItLSwgX1J1bkluUm9vdEZyYW1lJERldGVyLS1cbiAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKDEgIT09IG5hbWVQcm9wRGVzY3JpcHRvciB8fCAxICE9PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpIHtcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAobmFtZVByb3BEZXNjcmlwdG9yLS0sXG4gICAgICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tLFxuICAgICAgICAgICAgICAgICAgICAwID4gX1J1bkluUm9vdEZyYW1lJERldGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0ucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IG5ldyBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IFwiXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZm4uZGlzcGxheU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBfZnJhbWUuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIChfZnJhbWUgPSBfZnJhbWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGZuLmRpc3BsYXlOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKHJlZW50cnkgPSAhMSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2aW91c0Rpc3BhdGNoZXIpLFxuICAgICAgICAgIHJlZW5hYmxlTG9ncygpLFxuICAgICAgICAgIChFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGZyYW1lKTtcbiAgICAgIH1cbiAgICAgIHNhbXBsZUxpbmVzID0gKHNhbXBsZUxpbmVzID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogXCJcIilcbiAgICAgICAgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShzYW1wbGVMaW5lcylcbiAgICAgICAgOiBcIlwiO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiYgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHNhbXBsZUxpbmVzKTtcbiAgICAgIHJldHVybiBzYW1wbGVMaW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0T3duZXJTdGFjayhlcnJvcikge1xuICAgICAgdmFyIHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICBlcnJvciA9IGVycm9yLnN0YWNrO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2UHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBlcnJvci5zdGFydHNXaXRoKFwiRXJyb3I6IHJlYWN0LXN0YWNrLXRvcC1mcmFtZVxcblwiKSAmJlxuICAgICAgICAoZXJyb3IgPSBlcnJvci5zbGljZSgyOSkpO1xuICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlID0gZXJyb3IuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgIC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgJiZcbiAgICAgICAgKGVycm9yID0gZXJyb3Iuc2xpY2UocHJldlByZXBhcmVTdGFja1RyYWNlICsgMSkpO1xuICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlID0gZXJyb3IuaW5kZXhPZihcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiKTtcbiAgICAgIC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgJiZcbiAgICAgICAgKHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IGVycm9yLmxhc3RJbmRleE9mKFxuICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlXG4gICAgICAgICkpO1xuICAgICAgaWYgKC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UpXG4gICAgICAgIGVycm9yID0gZXJyb3Iuc2xpY2UoMCwgcHJldlByZXBhcmVTdGFja1RyYWNlKTtcbiAgICAgIGVsc2UgcmV0dXJuIFwiXCI7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQ29tcG9uZW50U3RhY2tCeVR5cGUodHlwZSkge1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnRcbiAgICAgICAgICA/IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgITApXG4gICAgICAgICAgOiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsICExKTtcbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyLCAhMSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLnR5cGUsICExKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZSxcbiAgICAgICAgICAgICAgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgICBsYXp5Q29tcG9uZW50ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHR5cGUgPSBsYXp5Q29tcG9uZW50KHBheWxvYWQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJMYXp5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50U3RhY2tCeVR5cGUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlLm5hbWUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChwYXlsb2FkID0gdHlwZS5lbnYpLFxuICAgICAgICAgICAgZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgICAgIHR5cGUubmFtZSArIChwYXlsb2FkID8gXCIgW1wiICsgcGF5bG9hZCArIFwiXVwiIDogXCJcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5lbnZpcm9ubWVudE5hbWVcbiAgICAgICkge1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gZXJyb3IuZW52aXJvbm1lbnROYW1lO1xuICAgICAgICBlcnJvciA9IFtlcnJvcl0uc2xpY2UoMCk7XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvclswXVxuICAgICAgICAgID8gZXJyb3Iuc3BsaWNlKFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICBcIlslc10gXCIgKyBlcnJvclswXSxcbiAgICAgICAgICAgICAgXCIgXCIgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgKyBcIiBcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogZXJyb3Iuc3BsaWNlKDAsIDAsIFwiWyVzXSBcIiwgXCIgXCIgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgKyBcIiBcIik7XG4gICAgICAgIGVycm9yLnVuc2hpZnQoY29uc29sZSk7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGJpbmQuYXBwbHkoY29uc29sZS5lcnJvciwgZXJyb3IpO1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQoKTtcbiAgICAgIH0gZWxzZSBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wKCkge31cbiAgICBmdW5jdGlvbiBSZXF1ZXN0SW5zdGFuY2UoXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICBwcm9ncmVzc2l2ZUNodW5rU2l6ZSxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBvbkFsbFJlYWR5LFxuICAgICAgb25TaGVsbFJlYWR5LFxuICAgICAgb25TaGVsbEVycm9yLFxuICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgb25Qb3N0cG9uZSxcbiAgICAgIGZvcm1TdGF0ZVxuICAgICkge1xuICAgICAgdmFyIGFib3J0U2V0ID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLmZsdXNoU2NoZWR1bGVkID0gITE7XG4gICAgICB0aGlzLnJlc3VtYWJsZVN0YXRlID0gcmVzdW1hYmxlU3RhdGU7XG4gICAgICB0aGlzLnJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGU7XG4gICAgICB0aGlzLnJvb3RGb3JtYXRDb250ZXh0ID0gcm9vdEZvcm1hdENvbnRleHQ7XG4gICAgICB0aGlzLnByb2dyZXNzaXZlQ2h1bmtTaXplID1cbiAgICAgICAgdm9pZCAwID09PSBwcm9ncmVzc2l2ZUNodW5rU2l6ZSA/IDEyODAwIDogcHJvZ3Jlc3NpdmVDaHVua1NpemU7XG4gICAgICB0aGlzLnN0YXR1cyA9IDEwO1xuICAgICAgdGhpcy5mYXRhbEVycm9yID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ1Jvb3RUYXNrcyA9IHRoaXMuYWxsUGVuZGluZ1Rhc2tzID0gdGhpcy5uZXh0U2VnbWVudElkID0gMDtcbiAgICAgIHRoaXMuY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cyA9IHRoaXMuY29tcGxldGVkUm9vdFNlZ21lbnQgPSBudWxsO1xuICAgICAgdGhpcy5hYm9ydGFibGVUYXNrcyA9IGFib3J0U2V0O1xuICAgICAgdGhpcy5waW5nZWRUYXNrcyA9IFtdO1xuICAgICAgdGhpcy5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMgPSBbXTtcbiAgICAgIHRoaXMuY29tcGxldGVkQm91bmRhcmllcyA9IFtdO1xuICAgICAgdGhpcy5wYXJ0aWFsQm91bmRhcmllcyA9IFtdO1xuICAgICAgdGhpcy50cmFja2VkUG9zdHBvbmVzID0gbnVsbDtcbiAgICAgIHRoaXMub25FcnJvciA9IHZvaWQgMCA9PT0gb25FcnJvciA/IGRlZmF1bHRFcnJvckhhbmRsZXIgOiBvbkVycm9yO1xuICAgICAgdGhpcy5vblBvc3Rwb25lID0gdm9pZCAwID09PSBvblBvc3Rwb25lID8gbm9vcCA6IG9uUG9zdHBvbmU7XG4gICAgICB0aGlzLm9uQWxsUmVhZHkgPSB2b2lkIDAgPT09IG9uQWxsUmVhZHkgPyBub29wIDogb25BbGxSZWFkeTtcbiAgICAgIHRoaXMub25TaGVsbFJlYWR5ID0gdm9pZCAwID09PSBvblNoZWxsUmVhZHkgPyBub29wIDogb25TaGVsbFJlYWR5O1xuICAgICAgdGhpcy5vblNoZWxsRXJyb3IgPSB2b2lkIDAgPT09IG9uU2hlbGxFcnJvciA/IG5vb3AgOiBvblNoZWxsRXJyb3I7XG4gICAgICB0aGlzLm9uRmF0YWxFcnJvciA9IHZvaWQgMCA9PT0gb25GYXRhbEVycm9yID8gbm9vcCA6IG9uRmF0YWxFcnJvcjtcbiAgICAgIHRoaXMuZm9ybVN0YXRlID0gdm9pZCAwID09PSBmb3JtU3RhdGUgPyBudWxsIDogZm9ybVN0YXRlO1xuICAgICAgdGhpcy5kaWRXYXJuRm9yS2V5ID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgICBvbkVycm9yLFxuICAgICAgb25BbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgIG9uRmF0YWxFcnJvcixcbiAgICAgIG9uUG9zdHBvbmUsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIHJlc3VtYWJsZVN0YXRlID0gbmV3IFJlcXVlc3RJbnN0YW5jZShcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIG9uQWxsUmVhZHksXG4gICAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgICAgb25TaGVsbEVycm9yLFxuICAgICAgICBvbkZhdGFsRXJyb3IsXG4gICAgICAgIG9uUG9zdHBvbmUsXG4gICAgICAgIGZvcm1TdGF0ZVxuICAgICAgKTtcbiAgICAgIHJlbmRlclN0YXRlID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAwLFxuICAgICAgICBudWxsLFxuICAgICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgITEsXG4gICAgICAgICExXG4gICAgICApO1xuICAgICAgcmVuZGVyU3RhdGUucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgY2hpbGRyZW4gPSBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIC0xLFxuICAgICAgICBudWxsLFxuICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUuYWJvcnRhYmxlVGFza3MsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgICBudWxsLFxuICAgICAgICBlbXB0eVRyZWVDb250ZXh0LFxuICAgICAgICBudWxsLFxuICAgICAgICAhMSxcbiAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgcHVzaENvbXBvbmVudFN0YWNrKGNoaWxkcmVuKTtcbiAgICAgIHJlc3VtYWJsZVN0YXRlLnBpbmdlZFRhc2tzLnB1c2goY2hpbGRyZW4pO1xuICAgICAgcmV0dXJuIHJlc3VtYWJsZVN0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKSB7XG4gICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2godGFzayk7XG4gICAgICAxID09PSByZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCAmJlxuICAgICAgICAoKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uKSxcbiAgICAgICAgcGVyZm9ybVdvcmsocmVxdWVzdCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGZhbGxiYWNrQWJvcnRhYmxlVGFza3MsXG4gICAgICBjb250ZW50UHJlYW1ibGUsXG4gICAgICBmYWxsYmFja1ByZWFtYmxlXG4gICAgKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IFBFTkRJTkcsXG4gICAgICAgIHJvb3RTZWdtZW50SUQ6IC0xLFxuICAgICAgICBwYXJlbnRGbHVzaGVkOiAhMSxcbiAgICAgICAgcGVuZGluZ1Rhc2tzOiAwLFxuICAgICAgICBjb21wbGV0ZWRTZWdtZW50czogW10sXG4gICAgICAgIGJ5dGVTaXplOiAwLFxuICAgICAgICBmYWxsYmFja0Fib3J0YWJsZVRhc2tzOiBmYWxsYmFja0Fib3J0YWJsZVRhc2tzLFxuICAgICAgICBlcnJvckRpZ2VzdDogbnVsbCxcbiAgICAgICAgY29udGVudFN0YXRlOiBjcmVhdGVIb2lzdGFibGVTdGF0ZSgpLFxuICAgICAgICBmYWxsYmFja1N0YXRlOiBjcmVhdGVIb2lzdGFibGVTdGF0ZSgpLFxuICAgICAgICBjb250ZW50UHJlYW1ibGU6IGNvbnRlbnRQcmVhbWJsZSxcbiAgICAgICAgZmFsbGJhY2tQcmVhbWJsZTogZmFsbGJhY2tQcmVhbWJsZSxcbiAgICAgICAgdHJhY2tlZENvbnRlbnRLZXlQYXRoOiBudWxsLFxuICAgICAgICB0cmFja2VkRmFsbGJhY2tOb2RlOiBudWxsLFxuICAgICAgICBlcnJvck1lc3NhZ2U6IG51bGwsXG4gICAgICAgIGVycm9yU3RhY2s6IG51bGwsXG4gICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2s6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGhlbmFibGVTdGF0ZSxcbiAgICAgIG5vZGUsXG4gICAgICBjaGlsZEluZGV4LFxuICAgICAgYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgYmxvY2tlZFNlZ21lbnQsXG4gICAgICBibG9ja2VkUHJlYW1ibGUsXG4gICAgICBob2lzdGFibGVTdGF0ZSxcbiAgICAgIGFib3J0U2V0LFxuICAgICAga2V5UGF0aCxcbiAgICAgIGZvcm1hdENvbnRleHQsXG4gICAgICBjb250ZXh0LFxuICAgICAgdHJlZUNvbnRleHQsXG4gICAgICBjb21wb25lbnRTdGFjayxcbiAgICAgIGlzRmFsbGJhY2ssXG4gICAgICBsZWdhY3lDb250ZXh0LFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcysrO1xuICAgICAgbnVsbCA9PT0gYmxvY2tlZEJvdW5kYXJ5XG4gICAgICAgID8gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKytcbiAgICAgICAgOiBibG9ja2VkQm91bmRhcnkucGVuZGluZ1Rhc2tzKys7XG4gICAgICB2YXIgdGFzayA9IHtcbiAgICAgICAgcmVwbGF5OiBudWxsLFxuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBjaGlsZEluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgICAgICB9LFxuICAgICAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgYmxvY2tlZFNlZ21lbnQ6IGJsb2NrZWRTZWdtZW50LFxuICAgICAgICBibG9ja2VkUHJlYW1ibGU6IGJsb2NrZWRQcmVhbWJsZSxcbiAgICAgICAgaG9pc3RhYmxlU3RhdGU6IGhvaXN0YWJsZVN0YXRlLFxuICAgICAgICBhYm9ydFNldDogYWJvcnRTZXQsXG4gICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgIGZvcm1hdENvbnRleHQ6IGZvcm1hdENvbnRleHQsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHRyZWVDb250ZXh0OiB0cmVlQ29udGV4dCxcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IGNvbXBvbmVudFN0YWNrLFxuICAgICAgICB0aGVuYWJsZVN0YXRlOiB0aGVuYWJsZVN0YXRlLFxuICAgICAgICBpc0ZhbGxiYWNrOiBpc0ZhbGxiYWNrXG4gICAgICB9O1xuICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBkZWJ1Z1Rhc2s7XG4gICAgICBhYm9ydFNldC5hZGQodGFzayk7XG4gICAgICByZXR1cm4gdGFzaztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVwbGF5VGFzayhcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0aGVuYWJsZVN0YXRlLFxuICAgICAgcmVwbGF5LFxuICAgICAgbm9kZSxcbiAgICAgIGNoaWxkSW5kZXgsXG4gICAgICBibG9ja2VkQm91bmRhcnksXG4gICAgICBob2lzdGFibGVTdGF0ZSxcbiAgICAgIGFib3J0U2V0LFxuICAgICAga2V5UGF0aCxcbiAgICAgIGZvcm1hdENvbnRleHQsXG4gICAgICBjb250ZXh0LFxuICAgICAgdHJlZUNvbnRleHQsXG4gICAgICBjb21wb25lbnRTdGFjayxcbiAgICAgIGlzRmFsbGJhY2ssXG4gICAgICBsZWdhY3lDb250ZXh0LFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcysrO1xuICAgICAgbnVsbCA9PT0gYmxvY2tlZEJvdW5kYXJ5XG4gICAgICAgID8gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKytcbiAgICAgICAgOiBibG9ja2VkQm91bmRhcnkucGVuZGluZ1Rhc2tzKys7XG4gICAgICByZXBsYXkucGVuZGluZ1Rhc2tzKys7XG4gICAgICB2YXIgdGFzayA9IHtcbiAgICAgICAgcmVwbGF5OiByZXBsYXksXG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIGNoaWxkSW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIHBpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcGluZ1Rhc2socmVxdWVzdCwgdGFzayk7XG4gICAgICAgIH0sXG4gICAgICAgIGJsb2NrZWRCb3VuZGFyeTogYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICBibG9ja2VkU2VnbWVudDogbnVsbCxcbiAgICAgICAgYmxvY2tlZFByZWFtYmxlOiBudWxsLFxuICAgICAgICBob2lzdGFibGVTdGF0ZTogaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgIGFib3J0U2V0OiBhYm9ydFNldCxcbiAgICAgICAga2V5UGF0aDoga2V5UGF0aCxcbiAgICAgICAgZm9ybWF0Q29udGV4dDogZm9ybWF0Q29udGV4dCxcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgdHJlZUNvbnRleHQ6IHRyZWVDb250ZXh0LFxuICAgICAgICBjb21wb25lbnRTdGFjazogY29tcG9uZW50U3RhY2ssXG4gICAgICAgIHRoZW5hYmxlU3RhdGU6IHRoZW5hYmxlU3RhdGUsXG4gICAgICAgIGlzRmFsbGJhY2s6IGlzRmFsbGJhY2tcbiAgICAgIH07XG4gICAgICB0YXNrLmRlYnVnVGFzayA9IGRlYnVnVGFzaztcbiAgICAgIGFib3J0U2V0LmFkZCh0YXNrKTtcbiAgICAgIHJldHVybiB0YXNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBpbmRleCxcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgcGFyZW50Rm9ybWF0Q29udGV4dCxcbiAgICAgIGxhc3RQdXNoZWRUZXh0LFxuICAgICAgdGV4dEVtYmVkZGVkXG4gICAgKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IFBFTkRJTkcsXG4gICAgICAgIHBhcmVudEZsdXNoZWQ6ICExLFxuICAgICAgICBpZDogLTEsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY2h1bmtzOiBbXSxcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBwcmVhbWJsZUNoaWxkcmVuOiBbXSxcbiAgICAgICAgcGFyZW50Rm9ybWF0Q29udGV4dDogcGFyZW50Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgICBsYXN0UHVzaGVkVGV4dDogbGFzdFB1c2hlZFRleHQsXG4gICAgICAgIHRleHRFbWJlZGRlZDogdGV4dEVtYmVkZGVkXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50U3RhY2tJbkRFVigpIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50VGFza0luREVWIHx8IG51bGwgPT09IGN1cnJlbnRUYXNrSW5ERVYuY29tcG9uZW50U3RhY2spXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgdmFyIGNvbXBvbmVudFN0YWNrID0gY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjaztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gXCJcIjtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjb21wb25lbnRTdGFjay50eXBlKVxuICAgICAgICAgIGluZm8gKz0gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoY29tcG9uZW50U3RhY2sudHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbXBvbmVudFN0YWNrLnR5cGUpIHtcbiAgICAgICAgICBpZiAoIWNvbXBvbmVudFN0YWNrLm93bmVyKSB7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gaW5mbyxcbiAgICAgICAgICAgICAgZm4gPSBjb21wb25lbnRTdGFjay50eXBlLFxuICAgICAgICAgICAgICBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogXCJcIjtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBuYW1lXG4gICAgICAgICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSlcbiAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgaW5mbyA9IEpTQ29tcGlsZXJfdGVtcF9jb25zdCArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGNvbXBvbmVudFN0YWNrLm93bmVyIHx8XG4gICAgICAgICAgICAoaW5mbyArPSBkZXNjcmliZUNvbXBvbmVudFN0YWNrQnlUeXBlKGNvbXBvbmVudFN0YWNrLnR5cGUpKTtcbiAgICAgICAgZm9yICg7IGNvbXBvbmVudFN0YWNrOyApXG4gICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPSBjb21wb25lbnRTdGFjay5kZWJ1Z1N0YWNrXG4gICAgICAgICAgICAgID8gKEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IGZvcm1hdE93bmVyU3RhY2soXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRTdGFjay5kZWJ1Z1N0YWNrXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgOiAoKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGNvbXBvbmVudFN0YWNrKSxcbiAgICAgICAgICAgICAgICBudWxsICE9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGFjayAmJlxuICAgICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9XG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICA/IChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuc3RhY2sgPSBmb3JtYXRPd25lclN0YWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgICAgOiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuc3RhY2spKSxcbiAgICAgICAgICAgIChjb21wb25lbnRTdGFjayA9IGNvbXBvbmVudFN0YWNrLm93bmVyKSAmJlxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QgJiZcbiAgICAgICAgICAgICAgKGluZm8gKz0gXCJcXG5cIiArIEpTQ29tcGlsZXJfdGVtcF9jb25zdCk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBpbmZvO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgIFwiXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogXCIgKyB4Lm1lc3NhZ2UgKyBcIlxcblwiICsgeC5zdGFjaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTZXJ2ZXJDb21wb25lbnRTdGFjayh0YXNrLCBkZWJ1Z0luZm8pIHtcbiAgICAgIGlmIChudWxsICE9IGRlYnVnSW5mbylcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWJ1Z0luZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY29tcG9uZW50SW5mbyA9IGRlYnVnSW5mb1tpXTtcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY29tcG9uZW50SW5mby5uYW1lICYmXG4gICAgICAgICAgICB2b2lkIDAgIT09IGNvbXBvbmVudEluZm8uZGVidWdTdGFjayAmJlxuICAgICAgICAgICAgKCh0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgICAgICAgICBwYXJlbnQ6IHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgIHR5cGU6IGNvbXBvbmVudEluZm8sXG4gICAgICAgICAgICAgIG93bmVyOiBjb21wb25lbnRJbmZvLm93bmVyLFxuICAgICAgICAgICAgICBzdGFjazogY29tcG9uZW50SW5mby5kZWJ1Z1N0YWNrXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICh0YXNrLmRlYnVnVGFzayA9IGNvbXBvbmVudEluZm8uZGVidWdUYXNrKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaENvbXBvbmVudFN0YWNrKHRhc2spIHtcbiAgICAgIHZhciBub2RlID0gdGFzay5ub2RlO1xuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmIG51bGwgIT09IG5vZGUpXG4gICAgICAgIHN3aXRjaCAobm9kZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGUsXG4gICAgICAgICAgICAgIG93bmVyID0gbm9kZS5fb3duZXIsXG4gICAgICAgICAgICAgIHN0YWNrID0gbm9kZS5fZGVidWdTdGFjaztcbiAgICAgICAgICAgIHB1c2hTZXJ2ZXJDb21wb25lbnRTdGFjayh0YXNrLCBub2RlLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBub2RlLl9kZWJ1Z1Rhc2s7XG4gICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgICAgICAgICBwYXJlbnQ6IHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIG93bmVyOiBvd25lcixcbiAgICAgICAgICAgICAgc3RhY2s6IHN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgbm9kZS5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBub2RlLnRoZW4gJiZcbiAgICAgICAgICAgICAgcHVzaFNlcnZlckNvbXBvbmVudFN0YWNrKHRhc2ssIG5vZGUuX2RlYnVnSW5mbyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGhyb3duSW5mbyhub2RlJGpzY29tcCQwKSB7XG4gICAgICB2YXIgZXJyb3JJbmZvID0ge307XG4gICAgICBub2RlJGpzY29tcCQwICYmXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvckluZm8sIFwiY29tcG9uZW50U3RhY2tcIiwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgaW5mbyA9IFwiXCIsXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUkanNjb21wJDA7XG4gICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgKGluZm8gKz0gZGVzY3JpYmVDb21wb25lbnRTdGFja0J5VHlwZShub2RlLnR5cGUpKSxcbiAgICAgICAgICAgICAgICAgIChub2RlID0gbm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgICB3aGlsZSAobm9kZSk7XG4gICAgICAgICAgICAgIHZhciBzdGFjayA9IGluZm87XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIHN0YWNrID0gXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9ySW5mbywgXCJjb21wb25lbnRTdGFja1wiLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBzdGFja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIHJldHVybiBlcnJvckluZm87XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZUVycm9yRm9yQm91bmRhcnkoXG4gICAgICBib3VuZGFyeSxcbiAgICAgIGRpZ2VzdCxcbiAgICAgIGVycm9yLFxuICAgICAgdGhyb3duSW5mbyxcbiAgICAgIHdhc0Fib3J0ZWRcbiAgICApIHtcbiAgICAgIGJvdW5kYXJ5LmVycm9yRGlnZXN0ID0gZGlnZXN0O1xuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICA/ICgoZGlnZXN0ID0gU3RyaW5nKGVycm9yLm1lc3NhZ2UpKSwgKGVycm9yID0gU3RyaW5nKGVycm9yLnN0YWNrKSkpXG4gICAgICAgIDogKChkaWdlc3QgPVxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmIG51bGwgIT09IGVycm9yXG4gICAgICAgICAgICAgID8gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoZXJyb3IpXG4gICAgICAgICAgICAgIDogU3RyaW5nKGVycm9yKSksXG4gICAgICAgICAgKGVycm9yID0gbnVsbCkpO1xuICAgICAgd2FzQWJvcnRlZCA9IHdhc0Fib3J0ZWRcbiAgICAgICAgPyBcIlN3aXRjaGVkIHRvIGNsaWVudCByZW5kZXJpbmcgYmVjYXVzZSB0aGUgc2VydmVyIHJlbmRlcmluZyBhYm9ydGVkIGR1ZSB0bzpcXG5cXG5cIlxuICAgICAgICA6IFwiU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZyBiZWNhdXNlIHRoZSBzZXJ2ZXIgcmVuZGVyaW5nIGVycm9yZWQ6XFxuXFxuXCI7XG4gICAgICBib3VuZGFyeS5lcnJvck1lc3NhZ2UgPSB3YXNBYm9ydGVkICsgZGlnZXN0O1xuICAgICAgYm91bmRhcnkuZXJyb3JTdGFjayA9IG51bGwgIT09IGVycm9yID8gd2FzQWJvcnRlZCArIGVycm9yIDogbnVsbDtcbiAgICAgIGJvdW5kYXJ5LmVycm9yQ29tcG9uZW50U3RhY2sgPSB0aHJvd25JbmZvLmNvbXBvbmVudFN0YWNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8sIGRlYnVnVGFzaykge1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3Qub25FcnJvcjtcbiAgICAgIGVycm9yID0gZGVidWdUYXNrXG4gICAgICAgID8gZGVidWdUYXNrLnJ1bihyZXF1ZXN0LmJpbmQobnVsbCwgZXJyb3IsIGVycm9ySW5mbykpXG4gICAgICAgIDogcmVxdWVzdChlcnJvciwgZXJyb3JJbmZvKTtcbiAgICAgIGlmIChudWxsICE9IGVycm9yICYmIFwic3RyaW5nXCIgIT09IHR5cGVvZiBlcnJvcilcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnb25FcnJvciByZXR1cm5lZCBzb21ldGhpbmcgd2l0aCBhIHR5cGUgb3RoZXIgdGhhbiBcInN0cmluZ1wiLiBvbkVycm9yIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgYW5kIG1heSByZXR1cm4gbnVsbCBvciB1bmRlZmluZWQgYnV0IG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBlbHNlLiBJdCByZWNlaXZlZCBzb21ldGhpbmcgb2YgdHlwZSBcIiVzXCIgaW5zdGVhZCcsXG4gICAgICAgICAgdHlwZW9mIGVycm9yXG4gICAgICAgICk7XG4gICAgICBlbHNlIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvLCBkZWJ1Z1Rhc2spIHtcbiAgICAgIGVycm9ySW5mbyA9IHJlcXVlc3Qub25TaGVsbEVycm9yO1xuICAgICAgdmFyIG9uRmF0YWxFcnJvciA9IHJlcXVlc3Qub25GYXRhbEVycm9yO1xuICAgICAgZGVidWdUYXNrXG4gICAgICAgID8gKGRlYnVnVGFzay5ydW4oZXJyb3JJbmZvLmJpbmQobnVsbCwgZXJyb3IpKSxcbiAgICAgICAgICBkZWJ1Z1Rhc2sucnVuKG9uRmF0YWxFcnJvci5iaW5kKG51bGwsIGVycm9yKSkpXG4gICAgICAgIDogKGVycm9ySW5mbyhlcnJvciksIG9uRmF0YWxFcnJvcihlcnJvcikpO1xuICAgICAgbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvblxuICAgICAgICA/ICgocmVxdWVzdC5zdGF0dXMgPSBDTE9TRUQpLCByZXF1ZXN0LmRlc3RpbmF0aW9uLmRlc3Ryb3koZXJyb3IpKVxuICAgICAgICA6ICgocmVxdWVzdC5zdGF0dXMgPSAxMyksIChyZXF1ZXN0LmZhdGFsRXJyb3IgPSBlcnJvcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJXaXRoSG9va3MoXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGFzayxcbiAgICAgIGtleVBhdGgsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBwcm9wcyxcbiAgICAgIHNlY29uZEFyZ1xuICAgICkge1xuICAgICAgdmFyIHByZXZUaGVuYWJsZVN0YXRlID0gdGFzay50aGVuYWJsZVN0YXRlO1xuICAgICAgdGFzay50aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHt9O1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9IHRhc2s7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGggPSBrZXlQYXRoO1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITE7XG4gICAgICBhY3Rpb25TdGF0ZUNvdW50ZXIgPSBsb2NhbElkQ291bnRlciA9IDA7XG4gICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXggPSAtMTtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBwcmV2VGhlbmFibGVTdGF0ZTtcbiAgICAgIGZvciAoXG4gICAgICAgIHJlcXVlc3QgPSBjYWxsQ29tcG9uZW50SW5ERVYoQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKTtcbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgICAgKVxuICAgICAgICAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExKSxcbiAgICAgICAgICAoYWN0aW9uU3RhdGVDb3VudGVyID0gbG9jYWxJZENvdW50ZXIgPSAwKSxcbiAgICAgICAgICAoYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4ID0gLTEpLFxuICAgICAgICAgICh0aGVuYWJsZUluZGV4Q291bnRlciA9IDApLFxuICAgICAgICAgIChudW1iZXJPZlJlUmVuZGVycyArPSAxKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbCksXG4gICAgICAgICAgKHJlcXVlc3QgPSBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZykpO1xuICAgICAgcmVzZXRIb29rc1N0YXRlKCk7XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluaXNoRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGFzayxcbiAgICAgIGtleVBhdGgsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGhhc0lkLFxuICAgICAgYWN0aW9uU3RhdGVDb3VudCxcbiAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleFxuICAgICkge1xuICAgICAgdmFyIGRpZEVtaXRBY3Rpb25TdGF0ZU1hcmtlcnMgPSAhMTtcbiAgICAgIGlmICgwICE9PSBhY3Rpb25TdGF0ZUNvdW50ICYmIG51bGwgIT09IHJlcXVlc3QuZm9ybVN0YXRlKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgICAgaWYgKG51bGwgIT09IHNlZ21lbnQpIHtcbiAgICAgICAgICBkaWRFbWl0QWN0aW9uU3RhdGVNYXJrZXJzID0gITA7XG4gICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnQuY2h1bmtzO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aW9uU3RhdGVDb3VudDsgaSsrKVxuICAgICAgICAgICAgaSA9PT0gYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4XG4gICAgICAgICAgICAgID8gc2VnbWVudC5wdXNoKFwiXFx4M2MhLS1GIS0tXFx4M2VcIilcbiAgICAgICAgICAgICAgOiBzZWdtZW50LnB1c2goXCJcXHgzYyEtLUYtLVxceDNlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhY3Rpb25TdGF0ZUNvdW50ID0gdGFzay5rZXlQYXRoO1xuICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgIGhhc0lkXG4gICAgICAgID8gKChrZXlQYXRoID0gdGFzay50cmVlQ29udGV4dCksXG4gICAgICAgICAgKHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQoa2V5UGF0aCwgMSwgMCkpLFxuICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4sIC0xKSxcbiAgICAgICAgICAodGFzay50cmVlQ29udGV4dCA9IGtleVBhdGgpKVxuICAgICAgICA6IGRpZEVtaXRBY3Rpb25TdGF0ZU1hcmtlcnNcbiAgICAgICAgICA/IHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4sIC0xKVxuICAgICAgICAgIDogcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSk7XG4gICAgICB0YXNrLmtleVBhdGggPSBhY3Rpb25TdGF0ZUNvdW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUsIHByb3BzLCByZWYpIHtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgdHlwZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCkge1xuICAgICAgICAgIHZhciBuZXdQcm9wcyA9IHByb3BzO1xuICAgICAgICAgIGlmIChcInJlZlwiIGluIHByb3BzKSB7XG4gICAgICAgICAgICBuZXdQcm9wcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpXG4gICAgICAgICAgICAgIFwicmVmXCIgIT09IHByb3BOYW1lICYmIChuZXdQcm9wc1twcm9wTmFtZV0gPSBwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgICAgaWYgKGRlZmF1bHRQcm9wcykge1xuICAgICAgICAgICAgbmV3UHJvcHMgPT09IHByb3BzICYmIChuZXdQcm9wcyA9IGFzc2lnbih7fSwgbmV3UHJvcHMsIHByb3BzKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKVxuICAgICAgICAgICAgICB2b2lkIDAgPT09IG5ld1Byb3BzW19wcm9wTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAobmV3UHJvcHNbX3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1tfcHJvcE5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc29sdmVkUHJvcHMgPSBuZXdQcm9wcztcbiAgICAgICAgICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdCxcbiAgICAgICAgICAgIGNvbnRleHRUeXBlID0gdHlwZS5jb250ZXh0VHlwZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImNvbnRleHRUeXBlXCIgaW4gdHlwZSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY29udGV4dFR5cGUgJiZcbiAgICAgICAgICAgICh2b2lkIDAgPT09IGNvbnRleHRUeXBlIHx8XG4gICAgICAgICAgICAgIGNvbnRleHRUeXBlLiQkdHlwZW9mICE9PSBSRUFDVF9DT05URVhUX1RZUEUpICYmXG4gICAgICAgICAgICAhZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmhhcyh0eXBlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZCh0eXBlKTtcbiAgICAgICAgICAgIHZhciBhZGRlbmR1bSA9XG4gICAgICAgICAgICAgIHZvaWQgMCA9PT0gY29udGV4dFR5cGVcbiAgICAgICAgICAgICAgICA/IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byB1bmRlZmluZWQuIFRoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuIFRoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvIHRyeSBtb3ZpbmcgdGhlIGNyZWF0ZUNvbnRleHQoKSBjYWxsIHRvIGEgc2VwYXJhdGUgZmlsZS5cIlxuICAgICAgICAgICAgICAgIDogXCJvYmplY3RcIiAhPT0gdHlwZW9mIGNvbnRleHRUeXBlXG4gICAgICAgICAgICAgICAgICA/IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhIFwiICsgdHlwZW9mIGNvbnRleHRUeXBlICsgXCIuXCJcbiAgICAgICAgICAgICAgICAgIDogY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEVcbiAgICAgICAgICAgICAgICAgICAgPyBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/XCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYW4gb2JqZWN0IHdpdGgga2V5cyB7XCIgK1xuICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnRleHRUeXBlKS5qb2luKFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgIFwifS5cIjtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgZGVmaW5lcyBhbiBpbnZhbGlkIGNvbnRleHRUeXBlLiBjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lc1wiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIixcbiAgICAgICAgICAgICAgYWRkZW5kdW1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjb250ZXh0VHlwZSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY29udGV4dFR5cGUgJiZcbiAgICAgICAgICAgIChjb250ZXh0ID0gY29udGV4dFR5cGUuX2N1cnJlbnRWYWx1ZTIpO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyB0eXBlKHJlc29sdmVkUHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gaW5zdGFuY2Uuc3RhdGUgfHwgdm9pZCAwID09PSBpbnN0YW5jZS5zdGF0ZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpIHx8XG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAlcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSBhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gaW5zdGFuY2Uuc3RhdGUgPyBcIm51bGxcIiA6IFwidW5kZWZpbmVkXCIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbCxcbiAgICAgICAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IG51bGwsXG4gICAgICAgICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgICAgPyAoZm91bmRXaWxsTW91bnROYW1lID0gXCJjb21wb25lbnRXaWxsTW91bnRcIilcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgKGZvdW5kV2lsbE1vdW50TmFtZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFwiKTtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgICEwICE9PVxuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgICAgPyAoZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiKVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgICAgIChmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID1cbiAgICAgICAgICAgICAgICAgIFwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIik7XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICAgID8gKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBcImNvbXBvbmVudFdpbGxVcGRhdGVcIilcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgIChmb3VuZFdpbGxVcGRhdGVOYW1lID0gXCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVwiKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsTW91bnROYW1lIHx8XG4gICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgfHxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsVXBkYXRlTmFtZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9XG4gICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIixcbiAgICAgICAgICAgICAgICBuZXdBcGlOYW1lID1cbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG4gICAgICAgICAgICAgICAgICAgID8gXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKVwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpXCI7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKF9jb21wb25lbnROYW1lKSB8fFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChcbiAgICAgICAgICAgICAgICAgIF9jb21wb25lbnROYW1lXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4lcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXNcIixcbiAgICAgICAgICAgICAgICAgIF9jb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgbmV3QXBpTmFtZSxcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbE1vdW50TmFtZVxuICAgICAgICAgICAgICAgICAgICA/IFwiXFxuICBcIiArIGZvdW5kV2lsbE1vdW50TmFtZVxuICAgICAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lXG4gICAgICAgICAgICAgICAgICAgID8gXCJcXG4gIFwiICsgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZVxuICAgICAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxVcGRhdGVOYW1lXG4gICAgICAgICAgICAgICAgICAgID8gXCJcXG4gIFwiICsgZm91bmRXaWxsVXBkYXRlTmFtZVxuICAgICAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIgfHxcbiAgICAgICAgICAgICh0eXBlLnByb3RvdHlwZSAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZW5kZXJcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzIGluc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yP1wiLFxuICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzIGluc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC5cIixcbiAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlIHx8XG4gICAgICAgICAgICBpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHxcbiAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlIHx8XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImdldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuIERpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkP1wiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGluc3RhbmNlLmdldERlZmF1bHRQcm9wcyAmJlxuICAgICAgICAgICAgIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGluc3RhbmNlLmNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImNvbnRleHRUeXBlIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdHlwZS5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICAgIWRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzLmhhcyh0eXBlKSAmJlxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzLmFkZCh0eXBlKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgdXNlcyB0aGUgbGVnYWN5IGNoaWxkQ29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgdHlwZS5jb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAgICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMS5oYXModHlwZSkgJiZcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMS5hZGQodHlwZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggc3RhdGljIGNvbnRleHRUeXBlIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyBUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdHlwZS5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgIHR5cGUucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmXG4gICAgICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuIHNob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkEgcHVyZSBjb21wb25lbnRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT9cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsIHVzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yIHJ1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/XCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT9cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IHJlc29sdmVkUHJvcHM7XG4gICAgICAgICAgdm9pZCAwICE9PSBpbnN0YW5jZS5wcm9wcyAmJlxuICAgICAgICAgICAgaGFzTXV0YXRlZFByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIldoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzIHVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGluc3RhbmNlLmRlZmF1bHRQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuXCIsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyh0eXBlKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5hZGQodHlwZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuIFRoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSlcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgICAgICAgIHN0YXRlICYmXG4gICAgICAgICAgICAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIHN0YXRlIHx8IGlzQXJyYXlJbXBsKHN0YXRlKSkgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIlcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGxcIiwgbmFtZSk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICYmXG4gICAgICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2YgdHlwZS5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIHVzZSBnZXRDaGlsZENvbnRleHQoKS5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdm9pZCAwICE9PSBpbnN0YW5jZS5zdGF0ZSA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgICAgICAgICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gcmVzb2x2ZWRQcm9wcztcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgICAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IHsgcXVldWU6IFtdLCByZXBsYWNlOiAhMSB9O1xuICAgICAgICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFscyA9IGludGVybmFsSW5zdGFuY2U7XG4gICAgICAgICAgdmFyIGNvbnRleHRUeXBlJGpzY29tcCQwID0gdHlwZS5jb250ZXh0VHlwZTtcbiAgICAgICAgICBpbnN0YW5jZS5jb250ZXh0ID1cbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjb250ZXh0VHlwZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY29udGV4dFR5cGUkanNjb21wJDBcbiAgICAgICAgICAgICAgPyBjb250ZXh0VHlwZSRqc2NvbXAkMC5fY3VycmVudFZhbHVlMlxuICAgICAgICAgICAgICA6IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IHJlc29sdmVkUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDBcbiAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQwXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSBiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDBcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKSB7XG4gICAgICAgICAgICB2YXIgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICAgICAgICByZXNvbHZlZFByb3BzLFxuICAgICAgICAgICAgICBpbml0aWFsU3RhdGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBwYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUkanNjb21wJDEgPVxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUkanNjb21wJDEpIHx8XG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSRqc2NvbXAkMSksXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuXCIsXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQxXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID1cbiAgICAgICAgICAgICAgbnVsbCA9PT0gcGFydGlhbFN0YXRlIHx8IHZvaWQgMCA9PT0gcGFydGlhbFN0YXRlXG4gICAgICAgICAgICAgICAgPyBpbml0aWFsU3RhdGVcbiAgICAgICAgICAgICAgICA6IGFzc2lnbih7fSwgaW5pdGlhbFN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAmJlxuICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgfHxcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUkanNjb21wJDIgPVxuICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiVW5rbm93blwiO1xuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnRbY29tcG9uZW50TmFtZSRqc2NvbXAkMl0gfHxcbiAgICAgICAgICAgICAgICAgIChjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgIFwiY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBjb2RlIGZyb20gY29tcG9uZW50V2lsbE1vdW50IHRvIGNvbXBvbmVudERpZE1vdW50IChwcmVmZXJyZWQgaW4gbW9zdCBjYXNlcykgb3IgdGhlIGNvbnN0cnVjdG9yLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQyXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnRbY29tcG9uZW50TmFtZSRqc2NvbXAkMl0gPVxuICAgICAgICAgICAgICAgICAgICAhMCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgICAgICBvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUgJiZcbiAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSAmJlxuICAgICAgICAgICAgICAwIDwgaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZS5sZW5ndGhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgb2xkUXVldWUgPSBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlLFxuICAgICAgICAgICAgICAgIG9sZFJlcGxhY2UgPSBpbnRlcm5hbEluc3RhbmNlLnJlcGxhY2U7XG4gICAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2UucXVldWUgPSBudWxsO1xuICAgICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlLnJlcGxhY2UgPSAhMTtcbiAgICAgICAgICAgICAgaWYgKG9sZFJlcGxhY2UgJiYgMSA9PT0gb2xkUXVldWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gb2xkUXVldWVbMF07XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gb2xkUmVwbGFjZSA/IG9sZFF1ZXVlWzBdIDogaW5zdGFuY2Uuc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGRvbnRNdXRhdGUgPSAhMCxcbiAgICAgICAgICAgICAgICAgICAgaSA9IG9sZFJlcGxhY2UgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgIGkgPCBvbGRRdWV1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBpKytcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gb2xkUXVldWVbaV0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxTdGF0ZSRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGFydGlhbFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJ0aWFsLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGFydGlhbDtcbiAgICAgICAgICAgICAgICAgIG51bGwgIT0gcGFydGlhbFN0YXRlJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICAgIChkb250TXV0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgPyAoKGRvbnRNdXRhdGUgPSAhMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAobmV4dFN0YXRlID0gYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsU3RhdGUkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgICAgICAgICAgIDogYXNzaWduKG5leHRTdGF0ZSwgcGFydGlhbFN0YXRlJGpzY29tcCQwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBjYWxsUmVuZGVySW5ERVYoaW5zdGFuY2UpO1xuICAgICAgICAgIGlmICgxMiA9PT0gcmVxdWVzdC5zdGF0dXMpIHRocm93IG51bGw7XG4gICAgICAgICAgaW5zdGFuY2UucHJvcHMgIT09IHJlc29sdmVkUHJvcHMgJiZcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJJdCBsb29rcyBsaWtlICVzIGlzIHJlYXNzaWduaW5nIGl0cyBvd24gYHRoaXMucHJvcHNgIHdoaWxlIHJlbmRlcmluZy4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBjYW4gbGVhZCB0byBjb25mdXNpbmcgYnVncy5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJhIGNvbXBvbmVudFwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9ICEwKSk7XG4gICAgICAgICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG5leHRDaGlsZHJlbiwgLTEpO1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZW5kZXIpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lJGpzY29tcCQzID1cbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiVW5rbm93blwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZSRqc2NvbXAkM10gfHxcbiAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMyxcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQzXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lJGpzY29tcCQzXSA9ICEwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKDEyID09PSByZXF1ZXN0LnN0YXR1cykgdGhyb3cgbnVsbDtcbiAgICAgICAgICB2YXIgaGFzSWQgPSAwICE9PSBsb2NhbElkQ291bnRlcixcbiAgICAgICAgICAgIGFjdGlvblN0YXRlQ291bnQgPSBhY3Rpb25TdGF0ZUNvdW50ZXIsXG4gICAgICAgICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXgkanNjb21wJDAgPSBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXg7XG4gICAgICAgICAgaWYgKHR5cGUuY29udGV4dFR5cGVzKSB7XG4gICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUkanNjb21wJDAgPVxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXNbX2NvbXBvbmVudE5hbWUkanNjb21wJDBdIHx8XG4gICAgICAgICAgICAgICgoZGlkV2FybkFib3V0Q29udGV4dFR5cGVzW19jb21wb25lbnROYW1lJGpzY29tcCQwXSA9ICEwKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggUmVhY3QudXNlQ29udGV4dCgpIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgICAgIF9jb21wb25lbnROYW1lJGpzY29tcCQwXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0eXBlICYmXG4gICAgICAgICAgICB0eXBlLmNoaWxkQ29udGV4dFR5cGVzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LlxcbiAgJXMuY2hpbGRDb250ZXh0VHlwZXMgPSAuLi5cIixcbiAgICAgICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZTIgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0gfHxcbiAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuXCIsXG4gICAgICAgICAgICAgICAgX2NvbXBvbmVudE5hbWUyXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0gPVxuICAgICAgICAgICAgICAgICEwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlLmNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICBudWxsICE9PSB0eXBlLmNvbnRleHRUeXBlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUzID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiVW5rbm93blwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gfHxcbiAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBjb250ZXh0VHlwZS5cIixcbiAgICAgICAgICAgICAgICBfY29tcG9uZW50TmFtZTNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdID1cbiAgICAgICAgICAgICAgICAhMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5pc2hGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgaGFzSWQsXG4gICAgICAgICAgICBhY3Rpb25TdGF0ZUNvdW50LFxuICAgICAgICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4JGpzY29tcCQwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgICBpZiAobnVsbCA9PT0gc2VnbWVudCkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgcHJldkNvbnRleHQgPSB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICBwcmV2S2V5UGF0aCRqc2NvbXAkMCA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBnZXRDaGlsZEZvcm1hdENvbnRleHQocHJldkNvbnRleHQsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2Q29udGV4dDtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCRqc2NvbXAkMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2NoaWxkcmVuID0gcHVzaFN0YXJ0SW5zdGFuY2UoXG4gICAgICAgICAgICBzZWdtZW50LmNodW5rcyxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgdGFzay5ibG9ja2VkUHJlYW1ibGUsXG4gICAgICAgICAgICB0YXNrLmhvaXN0YWJsZVN0YXRlLFxuICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAgIHRhc2suaXNGYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgICAgIHZhciBfcHJldkNvbnRleHQgPSB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICBfcHJldktleVBhdGgyID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHRhc2suZm9ybWF0Q29udGV4dCA9IGdldENoaWxkRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgICAgX3ByZXZDb250ZXh0LFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgKSkuaW5zZXJ0aW9uTW9kZSA9PT0gSFRNTF9IRUFEX01PREVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBwcmVhbWJsZVNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAhMSxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZWdtZW50LnByZWFtYmxlQ2hpbGRyZW4ucHVzaChwcmVhbWJsZVNlZ21lbnQpO1xuICAgICAgICAgICAgdmFyIHByZWFtYmxlVGFzayA9IGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIF9jaGlsZHJlbixcbiAgICAgICAgICAgICAgLTEsXG4gICAgICAgICAgICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICAgICAgICBwcmVhbWJsZVNlZ21lbnQsXG4gICAgICAgICAgICAgIHRhc2suYmxvY2tlZFByZWFtYmxlLFxuICAgICAgICAgICAgICB0YXNrLmhvaXN0YWJsZVN0YXRlLFxuICAgICAgICAgICAgICByZXF1ZXN0LmFib3J0YWJsZVRhc2tzLFxuICAgICAgICAgICAgICB0YXNrLmtleVBhdGgsXG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0LFxuICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0LFxuICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICB0YXNrLmlzRmFsbGJhY2ssXG4gICAgICAgICAgICAgIGVtcHR5Q29udGV4dE9iamVjdCxcbiAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwdXNoQ29tcG9uZW50U3RhY2socHJlYW1ibGVUYXNrKTtcbiAgICAgICAgICAgIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChwcmVhbWJsZVRhc2spO1xuICAgICAgICAgIH0gZWxzZSByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIF9jaGlsZHJlbiwgLTEpO1xuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IF9wcmV2Q29udGV4dDtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgyO1xuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBzZWdtZW50LmNodW5rcyxcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYXJlYVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImhyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJpbWdcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJrZXlnZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInBhcmFtXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInRyYWNrXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJ3YnJcIjpcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgIGlmIChfcHJldkNvbnRleHQuaW5zZXJ0aW9uTW9kZSA8PSBIVE1MX0hUTUxfTU9ERSkge1xuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaGFzQm9keSA9ICEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgICAgICAgICAgaWYgKF9wcmV2Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSkge1xuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaGFzSHRtbCA9ICEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJoZWFkXCI6XG4gICAgICAgICAgICAgICAgaWYgKF9wcmV2Q29udGV4dC5pbnNlcnRpb25Nb2RlIDw9IEhUTUxfSFRNTF9NT0RFKSBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcodHlwZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gITE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoJGpzY29tcCQxID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBwcm9wcy5jaGlsZHJlbiwgLTEpO1xuICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTpcbiAgICAgICAgICAgIGlmIChcImhpZGRlblwiICE9PSBwcm9wcy5tb2RlKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkMiA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgdmFyIF9wcmV2S2V5UGF0aDMgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgzO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfVklFV19UUkFOU0lUSU9OX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgc2NvcGUgY29tcG9uZW50cy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICBhOiBpZiAobnVsbCAhPT0gdGFzay5yZXBsYXkpIHtcbiAgICAgICAgICAgICAgdmFyIF9wcmV2S2V5UGF0aCA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgdmFyIF9jb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBfY29udGVudCwgLTEpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IF9wcmV2S2V5UGF0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoJGpzY29tcCQzID0gdGFzay5rZXlQYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudEJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgcGFyZW50UHJlYW1ibGUgPSB0YXNrLmJsb2NrZWRQcmVhbWJsZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRIb2lzdGFibGVTdGF0ZSA9IHRhc2suaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgcGFyZW50U2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQsXG4gICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBwcm9wcy5mYWxsYmFjayxcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgdmFyIG5ld0JvdW5kYXJ5ID1cbiAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8IEhUTUxfTU9ERVxuICAgICAgICAgICAgICAgICAgPyBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCxcbiAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVQcmVhbWJsZVN0YXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUHJlYW1ibGVTdGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIG51bGwgIT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAmJlxuICAgICAgICAgICAgICAgIChuZXdCb3VuZGFyeS50cmFja2VkQ29udGVudEtleVBhdGggPSBrZXlQYXRoKTtcbiAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcGFyZW50U2VnbWVudC5jaHVua3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAhMSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50LmNoaWxkcmVuLnB1c2goYm91bmRhcnlTZWdtZW50KTtcbiAgICAgICAgICAgICAgcGFyZW50U2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgICAgICAgICB2YXIgY29udGVudFJvb3RTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAgICExLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmFsbGJhY2tLZXlQYXRoID0gW1xuICAgICAgICAgICAgICAgICAgICBrZXlQYXRoWzBdLFxuICAgICAgICAgICAgICAgICAgICBcIlN1c3BlbnNlIEZhbGxiYWNrXCIsXG4gICAgICAgICAgICAgICAgICAgIGtleVBhdGhbMl1cbiAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICBmYWxsYmFja1JlcGxheU5vZGUgPSBbXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrS2V5UGF0aFsxXSxcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tLZXlQYXRoWzJdLFxuICAgICAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMud29ya2luZ01hcC5zZXQoXG4gICAgICAgICAgICAgICAgICBmYWxsYmFja0tleVBhdGgsXG4gICAgICAgICAgICAgICAgICBmYWxsYmFja1JlcGxheU5vZGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LnRyYWNrZWRGYWxsYmFja05vZGUgPSBmYWxsYmFja1JlcGxheU5vZGU7XG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkU2VnbWVudCA9IGJvdW5kYXJ5U2VnbWVudDtcbiAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRQcmVhbWJsZSA9IG5ld0JvdW5kYXJ5LmZhbGxiYWNrUHJlYW1ibGU7XG4gICAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gZmFsbGJhY2tLZXlQYXRoO1xuICAgICAgICAgICAgICAgIGJvdW5kYXJ5U2VnbWVudC5zdGF0dXMgPSA2O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGZhbGxiYWNrLCAtMSksXG4gICAgICAgICAgICAgICAgICAgIHB1c2hTZWdtZW50RmluYWxlKFxuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5U2VnbWVudC5jaHVua3MsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVNlZ21lbnQubGFzdFB1c2hlZFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlTZWdtZW50LnRleHRFbWJlZGRlZFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAoYm91bmRhcnlTZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICAgICAgKChib3VuZGFyeVNlZ21lbnQuc3RhdHVzID0gMTIgPT09IHJlcXVlc3Quc3RhdHVzID8gMyA6IDQpLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRTZWdtZW50ID0gcGFyZW50U2VnbWVudCksXG4gICAgICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRQcmVhbWJsZSA9IHBhcmVudFByZWFtYmxlKSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZFByaW1hcnlUYXNrID0gY3JlYXRlUmVuZGVyVGFzayhcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgIC0xLFxuICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnksXG4gICAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQsXG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5jb250ZW50UHJlYW1ibGUsXG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5jb250ZW50U3RhdGUsXG4gICAgICAgICAgICAgICAgICB0YXNrLmFib3J0U2V0LFxuICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICAgICAgdGFzay5pc0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHB1c2hDb21wb25lbnRTdGFjayhzdXNwZW5kZWRQcmltYXJ5VGFzayk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKHN1c3BlbmRlZFByaW1hcnlUYXNrKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IG5ld0JvdW5kYXJ5O1xuICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZFByZWFtYmxlID0gbmV3Qm91bmRhcnkuY29udGVudFByZWFtYmxlO1xuICAgICAgICAgICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUgPSBuZXdCb3VuZGFyeS5jb250ZW50U3RhdGU7XG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkU2VnbWVudCA9IGNvbnRlbnRSb290U2VnbWVudDtcbiAgICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5zdGF0dXMgPSA2O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChyZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNvbnRlbnQsIC0xKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaFNlZ21lbnRGaW5hbGUoXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LmNodW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQudGV4dEVtYmVkZGVkXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIChjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEKSxcbiAgICAgICAgICAgICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KG5ld0JvdW5kYXJ5LCBjb250ZW50Um9vdFNlZ21lbnQpLFxuICAgICAgICAgICAgICAgICAgICAwID09PSBuZXdCb3VuZGFyeS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRQcmVhbWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIHByZXBhcmVQcmVhbWJsZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSQyKSB7XG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAoMTIgPT09IHJlcXVlc3Quc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5zdGF0dXMgPSAzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSByZXF1ZXN0LmZhdGFsRXJyb3I7XG4gICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKGNvbnRlbnRSb290U2VnbWVudC5zdGF0dXMgPSA0KSwgKGVycm9yID0gdGhyb3duVmFsdWUkMik7XG4gICAgICAgICAgICAgICAgICB2YXIgdGhyb3duSW5mbyA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgICAgICAgICAgICAgICB2YXIgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgdGhyb3duSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd25JbmZvLFxuICAgICAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIHVudHJhY2tCb3VuZGFyeShyZXF1ZXN0LCBuZXdCb3VuZGFyeSk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IHBhcmVudEJvdW5kYXJ5KSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZFByZWFtYmxlID0gcGFyZW50UHJlYW1ibGUpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5ob2lzdGFibGVTdGF0ZSA9IHBhcmVudEhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZFNlZ21lbnQgPSBwYXJlbnRTZWdtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZEZhbGxiYWNrVGFzayA9IGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgLTEsXG4gICAgICAgICAgICAgICAgICBwYXJlbnRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5U2VnbWVudCxcbiAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LmZhbGxiYWNrUHJlYW1ibGUsXG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5mYWxsYmFja1N0YXRlLFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCxcbiAgICAgICAgICAgICAgICAgIFtrZXlQYXRoWzBdLCBcIlN1c3BlbnNlIEZhbGxiYWNrXCIsIGtleVBhdGhbMl1dLFxuICAgICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgdGFzay5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgICAgICAhMCxcbiAgICAgICAgICAgICAgICAgIGVtcHR5Q29udGV4dE9iamVjdCxcbiAgICAgICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwdXNoQ29tcG9uZW50U3RhY2soc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlKVxuICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBpZiAoXCJyZWZcIiBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wc1dpdGhvdXRSZWYgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpXG4gICAgICAgICAgICAgICAgICBcInJlZlwiICE9PSBrZXkgJiYgKHByb3BzV2l0aG91dFJlZltrZXldID0gcHJvcHNba2V5XSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBwcm9wc1dpdGhvdXRSZWYgPSBwcm9wcztcbiAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQwID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgIHR5cGUucmVuZGVyLFxuICAgICAgICAgICAgICAgIHByb3BzV2l0aG91dFJlZixcbiAgICAgICAgICAgICAgICByZWZcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZmluaXNoRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDAsXG4gICAgICAgICAgICAgICAgMCAhPT0gbG9jYWxJZENvdW50ZXIsXG4gICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVDb3VudGVyLFxuICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLnR5cGUsIHByb3BzLCByZWYpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIHZhbHVlJGpzY29tcCQwID0gcHJvcHMudmFsdWUsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDEgPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgdmFyIHByZXZTbmFwc2hvdCA9IHRhc2suY29udGV4dDtcbiAgICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoJGpzY29tcCQ0ID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gdHlwZS5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFZhbHVlMiA9IHZhbHVlJGpzY29tcCQwO1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuX2N1cnJlbnRSZW5kZXJlcjIgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB0eXBlLl9jdXJyZW50UmVuZGVyZXIyICYmXG4gICAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFJlbmRlcmVyMiAhPT0gcmVuZGVyZXJTaWdpbCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkRldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSBzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFJlbmRlcmVyMiA9IHJlbmRlcmVyU2lnaWw7XG4gICAgICAgICAgICAgIHZhciBwcmV2Tm9kZSA9IGN1cnJlbnRBY3RpdmVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiBwcmV2Tm9kZSxcbiAgICAgICAgICAgICAgICAgIGRlcHRoOiBudWxsID09PSBwcmV2Tm9kZSA/IDAgOiBwcmV2Tm9kZS5kZXB0aCArIDEsXG4gICAgICAgICAgICAgICAgICBjb250ZXh0OiB0eXBlLFxuICAgICAgICAgICAgICAgICAgcGFyZW50VmFsdWU6IHByZXZWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IG5ld05vZGU7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IG5ld05vZGU7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiRqc2NvbXAkMSwgLTEpO1xuICAgICAgICAgICAgICB2YXIgcHJldlNuYXBzaG90JGpzY29tcCQwID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gcHJldlNuYXBzaG90JGpzY29tcCQwKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUcmllZCB0byBwb3AgYSBDb250ZXh0IGF0IHRoZSByb290IG9mIHRoZSBhcHAuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwcmV2U25hcHNob3QkanNjb21wJDAuY29udGV4dCAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBwYXJlbnQgY29udGV4dCBpcyBub3QgdGhlIGV4cGVjdGVkIGNvbnRleHQuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwcmV2U25hcHNob3QkanNjb21wJDAuY29udGV4dC5fY3VycmVudFZhbHVlMiA9XG4gICAgICAgICAgICAgICAgcHJldlNuYXBzaG90JGpzY29tcCQwLnBhcmVudFZhbHVlO1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuX2N1cnJlbnRSZW5kZXJlcjIgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB0eXBlLl9jdXJyZW50UmVuZGVyZXIyICYmXG4gICAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFJlbmRlcmVyMiAhPT0gcmVuZGVyZXJTaWdpbCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkRldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSBzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFJlbmRlcmVyMiA9IHJlbmRlcmVyU2lnaWw7XG4gICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSAoY3VycmVudEFjdGl2ZVNuYXBzaG90ID1cbiAgICAgICAgICAgICAgICBwcmV2U25hcHNob3QkanNjb21wJDAucGFyZW50KTtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwO1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgcHJldlNuYXBzaG90ICE9PSB0YXNrLmNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJQb3BwaW5nIHRoZSBjb250ZXh0IHByb3ZpZGVyIGRpZCBub3QgcmV0dXJuIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHNuYXBzaG90LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgICB2YXIgY29udGV4dCRqc2NvbXAkMCA9IHR5cGUuX2NvbnRleHQsXG4gICAgICAgICAgICAgICAgcmVuZGVyID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHJlbmRlciAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkEgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCB0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIHRoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSBpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkcmVuID0gcmVuZGVyKGNvbnRleHQkanNjb21wJDAuX2N1cnJlbnRWYWx1ZTIpLFxuICAgICAgICAgICAgICAgIHByZXZLZXlQYXRoJGpzY29tcCQ1ID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbmV3Q2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gY2FsbExhenlJbml0SW5ERVYodHlwZSk7XG4gICAgICAgICAgICAgIGlmICgxMiA9PT0gcmVxdWVzdC5zdGF0dXMpIHRocm93IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgQ29tcG9uZW50LCBwcm9wcywgcmVmKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgdmFyIGluZm8gPSBcIlwiO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdm9pZCAwID09PSB0eXBlIHx8XG4gICAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAwID09PSBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGgpXG4gICAgICAgIClcbiAgICAgICAgICBpbmZvICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiBcIiArXG4gICAgICAgICAgICAoKG51bGwgPT0gdHlwZSA/IHR5cGUgOiB0eXBlb2YgdHlwZSkgKyBcIi5cIiArIGluZm8pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3VtZU5vZGUocmVxdWVzdCwgdGFzaywgc2VnbWVudElkLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gICAgICB2YXIgcHJldlJlcGxheSA9IHRhc2sucmVwbGF5LFxuICAgICAgICBibG9ja2VkQm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgcmVzdW1lZFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIDAsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgITEsXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICAgIHJlc3VtZWRTZWdtZW50LmlkID0gc2VnbWVudElkO1xuICAgICAgcmVzdW1lZFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgKHRhc2sucmVwbGF5ID0gbnVsbCksXG4gICAgICAgICAgKHRhc2suYmxvY2tlZFNlZ21lbnQgPSByZXN1bWVkU2VnbWVudCksXG4gICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KSxcbiAgICAgICAgICAocmVzdW1lZFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEKSxcbiAgICAgICAgICBudWxsID09PSBibG9ja2VkQm91bmRhcnlcbiAgICAgICAgICAgID8gKHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgPSByZXN1bWVkU2VnbWVudClcbiAgICAgICAgICAgIDogKHF1ZXVlQ29tcGxldGVkU2VnbWVudChibG9ja2VkQm91bmRhcnksIHJlc3VtZWRTZWdtZW50KSxcbiAgICAgICAgICAgICAgYmxvY2tlZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYmxvY2tlZEJvdW5kYXJ5KSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAodGFzay5yZXBsYXkgPSBwcmV2UmVwbGF5KSwgKHRhc2suYmxvY2tlZFNlZ21lbnQgPSBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5RWxlbWVudChcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0YXNrLFxuICAgICAga2V5UGF0aCxcbiAgICAgIG5hbWUsXG4gICAgICBrZXlPckluZGV4LFxuICAgICAgY2hpbGRJbmRleCxcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHJlZixcbiAgICAgIHJlcGxheVxuICAgICkge1xuICAgICAgY2hpbGRJbmRleCA9IHJlcGxheS5ub2RlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRJbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGNoaWxkSW5kZXhbaV07XG4gICAgICAgIGlmIChrZXlPckluZGV4ID09PSBub2RlWzFdKSB7XG4gICAgICAgICAgaWYgKDQgPT09IG5vZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gbmFtZSAmJiBuYW1lICE9PSBub2RlWzBdKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSByZXN1bWUgdG8gcmVuZGVyIDxcIiArXG4gICAgICAgICAgICAgICAgICBub2RlWzBdICtcbiAgICAgICAgICAgICAgICAgIFwiPiBpbiB0aGlzIHNsb3QgYnV0IGluc3RlYWQgaXQgcmVuZGVyZWQgPFwiICtcbiAgICAgICAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgICAgICAgXCI+LiBUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBub2RlWzJdO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVbM107XG4gICAgICAgICAgICBuYW1lID0gdGFzay5ub2RlO1xuICAgICAgICAgICAgdGFzay5yZXBsYXkgPSB7IG5vZGVzOiBjaGlsZE5vZGVzLCBzbG90czogbm9kZSwgcGVuZGluZ1Rhc2tzOiAxIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUsIHByb3BzLCByZWYpO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgMSA9PT0gdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgMCA8IHRhc2sucmVwbGF5Lm5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4ICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0geCAmJlxuICAgICAgICAgICAgICAgICh4ID09PSBTdXNwZW5zZUV4Y2VwdGlvbiB8fCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4LnRoZW4pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0aHJvdyAodGFzay5ub2RlID09PSBuYW1lICYmICh0YXNrLnJlcGxheSA9IHJlcGxheSksIHgpO1xuICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgdHlwZSA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgICAgICAgICAgIHByb3BzID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgcmVxdWVzdCA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICAgICAgICAgICAgICBrZXlQYXRoID0geDtcbiAgICAgICAgICAgICAgcmVmID0gbm9kZTtcbiAgICAgICAgICAgICAgbm9kZSA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocHJvcHMsIGtleVBhdGgsIHR5cGUsIHRhc2suZGVidWdUYXNrKTtcbiAgICAgICAgICAgICAgYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMsXG4gICAgICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnJlcGxheSA9IHJlcGxheTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09IFJFQUNUX1NVU1BFTlNFX1RZUEUpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIHJlc3VtZSB0byByZW5kZXIgPFN1c3BlbnNlPiBpbiB0aGlzIHNsb3QgYnV0IGluc3RlYWQgaXQgcmVuZGVyZWQgPFwiICtcbiAgICAgICAgICAgICAgICAgIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiPi4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgcmVwbGF5ID0gdm9pZCAwO1xuICAgICAgICAgICAgICB0eXBlID0gbm9kZVs1XTtcbiAgICAgICAgICAgICAgcmVmID0gbm9kZVsyXTtcbiAgICAgICAgICAgICAgbmFtZSA9IG5vZGVbM107XG4gICAgICAgICAgICAgIGtleU9ySW5kZXggPSBudWxsID09PSBub2RlWzRdID8gW10gOiBub2RlWzRdWzJdO1xuICAgICAgICAgICAgICBub2RlID0gbnVsbCA9PT0gbm9kZVs0XSA/IG51bGwgOiBub2RlWzRdWzNdO1xuICAgICAgICAgICAgICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGgsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNSZXBsYXlTZXQgPSB0YXNrLnJlcGxheSxcbiAgICAgICAgICAgICAgICBwYXJlbnRCb3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIHBhcmVudEhvaXN0YWJsZVN0YXRlID0gdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBwcm9wcy5mYWxsYmFjayxcbiAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICBwcm9wcyA9XG4gICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPCBIVE1MX01PREVcbiAgICAgICAgICAgICAgICAgID8gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUHJlYW1ibGVTdGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVByZWFtYmxlU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0LFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwcm9wcy5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICAgICAgICAgIHByb3BzLnJvb3RTZWdtZW50SUQgPSB0eXBlO1xuICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IHByb3BzO1xuICAgICAgICAgICAgICB0YXNrLmhvaXN0YWJsZVN0YXRlID0gcHJvcHMuY29udGVudFN0YXRlO1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLnJlcGxheSA9IHsgbm9kZXM6IHJlZiwgc2xvdHM6IG5hbWUsIHBlbmRpbmdUYXNrczogMSB9O1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY29udGVudCwgLTEpO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIDEgPT09IHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgMCA8IHRhc2sucmVwbGF5Lm5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHByb3BzLnBlbmRpbmdUYXNrcyAmJiBwcm9wcy5zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgICAgICAgICAgIHByb3BzLnN0YXR1cyA9IENPTVBMRVRFRDtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5wdXNoKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIChwcm9wcy5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQpLFxuICAgICAgICAgICAgICAgICAgKGNoaWxkTm9kZXMgPSBnZXRUaHJvd25JbmZvKHRhc2suY29tcG9uZW50U3RhY2spKSxcbiAgICAgICAgICAgICAgICAgIChyZXBsYXkgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShwcm9wcywgcmVwbGF5LCBlcnJvciwgY2hpbGROb2RlcywgITEpLFxuICAgICAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS0sXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKHByb3BzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAodGFzay5ibG9ja2VkQm91bmRhcnkgPSBwYXJlbnRCb3VuZGFyeSksXG4gICAgICAgICAgICAgICAgICAodGFzay5ob2lzdGFibGVTdGF0ZSA9IHBhcmVudEhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICh0YXNrLnJlcGxheSA9IHByZXZpb3VzUmVwbGF5U2V0KSxcbiAgICAgICAgICAgICAgICAgICh0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJvcHMgPSBjcmVhdGVSZXBsYXlUYXNrKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICB7IG5vZGVzOiBrZXlPckluZGV4LCBzbG90czogbm9kZSwgcGVuZGluZ1Rhc2tzOiAwIH0sXG4gICAgICAgICAgICAgICAgZmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgLTEsXG4gICAgICAgICAgICAgICAgcGFyZW50Qm91bmRhcnksXG4gICAgICAgICAgICAgICAgcHJvcHMuZmFsbGJhY2tTdGF0ZSxcbiAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0LFxuICAgICAgICAgICAgICAgIFtrZXlQYXRoWzBdLCBcIlN1c3BlbnNlIEZhbGxiYWNrXCIsIGtleVBhdGhbMl1dLFxuICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICAgICEwLFxuICAgICAgICAgICAgICAgIGVtcHR5Q29udGV4dE9iamVjdCxcbiAgICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwdXNoQ29tcG9uZW50U3RhY2socHJvcHMpO1xuICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2gocHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZEluZGV4LnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCkge1xuICAgICAgbnVsbCAhPT0gdGFzay5yZXBsYXkgJiYgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHRhc2sucmVwbGF5LnNsb3RzXG4gICAgICAgID8gcmVzdW1lTm9kZShyZXF1ZXN0LCB0YXNrLCB0YXNrLnJlcGxheS5zbG90cywgbm9kZSwgY2hpbGRJbmRleClcbiAgICAgICAgOiAoKHRhc2subm9kZSA9IG5vZGUpLFxuICAgICAgICAgICh0YXNrLmNoaWxkSW5kZXggPSBjaGlsZEluZGV4KSxcbiAgICAgICAgICAobm9kZSA9IHRhc2suY29tcG9uZW50U3RhY2spLFxuICAgICAgICAgIChjaGlsZEluZGV4ID0gdGFzay5kZWJ1Z1Rhc2spLFxuICAgICAgICAgIHB1c2hDb21wb25lbnRTdGFjayh0YXNrKSxcbiAgICAgICAgICByZXRyeU5vZGUocmVxdWVzdCwgdGFzayksXG4gICAgICAgICAgKHRhc2suY29tcG9uZW50U3RhY2sgPSBub2RlKSxcbiAgICAgICAgICAodGFzay5kZWJ1Z1Rhc2sgPSBjaGlsZEluZGV4KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldHJ5Tm9kZShyZXF1ZXN0LCB0YXNrKSB7XG4gICAgICB2YXIgbm9kZSA9IHRhc2subm9kZSxcbiAgICAgICAgY2hpbGRJbmRleCA9IHRhc2suY2hpbGRJbmRleDtcbiAgICAgIGlmIChudWxsICE9PSBub2RlKSB7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSkge1xuICAgICAgICAgIHN3aXRjaCAobm9kZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIGtleSA9IG5vZGUua2V5O1xuICAgICAgICAgICAgICBub2RlID0gbm9kZS5wcm9wcztcbiAgICAgICAgICAgICAgdmFyIHJlZlByb3AgPSBub2RlLnJlZjtcbiAgICAgICAgICAgICAgcmVmUHJvcCA9IHZvaWQgMCAhPT0gcmVmUHJvcCA/IHJlZlByb3AgOiBudWxsO1xuICAgICAgICAgICAgICB2YXIgZGVidWdUYXNrID0gdGFzay5kZWJ1Z1Rhc2ssXG4gICAgICAgICAgICAgICAgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgICAgICAga2V5ID0gbnVsbCA9PSBrZXkgPyAoLTEgPT09IGNoaWxkSW5kZXggPyAwIDogY2hpbGRJbmRleCkgOiBrZXk7XG4gICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gW3Rhc2sua2V5UGF0aCwgbmFtZSwga2V5XTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gdGFzay5yZXBsYXlcbiAgICAgICAgICAgICAgICA/IGRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgPyBkZWJ1Z1Rhc2sucnVuKFxuICAgICAgICAgICAgICAgICAgICAgIHJlcGxheUVsZW1lbnQuYmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmUHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucmVwbGF5XG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IHJlcGxheUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgcmVmUHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICB0YXNrLnJlcGxheVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBkZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICAgID8gZGVidWdUYXNrLnJ1bihcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJFbGVtZW50LmJpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZQcm9wXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZSwgbm9kZSwgcmVmUHJvcCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiUG9ydGFscyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZlciByZW5kZXJlci4gUmVuZGVyIHRoZW0gY29uZGl0aW9uYWxseSBzbyB0aGF0IHRoZXkgb25seSBhcHBlYXIgb24gdGhlIGNsaWVudCByZW5kZXIuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBub2RlID0gY2FsbExhenlJbml0SW5ERVYobm9kZSk7XG4gICAgICAgICAgICAgIGlmICgxMiA9PT0gcmVxdWVzdC5zdGF0dXMpIHRocm93IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwobm9kZSkpIHtcbiAgICAgICAgICAgIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bGwgPT09IG5vZGUgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG5vZGVcbiAgICAgICAgICAgID8gKGtleSA9IG51bGwpXG4gICAgICAgICAgICA6ICgodHlwZSA9XG4gICAgICAgICAgICAgICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBub2RlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICAgICAgICAgICAgbm9kZVtcIkBAaXRlcmF0b3JcIl0pLFxuICAgICAgICAgICAgICAoa2V5ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSA/IHR5cGUgOiBudWxsKSk7XG4gICAgICAgICAgaWYgKGtleSAmJiAodHlwZSA9IGtleS5jYWxsKG5vZGUpKSkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC0xICE9PSBjaGlsZEluZGV4IHx8XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gdGFzay5jb21wb25lbnRTdGFjayB8fFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHRhc2suY29tcG9uZW50U3RhY2sudHlwZSB8fFxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiAhPT1cbiAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXNrLmNvbXBvbmVudFN0YWNrLnR5cGUpIHx8XG4gICAgICAgICAgICAgICAgXCJbb2JqZWN0IEdlbmVyYXRvcl1cIiAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHR5cGUpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIHx8XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlVzaW5nIEl0ZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgdW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gWW91IG1heSBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggYEFycmF5LmZyb20oKWAgb3IgdGhlIGBbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gWW91IGNhbiBhbHNvIHVzZSBhbiBJdGVyYWJsZSB0aGF0IGNhbiBpdGVyYXRlIG11bHRpcGxlIHRpbWVzIG92ZXIgdGhlIHNhbWUgaXRlbXMuXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9ICEwKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBub2RlLmVudHJpZXMgIT09IGtleSB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgfHxcbiAgICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiBVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0TWFwcyA9ICEwKSk7XG4gICAgICAgICAgICBub2RlID0gdHlwZS5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoIW5vZGUuZG9uZSkge1xuICAgICAgICAgICAgICBrZXkgPSBbXTtcbiAgICAgICAgICAgICAgZG8ga2V5LnB1c2gobm9kZS52YWx1ZSksIChub2RlID0gdHlwZS5uZXh0KCkpO1xuICAgICAgICAgICAgICB3aGlsZSAoIW5vZGUuZG9uZSk7XG4gICAgICAgICAgICAgIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywga2V5LCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh0YXNrLnRoZW5hYmxlU3RhdGUgPSBudWxsKSxcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShub2RlKSxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgIG5vZGUuX2N1cnJlbnRWYWx1ZTIsXG4gICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVxdWVzdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChub2RlKTtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArXG4gICAgICAgICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgPyBcIm9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMobm9kZSkuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgICAgICA6IHJlcXVlc3QpICtcbiAgICAgICAgICAgICAgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgPyAoKHRhc2sgPSB0YXNrLmJsb2NrZWRTZWdtZW50KSxcbiAgICAgICAgICAgIG51bGwgIT09IHRhc2sgJiZcbiAgICAgICAgICAgICAgKHRhc2subGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgIHRhc2suY2h1bmtzLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICB0YXNrLmxhc3RQdXNoZWRUZXh0XG4gICAgICAgICAgICAgICkpKVxuICAgICAgICAgIDogXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5vZGUgfHwgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5vZGVcbiAgICAgICAgICAgID8gKCh0YXNrID0gdGFzay5ibG9ja2VkU2VnbWVudCksXG4gICAgICAgICAgICAgIG51bGwgIT09IHRhc2sgJiZcbiAgICAgICAgICAgICAgICAodGFzay5sYXN0UHVzaGVkVGV4dCA9IHB1c2hUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICB0YXNrLmNodW5rcyxcbiAgICAgICAgICAgICAgICAgIFwiXCIgKyBub2RlLFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIHRhc2subGFzdFB1c2hlZFRleHRcbiAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgICAgICAgICAoKHJlcXVlc3QgPSBub2RlLmRpc3BsYXlOYW1lIHx8IG5vZGUubmFtZSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgeW91IHJldHVybiAlcyBpbnN0ZWFkIG9mIDwlcyAvPiBmcm9tIHJlbmRlci4gT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXCIsXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlN5bWJvbHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLlxcbiAgJXNcIixcbiAgICAgICAgICAgICAgICAgIFN0cmluZyhub2RlKVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCBjaGlsZEluZGV4KSB7XG4gICAgICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGgsXG4gICAgICAgIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrO1xuICAgICAgdmFyIHByZXZpb3VzRGVidWdUYXNrID0gdGFzay5kZWJ1Z1Rhc2s7XG4gICAgICBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgdGFzay5ub2RlLl9kZWJ1Z0luZm8pO1xuICAgICAgaWYgKFxuICAgICAgICAtMSAhPT0gY2hpbGRJbmRleCAmJlxuICAgICAgICAoKHRhc2sua2V5UGF0aCA9IFt0YXNrLmtleVBhdGgsIFwiRnJhZ21lbnRcIiwgY2hpbGRJbmRleF0pLFxuICAgICAgICBudWxsICE9PSB0YXNrLnJlcGxheSlcbiAgICAgICkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciByZXBsYXkgPSB0YXNrLnJlcGxheSwgcmVwbGF5Tm9kZXMgPSByZXBsYXkubm9kZXMsIGogPSAwO1xuICAgICAgICAgIGogPCByZXBsYXlOb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgaisrXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBub2RlID0gcmVwbGF5Tm9kZXNbal07XG4gICAgICAgICAgaWYgKG5vZGVbMV0gPT09IGNoaWxkSW5kZXgpIHtcbiAgICAgICAgICAgIGNoaWxkSW5kZXggPSBub2RlWzJdO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVbM107XG4gICAgICAgICAgICB0YXNrLnJlcGxheSA9IHsgbm9kZXM6IGNoaWxkSW5kZXgsIHNsb3RzOiBub2RlLCBwZW5kaW5nVGFza3M6IDEgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDEgPT09IHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgIDAgPCB0YXNrLnJlcGxheS5ub2Rlcy5sZW5ndGhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDb3VsZG4ndCBmaW5kIGFsbCByZXN1bWFibGUgc2xvdHMgYnkga2V5L2luZGV4IGR1cmluZyByZXBsYXlpbmcuIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IHggJiZcbiAgICAgICAgICAgICAgICAoeCA9PT0gU3VzcGVuc2VFeGNlcHRpb24gfHwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeC50aGVuKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgeDtcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgIHZhciB0aHJvd25JbmZvID0gZ2V0VGhyb3duSW5mbyh0YXNrLmNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0geCxcbiAgICAgICAgICAgICAgICByZXN1bWVTbG90cyA9IG5vZGU7XG4gICAgICAgICAgICAgIG5vZGUgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgdGhyb3duSW5mbyxcbiAgICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleCxcbiAgICAgICAgICAgICAgICByZXN1bWVTbG90cyxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIHRocm93bkluZm8sXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2sucmVwbGF5ID0gcmVwbGF5O1xuICAgICAgICAgICAgcmVwbGF5Tm9kZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBwcmV2aW91c0RlYnVnVGFzaztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVwbGF5ID0gdGFzay50cmVlQ29udGV4dDtcbiAgICAgIHJlcGxheU5vZGVzID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSB0YXNrLnJlcGxheSAmJlxuICAgICAgICAoKGogPSB0YXNrLnJlcGxheS5zbG90cyksIG51bGwgIT09IGogJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGopXG4gICAgICApIHtcbiAgICAgICAgZm9yIChjaGlsZEluZGV4ID0gMDsgY2hpbGRJbmRleCA8IHJlcGxheU5vZGVzOyBjaGlsZEluZGV4KyspXG4gICAgICAgICAgKG5vZGUgPSBjaGlsZHJlbltjaGlsZEluZGV4XSksXG4gICAgICAgICAgICAodGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChcbiAgICAgICAgICAgICAgcmVwbGF5LFxuICAgICAgICAgICAgICByZXBsYXlOb2RlcyxcbiAgICAgICAgICAgICAgY2hpbGRJbmRleFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAoZXJyb3IgPSBqW2NoaWxkSW5kZXhdKSxcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBlcnJvclxuICAgICAgICAgICAgICA/IChyZXN1bWVOb2RlKHJlcXVlc3QsIHRhc2ssIGVycm9yLCBub2RlLCBjaGlsZEluZGV4KSxcbiAgICAgICAgICAgICAgICBkZWxldGUgaltjaGlsZEluZGV4XSlcbiAgICAgICAgICAgICAgOiByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcmVwbGF5O1xuICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDA7IGogPCByZXBsYXlOb2RlczsgaisrKSB7XG4gICAgICAgIGNoaWxkSW5kZXggPSBjaGlsZHJlbltqXTtcbiAgICAgICAgcmVzdW1lU2xvdHMgPSByZXF1ZXN0O1xuICAgICAgICBub2RlID0gdGFzaztcbiAgICAgICAgZXJyb3IgPSBjaGlsZEluZGV4O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiZcbiAgICAgICAgICAoZXJyb3IuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSB8fFxuICAgICAgICAgICAgZXJyb3IuJCR0eXBlb2YgPT09IFJFQUNUX1BPUlRBTF9UWVBFKSAmJlxuICAgICAgICAgIGVycm9yLl9zdG9yZSAmJlxuICAgICAgICAgICgoIWVycm9yLl9zdG9yZS52YWxpZGF0ZWQgJiYgbnVsbCA9PSBlcnJvci5rZXkpIHx8XG4gICAgICAgICAgICAyID09PSBlcnJvci5fc3RvcmUudmFsaWRhdGVkKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGVycm9yLl9zdG9yZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBlcnJvci5fc3RvcmUudmFsaWRhdGVkID0gMTtcbiAgICAgICAgICB0aHJvd25JbmZvID0gcmVzdW1lU2xvdHMuZGlkV2FybkZvcktleTtcbiAgICAgICAgICBudWxsID09IHRocm93bkluZm8gJiZcbiAgICAgICAgICAgICh0aHJvd25JbmZvID0gcmVzdW1lU2xvdHMuZGlkV2FybkZvcktleSA9IG5ldyBXZWFrU2V0KCkpO1xuICAgICAgICAgIHJlc3VtZVNsb3RzID0gbm9kZS5jb21wb25lbnRTdGFjaztcbiAgICAgICAgICBpZiAobnVsbCAhPT0gcmVzdW1lU2xvdHMgJiYgIXRocm93bkluZm8uaGFzKHJlc3VtZVNsb3RzKSkge1xuICAgICAgICAgICAgdGhyb3duSW5mby5hZGQocmVzdW1lU2xvdHMpO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZXJyb3IudHlwZSk7XG4gICAgICAgICAgICB0aHJvd25JbmZvID0gZXJyb3IuX293bmVyO1xuICAgICAgICAgICAgdmFyIHBhcmVudE93bmVyID0gcmVzdW1lU2xvdHMub3duZXI7XG4gICAgICAgICAgICByZXN1bWVTbG90cyA9IFwiXCI7XG4gICAgICAgICAgICBpZiAocGFyZW50T3duZXIgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHBhcmVudE93bmVyLnR5cGUpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50T3duZXIudHlwZSk7XG4gICAgICAgICAgICAgIG5hbWUgJiZcbiAgICAgICAgICAgICAgICAocmVzdW1lU2xvdHMgPVxuICAgICAgICAgICAgICAgICAgXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBuYW1lICsgXCJgLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VtZVNsb3RzIHx8XG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAgICAgKHJlc3VtZVNsb3RzID1cbiAgICAgICAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgK1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSArXG4gICAgICAgICAgICAgICAgICBcIj4uXCIpKTtcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgbnVsbCAhPSB0aHJvd25JbmZvICYmXG4gICAgICAgICAgICAgIHBhcmVudE93bmVyICE9PSB0aHJvd25JbmZvICYmXG4gICAgICAgICAgICAgICgocGFyZW50T3duZXIgPSBudWxsKSxcbiAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHRocm93bkluZm8udHlwZVxuICAgICAgICAgICAgICAgID8gKHBhcmVudE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRocm93bkluZm8udHlwZSkpXG4gICAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgdGhyb3duSW5mby5uYW1lICYmXG4gICAgICAgICAgICAgICAgICAocGFyZW50T3duZXIgPSB0aHJvd25JbmZvLm5hbWUpLFxuICAgICAgICAgICAgICBwYXJlbnRPd25lciAmJlxuICAgICAgICAgICAgICAgIChjb21wb25lbnROYW1lID1cbiAgICAgICAgICAgICAgICAgIFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgcGFyZW50T3duZXIgKyBcIi5cIikpO1xuICAgICAgICAgICAgdGhyb3duSW5mbyA9IG5vZGUuY29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICBub2RlLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgICAgICAgICBwYXJlbnQ6IG5vZGUuY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgIHR5cGU6IGVycm9yLnR5cGUsXG4gICAgICAgICAgICAgIG93bmVyOiBlcnJvci5fb3duZXIsXG4gICAgICAgICAgICAgIHN0YWNrOiBlcnJvci5fZGVidWdTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICAgICAgcmVzdW1lU2xvdHMsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBub2RlLmNvbXBvbmVudFN0YWNrID0gdGhyb3duSW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChyZXBsYXksIHJlcGxheU5vZGVzLCBqKTtcbiAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZEluZGV4LCBqKTtcbiAgICAgIH1cbiAgICAgIHRhc2sudHJlZUNvbnRleHQgPSByZXBsYXk7XG4gICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBwcmV2aW91c0RlYnVnVGFzaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdW50cmFja0JvdW5kYXJ5KHJlcXVlc3QsIGJvdW5kYXJ5KSB7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzO1xuICAgICAgbnVsbCAhPT0gcmVxdWVzdCAmJlxuICAgICAgICAoKGJvdW5kYXJ5ID0gYm91bmRhcnkudHJhY2tlZENvbnRlbnRLZXlQYXRoKSxcbiAgICAgICAgbnVsbCAhPT0gYm91bmRhcnkgJiZcbiAgICAgICAgICAoKGJvdW5kYXJ5ID0gcmVxdWVzdC53b3JraW5nTWFwLmdldChib3VuZGFyeSkpLFxuICAgICAgICAgIHZvaWQgMCAhPT0gYm91bmRhcnkgJiZcbiAgICAgICAgICAgICgoYm91bmRhcnkubGVuZ3RoID0gNCksIChib3VuZGFyeVsyXSA9IFtdKSwgKGJvdW5kYXJ5WzNdID0gbnVsbCkpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhyZXF1ZXN0LCB0YXNrLCB0aGVuYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVwbGF5VGFzayhcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgdGhlbmFibGVTdGF0ZSxcbiAgICAgICAgdGFzay5yZXBsYXksXG4gICAgICAgIHRhc2subm9kZSxcbiAgICAgICAgdGFzay5jaGlsZEluZGV4LFxuICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgdGFzay5hYm9ydFNldCxcbiAgICAgICAgdGFzay5rZXlQYXRoLFxuICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgdGFzay5pc0ZhbGxiYWNrLFxuICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2socmVxdWVzdCwgdGFzaywgdGhlbmFibGVTdGF0ZSkge1xuICAgICAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50LFxuICAgICAgICBuZXdTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBzZWdtZW50LmNodW5rcy5sZW5ndGgsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAhMFxuICAgICAgICApO1xuICAgICAgc2VnbWVudC5jaGlsZHJlbi5wdXNoKG5ld1NlZ21lbnQpO1xuICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIHRoZW5hYmxlU3RhdGUsXG4gICAgICAgIHRhc2subm9kZSxcbiAgICAgICAgdGFzay5jaGlsZEluZGV4LFxuICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgbmV3U2VnbWVudCxcbiAgICAgICAgdGFzay5ibG9ja2VkUHJlYW1ibGUsXG4gICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgIHRhc2suYWJvcnRTZXQsXG4gICAgICAgIHRhc2sua2V5UGF0aCxcbiAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgIHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgIHRhc2suaXNGYWxsYmFjayxcbiAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gICAgICB2YXIgcHJldmlvdXNGb3JtYXRDb250ZXh0ID0gdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICBwcmV2aW91c0NvbnRleHQgPSB0YXNrLmNvbnRleHQsXG4gICAgICAgIHByZXZpb3VzS2V5UGF0aCA9IHRhc2sua2V5UGF0aCxcbiAgICAgICAgcHJldmlvdXNUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICBwcmV2aW91c0RlYnVnVGFzayA9IHRhc2suZGVidWdUYXNrLFxuICAgICAgICBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgIGlmIChudWxsID09PSBzZWdtZW50KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHJlc2V0SG9va3NTdGF0ZSgpLFxuICAgICAgICAgICAgKG5vZGUgPVxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICA/IGdldFN1c3BlbmRlZFRoZW5hYmxlKClcbiAgICAgICAgICAgICAgICA6IHRocm93blZhbHVlKSxcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmIG51bGwgIT09IG5vZGUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygbm9kZS50aGVuKSB7XG4gICAgICAgICAgICAgIGNoaWxkSW5kZXggPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSBzcGF3bk5ld1N1c3BlbmRlZFJlcGxheVRhc2soXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgKS5waW5nO1xuICAgICAgICAgICAgICBub2RlLnRoZW4ocmVxdWVzdCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBwcmV2aW91c0RlYnVnVGFzaztcbiAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiID09PSBub2RlLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgbm9kZSA9IHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhyZXF1ZXN0LCB0YXNrLCBub2RlKTtcbiAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgIGNodW5rTGVuZ3RoID0gc2VnbWVudC5jaHVua3MubGVuZ3RoO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlJDMpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocmVzZXRIb29rc1N0YXRlKCksXG4gICAgICAgICAgICAoc2VnbWVudC5jaGlsZHJlbi5sZW5ndGggPSBjaGlsZHJlbkxlbmd0aCksXG4gICAgICAgICAgICAoc2VnbWVudC5jaHVua3MubGVuZ3RoID0gY2h1bmtMZW5ndGgpLFxuICAgICAgICAgICAgKG5vZGUgPVxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSQzID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgID8gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKVxuICAgICAgICAgICAgICAgIDogdGhyb3duVmFsdWUkMyksXG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJiBudWxsICE9PSBub2RlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUudGhlbikge1xuICAgICAgICAgICAgICBjaGlsZEluZGV4ID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICAgICAgICByZXF1ZXN0ID0gc3Bhd25OZXdTdXNwZW5kZWRSZW5kZXJUYXNrKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICAgICkucGluZztcbiAgICAgICAgICAgICAgbm9kZS50aGVuKHJlcXVlc3QsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwiTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIiA9PT0gbm9kZS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgIG5vZGUgPSBzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2socmVxdWVzdCwgdGFzaywgbm9kZSk7XG4gICAgICAgICAgICAgIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZpb3VzVHJlZUNvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFzayA9IHByZXZpb3VzRGVidWdUYXNrO1xuICAgICAgICAgICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0O1xuICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgdGhyb3cgbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWJvcnRUYXNrU29mdCh0YXNrKSB7XG4gICAgICB2YXIgYm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgICAgIHRhc2sgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgbnVsbCAhPT0gdGFzayAmJiAoKHRhc2suc3RhdHVzID0gMyksIGZpbmlzaGVkVGFzayh0aGlzLCBib3VuZGFyeSwgdGFzaykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgcmVxdWVzdCRqc2NvbXAkMCxcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgbm9kZXMsXG4gICAgICBzbG90cyxcbiAgICAgIGVycm9yJGpzY29tcCQwLFxuICAgICAgZXJyb3JEaWdlc3QkanNjb21wJDAsXG4gICAgICBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICBhYm9ydGVkXG4gICAgKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmICg0ID09PSBub2RlLmxlbmd0aClcbiAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgbm9kZVsyXSxcbiAgICAgICAgICAgIG5vZGVbM10sXG4gICAgICAgICAgICBlcnJvciRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9yRGlnZXN0JGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQwLFxuICAgICAgICAgICAgYWJvcnRlZFxuICAgICAgICAgICk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciByZXF1ZXN0ID0gcmVxdWVzdCRqc2NvbXAkMDtcbiAgICAgICAgICBub2RlID0gbm9kZVs1XTtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBlcnJvciRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9yRGlnZXN0ID0gZXJyb3JEaWdlc3QkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvckluZm8gPSBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICAgICAgICB3YXNBYm9ydGVkID0gYWJvcnRlZCxcbiAgICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bWVkQm91bmRhcnkucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeS5yb290U2VnbWVudElEID0gbm9kZTtcbiAgICAgICAgICByZXN1bWVkQm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEO1xuICAgICAgICAgIGVuY29kZUVycm9yRm9yQm91bmRhcnkoXG4gICAgICAgICAgICByZXN1bWVkQm91bmRhcnksXG4gICAgICAgICAgICBlcnJvckRpZ2VzdCxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgZXJyb3JJbmZvLFxuICAgICAgICAgICAgd2FzQWJvcnRlZFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2gocmVzdW1lZEJvdW5kYXJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZXMubGVuZ3RoID0gMDtcbiAgICAgIGlmIChudWxsICE9PSBzbG90cykge1xuICAgICAgICBpZiAobnVsbCA9PT0gYm91bmRhcnkpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIldlIHNob3VsZCBub3QgaGF2ZSBhbnkgcmVzdW1hYmxlIG5vZGVzIGluIHRoZSBzaGVsbC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEICYmXG4gICAgICAgICAgKChib3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQpLFxuICAgICAgICAgIGVuY29kZUVycm9yRm9yQm91bmRhcnkoXG4gICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgIGVycm9yRGlnZXN0JGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3IkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICAgICAgICBhYm9ydGVkXG4gICAgICAgICAgKSxcbiAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwLmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2Ygc2xvdHMpXG4gICAgICAgICAgZm9yICh2YXIgaW5kZXggaW4gc2xvdHMpIGRlbGV0ZSBzbG90c1tpbmRleF07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFib3J0VGFzayh0YXNrLCByZXF1ZXN0LCBlcnJvcikge1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgaWYgKG51bGwgIT09IHNlZ21lbnQpIHtcbiAgICAgICAgaWYgKDYgPT09IHNlZ21lbnQuc3RhdHVzKSByZXR1cm47XG4gICAgICAgIHNlZ21lbnQuc3RhdHVzID0gMztcbiAgICAgIH1cbiAgICAgIHNlZ21lbnQgPSBnZXRUaHJvd25JbmZvKHRhc2suY29tcG9uZW50U3RhY2spO1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KSB7XG4gICAgICAgIGlmICgxMyAhPT0gcmVxdWVzdC5zdGF0dXMgJiYgcmVxdWVzdC5zdGF0dXMgIT09IENMT1NFRCkge1xuICAgICAgICAgIGJvdW5kYXJ5ID0gdGFzay5yZXBsYXk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KSB7XG4gICAgICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBzZWdtZW50LCBudWxsKTtcbiAgICAgICAgICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IsIHNlZ21lbnQsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib3VuZGFyeS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAwID09PSBib3VuZGFyeS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgIDAgPCBib3VuZGFyeS5ub2Rlcy5sZW5ndGggJiZcbiAgICAgICAgICAgICgodGFzayA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIHNlZ21lbnQsIG51bGwpKSxcbiAgICAgICAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGJvdW5kYXJ5Lm5vZGVzLFxuICAgICAgICAgICAgICBib3VuZGFyeS5zbG90cyxcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICAgICEwXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MtLTtcbiAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiYgY29tcGxldGVTaGVsbChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIGJvdW5kYXJ5LnBlbmRpbmdUYXNrcy0tLFxuICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEICYmXG4gICAgICAgICAgICAoKGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRCksXG4gICAgICAgICAgICAodGFzayA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIHNlZ21lbnQsIG51bGwpKSxcbiAgICAgICAgICAgIChib3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQpLFxuICAgICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShib3VuZGFyeSwgdGFzaywgZXJyb3IsIHNlZ21lbnQsICEwKSxcbiAgICAgICAgICAgIHVudHJhY2tCb3VuZGFyeShyZXF1ZXN0LCBib3VuZGFyeSksXG4gICAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpKSxcbiAgICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmZvckVhY2goZnVuY3Rpb24gKGZhbGxiYWNrVGFzaykge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0VGFzayhmYWxsYmFja1Rhc2ssIHJlcXVlc3QsIGVycm9yKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tO1xuICAgICAgMCA9PT0gcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgJiYgY29tcGxldGVBbGwocmVxdWVzdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QsIHNoZWxsQ29tcGxldGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgb25IZWFkZXJzID0gcmVuZGVyU3RhdGUub25IZWFkZXJzO1xuICAgICAgICBpZiAob25IZWFkZXJzKSB7XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5oZWFkZXJzID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBsaW5rSGVhZGVyID0gaGVhZGVycy5wcmVjb25uZWN0cztcbiAgICAgICAgICAgIGhlYWRlcnMuZm9udFByZWxvYWRzICYmXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICYmIChsaW5rSGVhZGVyICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICs9IGhlYWRlcnMuZm9udFByZWxvYWRzKSk7XG4gICAgICAgICAgICBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICYmXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICYmIChsaW5rSGVhZGVyICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICs9IGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMpKTtcbiAgICAgICAgICAgIGlmICghc2hlbGxDb21wbGV0ZSkge1xuICAgICAgICAgICAgICB2YXIgcXVldWVJdGVyID0gcmVuZGVyU3RhdGUuc3R5bGVzLnZhbHVlcygpLFxuICAgICAgICAgICAgICAgIHF1ZXVlU3RlcCA9IHF1ZXVlSXRlci5uZXh0KCk7XG4gICAgICAgICAgICAgIGI6IGZvciAoXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIDAgPCBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ICYmICFxdWV1ZVN0ZXAuZG9uZTtcbiAgICAgICAgICAgICAgICBxdWV1ZVN0ZXAgPSBxdWV1ZUl0ZXIubmV4dCgpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgdmFyIHNoZWV0SXRlciA9IHF1ZXVlU3RlcC52YWx1ZS5zaGVldHMudmFsdWVzKCksXG4gICAgICAgICAgICAgICAgICAgIHNoZWV0U3RlcCA9IHNoZWV0SXRlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAwIDwgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAmJiAhc2hlZXRTdGVwLmRvbmU7XG4gICAgICAgICAgICAgICAgICBzaGVldFN0ZXAgPSBzaGVldEl0ZXIubmV4dCgpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc2hlZXQgPSBzaGVldFN0ZXAudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzID0gc2hlZXQucHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHByb3BzLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzJGpzY29tcCQwID0gc2hlZXQucHJvcHM7XG4gICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gZ2V0UHJlbG9hZEFzSGVhZGVyKFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyRqc2NvbXAkMC5ocmVmLFxuICAgICAgICAgICAgICAgICAgICBcInN0eWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogcHJvcHMkanNjb21wJDAuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgaW50ZWdyaXR5OiBwcm9wcyRqc2NvbXAkMC5pbnRlZ3JpdHksXG4gICAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHByb3BzJGpzY29tcCQwLm5vbmNlLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHByb3BzJGpzY29tcCQwLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogcHJvcHMkanNjb21wJDAuZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICByZWZlcnJlclBvbGljeTogcHJvcHMkanNjb21wJDAucmVmZXJyZXJQb2xpY3ksXG4gICAgICAgICAgICAgICAgICAgICAgbWVkaWE6IHByb3BzJGpzY29tcCQwLm1lZGlhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAoMCA8PSAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpXG4gICAgICAgICAgICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZXNldHMuc3R5bGVba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFMpLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmtIZWFkZXIgJiYgKGxpbmtIZWFkZXIgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAobGlua0hlYWRlciArPSBoZWFkZXIpLFxuICAgICAgICAgICAgICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZXNldHMuc3R5bGVba2V5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMuY3Jvc3NPcmlnaW4gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcHJvcHMuY3Jvc3NPcmlnaW4sIHByb3BzLmludGVncml0eV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBQUkVMT0FEX05PX0NSRURTKTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rSGVhZGVyID8gb25IZWFkZXJzKHsgTGluazogbGlua0hlYWRlciB9KSA6IG9uSGVhZGVycyh7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCB7fSwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlU2hlbGwocmVxdWVzdCkge1xuICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QsICEwKTtcbiAgICAgIG51bGwgPT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAmJiBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCk7XG4gICAgICByZXF1ZXN0Lm9uU2hlbGxFcnJvciA9IG5vb3A7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5vblNoZWxsUmVhZHk7XG4gICAgICByZXF1ZXN0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlQWxsKHJlcXVlc3QpIHtcbiAgICAgIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXNcbiAgICAgICAgICA/ICEwXG4gICAgICAgICAgOiBudWxsID09PSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50IHx8XG4gICAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQuc3RhdHVzICE9PSBQT1NUUE9ORURcbiAgICAgICk7XG4gICAgICBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCk7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5vbkFsbFJlYWR5O1xuICAgICAgcmVxdWVzdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gc2VnbWVudC5jaHVua3MubGVuZ3RoICYmXG4gICAgICAgIDEgPT09IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIG51bGwgPT09IHNlZ21lbnQuY2hpbGRyZW5bMF0uYm91bmRhcnkgJiZcbiAgICAgICAgLTEgPT09IHNlZ21lbnQuY2hpbGRyZW5bMF0uaWRcbiAgICAgICkge1xuICAgICAgICB2YXIgY2hpbGRTZWdtZW50ID0gc2VnbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgY2hpbGRTZWdtZW50LmlkID0gc2VnbWVudC5pZDtcbiAgICAgICAgY2hpbGRTZWdtZW50LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgICAgY2hpbGRTZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEICYmXG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBjaGlsZFNlZ21lbnQpO1xuICAgICAgfSBlbHNlIGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaGVkVGFzayhyZXF1ZXN0LCBib3VuZGFyeSwgc2VnbWVudCkge1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KSB7XG4gICAgICAgIGlmIChudWxsICE9PSBzZWdtZW50ICYmIHNlZ21lbnQucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlcmUgY2FuIG9ubHkgYmUgb25lIHJvb3Qgc2VnbWVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID0gc2VnbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MtLTtcbiAgICAgICAgMCA9PT0gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzICYmIGNvbXBsZXRlU2hlbGwocmVxdWVzdCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS0sXG4gICAgICAgICAgYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQgJiZcbiAgICAgICAgICAgICgwID09PSBib3VuZGFyeS5wZW5kaW5nVGFza3NcbiAgICAgICAgICAgICAgPyAoYm91bmRhcnkuc3RhdHVzID09PSBQRU5ESU5HICYmIChib3VuZGFyeS5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IHNlZ21lbnQgJiZcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnQucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgICAgc2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCAmJlxuICAgICAgICAgICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KSxcbiAgICAgICAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSksXG4gICAgICAgICAgICAgICAgYm91bmRhcnkuc3RhdHVzID09PSBDT01QTEVURUQgJiZcbiAgICAgICAgICAgICAgICAgIChib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgIGFib3J0VGFza1NvZnQsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCksXG4gICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGJvdW5kYXJ5LmNvbnRlbnRQcmVhbWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCkpKVxuICAgICAgICAgICAgICA6IG51bGwgIT09IHNlZ21lbnQgJiZcbiAgICAgICAgICAgICAgICBzZWdtZW50LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgICBzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEICYmXG4gICAgICAgICAgICAgICAgKHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgc2VnbWVudCksXG4gICAgICAgICAgICAgICAgMSA9PT0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpKSk7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tO1xuICAgICAgMCA9PT0gcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgJiYgY29tcGxldGVBbGwocmVxdWVzdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrKHJlcXVlc3QkanNjb21wJDIpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmVxdWVzdCRqc2NvbXAkMi5zdGF0dXMgIT09IENMT1NFRCAmJlxuICAgICAgICAxMyAhPT0gcmVxdWVzdCRqc2NvbXAkMi5zdGF0dXNcbiAgICAgICkge1xuICAgICAgICB2YXIgcHJldkNvbnRleHQgPSBjdXJyZW50QWN0aXZlU25hcHNob3QsXG4gICAgICAgICAgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSG9va3NEaXNwYXRjaGVyO1xuICAgICAgICB2YXIgcHJldkFzeW5jRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyO1xuICAgICAgICB2YXIgcHJldlJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdDtcbiAgICAgICAgY3VycmVudFJlcXVlc3QgPSByZXF1ZXN0JGpzY29tcCQyO1xuICAgICAgICB2YXIgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRTdGFja0luREVWO1xuICAgICAgICB2YXIgcHJldlJlc3VtYWJsZVN0YXRlID0gY3VycmVudFJlc3VtYWJsZVN0YXRlO1xuICAgICAgICBjdXJyZW50UmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0JGpzY29tcCQyLnJlc3VtYWJsZVN0YXRlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBwaW5nZWRUYXNrcyA9IHJlcXVlc3QkanNjb21wJDIucGluZ2VkVGFza3MsXG4gICAgICAgICAgICBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwaW5nZWRUYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSByZXF1ZXN0JGpzY29tcCQyLFxuICAgICAgICAgICAgICB0YXNrID0gcGluZ2VkVGFza3NbaV0sXG4gICAgICAgICAgICAgIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IHNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZUYXNrSW5ERVYgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSB0YXNrO1xuICAgICAgICAgICAgICBpZiAoMCAhPT0gcmVxdWVzdC5yZXBsYXkucGVuZGluZ1Rhc2tzKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChyZXF1ZXN0LmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHByZXZUYXNrSW5ERVYgPSBjdXJyZW50VGFza0luREVWO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgcmVxdWVzdC5yZXBsYXkuc2xvdHNcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bWVOb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGxheS5zbG90cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2hpbGRJbmRleFxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiByZXRyeU5vZGUocmVxdWVzdCRqc2NvbXAkMCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIDEgPT09IHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAwIDwgcmVxdWVzdC5yZXBsYXkubm9kZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LmFib3J0U2V0LmRlbGV0ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkVGFzayhyZXF1ZXN0JGpzY29tcCQwLCByZXF1ZXN0LmJsb2NrZWRCb3VuZGFyeSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgdmFyIHggPVxuICAgICAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICA/IGdldFN1c3BlbmRlZFRoZW5hYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICA6IHRocm93blZhbHVlO1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSB4ICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHgudGhlblxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaW5nID0gcmVxdWVzdC5waW5nO1xuICAgICAgICAgICAgICAgICAgICB4LnRoZW4ocGluZywgcGluZyk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QudGhlbmFibGVTdGF0ZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmFib3J0U2V0LmRlbGV0ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9ySW5mbyA9IGdldFRocm93bkluZm8ocmVxdWVzdC5jb21wb25lbnRTdGFjayksXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMSA9IHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkgPSByZXF1ZXN0LmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvciRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAxMiA9PT0gcmVxdWVzdCRqc2NvbXAkMC5zdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXF1ZXN0JGpzY29tcCQwLmZhdGFsRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiB4LFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCA9IGVycm9ySW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICByZXBsYXlOb2RlcyA9IHJlcXVlc3QucmVwbGF5Lm5vZGVzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VtZVNsb3RzID0gcmVxdWVzdC5yZXBsYXkuc2xvdHM7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgICAgcmVwbGF5Tm9kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdW1lU2xvdHMsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAucGVuZGluZ1Jvb3RUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0JGpzY29tcCQwLnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVNoZWxsKHJlcXVlc3QkanNjb21wJDApO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwLmFsbFBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0JGpzY29tcCQwLmFsbFBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlQWxsKHJlcXVlc3QkanNjb21wJDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFza0luREVWID0gcHJldlRhc2tJbkRFVjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICgocmVxdWVzdCRqc2NvbXAkMCA9IHByZXZUYXNrSW5ERVYgPSB2b2lkIDApLFxuICAgICAgICAgICAgICAoZXJyb3JEaWdlc3QgPSB0YXNrKSxcbiAgICAgICAgICAgICAgKHJlcXVlc3QkanNjb21wJDEgPSBzZWdtZW50KSxcbiAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5zdGF0dXMgPT09IFBFTkRJTkcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5zdGF0dXMgPSA2O1xuICAgICAgICAgICAgICBzd2l0Y2hDb250ZXh0KGVycm9yRGlnZXN0LmNvbnRleHQpO1xuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICAgICAgICAgICAgY3VycmVudFRhc2tJbkRFViA9IGVycm9yRGlnZXN0O1xuICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5MZW5ndGggPSByZXF1ZXN0JGpzY29tcCQxLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjaHVua0xlbmd0aCA9IHJlcXVlc3QkanNjb21wJDEuY2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXRyeU5vZGUocmVxdWVzdCwgZXJyb3JEaWdlc3QpLFxuICAgICAgICAgICAgICAgICAgcHVzaFNlZ21lbnRGaW5hbGUoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuY2h1bmtzLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLmxhc3RQdXNoZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLnRleHRFbWJlZGRlZFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmFib3J0U2V0LmRlbGV0ZShlcnJvckRpZ2VzdCksXG4gICAgICAgICAgICAgICAgICAocmVxdWVzdCRqc2NvbXAkMS5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRUYXNrKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdC5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDFcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzZXRIb29rc1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5jaGlsZHJlbi5sZW5ndGggPSBjaGlsZHJlbkxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLmNodW5rcy5sZW5ndGggPSBjaHVua0xlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgeCRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgICAgIDogMTIgPT09IHJlcXVlc3Quc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgPyByZXF1ZXN0LmZhdGFsRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICA6IHRocm93blZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4JGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSB4JGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4JGpzY29tcCQwLnRoZW5cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuc3RhdHVzID0gUEVORElORztcbiAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LnRoZW5hYmxlU3RhdGUgPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgcGluZyRqc2NvbXAkMCA9IGVycm9yRGlnZXN0LnBpbmc7XG4gICAgICAgICAgICAgICAgICB4JGpzY29tcCQwLnRoZW4ocGluZyRqc2NvbXAkMCwgcGluZyRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvckluZm8kanNjb21wJDEgPSBnZXRUaHJvd25JbmZvKFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdC5jb21wb25lbnRTdGFja1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmFib3J0U2V0LmRlbGV0ZShlcnJvckRpZ2VzdCk7XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLnN0YXR1cyA9IDQ7XG4gICAgICAgICAgICAgICAgICB2YXIgYm91bmRhcnkkanNjb21wJDAgPSBlcnJvckRpZ2VzdC5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnVGFzayA9IGVycm9yRGlnZXN0LmRlYnVnVGFzaztcbiAgICAgICAgICAgICAgICAgIHByZXZUYXNrSW5ERVYgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICB4JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IGJvdW5kYXJ5JGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgID8gZmF0YWxFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB4JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdUYXNrXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IChib3VuZGFyeSRqc2NvbXAkMC5wZW5kaW5nVGFza3MtLSxcbiAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSRqc2NvbXAkMC5zdGF0dXMgIT09IENMSUVOVF9SRU5ERVJFRCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKChib3VuZGFyeSRqc2NvbXAkMC5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZUYXNrSW5ERVYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHgkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnRyYWNrQm91bmRhcnkocmVxdWVzdCwgYm91bmRhcnkkanNjb21wJDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5JGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGJvdW5kYXJ5JGpzY29tcCQwLmNvbnRlbnRQcmVhbWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCkpKTtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyAmJiBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRhc2tJbkRFViA9IHJlcXVlc3QkanNjb21wJDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGluZ2VkVGFza3Muc3BsaWNlKDAsIGkpO1xuICAgICAgICAgIG51bGwgIT09IHJlcXVlc3QkanNjb21wJDIuZGVzdGluYXRpb24gJiZcbiAgICAgICAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKFxuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQyLFxuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQyLmRlc3RpbmF0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIChwaW5nZWRUYXNrcyA9IHt9KSxcbiAgICAgICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCRqc2NvbXAkMiwgZXJyb3IsIHBpbmdlZFRhc2tzLCBudWxsKSxcbiAgICAgICAgICAgIGZhdGFsRXJyb3IocmVxdWVzdCRqc2NvbXAkMiwgZXJyb3IsIHBpbmdlZFRhc2tzLCBudWxsKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAoY3VycmVudFJlc3VtYWJsZVN0YXRlID0gcHJldlJlc3VtYWJsZVN0YXRlKSxcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXIpLFxuICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBwcmV2QXN5bmNEaXNwYXRjaGVyKSxcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCksXG4gICAgICAgICAgICBwcmV2RGlzcGF0Y2hlciA9PT0gSG9va3NEaXNwYXRjaGVyICYmIHN3aXRjaENvbnRleHQocHJldkNvbnRleHQpLFxuICAgICAgICAgICAgKGN1cnJlbnRSZXF1ZXN0ID0gcHJldlJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVQcmVhbWJsZUZyb21TdWJ0cmVlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHNlZ21lbnQsXG4gICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgKSB7XG4gICAgICBzZWdtZW50LnByZWFtYmxlQ2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHMucHVzaChzZWdtZW50LnByZWFtYmxlQ2hpbGRyZW4pO1xuICAgICAgZm9yICh2YXIgcGVuZGluZ1ByZWFtYmxlcyA9ICExLCBpID0gMDsgaSA8IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgIHBlbmRpbmdQcmVhbWJsZXMgPVxuICAgICAgICAgIHByZXBhcmVQcmVhbWJsZUZyb21TZWdtZW50KFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHNlZ21lbnQuY2hpbGRyZW5baV0sXG4gICAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICAgKSB8fCBwZW5kaW5nUHJlYW1ibGVzO1xuICAgICAgcmV0dXJuIHBlbmRpbmdQcmVhbWJsZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVQcmVhbWJsZUZyb21TZWdtZW50KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHNlZ21lbnQsXG4gICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgKSB7XG4gICAgICB2YXIgYm91bmRhcnkgPSBzZWdtZW50LmJvdW5kYXJ5O1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KVxuICAgICAgICByZXR1cm4gcHJlcGFyZVByZWFtYmxlRnJvbVN1YnRyZWUoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHNcbiAgICAgICAgKTtcbiAgICAgIHZhciBwcmVhbWJsZSA9IGJvdW5kYXJ5LmNvbnRlbnRQcmVhbWJsZSxcbiAgICAgICAgZmFsbGJhY2tQcmVhbWJsZSA9IGJvdW5kYXJ5LmZhbGxiYWNrUHJlYW1ibGU7XG4gICAgICBpZiAobnVsbCA9PT0gcHJlYW1ibGUgfHwgbnVsbCA9PT0gZmFsbGJhY2tQcmVhbWJsZSkgcmV0dXJuICExO1xuICAgICAgc3dpdGNoIChib3VuZGFyeS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBDT01QTEVURUQ6XG4gICAgICAgICAgaG9pc3RQcmVhbWJsZVN0YXRlKHJlcXVlc3QucmVuZGVyU3RhdGUsIHByZWFtYmxlKTtcbiAgICAgICAgICBzZWdtZW50ID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHNbMF07XG4gICAgICAgICAgaWYgKCFzZWdtZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQSBwcmV2aW91c2x5IHVudmlzaXRlZCBib3VuZGFyeSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgcm9vdCBzZWdtZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBwcmVwYXJlUHJlYW1ibGVGcm9tU3VidHJlZShcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgICAgY29sbGVjdGVkUHJlYW1ibGVTZWdtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgUE9TVFBPTkVEOlxuICAgICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMpIHJldHVybiAhMDtcbiAgICAgICAgY2FzZSBDTElFTlRfUkVOREVSRUQ6XG4gICAgICAgICAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBDT01QTEVURUQpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBob2lzdFByZWFtYmxlU3RhdGUocmVxdWVzdC5yZW5kZXJTdGF0ZSwgZmFsbGJhY2tQcmVhbWJsZSksXG4gICAgICAgICAgICAgIHByZXBhcmVQcmVhbWJsZUZyb21TdWJ0cmVlKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCkge1xuICAgICAgaWYgKFxuICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ICYmXG4gICAgICAgIG51bGwgPT09IHJlcXVlc3QuY29tcGxldGVkUHJlYW1ibGVTZWdtZW50c1xuICAgICAgKSB7XG4gICAgICAgIHZhciBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzID0gW10sXG4gICAgICAgICAgaGFzUGVuZGluZ1ByZWFtYmxlcyA9IHByZXBhcmVQcmVhbWJsZUZyb21TZWdtZW50KFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQsXG4gICAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICAgKSxcbiAgICAgICAgICBwcmVhbWJsZSA9IHJlcXVlc3QucmVuZGVyU3RhdGUucHJlYW1ibGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhMSA9PT0gaGFzUGVuZGluZ1ByZWFtYmxlcyB8fFxuICAgICAgICAgIChwcmVhbWJsZS5oZWFkQ2h1bmtzICYmIHByZWFtYmxlLmJvZHlDaHVua3MpXG4gICAgICAgIClcbiAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMgPSBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKSB7XG4gICAgICBzZWdtZW50LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgIHN3aXRjaCAoc2VnbWVudC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBQRU5ESU5HOlxuICAgICAgICAgIHNlZ21lbnQuaWQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKztcbiAgICAgICAgY2FzZSBQT1NUUE9ORUQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChob2lzdGFibGVTdGF0ZSA9IHNlZ21lbnQuaWQpLFxuICAgICAgICAgICAgKHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSAhMSksXG4gICAgICAgICAgICAoc2VnbWVudC50ZXh0RW1iZWRkZWQgPSAhMSksXG4gICAgICAgICAgICAocmVxdWVzdCA9IHJlcXVlc3QucmVuZGVyU3RhdGUpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChwbGFjZWhvbGRlcjEpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZXF1ZXN0LnBsYWNlaG9sZGVyUHJlZml4KSxcbiAgICAgICAgICAgIChyZXF1ZXN0ID0gaG9pc3RhYmxlU3RhdGUudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVxdWVzdCksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHBsYWNlaG9sZGVyMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIENPTVBMRVRFRDpcbiAgICAgICAgICBzZWdtZW50LnN0YXR1cyA9IEZMVVNIRUQ7XG4gICAgICAgICAgdmFyIHIgPSAhMCxcbiAgICAgICAgICAgIGNodW5rcyA9IHNlZ21lbnQuY2h1bmtzLFxuICAgICAgICAgICAgY2h1bmtJZHggPSAwO1xuICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50LmNoaWxkcmVuO1xuICAgICAgICAgIGZvciAodmFyIGNoaWxkSWR4ID0gMDsgY2hpbGRJZHggPCBzZWdtZW50Lmxlbmd0aDsgY2hpbGRJZHgrKykge1xuICAgICAgICAgICAgZm9yIChyID0gc2VnbWVudFtjaGlsZElkeF07IGNodW5rSWR4IDwgci5pbmRleDsgY2h1bmtJZHgrKylcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChjaHVua3NbY2h1bmtJZHhdKTtcbiAgICAgICAgICAgIHIgPSBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHIsIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICg7IGNodW5rSWR4IDwgY2h1bmtzLmxlbmd0aCAtIDE7IGNodW5rSWR4KyspXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICAgIGNodW5rSWR4IDwgY2h1bmtzLmxlbmd0aCAmJiAociA9IGRlc3RpbmF0aW9uLnB1c2goY2h1bmtzW2NodW5rSWR4XSkpO1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJBYm9ydGVkLCBlcnJvcmVkIG9yIGFscmVhZHkgZmx1c2hlZCBib3VuZGFyaWVzIHNob3VsZCBub3QgYmUgZmx1c2hlZCBhZ2Fpbi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpIHtcbiAgICAgIHZhciBib3VuZGFyeSA9IHNlZ21lbnQuYm91bmRhcnk7XG4gICAgICBpZiAobnVsbCA9PT0gYm91bmRhcnkpXG4gICAgICAgIHJldHVybiBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgIGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgIGlmIChib3VuZGFyeS5zdGF0dXMgPT09IENMSUVOVF9SRU5ERVJFRCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QucmVuZGVyU3RhdGUuZ2VuZXJhdGVTdGF0aWNNYXJrdXApIHtcbiAgICAgICAgICB2YXIgZXJyb3JEaWdlc3QgPSBib3VuZGFyeS5lcnJvckRpZ2VzdCxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGJvdW5kYXJ5LmVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgIGVycm9yU3RhY2sgPSBib3VuZGFyeS5lcnJvclN0YWNrLFxuICAgICAgICAgICAgZXJyb3JDb21wb25lbnRTdGFjayA9IGJvdW5kYXJ5LmVycm9yQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSk7XG4gICAgICAgICAgZGVzdGluYXRpb24ucHVzaChjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEpO1xuICAgICAgICAgIGVycm9yRGlnZXN0ICYmXG4gICAgICAgICAgICAoZGVzdGluYXRpb24ucHVzaChjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBKSxcbiAgICAgICAgICAgIChlcnJvckRpZ2VzdCA9IGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yRGlnZXN0KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVycm9yRGlnZXN0KSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goXG4gICAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlICYmXG4gICAgICAgICAgICAoZGVzdGluYXRpb24ucHVzaChjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFCKSxcbiAgICAgICAgICAgIChlcnJvck1lc3NhZ2UgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvck1lc3NhZ2UpKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goZXJyb3JNZXNzYWdlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goXG4gICAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgZXJyb3JTdGFjayAmJlxuICAgICAgICAgICAgKGRlc3RpbmF0aW9uLnB1c2goY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyksXG4gICAgICAgICAgICAoZXJyb3JTdGFjayA9IGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yU3RhY2spKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goZXJyb3JTdGFjayksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKFxuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWxcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2sgJiZcbiAgICAgICAgICAgIChkZXN0aW5hdGlvbi5wdXNoKGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUQpLFxuICAgICAgICAgICAgKGVycm9yQ29tcG9uZW50U3RhY2sgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvckNvbXBvbmVudFN0YWNrKSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVycm9yQ29tcG9uZW50U3RhY2spLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMik7XG4gICAgICAgIH1cbiAgICAgICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUuZ2VuZXJhdGVTdGF0aWNNYXJrdXBcbiAgICAgICAgICA/IChkZXN0aW5hdGlvbiA9ICEwKVxuICAgICAgICAgIDogKChyZXF1ZXN0ID0gYm91bmRhcnkuZmFsbGJhY2tQcmVhbWJsZSkgJiZcbiAgICAgICAgICAgICAgd3JpdGVQcmVhbWJsZUNvbnRyaWJ1dGlvbihkZXN0aW5hdGlvbiwgcmVxdWVzdCksXG4gICAgICAgICAgICAoZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbi5wdXNoKGVuZFN1c3BlbnNlQm91bmRhcnkpKSk7XG4gICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChib3VuZGFyeS5zdGF0dXMgIT09IENPTVBMRVRFRClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBib3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcgJiZcbiAgICAgICAgICAgIChib3VuZGFyeS5yb290U2VnbWVudElEID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKyspLFxuICAgICAgICAgIDAgPCBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggJiZcbiAgICAgICAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSksXG4gICAgICAgICAgd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgYm91bmRhcnkucm9vdFNlZ21lbnRJRFxuICAgICAgICAgICksXG4gICAgICAgICAgaG9pc3RhYmxlU3RhdGUgJiZcbiAgICAgICAgICAgICgoYm91bmRhcnkgPSBib3VuZGFyeS5mYWxsYmFja1N0YXRlKSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnN0eWxlcy5mb3JFYWNoKGhvaXN0U3R5bGVRdWV1ZURlcGVuZGVuY3ksIGhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnN0eWxlc2hlZXRzLmZvckVhY2goXG4gICAgICAgICAgICAgIGhvaXN0U3R5bGVzaGVldERlcGVuZGVuY3ksXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVuZFN1c3BlbnNlQm91bmRhcnkpXG4gICAgICAgICk7XG4gICAgICBpZiAoYm91bmRhcnkuYnl0ZVNpemUgPiByZXF1ZXN0LnByb2dyZXNzaXZlQ2h1bmtTaXplKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChib3VuZGFyeS5yb290U2VnbWVudElEID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKyspLFxuICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSxcbiAgICAgICAgICB3cml0ZVN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBib3VuZGFyeS5yb290U2VnbWVudElEXG4gICAgICAgICAgKSxcbiAgICAgICAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVuZFN1c3BlbnNlQm91bmRhcnkpXG4gICAgICAgICk7XG4gICAgICBob2lzdGFibGVTdGF0ZSAmJlxuICAgICAgICAoKHNlZ21lbnQgPSBib3VuZGFyeS5jb250ZW50U3RhdGUpLFxuICAgICAgICBzZWdtZW50LnN0eWxlcy5mb3JFYWNoKGhvaXN0U3R5bGVRdWV1ZURlcGVuZGVuY3ksIGhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgc2VnbWVudC5zdHlsZXNoZWV0cy5mb3JFYWNoKGhvaXN0U3R5bGVzaGVldERlcGVuZGVuY3ksIGhvaXN0YWJsZVN0YXRlKSk7XG4gICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwIHx8XG4gICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KTtcbiAgICAgIHNlZ21lbnQgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcbiAgICAgIGlmICgxICE9PSBzZWdtZW50Lmxlbmd0aClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJBIHByZXZpb3VzbHkgdW52aXNpdGVkIGJvdW5kYXJ5IG11c3QgaGF2ZSBleGFjdGx5IG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudFswXSwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cFxuICAgICAgICA/IChkZXN0aW5hdGlvbiA9ICEwKVxuICAgICAgICA6ICgocmVxdWVzdCA9IGJvdW5kYXJ5LmNvbnRlbnRQcmVhbWJsZSkgJiZcbiAgICAgICAgICAgIHdyaXRlUHJlYW1ibGVDb250cmlidXRpb24oZGVzdGluYXRpb24sIHJlcXVlc3QpLFxuICAgICAgICAgIChkZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uLnB1c2goZW5kU3VzcGVuc2VCb3VuZGFyeSkpKTtcbiAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTZWdtZW50Q29udGFpbmVyKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgc2VnbWVudCxcbiAgICAgIGhvaXN0YWJsZVN0YXRlXG4gICAgKSB7XG4gICAgICB3cml0ZVN0YXJ0U2VnbWVudChcbiAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgIHNlZ21lbnQucGFyZW50Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgc2VnbWVudC5pZFxuICAgICAgKTtcbiAgICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgcmV0dXJuIHdyaXRlRW5kU2VnbWVudChkZXN0aW5hdGlvbiwgc2VnbWVudC5wYXJlbnRGb3JtYXRDb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnkpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLCBpID0gMDtcbiAgICAgICAgaSA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaSsrXG4gICAgICApXG4gICAgICAgIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgIGNvbXBsZXRlZFNlZ21lbnRzW2ldXG4gICAgICAgICk7XG4gICAgICBjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggPSAwO1xuICAgICAgd3JpdGVIb2lzdGFibGVzRm9yQm91bmRhcnkoXG4gICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICBib3VuZGFyeS5jb250ZW50U3RhdGUsXG4gICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGVcbiAgICAgICk7XG4gICAgICBjb21wbGV0ZWRTZWdtZW50cyA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgIGkgPSBib3VuZGFyeS5yb290U2VnbWVudElEO1xuICAgICAgYm91bmRhcnkgPSBib3VuZGFyeS5jb250ZW50U3RhdGU7XG4gICAgICB2YXIgcmVxdWlyZXNTdHlsZUluc2VydGlvbiA9IHJlcXVlc3Quc3R5bGVzVG9Ib2lzdDtcbiAgICAgIHJlcXVlc3Quc3R5bGVzVG9Ib2lzdCA9ICExO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChyZXF1ZXN0LnN0YXJ0SW5saW5lU2NyaXB0KTtcbiAgICAgIHJlcXVpcmVzU3R5bGVJbnNlcnRpb25cbiAgICAgICAgPyAoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zICYgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbikgPT09XG4gICAgICAgICAgTm90aGluZ1NlbnRcbiAgICAgICAgICA/ICgoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zID1cbiAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zIHxcbiAgICAgICAgICAgICAgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24gfFxuICAgICAgICAgICAgICBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbEJvdGgpKVxuICAgICAgICAgIDogKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyAmIFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uKSA9PT1cbiAgICAgICAgICAgICAgTm90aGluZ1NlbnRcbiAgICAgICAgICAgID8gKChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgfD0gU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24pLFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsKSlcbiAgICAgICAgICAgIDogZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsKVxuICAgICAgICA6IChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSA9PT1cbiAgICAgICAgICAgIE5vdGhpbmdTZW50XG4gICAgICAgICAgPyAoKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyB8PSBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsKSlcbiAgICAgICAgICA6IGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVCb3VuZGFyeVNjcmlwdDFQYXJ0aWFsKTtcbiAgICAgIGNvbXBsZXRlZFNlZ21lbnRzID0gaS50b1N0cmluZygxNik7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlcXVlc3QuYm91bmRhcnlQcmVmaXgpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZWRTZWdtZW50cyk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlQm91bmRhcnlTY3JpcHQyKTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVxdWVzdC5zZWdtZW50UHJlZml4KTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVkU2VnbWVudHMpO1xuICAgICAgcmVxdWlyZXNTdHlsZUluc2VydGlvblxuICAgICAgICA/IChkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYSksXG4gICAgICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5KUyhkZXN0aW5hdGlvbiwgYm91bmRhcnkpKVxuICAgICAgICA6IGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVCb3VuZGFyeVNjcmlwdDNiKTtcbiAgICAgIGJvdW5kYXJ5ID0gZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kKTtcbiAgICAgIHJldHVybiB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVxdWVzdCkgJiYgYm91bmRhcnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgc2VnbWVudFxuICAgICkge1xuICAgICAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBGTFVTSEVEKSByZXR1cm4gITA7XG4gICAgICB2YXIgaG9pc3RhYmxlU3RhdGUgPSBib3VuZGFyeS5jb250ZW50U3RhdGUsXG4gICAgICAgIHNlZ21lbnRJRCA9IHNlZ21lbnQuaWQ7XG4gICAgICBpZiAoLTEgPT09IHNlZ21lbnRJRCkge1xuICAgICAgICBpZiAoLTEgPT09IChzZWdtZW50LmlkID0gYm91bmRhcnkucm9vdFNlZ21lbnRJRCkpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkEgcm9vdCBzZWdtZW50IElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJ5IG5vdy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBmbHVzaFNlZ21lbnRDb250YWluZXIoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgIGhvaXN0YWJsZVN0YXRlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VnbWVudElEID09PSBib3VuZGFyeS5yb290U2VnbWVudElEKVxuICAgICAgICByZXR1cm4gZmx1c2hTZWdtZW50Q29udGFpbmVyKFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICBob2lzdGFibGVTdGF0ZVxuICAgICAgICApO1xuICAgICAgZmx1c2hTZWdtZW50Q29udGFpbmVyKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICBib3VuZGFyeSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVxdWVzdC5zdGFydElubGluZVNjcmlwdCk7XG4gICAgICAoYm91bmRhcnkuaW5zdHJ1Y3Rpb25zICYgU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uKSA9PT0gTm90aGluZ1NlbnRcbiAgICAgICAgPyAoKGJvdW5kYXJ5Lmluc3RydWN0aW9ucyB8PSBTZW50Q29tcGxldGVTZWdtZW50RnVuY3Rpb24pLFxuICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVTZWdtZW50U2NyaXB0MUZ1bGwpKVxuICAgICAgICA6IGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChyZXF1ZXN0LnNlZ21lbnRQcmVmaXgpO1xuICAgICAgc2VnbWVudElEID0gc2VnbWVudElELnRvU3RyaW5nKDE2KTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goc2VnbWVudElEKTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVTZWdtZW50U2NyaXB0Mik7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlcXVlc3QucGxhY2Vob2xkZXJQcmVmaXgpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChzZWdtZW50SUQpO1xuICAgICAgZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlU2VnbWVudFNjcmlwdEVuZCk7XG4gICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoISgwIDwgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKSkge1xuICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50O1xuICAgICAgICAgIGlmIChudWxsICE9PSBjb21wbGV0ZWRSb290U2VnbWVudCkge1xuICAgICAgICAgICAgaWYgKGNvbXBsZXRlZFJvb3RTZWdtZW50LnN0YXR1cyA9PT0gUE9TVFBPTkVEKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cyA9IHJlcXVlc3QuY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cztcbiAgICAgICAgICAgIGlmIChudWxsID09PSBjb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICBwcmVhbWJsZSA9IHJlbmRlclN0YXRlLnByZWFtYmxlLFxuICAgICAgICAgICAgICBodG1sQ2h1bmtzID0gcHJlYW1ibGUuaHRtbENodW5rcyxcbiAgICAgICAgICAgICAgaGVhZENodW5rcyA9IHByZWFtYmxlLmhlYWRDaHVua3MsXG4gICAgICAgICAgICAgIGkkanNjb21wJDA7XG4gICAgICAgICAgICBpZiAoaHRtbENodW5rcykge1xuICAgICAgICAgICAgICBmb3IgKGkkanNjb21wJDAgPSAwOyBpJGpzY29tcCQwIDwgaHRtbENodW5rcy5sZW5ndGg7IGkkanNjb21wJDArKylcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGh0bWxDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgICBpZiAoaGVhZENodW5rcylcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgaGVhZENodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGhlYWRDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmsgPSBzdGFydENodW5rRm9yVGFnKFwiaGVhZFwiKTtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRDaHVua3MpXG4gICAgICAgICAgICAgIGZvciAoaSRqc2NvbXAkMCA9IDA7IGkkanNjb21wJDAgPCBoZWFkQ2h1bmtzLmxlbmd0aDsgaSRqc2NvbXAkMCsrKVxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goaGVhZENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICB2YXIgY2hhcnNldENodW5rcyA9IHJlbmRlclN0YXRlLmNoYXJzZXRDaHVua3M7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IGNoYXJzZXRDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChjaGFyc2V0Q2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgIGNoYXJzZXRDaHVua3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydENodW5rcyA9IHJlbmRlclN0YXRlLnZpZXdwb3J0Q2h1bmtzO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPCB2aWV3cG9ydENodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGkkanNjb21wJDArK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHZpZXdwb3J0Q2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgIHZpZXdwb3J0Q2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5mb3JFYWNoKGZsdXNoU3R5bGVzSW5QcmVhbWJsZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgdmFyIGltcG9ydE1hcENodW5rcyA9IHJlbmRlclN0YXRlLmltcG9ydE1hcENodW5rcztcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgaW1wb3J0TWFwQ2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCsrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goaW1wb3J0TWFwQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgIGltcG9ydE1hcENodW5rcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwU2NyaXB0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmNsZWFyKCk7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHZhciBob2lzdGFibGVDaHVua3MgPSByZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3M7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IGhvaXN0YWJsZUNodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGkkanNjb21wJDArK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGhvaXN0YWJsZUNodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSA9IGhvaXN0YWJsZUNodW5rcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSA8IGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gY29tcGxldGVkUHJlYW1ibGVTZWdtZW50c1tyZW5kZXJTdGF0ZV07XG4gICAgICAgICAgICAgIGZvciAocHJlYW1ibGUgPSAwOyBwcmVhbWJsZSA8IHNlZ21lbnRzLmxlbmd0aDsgcHJlYW1ibGUrKylcbiAgICAgICAgICAgICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnRzW3ByZWFtYmxlXSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJlYW1ibGUkanNjb21wJDAgPSByZXF1ZXN0LnJlbmRlclN0YXRlLnByZWFtYmxlLFxuICAgICAgICAgICAgICBoZWFkQ2h1bmtzJGpzY29tcCQwID0gcHJlYW1ibGUkanNjb21wJDAuaGVhZENodW5rcztcbiAgICAgICAgICAgIGlmIChwcmVhbWJsZSRqc2NvbXAkMC5odG1sQ2h1bmtzIHx8IGhlYWRDaHVua3MkanNjb21wJDApIHtcbiAgICAgICAgICAgICAgdmFyIGNodW5rJGpzY29tcCQwID0gZW5kQ2h1bmtGb3JUYWcoXCJoZWFkXCIpO1xuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNodW5rJGpzY29tcCQwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBib2R5Q2h1bmtzID0gcHJlYW1ibGUkanNjb21wJDAuYm9keUNodW5rcztcbiAgICAgICAgICAgIGlmIChib2R5Q2h1bmtzKVxuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMgPSAwO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMgPCBib2R5Q2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goYm9keUNodW5rc1tjb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzXSk7XG4gICAgICAgICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGNvbXBsZXRlZFJvb3RTZWdtZW50LCBudWxsKTtcbiAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgPSBudWxsO1xuICAgICAgICAgICAgd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlcXVlc3QucmVuZGVyU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUkanNjb21wJDAgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gMDtcbiAgICAgICAgICB2YXIgdmlld3BvcnRDaHVua3MkanNjb21wJDAgPSByZW5kZXJTdGF0ZSRqc2NvbXAkMC52aWV3cG9ydENodW5rcztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPSAwO1xuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPCB2aWV3cG9ydENodW5rcyRqc2NvbXAkMC5sZW5ndGg7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCsrXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaCh2aWV3cG9ydENodW5rcyRqc2NvbXAkMFtjb21wbGV0ZWRSb290U2VnbWVudF0pO1xuICAgICAgICAgIHZpZXdwb3J0Q2h1bmtzJGpzY29tcCQwLmxlbmd0aCA9IDA7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHJlY29ubmVjdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHJlY29ubmVjdHMuY2xlYXIoKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5mb250UHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuZm9udFByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuaGlnaEltYWdlUHJlbG9hZHMuZm9yRWFjaChcbiAgICAgICAgICAgIGZsdXNoUmVzb3VyY2UsXG4gICAgICAgICAgICBkZXN0aW5hdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5zdHlsZXMuZm9yRWFjaChwcmVsb2FkTGF0ZVN0eWxlcywgZGVzdGluYXRpb24pO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuc2NyaXB0cy5jbGVhcigpO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLmJ1bGtQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5idWxrUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICB2YXIgaG9pc3RhYmxlQ2h1bmtzJGpzY29tcCQwID0gcmVuZGVyU3RhdGUkanNjb21wJDAuaG9pc3RhYmxlQ2h1bmtzO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCA9IDA7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCA8IGhvaXN0YWJsZUNodW5rcyRqc2NvbXAkMC5sZW5ndGg7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCsrXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChob2lzdGFibGVDaHVua3MkanNjb21wJDBbY29tcGxldGVkUm9vdFNlZ21lbnRdKTtcbiAgICAgICAgICBob2lzdGFibGVDaHVua3MkanNjb21wJDAubGVuZ3RoID0gMDtcbiAgICAgICAgICB2YXIgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXM7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvdW5kYXJ5ID0gY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzW2ldO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxID0gcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgaWQgPSBib3VuZGFyeS5yb290U2VnbWVudElELFxuICAgICAgICAgICAgICBlcnJvckRpZ2VzdCA9IGJvdW5kYXJ5LmVycm9yRGlnZXN0LFxuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBib3VuZGFyeS5lcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgIGVycm9yU3RhY2sgPSBib3VuZGFyeS5lcnJvclN0YWNrLFxuICAgICAgICAgICAgICBlcnJvckNvbXBvbmVudFN0YWNrID0gYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnB1c2gocmVuZGVyU3RhdGUkanNjb21wJDEuc3RhcnRJbmxpbmVTY3JpcHQpO1xuICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbikgPT09XG4gICAgICAgICAgICBOb3RoaW5nU2VudFxuICAgICAgICAgICAgICA/ICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbiksXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCkpXG4gICAgICAgICAgICAgIDogcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCk7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKHJlbmRlclN0YXRlJGpzY29tcCQxLmJvdW5kYXJ5UHJlZml4KTtcbiAgICAgICAgICAgIHZhciBjaHVuayRqc2NvbXAkMSA9IGlkLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnB1c2goY2h1bmskanNjb21wJDEpO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjbGllbnRSZW5kZXJTY3JpcHQxQSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGVycm9yRGlnZXN0IHx8XG4gICAgICAgICAgICAgIGVycm9yTWVzc2FnZSB8fFxuICAgICAgICAgICAgICBlcnJvclN0YWNrIHx8XG4gICAgICAgICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2tcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgICAgdmFyIGNodW5rJGpzY29tcCQyID0gZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKFxuICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0IHx8IFwiXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjaHVuayRqc2NvbXAkMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlIHx8IGVycm9yU3RhY2sgfHwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgICAgdmFyIGNodW5rJGpzY29tcCQzID0gZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKFxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSB8fCBcIlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnB1c2goY2h1bmskanNjb21wJDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yU3RhY2sgfHwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgICAgdmFyIGNodW5rJGpzY29tcCQ0ID0gZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKFxuICAgICAgICAgICAgICAgIGVycm9yU3RhY2sgfHwgXCJcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKGNodW5rJGpzY29tcCQ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnB1c2goY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwpO1xuICAgICAgICAgICAgICB2YXIgY2h1bmskanNjb21wJDUgPVxuICAgICAgICAgICAgICAgIGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvckNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjaHVuayRqc2NvbXAkNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyU2NyaXB0RW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgIHZhciBjb21wbGV0ZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZEJvdW5kYXJpZXNbaV1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGNvbXBsZXRlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY29tcGxldGVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgdmFyIHBhcnRpYWxCb3VuZGFyaWVzID0gcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFydGlhbEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgYm91bmRhcnkgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5JGpzY29tcCQwID0gcGFydGlhbEJvdW5kYXJpZXNbaV0sXG4gICAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeSRqc2NvbXAkMC5jb21wbGV0ZWRTZWdtZW50cztcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAwO1xuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgIWZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZFNlZ21lbnRzW0pTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdF1cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCsrO1xuICAgICAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gITE7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCk7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IHdyaXRlSG9pc3RhYmxlc0ZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5JGpzY29tcCQwLmNvbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucmVuZGVyU3RhdGVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIHBhcnRpYWxCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0aWFsQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgdmFyIGxhcmdlQm91bmRhcmllcyA9IHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFyZ2VCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgbGFyZ2VCb3VuZGFyaWVzW2ldKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGxhcmdlQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBsYXJnZUJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAwID09PSByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgIDAgPT09IHJlcXVlc3QucGluZ2VkVGFza3MubGVuZ3RoICYmXG4gICAgICAgICAgMCA9PT0gcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMubGVuZ3RoICYmXG4gICAgICAgICAgMCA9PT0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aCAmJlxuICAgICAgICAgICgocmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9ICExKSxcbiAgICAgICAgICAoaSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUpLFxuICAgICAgICAgIGkuaGFzQm9keSAmJlxuICAgICAgICAgICAgKChwYXJ0aWFsQm91bmRhcmllcyA9IGVuZENodW5rRm9yVGFnKFwiYm9keVwiKSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHBhcnRpYWxCb3VuZGFyaWVzKSksXG4gICAgICAgICAgaS5oYXNIdG1sICYmICgoaSA9IGVuZENodW5rRm9yVGFnKFwiaHRtbFwiKSksIGRlc3RpbmF0aW9uLnB1c2goaSkpLFxuICAgICAgICAgIDAgIT09IHJlcXVlc3QuYWJvcnRhYmxlVGFza3Muc2l6ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgc3RpbGwgYWJvcnRhYmxlIHRhc2sgYXQgdGhlIHJvb3Qgd2hlbiB3ZSBjbG9zZWQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEKSxcbiAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKG51bGwpLFxuICAgICAgICAgIChyZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFdvcmsocmVxdWVzdCkge1xuICAgICAgcmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9IG51bGwgIT09IHJlcXVlc3QuZGVzdGluYXRpb247XG4gICAgICBwZXJmb3JtV29yayhyZXF1ZXN0KTtcbiAgICAgIDEwID09PSByZXF1ZXN0LnN0YXR1cyAmJiAocmVxdWVzdC5zdGF0dXMgPSAxMSk7XG4gICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgJiZcbiAgICAgICAgc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgMCA9PT0gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUZsdXNoKHJlcXVlc3QpIHtcbiAgICAgIGlmIChcbiAgICAgICAgITEgPT09IHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgJiZcbiAgICAgICAgMCA9PT0gcmVxdWVzdC5waW5nZWRUYXNrcy5sZW5ndGggJiZcbiAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvblxuICAgICAgKSB7XG4gICAgICAgIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSAhMDtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gcmVxdWVzdC5kZXN0aW5hdGlvbjtcbiAgICAgICAgZGVzdGluYXRpb25cbiAgICAgICAgICA/IGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKVxuICAgICAgICAgIDogKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSAhMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICAgICAgaWYgKDEzID09PSByZXF1ZXN0LnN0YXR1cylcbiAgICAgICAgKHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEKSwgZGVzdGluYXRpb24uZGVzdHJveShyZXF1ZXN0LmZhdGFsRXJyb3IpO1xuICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgIT09IENMT1NFRCAmJiBudWxsID09PSByZXF1ZXN0LmRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgKGRlc3RpbmF0aW9uID0ge30pLFxuICAgICAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZGVzdGluYXRpb24sIG51bGwpLFxuICAgICAgICAgICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvciwgZGVzdGluYXRpb24sIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFib3J0KHJlcXVlc3QsIHJlYXNvbikge1xuICAgICAgaWYgKDExID09PSByZXF1ZXN0LnN0YXR1cyB8fCAxMCA9PT0gcmVxdWVzdC5zdGF0dXMpIHJlcXVlc3Quc3RhdHVzID0gMTI7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgYWJvcnRhYmxlVGFza3MgPSByZXF1ZXN0LmFib3J0YWJsZVRhc2tzO1xuICAgICAgICBpZiAoMCA8IGFib3J0YWJsZVRhc2tzLnNpemUpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPVxuICAgICAgICAgICAgdm9pZCAwID09PSByZWFzb25cbiAgICAgICAgICAgICAgPyBFcnJvcihcIlRoZSByZW5kZXIgd2FzIGFib3J0ZWQgYnkgdGhlIHNlcnZlciB3aXRob3V0IGEgcmVhc29uLlwiKVxuICAgICAgICAgICAgICA6IFwib2JqZWN0XCIgPT09IHR5cGVvZiByZWFzb24gJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJlYXNvbiAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVhc29uLnRoZW5cbiAgICAgICAgICAgICAgICA/IEVycm9yKFwiVGhlIHJlbmRlciB3YXMgYWJvcnRlZCBieSB0aGUgc2VydmVyIHdpdGggYSBwcm9taXNlLlwiKVxuICAgICAgICAgICAgICAgIDogcmVhc29uO1xuICAgICAgICAgIHJlcXVlc3QuZmF0YWxFcnJvciA9IGVycm9yO1xuICAgICAgICAgIGFib3J0YWJsZVRhc2tzLmZvckVhY2goZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydFRhc2sodGFzaywgcmVxdWVzdCwgZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvbiAmJlxuICAgICAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIHJlcXVlc3QuZGVzdGluYXRpb24pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IkNCkge1xuICAgICAgICAocmVhc29uID0ge30pLFxuICAgICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IkNCwgcmVhc29uLCBudWxsKSxcbiAgICAgICAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yJDQsIHJlYXNvbiwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRXJyb3IoKSB7fVxuICAgIGZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nSW1wbChcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGdlbmVyYXRlU3RhdGljTWFya3VwLFxuICAgICAgYWJvcnRSZWFzb25cbiAgICApIHtcbiAgICAgIHZhciBkaWRGYXRhbCA9ICExLFxuICAgICAgICBmYXRhbEVycm9yID0gbnVsbCxcbiAgICAgICAgcmVzdWx0ID0gXCJcIixcbiAgICAgICAgcmVhZHlUb1N0cmVhbSA9ICExO1xuICAgICAgb3B0aW9ucyA9IGNyZWF0ZVJlc3VtYWJsZVN0YXRlKFxuICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IDogdm9pZCAwXG4gICAgICApO1xuICAgICAgY2hpbGRyZW4gPSBjcmVhdGVSZXF1ZXN0KFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgY3JlYXRlUmVuZGVyU3RhdGUob3B0aW9ucywgZ2VuZXJhdGVTdGF0aWNNYXJrdXApLFxuICAgICAgICBjcmVhdGVGb3JtYXRDb250ZXh0KFJPT1RfSFRNTF9NT0RFLCBudWxsLCAwKSxcbiAgICAgICAgSW5maW5pdHksXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlYWR5VG9TdHJlYW0gPSAhMDtcbiAgICAgICAgfSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHZvaWQgMFxuICAgICAgKTtcbiAgICAgIHN0YXJ0V29yayhjaGlsZHJlbik7XG4gICAgICBhYm9ydChjaGlsZHJlbiwgYWJvcnRSZWFzb24pO1xuICAgICAgc3RhcnRGbG93aW5nKGNoaWxkcmVuLCB7XG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgIG51bGwgIT09IGNodW5rICYmIChyZXN1bHQgKz0gY2h1bmspO1xuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgZGlkRmF0YWwgPSAhMDtcbiAgICAgICAgICBmYXRhbEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGRpZEZhdGFsICYmIGZhdGFsRXJyb3IgIT09IGFib3J0UmVhc29uKSB0aHJvdyBmYXRhbEVycm9yO1xuICAgICAgaWYgKCFyZWFkeVRvU3RyZWFtKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkEgY29tcG9uZW50IHN1c3BlbmRlZCB3aGlsZSByZXNwb25kaW5nIHRvIHN5bmNocm9ub3VzIGlucHV0LiBUaGlzIHdpbGwgY2F1c2UgdGhlIFVJIHRvIGJlIHJlcGxhY2VkIHdpdGggYSBsb2FkaW5nIGluZGljYXRvci4gVG8gZml4LCB1cGRhdGVzIHRoYXQgc3VzcGVuZCBzaG91bGQgYmUgd3JhcHBlZCB3aXRoIHN0YXJ0VHJhbnNpdGlvbi5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJlYWN0RE9NID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb21cIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgICBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9TQ09QRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnNjb3BlXCIpLFxuICAgICAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLFxuICAgICAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxlZ2FjeV9oaWRkZW5cIiksXG4gICAgICBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIiksXG4gICAgICBSRUFDVF9WSUVXX1RSQU5TSVRJT05fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC52aWV3X3RyYW5zaXRpb25cIiksXG4gICAgICBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3IsXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBqc3hQcm9wc1BhcmVudHMgPSBuZXcgV2Vha01hcCgpLFxuICAgICAganN4Q2hpbGRyZW5QYXJlbnRzID0gbmV3IFdlYWtNYXAoKSxcbiAgICAgIENMSUVOVF9SRUZFUkVOQ0VfVEFHID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBSZWdFeHAoXG4gICAgICAgIFwiXls6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fSxcbiAgICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9LFxuICAgICAgdW5pdGxlc3NOdW1iZXJzID0gbmV3IFNldChcbiAgICAgICAgXCJhbmltYXRpb25JdGVyYXRpb25Db3VudCBhc3BlY3RSYXRpbyBib3JkZXJJbWFnZU91dHNldCBib3JkZXJJbWFnZVNsaWNlIGJvcmRlckltYWdlV2lkdGggYm94RmxleCBib3hGbGV4R3JvdXAgYm94T3JkaW5hbEdyb3VwIGNvbHVtbkNvdW50IGNvbHVtbnMgZmxleCBmbGV4R3JvdyBmbGV4UG9zaXRpdmUgZmxleFNocmluayBmbGV4TmVnYXRpdmUgZmxleE9yZGVyIGdyaWRBcmVhIGdyaWRSb3cgZ3JpZFJvd0VuZCBncmlkUm93U3BhbiBncmlkUm93U3RhcnQgZ3JpZENvbHVtbiBncmlkQ29sdW1uRW5kIGdyaWRDb2x1bW5TcGFuIGdyaWRDb2x1bW5TdGFydCBmb250V2VpZ2h0IGxpbmVDbGFtcCBsaW5lSGVpZ2h0IG9wYWNpdHkgb3JkZXIgb3JwaGFucyBzY2FsZSB0YWJTaXplIHdpZG93cyB6SW5kZXggem9vbSBmaWxsT3BhY2l0eSBmbG9vZE9wYWNpdHkgc3RvcE9wYWNpdHkgc3Ryb2tlRGFzaGFycmF5IHN0cm9rZURhc2hvZmZzZXQgc3Ryb2tlTWl0ZXJsaW1pdCBzdHJva2VPcGFjaXR5IHN0cm9rZVdpZHRoIE1vekFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IE1vekJveEZsZXggTW96Qm94RmxleEdyb3VwIE1vekxpbmVDbGFtcCBtc0FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IG1zRmxleCBtc1pvb20gbXNGbGV4R3JvdyBtc0ZsZXhOZWdhdGl2ZSBtc0ZsZXhPcmRlciBtc0ZsZXhQb3NpdGl2ZSBtc0ZsZXhTaHJpbmsgbXNHcmlkQ29sdW1uIG1zR3JpZENvbHVtblNwYW4gbXNHcmlkUm93IG1zR3JpZFJvd1NwYW4gV2Via2l0QW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgV2Via2l0Qm94RmxleCBXZWJLaXRCb3hGbGV4R3JvdXAgV2Via2l0Qm94T3JkaW5hbEdyb3VwIFdlYmtpdENvbHVtbkNvdW50IFdlYmtpdENvbHVtbnMgV2Via2l0RmxleCBXZWJraXRGbGV4R3JvdyBXZWJraXRGbGV4UG9zaXRpdmUgV2Via2l0RmxleFNocmluayBXZWJraXRMaW5lQ2xhbXBcIi5zcGxpdChcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApXG4gICAgICApLFxuICAgICAgYWxpYXNlcyA9IG5ldyBNYXAoW1xuICAgICAgICBbXCJhY2NlcHRDaGFyc2V0XCIsIFwiYWNjZXB0LWNoYXJzZXRcIl0sXG4gICAgICAgIFtcImh0bWxGb3JcIiwgXCJmb3JcIl0sXG4gICAgICAgIFtcImh0dHBFcXVpdlwiLCBcImh0dHAtZXF1aXZcIl0sXG4gICAgICAgIFtcImNyb3NzT3JpZ2luXCIsIFwiY3Jvc3NvcmlnaW5cIl0sXG4gICAgICAgIFtcImFjY2VudEhlaWdodFwiLCBcImFjY2VudC1oZWlnaHRcIl0sXG4gICAgICAgIFtcImFsaWdubWVudEJhc2VsaW5lXCIsIFwiYWxpZ25tZW50LWJhc2VsaW5lXCJdLFxuICAgICAgICBbXCJhcmFiaWNGb3JtXCIsIFwiYXJhYmljLWZvcm1cIl0sXG4gICAgICAgIFtcImJhc2VsaW5lU2hpZnRcIiwgXCJiYXNlbGluZS1zaGlmdFwiXSxcbiAgICAgICAgW1wiY2FwSGVpZ2h0XCIsIFwiY2FwLWhlaWdodFwiXSxcbiAgICAgICAgW1wiY2xpcFBhdGhcIiwgXCJjbGlwLXBhdGhcIl0sXG4gICAgICAgIFtcImNsaXBSdWxlXCIsIFwiY2xpcC1ydWxlXCJdLFxuICAgICAgICBbXCJjb2xvckludGVycG9sYXRpb25cIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCJdLFxuICAgICAgICBbXCJjb2xvckludGVycG9sYXRpb25GaWx0ZXJzXCIsIFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCJdLFxuICAgICAgICBbXCJjb2xvclByb2ZpbGVcIiwgXCJjb2xvci1wcm9maWxlXCJdLFxuICAgICAgICBbXCJjb2xvclJlbmRlcmluZ1wiLCBcImNvbG9yLXJlbmRlcmluZ1wiXSxcbiAgICAgICAgW1wiZG9taW5hbnRCYXNlbGluZVwiLCBcImRvbWluYW50LWJhc2VsaW5lXCJdLFxuICAgICAgICBbXCJlbmFibGVCYWNrZ3JvdW5kXCIsIFwiZW5hYmxlLWJhY2tncm91bmRcIl0sXG4gICAgICAgIFtcImZpbGxPcGFjaXR5XCIsIFwiZmlsbC1vcGFjaXR5XCJdLFxuICAgICAgICBbXCJmaWxsUnVsZVwiLCBcImZpbGwtcnVsZVwiXSxcbiAgICAgICAgW1wiZmxvb2RDb2xvclwiLCBcImZsb29kLWNvbG9yXCJdLFxuICAgICAgICBbXCJmbG9vZE9wYWNpdHlcIiwgXCJmbG9vZC1vcGFjaXR5XCJdLFxuICAgICAgICBbXCJmb250RmFtaWx5XCIsIFwiZm9udC1mYW1pbHlcIl0sXG4gICAgICAgIFtcImZvbnRTaXplXCIsIFwiZm9udC1zaXplXCJdLFxuICAgICAgICBbXCJmb250U2l6ZUFkanVzdFwiLCBcImZvbnQtc2l6ZS1hZGp1c3RcIl0sXG4gICAgICAgIFtcImZvbnRTdHJldGNoXCIsIFwiZm9udC1zdHJldGNoXCJdLFxuICAgICAgICBbXCJmb250U3R5bGVcIiwgXCJmb250LXN0eWxlXCJdLFxuICAgICAgICBbXCJmb250VmFyaWFudFwiLCBcImZvbnQtdmFyaWFudFwiXSxcbiAgICAgICAgW1wiZm9udFdlaWdodFwiLCBcImZvbnQtd2VpZ2h0XCJdLFxuICAgICAgICBbXCJnbHlwaE5hbWVcIiwgXCJnbHlwaC1uYW1lXCJdLFxuICAgICAgICBbXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLCBcImdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWxcIl0sXG4gICAgICAgIFtcImdseXBoT3JpZW50YXRpb25WZXJ0aWNhbFwiLCBcImdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsXCJdLFxuICAgICAgICBbXCJob3JpekFkdlhcIiwgXCJob3Jpei1hZHYteFwiXSxcbiAgICAgICAgW1wiaG9yaXpPcmlnaW5YXCIsIFwiaG9yaXotb3JpZ2luLXhcIl0sXG4gICAgICAgIFtcImltYWdlUmVuZGVyaW5nXCIsIFwiaW1hZ2UtcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJsZXR0ZXJTcGFjaW5nXCIsIFwibGV0dGVyLXNwYWNpbmdcIl0sXG4gICAgICAgIFtcImxpZ2h0aW5nQ29sb3JcIiwgXCJsaWdodGluZy1jb2xvclwiXSxcbiAgICAgICAgW1wibWFya2VyRW5kXCIsIFwibWFya2VyLWVuZFwiXSxcbiAgICAgICAgW1wibWFya2VyTWlkXCIsIFwibWFya2VyLW1pZFwiXSxcbiAgICAgICAgW1wibWFya2VyU3RhcnRcIiwgXCJtYXJrZXItc3RhcnRcIl0sXG4gICAgICAgIFtcIm92ZXJsaW5lUG9zaXRpb25cIiwgXCJvdmVybGluZS1wb3NpdGlvblwiXSxcbiAgICAgICAgW1wib3ZlcmxpbmVUaGlja25lc3NcIiwgXCJvdmVybGluZS10aGlja25lc3NcIl0sXG4gICAgICAgIFtcInBhaW50T3JkZXJcIiwgXCJwYWludC1vcmRlclwiXSxcbiAgICAgICAgW1wicGFub3NlLTFcIiwgXCJwYW5vc2UtMVwiXSxcbiAgICAgICAgW1wicG9pbnRlckV2ZW50c1wiLCBcInBvaW50ZXItZXZlbnRzXCJdLFxuICAgICAgICBbXCJyZW5kZXJpbmdJbnRlbnRcIiwgXCJyZW5kZXJpbmctaW50ZW50XCJdLFxuICAgICAgICBbXCJzaGFwZVJlbmRlcmluZ1wiLCBcInNoYXBlLXJlbmRlcmluZ1wiXSxcbiAgICAgICAgW1wic3RvcENvbG9yXCIsIFwic3RvcC1jb2xvclwiXSxcbiAgICAgICAgW1wic3RvcE9wYWNpdHlcIiwgXCJzdG9wLW9wYWNpdHlcIl0sXG4gICAgICAgIFtcInN0cmlrZXRocm91Z2hQb3NpdGlvblwiLCBcInN0cmlrZXRocm91Z2gtcG9zaXRpb25cIl0sXG4gICAgICAgIFtcInN0cmlrZXRocm91Z2hUaGlja25lc3NcIiwgXCJzdHJpa2V0aHJvdWdoLXRoaWNrbmVzc1wiXSxcbiAgICAgICAgW1wic3Ryb2tlRGFzaGFycmF5XCIsIFwic3Ryb2tlLWRhc2hhcnJheVwiXSxcbiAgICAgICAgW1wic3Ryb2tlRGFzaG9mZnNldFwiLCBcInN0cm9rZS1kYXNob2Zmc2V0XCJdLFxuICAgICAgICBbXCJzdHJva2VMaW5lY2FwXCIsIFwic3Ryb2tlLWxpbmVjYXBcIl0sXG4gICAgICAgIFtcInN0cm9rZUxpbmVqb2luXCIsIFwic3Ryb2tlLWxpbmVqb2luXCJdLFxuICAgICAgICBbXCJzdHJva2VNaXRlcmxpbWl0XCIsIFwic3Ryb2tlLW1pdGVybGltaXRcIl0sXG4gICAgICAgIFtcInN0cm9rZU9wYWNpdHlcIiwgXCJzdHJva2Utb3BhY2l0eVwiXSxcbiAgICAgICAgW1wic3Ryb2tlV2lkdGhcIiwgXCJzdHJva2Utd2lkdGhcIl0sXG4gICAgICAgIFtcInRleHRBbmNob3JcIiwgXCJ0ZXh0LWFuY2hvclwiXSxcbiAgICAgICAgW1widGV4dERlY29yYXRpb25cIiwgXCJ0ZXh0LWRlY29yYXRpb25cIl0sXG4gICAgICAgIFtcInRleHRSZW5kZXJpbmdcIiwgXCJ0ZXh0LXJlbmRlcmluZ1wiXSxcbiAgICAgICAgW1widHJhbnNmb3JtT3JpZ2luXCIsIFwidHJhbnNmb3JtLW9yaWdpblwiXSxcbiAgICAgICAgW1widW5kZXJsaW5lUG9zaXRpb25cIiwgXCJ1bmRlcmxpbmUtcG9zaXRpb25cIl0sXG4gICAgICAgIFtcInVuZGVybGluZVRoaWNrbmVzc1wiLCBcInVuZGVybGluZS10aGlja25lc3NcIl0sXG4gICAgICAgIFtcInVuaWNvZGVCaWRpXCIsIFwidW5pY29kZS1iaWRpXCJdLFxuICAgICAgICBbXCJ1bmljb2RlUmFuZ2VcIiwgXCJ1bmljb2RlLXJhbmdlXCJdLFxuICAgICAgICBbXCJ1bml0c1BlckVtXCIsIFwidW5pdHMtcGVyLWVtXCJdLFxuICAgICAgICBbXCJ2QWxwaGFiZXRpY1wiLCBcInYtYWxwaGFiZXRpY1wiXSxcbiAgICAgICAgW1widkhhbmdpbmdcIiwgXCJ2LWhhbmdpbmdcIl0sXG4gICAgICAgIFtcInZJZGVvZ3JhcGhpY1wiLCBcInYtaWRlb2dyYXBoaWNcIl0sXG4gICAgICAgIFtcInZNYXRoZW1hdGljYWxcIiwgXCJ2LW1hdGhlbWF0aWNhbFwiXSxcbiAgICAgICAgW1widmVjdG9yRWZmZWN0XCIsIFwidmVjdG9yLWVmZmVjdFwiXSxcbiAgICAgICAgW1widmVydEFkdllcIiwgXCJ2ZXJ0LWFkdi15XCJdLFxuICAgICAgICBbXCJ2ZXJ0T3JpZ2luWFwiLCBcInZlcnQtb3JpZ2luLXhcIl0sXG4gICAgICAgIFtcInZlcnRPcmlnaW5ZXCIsIFwidmVydC1vcmlnaW4teVwiXSxcbiAgICAgICAgW1wid29yZFNwYWNpbmdcIiwgXCJ3b3JkLXNwYWNpbmdcIl0sXG4gICAgICAgIFtcIndyaXRpbmdNb2RlXCIsIFwid3JpdGluZy1tb2RlXCJdLFxuICAgICAgICBbXCJ4bWxuc1hsaW5rXCIsIFwieG1sbnM6eGxpbmtcIl0sXG4gICAgICAgIFtcInhIZWlnaHRcIiwgXCJ4LWhlaWdodFwiXVxuICAgICAgXSksXG4gICAgICBoYXNSZWFkT25seVZhbHVlID0ge1xuICAgICAgICBidXR0b246ICEwLFxuICAgICAgICBjaGVja2JveDogITAsXG4gICAgICAgIGltYWdlOiAhMCxcbiAgICAgICAgaGlkZGVuOiAhMCxcbiAgICAgICAgcmFkaW86ICEwLFxuICAgICAgICByZXNldDogITAsXG4gICAgICAgIHN1Ym1pdDogITBcbiAgICAgIH0sXG4gICAgICBhcmlhUHJvcGVydGllcyA9IHtcbiAgICAgICAgXCJhcmlhLWN1cnJlbnRcIjogMCxcbiAgICAgICAgXCJhcmlhLWRlc2NyaXB0aW9uXCI6IDAsXG4gICAgICAgIFwiYXJpYS1kZXRhaWxzXCI6IDAsXG4gICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiAwLFxuICAgICAgICBcImFyaWEtaGlkZGVuXCI6IDAsXG4gICAgICAgIFwiYXJpYS1pbnZhbGlkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1rZXlzaG9ydGN1dHNcIjogMCxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogMCxcbiAgICAgICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiAwLFxuICAgICAgICBcImFyaWEtY2hlY2tlZFwiOiAwLFxuICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IDAsXG4gICAgICAgIFwiYXJpYS1sZXZlbFwiOiAwLFxuICAgICAgICBcImFyaWEtbW9kYWxcIjogMCxcbiAgICAgICAgXCJhcmlhLW11bHRpbGluZVwiOiAwLFxuICAgICAgICBcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1vcmllbnRhdGlvblwiOiAwLFxuICAgICAgICBcImFyaWEtcGxhY2Vob2xkZXJcIjogMCxcbiAgICAgICAgXCJhcmlhLXByZXNzZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLXJlYWRvbmx5XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yZXF1aXJlZFwiOiAwLFxuICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLXNvcnRcIjogMCxcbiAgICAgICAgXCJhcmlhLXZhbHVlbWF4XCI6IDAsXG4gICAgICAgIFwiYXJpYS12YWx1ZW1pblwiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWVub3dcIjogMCxcbiAgICAgICAgXCJhcmlhLXZhbHVldGV4dFwiOiAwLFxuICAgICAgICBcImFyaWEtYXRvbWljXCI6IDAsXG4gICAgICAgIFwiYXJpYS1idXN5XCI6IDAsXG4gICAgICAgIFwiYXJpYS1saXZlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1yZWxldmFudFwiOiAwLFxuICAgICAgICBcImFyaWEtZHJvcGVmZmVjdFwiOiAwLFxuICAgICAgICBcImFyaWEtZ3JhYmJlZFwiOiAwLFxuICAgICAgICBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiAwLFxuICAgICAgICBcImFyaWEtY29sY291bnRcIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbGluZGV4XCI6IDAsXG4gICAgICAgIFwiYXJpYS1jb2xzcGFuXCI6IDAsXG4gICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiAwLFxuICAgICAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogMCxcbiAgICAgICAgXCJhcmlhLWVycm9ybWVzc2FnZVwiOiAwLFxuICAgICAgICBcImFyaWEtZmxvd3RvXCI6IDAsXG4gICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IDAsXG4gICAgICAgIFwiYXJpYS1vd25zXCI6IDAsXG4gICAgICAgIFwiYXJpYS1wb3NpbnNldFwiOiAwLFxuICAgICAgICBcImFyaWEtcm93Y291bnRcIjogMCxcbiAgICAgICAgXCJhcmlhLXJvd2luZGV4XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb3dzcGFuXCI6IDAsXG4gICAgICAgIFwiYXJpYS1zZXRzaXplXCI6IDBcbiAgICAgIH0sXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fSxcbiAgICAgIHJBUklBJDEgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKS1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICByQVJJQUNhbWVsJDEgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKVtBLVpdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9ICExLFxuICAgICAgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAgICAgICBhY2NlcHQ6IFwiYWNjZXB0XCIsXG4gICAgICAgIGFjY2VwdGNoYXJzZXQ6IFwiYWNjZXB0Q2hhcnNldFwiLFxuICAgICAgICBcImFjY2VwdC1jaGFyc2V0XCI6IFwiYWNjZXB0Q2hhcnNldFwiLFxuICAgICAgICBhY2Nlc3NrZXk6IFwiYWNjZXNzS2V5XCIsXG4gICAgICAgIGFjdGlvbjogXCJhY3Rpb25cIixcbiAgICAgICAgYWxsb3dmdWxsc2NyZWVuOiBcImFsbG93RnVsbFNjcmVlblwiLFxuICAgICAgICBhbHQ6IFwiYWx0XCIsXG4gICAgICAgIGFzOiBcImFzXCIsXG4gICAgICAgIGFzeW5jOiBcImFzeW5jXCIsXG4gICAgICAgIGF1dG9jYXBpdGFsaXplOiBcImF1dG9DYXBpdGFsaXplXCIsXG4gICAgICAgIGF1dG9jb21wbGV0ZTogXCJhdXRvQ29tcGxldGVcIixcbiAgICAgICAgYXV0b2NvcnJlY3Q6IFwiYXV0b0NvcnJlY3RcIixcbiAgICAgICAgYXV0b2ZvY3VzOiBcImF1dG9Gb2N1c1wiLFxuICAgICAgICBhdXRvcGxheTogXCJhdXRvUGxheVwiLFxuICAgICAgICBhdXRvc2F2ZTogXCJhdXRvU2F2ZVwiLFxuICAgICAgICBjYXB0dXJlOiBcImNhcHR1cmVcIixcbiAgICAgICAgY2VsbHBhZGRpbmc6IFwiY2VsbFBhZGRpbmdcIixcbiAgICAgICAgY2VsbHNwYWNpbmc6IFwiY2VsbFNwYWNpbmdcIixcbiAgICAgICAgY2hhbGxlbmdlOiBcImNoYWxsZW5nZVwiLFxuICAgICAgICBjaGFyc2V0OiBcImNoYXJTZXRcIixcbiAgICAgICAgY2hlY2tlZDogXCJjaGVja2VkXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcImNoaWxkcmVuXCIsXG4gICAgICAgIGNpdGU6IFwiY2l0ZVwiLFxuICAgICAgICBjbGFzczogXCJjbGFzc05hbWVcIixcbiAgICAgICAgY2xhc3NpZDogXCJjbGFzc0lEXCIsXG4gICAgICAgIGNsYXNzbmFtZTogXCJjbGFzc05hbWVcIixcbiAgICAgICAgY29sczogXCJjb2xzXCIsXG4gICAgICAgIGNvbHNwYW46IFwiY29sU3BhblwiLFxuICAgICAgICBjb250ZW50OiBcImNvbnRlbnRcIixcbiAgICAgICAgY29udGVudGVkaXRhYmxlOiBcImNvbnRlbnRFZGl0YWJsZVwiLFxuICAgICAgICBjb250ZXh0bWVudTogXCJjb250ZXh0TWVudVwiLFxuICAgICAgICBjb250cm9sczogXCJjb250cm9sc1wiLFxuICAgICAgICBjb250cm9sc2xpc3Q6IFwiY29udHJvbHNMaXN0XCIsXG4gICAgICAgIGNvb3JkczogXCJjb29yZHNcIixcbiAgICAgICAgY3Jvc3NvcmlnaW46IFwiY3Jvc3NPcmlnaW5cIixcbiAgICAgICAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6IFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIixcbiAgICAgICAgZGF0YTogXCJkYXRhXCIsXG4gICAgICAgIGRhdGV0aW1lOiBcImRhdGVUaW1lXCIsXG4gICAgICAgIGRlZmF1bHQ6IFwiZGVmYXVsdFwiLFxuICAgICAgICBkZWZhdWx0Y2hlY2tlZDogXCJkZWZhdWx0Q2hlY2tlZFwiLFxuICAgICAgICBkZWZhdWx0dmFsdWU6IFwiZGVmYXVsdFZhbHVlXCIsXG4gICAgICAgIGRlZmVyOiBcImRlZmVyXCIsXG4gICAgICAgIGRpcjogXCJkaXJcIixcbiAgICAgICAgZGlzYWJsZWQ6IFwiZGlzYWJsZWRcIixcbiAgICAgICAgZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6IFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIixcbiAgICAgICAgZGlzYWJsZXJlbW90ZXBsYXliYWNrOiBcImRpc2FibGVSZW1vdGVQbGF5YmFja1wiLFxuICAgICAgICBkb3dubG9hZDogXCJkb3dubG9hZFwiLFxuICAgICAgICBkcmFnZ2FibGU6IFwiZHJhZ2dhYmxlXCIsXG4gICAgICAgIGVuY3R5cGU6IFwiZW5jVHlwZVwiLFxuICAgICAgICBlbnRlcmtleWhpbnQ6IFwiZW50ZXJLZXlIaW50XCIsXG4gICAgICAgIGZldGNocHJpb3JpdHk6IFwiZmV0Y2hQcmlvcml0eVwiLFxuICAgICAgICBmb3I6IFwiaHRtbEZvclwiLFxuICAgICAgICBmb3JtOiBcImZvcm1cIixcbiAgICAgICAgZm9ybW1ldGhvZDogXCJmb3JtTWV0aG9kXCIsXG4gICAgICAgIGZvcm1hY3Rpb246IFwiZm9ybUFjdGlvblwiLFxuICAgICAgICBmb3JtZW5jdHlwZTogXCJmb3JtRW5jVHlwZVwiLFxuICAgICAgICBmb3Jtbm92YWxpZGF0ZTogXCJmb3JtTm9WYWxpZGF0ZVwiLFxuICAgICAgICBmb3JtdGFyZ2V0OiBcImZvcm1UYXJnZXRcIixcbiAgICAgICAgZnJhbWVib3JkZXI6IFwiZnJhbWVCb3JkZXJcIixcbiAgICAgICAgaGVhZGVyczogXCJoZWFkZXJzXCIsXG4gICAgICAgIGhlaWdodDogXCJoZWlnaHRcIixcbiAgICAgICAgaGlkZGVuOiBcImhpZGRlblwiLFxuICAgICAgICBoaWdoOiBcImhpZ2hcIixcbiAgICAgICAgaHJlZjogXCJocmVmXCIsXG4gICAgICAgIGhyZWZsYW5nOiBcImhyZWZMYW5nXCIsXG4gICAgICAgIGh0bWxmb3I6IFwiaHRtbEZvclwiLFxuICAgICAgICBodHRwZXF1aXY6IFwiaHR0cEVxdWl2XCIsXG4gICAgICAgIFwiaHR0cC1lcXVpdlwiOiBcImh0dHBFcXVpdlwiLFxuICAgICAgICBpY29uOiBcImljb25cIixcbiAgICAgICAgaWQ6IFwiaWRcIixcbiAgICAgICAgaW1hZ2VzaXplczogXCJpbWFnZVNpemVzXCIsXG4gICAgICAgIGltYWdlc3Jjc2V0OiBcImltYWdlU3JjU2V0XCIsXG4gICAgICAgIGluZXJ0OiBcImluZXJ0XCIsXG4gICAgICAgIGlubmVyaHRtbDogXCJpbm5lckhUTUxcIixcbiAgICAgICAgaW5wdXRtb2RlOiBcImlucHV0TW9kZVwiLFxuICAgICAgICBpbnRlZ3JpdHk6IFwiaW50ZWdyaXR5XCIsXG4gICAgICAgIGlzOiBcImlzXCIsXG4gICAgICAgIGl0ZW1pZDogXCJpdGVtSURcIixcbiAgICAgICAgaXRlbXByb3A6IFwiaXRlbVByb3BcIixcbiAgICAgICAgaXRlbXJlZjogXCJpdGVtUmVmXCIsXG4gICAgICAgIGl0ZW1zY29wZTogXCJpdGVtU2NvcGVcIixcbiAgICAgICAgaXRlbXR5cGU6IFwiaXRlbVR5cGVcIixcbiAgICAgICAga2V5cGFyYW1zOiBcImtleVBhcmFtc1wiLFxuICAgICAgICBrZXl0eXBlOiBcImtleVR5cGVcIixcbiAgICAgICAga2luZDogXCJraW5kXCIsXG4gICAgICAgIGxhYmVsOiBcImxhYmVsXCIsXG4gICAgICAgIGxhbmc6IFwibGFuZ1wiLFxuICAgICAgICBsaXN0OiBcImxpc3RcIixcbiAgICAgICAgbG9vcDogXCJsb29wXCIsXG4gICAgICAgIGxvdzogXCJsb3dcIixcbiAgICAgICAgbWFuaWZlc3Q6IFwibWFuaWZlc3RcIixcbiAgICAgICAgbWFyZ2lud2lkdGg6IFwibWFyZ2luV2lkdGhcIixcbiAgICAgICAgbWFyZ2luaGVpZ2h0OiBcIm1hcmdpbkhlaWdodFwiLFxuICAgICAgICBtYXg6IFwibWF4XCIsXG4gICAgICAgIG1heGxlbmd0aDogXCJtYXhMZW5ndGhcIixcbiAgICAgICAgbWVkaWE6IFwibWVkaWFcIixcbiAgICAgICAgbWVkaWFncm91cDogXCJtZWRpYUdyb3VwXCIsXG4gICAgICAgIG1ldGhvZDogXCJtZXRob2RcIixcbiAgICAgICAgbWluOiBcIm1pblwiLFxuICAgICAgICBtaW5sZW5ndGg6IFwibWluTGVuZ3RoXCIsXG4gICAgICAgIG11bHRpcGxlOiBcIm11bHRpcGxlXCIsXG4gICAgICAgIG11dGVkOiBcIm11dGVkXCIsXG4gICAgICAgIG5hbWU6IFwibmFtZVwiLFxuICAgICAgICBub21vZHVsZTogXCJub01vZHVsZVwiLFxuICAgICAgICBub25jZTogXCJub25jZVwiLFxuICAgICAgICBub3ZhbGlkYXRlOiBcIm5vVmFsaWRhdGVcIixcbiAgICAgICAgb3BlbjogXCJvcGVuXCIsXG4gICAgICAgIG9wdGltdW06IFwib3B0aW11bVwiLFxuICAgICAgICBwYXR0ZXJuOiBcInBhdHRlcm5cIixcbiAgICAgICAgcGxhY2Vob2xkZXI6IFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgcGxheXNpbmxpbmU6IFwicGxheXNJbmxpbmVcIixcbiAgICAgICAgcG9zdGVyOiBcInBvc3RlclwiLFxuICAgICAgICBwcmVsb2FkOiBcInByZWxvYWRcIixcbiAgICAgICAgcHJvZmlsZTogXCJwcm9maWxlXCIsXG4gICAgICAgIHJhZGlvZ3JvdXA6IFwicmFkaW9Hcm91cFwiLFxuICAgICAgICByZWFkb25seTogXCJyZWFkT25seVwiLFxuICAgICAgICByZWZlcnJlcnBvbGljeTogXCJyZWZlcnJlclBvbGljeVwiLFxuICAgICAgICByZWw6IFwicmVsXCIsXG4gICAgICAgIHJlcXVpcmVkOiBcInJlcXVpcmVkXCIsXG4gICAgICAgIHJldmVyc2VkOiBcInJldmVyc2VkXCIsXG4gICAgICAgIHJvbGU6IFwicm9sZVwiLFxuICAgICAgICByb3dzOiBcInJvd3NcIixcbiAgICAgICAgcm93c3BhbjogXCJyb3dTcGFuXCIsXG4gICAgICAgIHNhbmRib3g6IFwic2FuZGJveFwiLFxuICAgICAgICBzY29wZTogXCJzY29wZVwiLFxuICAgICAgICBzY29wZWQ6IFwic2NvcGVkXCIsXG4gICAgICAgIHNjcm9sbGluZzogXCJzY3JvbGxpbmdcIixcbiAgICAgICAgc2VhbWxlc3M6IFwic2VhbWxlc3NcIixcbiAgICAgICAgc2VsZWN0ZWQ6IFwic2VsZWN0ZWRcIixcbiAgICAgICAgc2hhcGU6IFwic2hhcGVcIixcbiAgICAgICAgc2l6ZTogXCJzaXplXCIsXG4gICAgICAgIHNpemVzOiBcInNpemVzXCIsXG4gICAgICAgIHNwYW46IFwic3BhblwiLFxuICAgICAgICBzcGVsbGNoZWNrOiBcInNwZWxsQ2hlY2tcIixcbiAgICAgICAgc3JjOiBcInNyY1wiLFxuICAgICAgICBzcmNkb2M6IFwic3JjRG9jXCIsXG4gICAgICAgIHNyY2xhbmc6IFwic3JjTGFuZ1wiLFxuICAgICAgICBzcmNzZXQ6IFwic3JjU2V0XCIsXG4gICAgICAgIHN0YXJ0OiBcInN0YXJ0XCIsXG4gICAgICAgIHN0ZXA6IFwic3RlcFwiLFxuICAgICAgICBzdHlsZTogXCJzdHlsZVwiLFxuICAgICAgICBzdW1tYXJ5OiBcInN1bW1hcnlcIixcbiAgICAgICAgdGFiaW5kZXg6IFwidGFiSW5kZXhcIixcbiAgICAgICAgdGFyZ2V0OiBcInRhcmdldFwiLFxuICAgICAgICB0aXRsZTogXCJ0aXRsZVwiLFxuICAgICAgICB0eXBlOiBcInR5cGVcIixcbiAgICAgICAgdXNlbWFwOiBcInVzZU1hcFwiLFxuICAgICAgICB2YWx1ZTogXCJ2YWx1ZVwiLFxuICAgICAgICB3aWR0aDogXCJ3aWR0aFwiLFxuICAgICAgICB3bW9kZTogXCJ3bW9kZVwiLFxuICAgICAgICB3cmFwOiBcIndyYXBcIixcbiAgICAgICAgYWJvdXQ6IFwiYWJvdXRcIixcbiAgICAgICAgYWNjZW50aGVpZ2h0OiBcImFjY2VudEhlaWdodFwiLFxuICAgICAgICBcImFjY2VudC1oZWlnaHRcIjogXCJhY2NlbnRIZWlnaHRcIixcbiAgICAgICAgYWNjdW11bGF0ZTogXCJhY2N1bXVsYXRlXCIsXG4gICAgICAgIGFkZGl0aXZlOiBcImFkZGl0aXZlXCIsXG4gICAgICAgIGFsaWdubWVudGJhc2VsaW5lOiBcImFsaWdubWVudEJhc2VsaW5lXCIsXG4gICAgICAgIFwiYWxpZ25tZW50LWJhc2VsaW5lXCI6IFwiYWxpZ25tZW50QmFzZWxpbmVcIixcbiAgICAgICAgYWxsb3dyZW9yZGVyOiBcImFsbG93UmVvcmRlclwiLFxuICAgICAgICBhbHBoYWJldGljOiBcImFscGhhYmV0aWNcIixcbiAgICAgICAgYW1wbGl0dWRlOiBcImFtcGxpdHVkZVwiLFxuICAgICAgICBhcmFiaWNmb3JtOiBcImFyYWJpY0Zvcm1cIixcbiAgICAgICAgXCJhcmFiaWMtZm9ybVwiOiBcImFyYWJpY0Zvcm1cIixcbiAgICAgICAgYXNjZW50OiBcImFzY2VudFwiLFxuICAgICAgICBhdHRyaWJ1dGVuYW1lOiBcImF0dHJpYnV0ZU5hbWVcIixcbiAgICAgICAgYXR0cmlidXRldHlwZTogXCJhdHRyaWJ1dGVUeXBlXCIsXG4gICAgICAgIGF1dG9yZXZlcnNlOiBcImF1dG9SZXZlcnNlXCIsXG4gICAgICAgIGF6aW11dGg6IFwiYXppbXV0aFwiLFxuICAgICAgICBiYXNlZnJlcXVlbmN5OiBcImJhc2VGcmVxdWVuY3lcIixcbiAgICAgICAgYmFzZWxpbmVzaGlmdDogXCJiYXNlbGluZVNoaWZ0XCIsXG4gICAgICAgIFwiYmFzZWxpbmUtc2hpZnRcIjogXCJiYXNlbGluZVNoaWZ0XCIsXG4gICAgICAgIGJhc2Vwcm9maWxlOiBcImJhc2VQcm9maWxlXCIsXG4gICAgICAgIGJib3g6IFwiYmJveFwiLFxuICAgICAgICBiZWdpbjogXCJiZWdpblwiLFxuICAgICAgICBiaWFzOiBcImJpYXNcIixcbiAgICAgICAgYnk6IFwiYnlcIixcbiAgICAgICAgY2FsY21vZGU6IFwiY2FsY01vZGVcIixcbiAgICAgICAgY2FwaGVpZ2h0OiBcImNhcEhlaWdodFwiLFxuICAgICAgICBcImNhcC1oZWlnaHRcIjogXCJjYXBIZWlnaHRcIixcbiAgICAgICAgY2xpcDogXCJjbGlwXCIsXG4gICAgICAgIGNsaXBwYXRoOiBcImNsaXBQYXRoXCIsXG4gICAgICAgIFwiY2xpcC1wYXRoXCI6IFwiY2xpcFBhdGhcIixcbiAgICAgICAgY2xpcHBhdGh1bml0czogXCJjbGlwUGF0aFVuaXRzXCIsXG4gICAgICAgIGNsaXBydWxlOiBcImNsaXBSdWxlXCIsXG4gICAgICAgIFwiY2xpcC1ydWxlXCI6IFwiY2xpcFJ1bGVcIixcbiAgICAgICAgY29sb3I6IFwiY29sb3JcIixcbiAgICAgICAgY29sb3JpbnRlcnBvbGF0aW9uOiBcImNvbG9ySW50ZXJwb2xhdGlvblwiLFxuICAgICAgICBcImNvbG9yLWludGVycG9sYXRpb25cIjogXCJjb2xvckludGVycG9sYXRpb25cIixcbiAgICAgICAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogXCJjb2xvckludGVycG9sYXRpb25GaWx0ZXJzXCIsXG4gICAgICAgIFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCI6IFwiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyc1wiLFxuICAgICAgICBjb2xvcnByb2ZpbGU6IFwiY29sb3JQcm9maWxlXCIsXG4gICAgICAgIFwiY29sb3ItcHJvZmlsZVwiOiBcImNvbG9yUHJvZmlsZVwiLFxuICAgICAgICBjb2xvcnJlbmRlcmluZzogXCJjb2xvclJlbmRlcmluZ1wiLFxuICAgICAgICBcImNvbG9yLXJlbmRlcmluZ1wiOiBcImNvbG9yUmVuZGVyaW5nXCIsXG4gICAgICAgIGNvbnRlbnRzY3JpcHR0eXBlOiBcImNvbnRlbnRTY3JpcHRUeXBlXCIsXG4gICAgICAgIGNvbnRlbnRzdHlsZXR5cGU6IFwiY29udGVudFN0eWxlVHlwZVwiLFxuICAgICAgICBjdXJzb3I6IFwiY3Vyc29yXCIsXG4gICAgICAgIGN4OiBcImN4XCIsXG4gICAgICAgIGN5OiBcImN5XCIsXG4gICAgICAgIGQ6IFwiZFwiLFxuICAgICAgICBkYXRhdHlwZTogXCJkYXRhdHlwZVwiLFxuICAgICAgICBkZWNlbGVyYXRlOiBcImRlY2VsZXJhdGVcIixcbiAgICAgICAgZGVzY2VudDogXCJkZXNjZW50XCIsXG4gICAgICAgIGRpZmZ1c2Vjb25zdGFudDogXCJkaWZmdXNlQ29uc3RhbnRcIixcbiAgICAgICAgZGlyZWN0aW9uOiBcImRpcmVjdGlvblwiLFxuICAgICAgICBkaXNwbGF5OiBcImRpc3BsYXlcIixcbiAgICAgICAgZGl2aXNvcjogXCJkaXZpc29yXCIsXG4gICAgICAgIGRvbWluYW50YmFzZWxpbmU6IFwiZG9taW5hbnRCYXNlbGluZVwiLFxuICAgICAgICBcImRvbWluYW50LWJhc2VsaW5lXCI6IFwiZG9taW5hbnRCYXNlbGluZVwiLFxuICAgICAgICBkdXI6IFwiZHVyXCIsXG4gICAgICAgIGR4OiBcImR4XCIsXG4gICAgICAgIGR5OiBcImR5XCIsXG4gICAgICAgIGVkZ2Vtb2RlOiBcImVkZ2VNb2RlXCIsXG4gICAgICAgIGVsZXZhdGlvbjogXCJlbGV2YXRpb25cIixcbiAgICAgICAgZW5hYmxlYmFja2dyb3VuZDogXCJlbmFibGVCYWNrZ3JvdW5kXCIsXG4gICAgICAgIFwiZW5hYmxlLWJhY2tncm91bmRcIjogXCJlbmFibGVCYWNrZ3JvdW5kXCIsXG4gICAgICAgIGVuZDogXCJlbmRcIixcbiAgICAgICAgZXhwb25lbnQ6IFwiZXhwb25lbnRcIixcbiAgICAgICAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogXCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCIsXG4gICAgICAgIGZpbGw6IFwiZmlsbFwiLFxuICAgICAgICBmaWxsb3BhY2l0eTogXCJmaWxsT3BhY2l0eVwiLFxuICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiBcImZpbGxPcGFjaXR5XCIsXG4gICAgICAgIGZpbGxydWxlOiBcImZpbGxSdWxlXCIsXG4gICAgICAgIFwiZmlsbC1ydWxlXCI6IFwiZmlsbFJ1bGVcIixcbiAgICAgICAgZmlsdGVyOiBcImZpbHRlclwiLFxuICAgICAgICBmaWx0ZXJyZXM6IFwiZmlsdGVyUmVzXCIsXG4gICAgICAgIGZpbHRlcnVuaXRzOiBcImZpbHRlclVuaXRzXCIsXG4gICAgICAgIGZsb29kb3BhY2l0eTogXCJmbG9vZE9wYWNpdHlcIixcbiAgICAgICAgXCJmbG9vZC1vcGFjaXR5XCI6IFwiZmxvb2RPcGFjaXR5XCIsXG4gICAgICAgIGZsb29kY29sb3I6IFwiZmxvb2RDb2xvclwiLFxuICAgICAgICBcImZsb29kLWNvbG9yXCI6IFwiZmxvb2RDb2xvclwiLFxuICAgICAgICBmb2N1c2FibGU6IFwiZm9jdXNhYmxlXCIsXG4gICAgICAgIGZvbnRmYW1pbHk6IFwiZm9udEZhbWlseVwiLFxuICAgICAgICBcImZvbnQtZmFtaWx5XCI6IFwiZm9udEZhbWlseVwiLFxuICAgICAgICBmb250c2l6ZTogXCJmb250U2l6ZVwiLFxuICAgICAgICBcImZvbnQtc2l6ZVwiOiBcImZvbnRTaXplXCIsXG4gICAgICAgIGZvbnRzaXplYWRqdXN0OiBcImZvbnRTaXplQWRqdXN0XCIsXG4gICAgICAgIFwiZm9udC1zaXplLWFkanVzdFwiOiBcImZvbnRTaXplQWRqdXN0XCIsXG4gICAgICAgIGZvbnRzdHJldGNoOiBcImZvbnRTdHJldGNoXCIsXG4gICAgICAgIFwiZm9udC1zdHJldGNoXCI6IFwiZm9udFN0cmV0Y2hcIixcbiAgICAgICAgZm9udHN0eWxlOiBcImZvbnRTdHlsZVwiLFxuICAgICAgICBcImZvbnQtc3R5bGVcIjogXCJmb250U3R5bGVcIixcbiAgICAgICAgZm9udHZhcmlhbnQ6IFwiZm9udFZhcmlhbnRcIixcbiAgICAgICAgXCJmb250LXZhcmlhbnRcIjogXCJmb250VmFyaWFudFwiLFxuICAgICAgICBmb250d2VpZ2h0OiBcImZvbnRXZWlnaHRcIixcbiAgICAgICAgXCJmb250LXdlaWdodFwiOiBcImZvbnRXZWlnaHRcIixcbiAgICAgICAgZm9ybWF0OiBcImZvcm1hdFwiLFxuICAgICAgICBmcm9tOiBcImZyb21cIixcbiAgICAgICAgZng6IFwiZnhcIixcbiAgICAgICAgZnk6IFwiZnlcIixcbiAgICAgICAgZzE6IFwiZzFcIixcbiAgICAgICAgZzI6IFwiZzJcIixcbiAgICAgICAgZ2x5cGhuYW1lOiBcImdseXBoTmFtZVwiLFxuICAgICAgICBcImdseXBoLW5hbWVcIjogXCJnbHlwaE5hbWVcIixcbiAgICAgICAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6IFwiZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWxcIixcbiAgICAgICAgXCJnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsXCI6IFwiZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWxcIixcbiAgICAgICAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiBcImdseXBoT3JpZW50YXRpb25WZXJ0aWNhbFwiLFxuICAgICAgICBcImdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsXCI6IFwiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsXCIsXG4gICAgICAgIGdseXBocmVmOiBcImdseXBoUmVmXCIsXG4gICAgICAgIGdyYWRpZW50dHJhbnNmb3JtOiBcImdyYWRpZW50VHJhbnNmb3JtXCIsXG4gICAgICAgIGdyYWRpZW50dW5pdHM6IFwiZ3JhZGllbnRVbml0c1wiLFxuICAgICAgICBoYW5naW5nOiBcImhhbmdpbmdcIixcbiAgICAgICAgaG9yaXphZHZ4OiBcImhvcml6QWR2WFwiLFxuICAgICAgICBcImhvcml6LWFkdi14XCI6IFwiaG9yaXpBZHZYXCIsXG4gICAgICAgIGhvcml6b3JpZ2lueDogXCJob3Jpek9yaWdpblhcIixcbiAgICAgICAgXCJob3Jpei1vcmlnaW4teFwiOiBcImhvcml6T3JpZ2luWFwiLFxuICAgICAgICBpZGVvZ3JhcGhpYzogXCJpZGVvZ3JhcGhpY1wiLFxuICAgICAgICBpbWFnZXJlbmRlcmluZzogXCJpbWFnZVJlbmRlcmluZ1wiLFxuICAgICAgICBcImltYWdlLXJlbmRlcmluZ1wiOiBcImltYWdlUmVuZGVyaW5nXCIsXG4gICAgICAgIGluMjogXCJpbjJcIixcbiAgICAgICAgaW46IFwiaW5cIixcbiAgICAgICAgaW5saXN0OiBcImlubGlzdFwiLFxuICAgICAgICBpbnRlcmNlcHQ6IFwiaW50ZXJjZXB0XCIsXG4gICAgICAgIGsxOiBcImsxXCIsXG4gICAgICAgIGsyOiBcImsyXCIsXG4gICAgICAgIGszOiBcImszXCIsXG4gICAgICAgIGs0OiBcIms0XCIsXG4gICAgICAgIGs6IFwia1wiLFxuICAgICAgICBrZXJuZWxtYXRyaXg6IFwia2VybmVsTWF0cml4XCIsXG4gICAgICAgIGtlcm5lbHVuaXRsZW5ndGg6IFwia2VybmVsVW5pdExlbmd0aFwiLFxuICAgICAgICBrZXJuaW5nOiBcImtlcm5pbmdcIixcbiAgICAgICAga2V5cG9pbnRzOiBcImtleVBvaW50c1wiLFxuICAgICAgICBrZXlzcGxpbmVzOiBcImtleVNwbGluZXNcIixcbiAgICAgICAga2V5dGltZXM6IFwia2V5VGltZXNcIixcbiAgICAgICAgbGVuZ3RoYWRqdXN0OiBcImxlbmd0aEFkanVzdFwiLFxuICAgICAgICBsZXR0ZXJzcGFjaW5nOiBcImxldHRlclNwYWNpbmdcIixcbiAgICAgICAgXCJsZXR0ZXItc3BhY2luZ1wiOiBcImxldHRlclNwYWNpbmdcIixcbiAgICAgICAgbGlnaHRpbmdjb2xvcjogXCJsaWdodGluZ0NvbG9yXCIsXG4gICAgICAgIFwibGlnaHRpbmctY29sb3JcIjogXCJsaWdodGluZ0NvbG9yXCIsXG4gICAgICAgIGxpbWl0aW5nY29uZWFuZ2xlOiBcImxpbWl0aW5nQ29uZUFuZ2xlXCIsXG4gICAgICAgIGxvY2FsOiBcImxvY2FsXCIsXG4gICAgICAgIG1hcmtlcmVuZDogXCJtYXJrZXJFbmRcIixcbiAgICAgICAgXCJtYXJrZXItZW5kXCI6IFwibWFya2VyRW5kXCIsXG4gICAgICAgIG1hcmtlcmhlaWdodDogXCJtYXJrZXJIZWlnaHRcIixcbiAgICAgICAgbWFya2VybWlkOiBcIm1hcmtlck1pZFwiLFxuICAgICAgICBcIm1hcmtlci1taWRcIjogXCJtYXJrZXJNaWRcIixcbiAgICAgICAgbWFya2Vyc3RhcnQ6IFwibWFya2VyU3RhcnRcIixcbiAgICAgICAgXCJtYXJrZXItc3RhcnRcIjogXCJtYXJrZXJTdGFydFwiLFxuICAgICAgICBtYXJrZXJ1bml0czogXCJtYXJrZXJVbml0c1wiLFxuICAgICAgICBtYXJrZXJ3aWR0aDogXCJtYXJrZXJXaWR0aFwiLFxuICAgICAgICBtYXNrOiBcIm1hc2tcIixcbiAgICAgICAgbWFza2NvbnRlbnR1bml0czogXCJtYXNrQ29udGVudFVuaXRzXCIsXG4gICAgICAgIG1hc2t1bml0czogXCJtYXNrVW5pdHNcIixcbiAgICAgICAgbWF0aGVtYXRpY2FsOiBcIm1hdGhlbWF0aWNhbFwiLFxuICAgICAgICBtb2RlOiBcIm1vZGVcIixcbiAgICAgICAgbnVtb2N0YXZlczogXCJudW1PY3RhdmVzXCIsXG4gICAgICAgIG9mZnNldDogXCJvZmZzZXRcIixcbiAgICAgICAgb3BhY2l0eTogXCJvcGFjaXR5XCIsXG4gICAgICAgIG9wZXJhdG9yOiBcIm9wZXJhdG9yXCIsXG4gICAgICAgIG9yZGVyOiBcIm9yZGVyXCIsXG4gICAgICAgIG9yaWVudDogXCJvcmllbnRcIixcbiAgICAgICAgb3JpZW50YXRpb246IFwib3JpZW50YXRpb25cIixcbiAgICAgICAgb3JpZ2luOiBcIm9yaWdpblwiLFxuICAgICAgICBvdmVyZmxvdzogXCJvdmVyZmxvd1wiLFxuICAgICAgICBvdmVybGluZXBvc2l0aW9uOiBcIm92ZXJsaW5lUG9zaXRpb25cIixcbiAgICAgICAgXCJvdmVybGluZS1wb3NpdGlvblwiOiBcIm92ZXJsaW5lUG9zaXRpb25cIixcbiAgICAgICAgb3ZlcmxpbmV0aGlja25lc3M6IFwib3ZlcmxpbmVUaGlja25lc3NcIixcbiAgICAgICAgXCJvdmVybGluZS10aGlja25lc3NcIjogXCJvdmVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICBwYWludG9yZGVyOiBcInBhaW50T3JkZXJcIixcbiAgICAgICAgXCJwYWludC1vcmRlclwiOiBcInBhaW50T3JkZXJcIixcbiAgICAgICAgcGFub3NlMTogXCJwYW5vc2UxXCIsXG4gICAgICAgIFwicGFub3NlLTFcIjogXCJwYW5vc2UxXCIsXG4gICAgICAgIHBhdGhsZW5ndGg6IFwicGF0aExlbmd0aFwiLFxuICAgICAgICBwYXR0ZXJuY29udGVudHVuaXRzOiBcInBhdHRlcm5Db250ZW50VW5pdHNcIixcbiAgICAgICAgcGF0dGVybnRyYW5zZm9ybTogXCJwYXR0ZXJuVHJhbnNmb3JtXCIsXG4gICAgICAgIHBhdHRlcm51bml0czogXCJwYXR0ZXJuVW5pdHNcIixcbiAgICAgICAgcG9pbnRlcmV2ZW50czogXCJwb2ludGVyRXZlbnRzXCIsXG4gICAgICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJwb2ludGVyRXZlbnRzXCIsXG4gICAgICAgIHBvaW50czogXCJwb2ludHNcIixcbiAgICAgICAgcG9pbnRzYXR4OiBcInBvaW50c0F0WFwiLFxuICAgICAgICBwb2ludHNhdHk6IFwicG9pbnRzQXRZXCIsXG4gICAgICAgIHBvaW50c2F0ejogXCJwb2ludHNBdFpcIixcbiAgICAgICAgcG9wb3ZlcjogXCJwb3BvdmVyXCIsXG4gICAgICAgIHBvcG92ZXJ0YXJnZXQ6IFwicG9wb3ZlclRhcmdldFwiLFxuICAgICAgICBwb3BvdmVydGFyZ2V0YWN0aW9uOiBcInBvcG92ZXJUYXJnZXRBY3Rpb25cIixcbiAgICAgICAgcHJlZml4OiBcInByZWZpeFwiLFxuICAgICAgICBwcmVzZXJ2ZWFscGhhOiBcInByZXNlcnZlQWxwaGFcIixcbiAgICAgICAgcHJlc2VydmVhc3BlY3RyYXRpbzogXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsXG4gICAgICAgIHByaW1pdGl2ZXVuaXRzOiBcInByaW1pdGl2ZVVuaXRzXCIsXG4gICAgICAgIHByb3BlcnR5OiBcInByb3BlcnR5XCIsXG4gICAgICAgIHI6IFwiclwiLFxuICAgICAgICByYWRpdXM6IFwicmFkaXVzXCIsXG4gICAgICAgIHJlZng6IFwicmVmWFwiLFxuICAgICAgICByZWZ5OiBcInJlZllcIixcbiAgICAgICAgcmVuZGVyaW5naW50ZW50OiBcInJlbmRlcmluZ0ludGVudFwiLFxuICAgICAgICBcInJlbmRlcmluZy1pbnRlbnRcIjogXCJyZW5kZXJpbmdJbnRlbnRcIixcbiAgICAgICAgcmVwZWF0Y291bnQ6IFwicmVwZWF0Q291bnRcIixcbiAgICAgICAgcmVwZWF0ZHVyOiBcInJlcGVhdER1clwiLFxuICAgICAgICByZXF1aXJlZGV4dGVuc2lvbnM6IFwicmVxdWlyZWRFeHRlbnNpb25zXCIsXG4gICAgICAgIHJlcXVpcmVkZmVhdHVyZXM6IFwicmVxdWlyZWRGZWF0dXJlc1wiLFxuICAgICAgICByZXNvdXJjZTogXCJyZXNvdXJjZVwiLFxuICAgICAgICByZXN0YXJ0OiBcInJlc3RhcnRcIixcbiAgICAgICAgcmVzdWx0OiBcInJlc3VsdFwiLFxuICAgICAgICByZXN1bHRzOiBcInJlc3VsdHNcIixcbiAgICAgICAgcm90YXRlOiBcInJvdGF0ZVwiLFxuICAgICAgICByeDogXCJyeFwiLFxuICAgICAgICByeTogXCJyeVwiLFxuICAgICAgICBzY2FsZTogXCJzY2FsZVwiLFxuICAgICAgICBzZWN1cml0eTogXCJzZWN1cml0eVwiLFxuICAgICAgICBzZWVkOiBcInNlZWRcIixcbiAgICAgICAgc2hhcGVyZW5kZXJpbmc6IFwic2hhcGVSZW5kZXJpbmdcIixcbiAgICAgICAgXCJzaGFwZS1yZW5kZXJpbmdcIjogXCJzaGFwZVJlbmRlcmluZ1wiLFxuICAgICAgICBzbG9wZTogXCJzbG9wZVwiLFxuICAgICAgICBzcGFjaW5nOiBcInNwYWNpbmdcIixcbiAgICAgICAgc3BlY3VsYXJjb25zdGFudDogXCJzcGVjdWxhckNvbnN0YW50XCIsXG4gICAgICAgIHNwZWN1bGFyZXhwb25lbnQ6IFwic3BlY3VsYXJFeHBvbmVudFwiLFxuICAgICAgICBzcGVlZDogXCJzcGVlZFwiLFxuICAgICAgICBzcHJlYWRtZXRob2Q6IFwic3ByZWFkTWV0aG9kXCIsXG4gICAgICAgIHN0YXJ0b2Zmc2V0OiBcInN0YXJ0T2Zmc2V0XCIsXG4gICAgICAgIHN0ZGRldmlhdGlvbjogXCJzdGREZXZpYXRpb25cIixcbiAgICAgICAgc3RlbWg6IFwic3RlbWhcIixcbiAgICAgICAgc3RlbXY6IFwic3RlbXZcIixcbiAgICAgICAgc3RpdGNodGlsZXM6IFwic3RpdGNoVGlsZXNcIixcbiAgICAgICAgc3RvcGNvbG9yOiBcInN0b3BDb2xvclwiLFxuICAgICAgICBcInN0b3AtY29sb3JcIjogXCJzdG9wQ29sb3JcIixcbiAgICAgICAgc3RvcG9wYWNpdHk6IFwic3RvcE9wYWNpdHlcIixcbiAgICAgICAgXCJzdG9wLW9wYWNpdHlcIjogXCJzdG9wT3BhY2l0eVwiLFxuICAgICAgICBzdHJpa2V0aHJvdWdocG9zaXRpb246IFwic3RyaWtldGhyb3VnaFBvc2l0aW9uXCIsXG4gICAgICAgIFwic3RyaWtldGhyb3VnaC1wb3NpdGlvblwiOiBcInN0cmlrZXRocm91Z2hQb3NpdGlvblwiLFxuICAgICAgICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiBcInN0cmlrZXRocm91Z2hUaGlja25lc3NcIixcbiAgICAgICAgXCJzdHJpa2V0aHJvdWdoLXRoaWNrbmVzc1wiOiBcInN0cmlrZXRocm91Z2hUaGlja25lc3NcIixcbiAgICAgICAgc3RyaW5nOiBcInN0cmluZ1wiLFxuICAgICAgICBzdHJva2U6IFwic3Ryb2tlXCIsXG4gICAgICAgIHN0cm9rZWRhc2hhcnJheTogXCJzdHJva2VEYXNoYXJyYXlcIixcbiAgICAgICAgXCJzdHJva2UtZGFzaGFycmF5XCI6IFwic3Ryb2tlRGFzaGFycmF5XCIsXG4gICAgICAgIHN0cm9rZWRhc2hvZmZzZXQ6IFwic3Ryb2tlRGFzaG9mZnNldFwiLFxuICAgICAgICBcInN0cm9rZS1kYXNob2Zmc2V0XCI6IFwic3Ryb2tlRGFzaG9mZnNldFwiLFxuICAgICAgICBzdHJva2VsaW5lY2FwOiBcInN0cm9rZUxpbmVjYXBcIixcbiAgICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiBcInN0cm9rZUxpbmVjYXBcIixcbiAgICAgICAgc3Ryb2tlbGluZWpvaW46IFwic3Ryb2tlTGluZWpvaW5cIixcbiAgICAgICAgXCJzdHJva2UtbGluZWpvaW5cIjogXCJzdHJva2VMaW5lam9pblwiLFxuICAgICAgICBzdHJva2VtaXRlcmxpbWl0OiBcInN0cm9rZU1pdGVybGltaXRcIixcbiAgICAgICAgXCJzdHJva2UtbWl0ZXJsaW1pdFwiOiBcInN0cm9rZU1pdGVybGltaXRcIixcbiAgICAgICAgc3Ryb2tld2lkdGg6IFwic3Ryb2tlV2lkdGhcIixcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogXCJzdHJva2VXaWR0aFwiLFxuICAgICAgICBzdHJva2VvcGFjaXR5OiBcInN0cm9rZU9wYWNpdHlcIixcbiAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiBcInN0cm9rZU9wYWNpdHlcIixcbiAgICAgICAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiLFxuICAgICAgICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6IFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIsXG4gICAgICAgIHN1cmZhY2VzY2FsZTogXCJzdXJmYWNlU2NhbGVcIixcbiAgICAgICAgc3lzdGVtbGFuZ3VhZ2U6IFwic3lzdGVtTGFuZ3VhZ2VcIixcbiAgICAgICAgdGFibGV2YWx1ZXM6IFwidGFibGVWYWx1ZXNcIixcbiAgICAgICAgdGFyZ2V0eDogXCJ0YXJnZXRYXCIsXG4gICAgICAgIHRhcmdldHk6IFwidGFyZ2V0WVwiLFxuICAgICAgICB0ZXh0YW5jaG9yOiBcInRleHRBbmNob3JcIixcbiAgICAgICAgXCJ0ZXh0LWFuY2hvclwiOiBcInRleHRBbmNob3JcIixcbiAgICAgICAgdGV4dGRlY29yYXRpb246IFwidGV4dERlY29yYXRpb25cIixcbiAgICAgICAgXCJ0ZXh0LWRlY29yYXRpb25cIjogXCJ0ZXh0RGVjb3JhdGlvblwiLFxuICAgICAgICB0ZXh0bGVuZ3RoOiBcInRleHRMZW5ndGhcIixcbiAgICAgICAgdGV4dHJlbmRlcmluZzogXCJ0ZXh0UmVuZGVyaW5nXCIsXG4gICAgICAgIFwidGV4dC1yZW5kZXJpbmdcIjogXCJ0ZXh0UmVuZGVyaW5nXCIsXG4gICAgICAgIHRvOiBcInRvXCIsXG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgdHJhbnNmb3Jtb3JpZ2luOiBcInRyYW5zZm9ybU9yaWdpblwiLFxuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogXCJ0cmFuc2Zvcm1PcmlnaW5cIixcbiAgICAgICAgdHlwZW9mOiBcInR5cGVvZlwiLFxuICAgICAgICB1MTogXCJ1MVwiLFxuICAgICAgICB1MjogXCJ1MlwiLFxuICAgICAgICB1bmRlcmxpbmVwb3NpdGlvbjogXCJ1bmRlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICBcInVuZGVybGluZS1wb3NpdGlvblwiOiBcInVuZGVybGluZVBvc2l0aW9uXCIsXG4gICAgICAgIHVuZGVybGluZXRoaWNrbmVzczogXCJ1bmRlcmxpbmVUaGlja25lc3NcIixcbiAgICAgICAgXCJ1bmRlcmxpbmUtdGhpY2tuZXNzXCI6IFwidW5kZXJsaW5lVGhpY2tuZXNzXCIsXG4gICAgICAgIHVuaWNvZGU6IFwidW5pY29kZVwiLFxuICAgICAgICB1bmljb2RlYmlkaTogXCJ1bmljb2RlQmlkaVwiLFxuICAgICAgICBcInVuaWNvZGUtYmlkaVwiOiBcInVuaWNvZGVCaWRpXCIsXG4gICAgICAgIHVuaWNvZGVyYW5nZTogXCJ1bmljb2RlUmFuZ2VcIixcbiAgICAgICAgXCJ1bmljb2RlLXJhbmdlXCI6IFwidW5pY29kZVJhbmdlXCIsXG4gICAgICAgIHVuaXRzcGVyZW06IFwidW5pdHNQZXJFbVwiLFxuICAgICAgICBcInVuaXRzLXBlci1lbVwiOiBcInVuaXRzUGVyRW1cIixcbiAgICAgICAgdW5zZWxlY3RhYmxlOiBcInVuc2VsZWN0YWJsZVwiLFxuICAgICAgICB2YWxwaGFiZXRpYzogXCJ2QWxwaGFiZXRpY1wiLFxuICAgICAgICBcInYtYWxwaGFiZXRpY1wiOiBcInZBbHBoYWJldGljXCIsXG4gICAgICAgIHZhbHVlczogXCJ2YWx1ZXNcIixcbiAgICAgICAgdmVjdG9yZWZmZWN0OiBcInZlY3RvckVmZmVjdFwiLFxuICAgICAgICBcInZlY3Rvci1lZmZlY3RcIjogXCJ2ZWN0b3JFZmZlY3RcIixcbiAgICAgICAgdmVyc2lvbjogXCJ2ZXJzaW9uXCIsXG4gICAgICAgIHZlcnRhZHZ5OiBcInZlcnRBZHZZXCIsXG4gICAgICAgIFwidmVydC1hZHYteVwiOiBcInZlcnRBZHZZXCIsXG4gICAgICAgIHZlcnRvcmlnaW54OiBcInZlcnRPcmlnaW5YXCIsXG4gICAgICAgIFwidmVydC1vcmlnaW4teFwiOiBcInZlcnRPcmlnaW5YXCIsXG4gICAgICAgIHZlcnRvcmlnaW55OiBcInZlcnRPcmlnaW5ZXCIsXG4gICAgICAgIFwidmVydC1vcmlnaW4teVwiOiBcInZlcnRPcmlnaW5ZXCIsXG4gICAgICAgIHZoYW5naW5nOiBcInZIYW5naW5nXCIsXG4gICAgICAgIFwidi1oYW5naW5nXCI6IFwidkhhbmdpbmdcIixcbiAgICAgICAgdmlkZW9ncmFwaGljOiBcInZJZGVvZ3JhcGhpY1wiLFxuICAgICAgICBcInYtaWRlb2dyYXBoaWNcIjogXCJ2SWRlb2dyYXBoaWNcIixcbiAgICAgICAgdmlld2JveDogXCJ2aWV3Qm94XCIsXG4gICAgICAgIHZpZXd0YXJnZXQ6IFwidmlld1RhcmdldFwiLFxuICAgICAgICB2aXNpYmlsaXR5OiBcInZpc2liaWxpdHlcIixcbiAgICAgICAgdm1hdGhlbWF0aWNhbDogXCJ2TWF0aGVtYXRpY2FsXCIsXG4gICAgICAgIFwidi1tYXRoZW1hdGljYWxcIjogXCJ2TWF0aGVtYXRpY2FsXCIsXG4gICAgICAgIHZvY2FiOiBcInZvY2FiXCIsXG4gICAgICAgIHdpZHRoczogXCJ3aWR0aHNcIixcbiAgICAgICAgd29yZHNwYWNpbmc6IFwid29yZFNwYWNpbmdcIixcbiAgICAgICAgXCJ3b3JkLXNwYWNpbmdcIjogXCJ3b3JkU3BhY2luZ1wiLFxuICAgICAgICB3cml0aW5nbW9kZTogXCJ3cml0aW5nTW9kZVwiLFxuICAgICAgICBcIndyaXRpbmctbW9kZVwiOiBcIndyaXRpbmdNb2RlXCIsXG4gICAgICAgIHgxOiBcIngxXCIsXG4gICAgICAgIHgyOiBcIngyXCIsXG4gICAgICAgIHg6IFwieFwiLFxuICAgICAgICB4Y2hhbm5lbHNlbGVjdG9yOiBcInhDaGFubmVsU2VsZWN0b3JcIixcbiAgICAgICAgeGhlaWdodDogXCJ4SGVpZ2h0XCIsXG4gICAgICAgIFwieC1oZWlnaHRcIjogXCJ4SGVpZ2h0XCIsXG4gICAgICAgIHhsaW5rYWN0dWF0ZTogXCJ4bGlua0FjdHVhdGVcIixcbiAgICAgICAgXCJ4bGluazphY3R1YXRlXCI6IFwieGxpbmtBY3R1YXRlXCIsXG4gICAgICAgIHhsaW5rYXJjcm9sZTogXCJ4bGlua0FyY3JvbGVcIixcbiAgICAgICAgXCJ4bGluazphcmNyb2xlXCI6IFwieGxpbmtBcmNyb2xlXCIsXG4gICAgICAgIHhsaW5raHJlZjogXCJ4bGlua0hyZWZcIixcbiAgICAgICAgXCJ4bGluazpocmVmXCI6IFwieGxpbmtIcmVmXCIsXG4gICAgICAgIHhsaW5rcm9sZTogXCJ4bGlua1JvbGVcIixcbiAgICAgICAgXCJ4bGluazpyb2xlXCI6IFwieGxpbmtSb2xlXCIsXG4gICAgICAgIHhsaW5rc2hvdzogXCJ4bGlua1Nob3dcIixcbiAgICAgICAgXCJ4bGluazpzaG93XCI6IFwieGxpbmtTaG93XCIsXG4gICAgICAgIHhsaW5rdGl0bGU6IFwieGxpbmtUaXRsZVwiLFxuICAgICAgICBcInhsaW5rOnRpdGxlXCI6IFwieGxpbmtUaXRsZVwiLFxuICAgICAgICB4bGlua3R5cGU6IFwieGxpbmtUeXBlXCIsXG4gICAgICAgIFwieGxpbms6dHlwZVwiOiBcInhsaW5rVHlwZVwiLFxuICAgICAgICB4bWxiYXNlOiBcInhtbEJhc2VcIixcbiAgICAgICAgXCJ4bWw6YmFzZVwiOiBcInhtbEJhc2VcIixcbiAgICAgICAgeG1sbGFuZzogXCJ4bWxMYW5nXCIsXG4gICAgICAgIFwieG1sOmxhbmdcIjogXCJ4bWxMYW5nXCIsXG4gICAgICAgIHhtbG5zOiBcInhtbG5zXCIsXG4gICAgICAgIFwieG1sOnNwYWNlXCI6IFwieG1sU3BhY2VcIixcbiAgICAgICAgeG1sbnN4bGluazogXCJ4bWxuc1hsaW5rXCIsXG4gICAgICAgIFwieG1sbnM6eGxpbmtcIjogXCJ4bWxuc1hsaW5rXCIsXG4gICAgICAgIHhtbHNwYWNlOiBcInhtbFNwYWNlXCIsXG4gICAgICAgIHkxOiBcInkxXCIsXG4gICAgICAgIHkyOiBcInkyXCIsXG4gICAgICAgIHk6IFwieVwiLFxuICAgICAgICB5Y2hhbm5lbHNlbGVjdG9yOiBcInlDaGFubmVsU2VsZWN0b3JcIixcbiAgICAgICAgejogXCJ6XCIsXG4gICAgICAgIHpvb21hbmRwYW46IFwiem9vbUFuZFBhblwiXG4gICAgICB9LFxuICAgICAgd2FybmVkUHJvcGVydGllcyA9IHt9LFxuICAgICAgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLyxcbiAgICAgIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vLFxuICAgICAgckFSSUEgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKS1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICByQVJJQUNhbWVsID0gUmVnRXhwKFxuICAgICAgICBcIl4oYXJpYSlbQS1aXVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLyxcbiAgICAgIG1zUGF0dGVybiQxID0gL14tbXMtLyxcbiAgICAgIGh5cGhlblBhdHRlcm4gPSAvLSguKS9nLFxuICAgICAgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC8sXG4gICAgICB3YXJuZWRTdHlsZU5hbWVzID0ge30sXG4gICAgICB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9LFxuICAgICAgd2FybmVkRm9yTmFOVmFsdWUgPSAhMSxcbiAgICAgIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSAhMSxcbiAgICAgIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS8sXG4gICAgICB1cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZyxcbiAgICAgIG1zUGF0dGVybiA9IC9ebXMtLyxcbiAgICAgIGlzSmF2YVNjcmlwdFByb3RvY29sID1cbiAgICAgICAgL15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKjovaSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdERPTS5fX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBOb3RQZW5kaW5nID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHBlbmRpbmc6ICExLFxuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBtZXRob2Q6IG51bGwsXG4gICAgICAgIGFjdGlvbjogbnVsbFxuICAgICAgfSksXG4gICAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5kO1xuICAgIFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLmQgPSB7XG4gICAgICBmOiBwcmV2aW91c0Rpc3BhdGNoZXIuZixcbiAgICAgIHI6IHByZXZpb3VzRGlzcGF0Y2hlci5yLFxuICAgICAgRDogZnVuY3Rpb24gKGhyZWYpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VtYWJsZVN0YXRlLmRuc1Jlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSkge1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5kbnNSZXNvdXJjZXNbaHJlZl0gPSBFWElTVFM7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlID0gcmVuZGVyU3RhdGUuaGVhZGVycztcbiAgICAgICAgICAgICAgdmFyIGhlYWRlciwgSlNDb21waWxlcl90ZW1wO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSAmJiAwIDwgcmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgKChoZWFkZXIgPVxuICAgICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmKSArXG4gICAgICAgICAgICAgICAgICAgIFwiPjsgcmVsPWRucy1wcmVmZXRjaFwiKSxcbiAgICAgICAgICAgICAgICAgIDAgPD0gKHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGggKyAyKSk7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcFxuICAgICAgICAgICAgICAgID8gKChyZW5kZXJTdGF0ZS5yZXNldHMuZG5zW2hyZWZdID0gRVhJU1RTKSxcbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICYmXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICs9IGhlYWRlcikpXG4gICAgICAgICAgICAgICAgOiAoKGhlYWRlciA9IFtdKSxcbiAgICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChoZWFkZXIsIHsgaHJlZjogaHJlZiwgcmVsOiBcImRucy1wcmVmZXRjaFwiIH0pLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuYWRkKGhlYWRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5EKGhyZWYpO1xuICAgICAgfSxcbiAgICAgIEM6IGZ1bmN0aW9uIChocmVmLCBjcm9zc09yaWdpbikge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWYpIHtcbiAgICAgICAgICAgIHZhciBidWNrZXQgPVxuICAgICAgICAgICAgICBcInVzZS1jcmVkZW50aWFsc1wiID09PSBjcm9zc09yaWdpblxuICAgICAgICAgICAgICAgID8gXCJjcmVkZW50aWFsc1wiXG4gICAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgID8gXCJhbm9ueW1vdXNcIlxuICAgICAgICAgICAgICAgICAgOiBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgIGlmICghcmVzdW1hYmxlU3RhdGUuY29ubmVjdFJlc291cmNlc1tidWNrZXRdLmhhc093blByb3BlcnR5KGhyZWYpKSB7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmNvbm5lY3RSZXNvdXJjZXNbYnVja2V0XVtocmVmXSA9IEVYSVNUUztcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgICAgICB2YXIgaGVhZGVyLCBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlICYmIDAgPCByZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSlcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgICAgICAgIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmKSArXG4gICAgICAgICAgICAgICAgICBcIj47IHJlbD1wcmVjb25uZWN0XCI7XG4gICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjcm9zc09yaWdpbikge1xuICAgICAgICAgICAgICAgICAgdmFyIGVzY2FwZWRDcm9zc09yaWdpbiA9XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dChcbiAgICAgICAgICAgICAgICAgICAgICBjcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICBcImNyb3NzT3JpZ2luXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCArPVxuICAgICAgICAgICAgICAgICAgICAnOyBjcm9zc29yaWdpbj1cIicgKyBlc2NhcGVkQ3Jvc3NPcmlnaW4gKyAnXCInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgKChoZWFkZXIgPSBKU0NvbXBpbGVyX3RlbXApLFxuICAgICAgICAgICAgICAgICAgMCA8PSAocmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCArIDIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXBcbiAgICAgICAgICAgICAgICA/ICgocmVuZGVyU3RhdGUucmVzZXRzLmNvbm5lY3RbYnVja2V0XVtocmVmXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyAmJlxuICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyArPSBoZWFkZXIpKVxuICAgICAgICAgICAgICAgIDogKChidWNrZXQgPSBbXSksXG4gICAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwoYnVja2V0LCB7XG4gICAgICAgICAgICAgICAgICAgIHJlbDogXCJwcmVjb25uZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5hZGQoYnVja2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLkMoaHJlZiwgY3Jvc3NPcmlnaW4pO1xuICAgICAgfSxcbiAgICAgIEw6IGZ1bmN0aW9uIChocmVmLCBhcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKGFzICYmIGhyZWYpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXMpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVNyY1NldCA9IG9wdGlvbnMuaW1hZ2VTcmNTZXQ7XG4gICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VTaXplcyA9IG9wdGlvbnMuaW1hZ2VTaXplcztcbiAgICAgICAgICAgICAgICAgIHZhciBmZXRjaFByaW9yaXR5ID0gb3B0aW9ucy5mZXRjaFByaW9yaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gaW1hZ2VTcmNTZXRcbiAgICAgICAgICAgICAgICAgID8gaW1hZ2VTcmNTZXQgKyBcIlxcblwiICsgKGltYWdlU2l6ZXMgfHwgXCJcIilcbiAgICAgICAgICAgICAgICAgIDogaHJlZjtcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmltYWdlUmVzb3VyY2VzW2tleV0gPSBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlID0gcmVuZGVyU3RhdGUuaGVhZGVycztcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgMCA8IHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5ICYmXG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGltYWdlU3JjU2V0ICYmXG4gICAgICAgICAgICAgICAgXCJoaWdoXCIgPT09IGZldGNoUHJpb3JpdHkgJiZcbiAgICAgICAgICAgICAgICAoKGhlYWRlciA9IGdldFByZWxvYWRBc0hlYWRlcihocmVmLCBhcywgb3B0aW9ucykpLFxuICAgICAgICAgICAgICAgIDAgPD0gKHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGggKyAyKSlcbiAgICAgICAgICAgICAgICAgID8gKChyZW5kZXJTdGF0ZS5yZXNldHMuaW1hZ2Vba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFMpLFxuICAgICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5oaWdoSW1hZ2VQcmVsb2FkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5oaWdoSW1hZ2VQcmVsb2FkcyArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMgKz0gaGVhZGVyKSlcbiAgICAgICAgICAgICAgICAgIDogKChyZXN1bWFibGVTdGF0ZSA9IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogaW1hZ2VTcmNTZXQgPyB2b2lkIDAgOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhczogYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBcImhpZ2hcIiA9PT0gZmV0Y2hQcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICAgID8gcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc3VtYWJsZVN0YXRlKVxuICAgICAgICAgICAgICAgICAgICAgIDogKHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQocmVzdW1hYmxlU3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuaW1hZ2VzLnNldChrZXksIHJlc3VtYWJsZVN0YXRlKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpbWFnZVNyY1NldCA9IFtdO1xuICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChcbiAgICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0LFxuICAgICAgICAgICAgICAgICAgYXNzaWduKHsgcmVsOiBcInByZWxvYWRcIiwgaHJlZjogaHJlZiwgYXM6IGFzIH0sIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tocmVmXSA9XG4gICAgICAgICAgICAgICAgICAhb3B0aW9ucyB8fFxuICAgICAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSlcbiAgICAgICAgICAgICAgICAgICAgPyBQUkVMT0FEX05PX0NSRURTXG4gICAgICAgICAgICAgICAgICAgIDogW29wdGlvbnMuY3Jvc3NPcmlnaW4sIG9wdGlvbnMuaW50ZWdyaXR5XTtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zdHlsZXNoZWV0cy5zZXQoaHJlZiwgaW1hZ2VTcmNTZXQpO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQoaW1hZ2VTcmNTZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0ID0gW107XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuc2NyaXB0cy5zZXQoaHJlZiwgaW1hZ2VTcmNTZXQpO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQoaW1hZ2VTcmNTZXQpO1xuICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChcbiAgICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0LFxuICAgICAgICAgICAgICAgICAgYXNzaWduKHsgcmVsOiBcInByZWxvYWRcIiwgaHJlZjogaHJlZiwgYXM6IGFzIH0sIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNbaHJlZl0gPVxuICAgICAgICAgICAgICAgICAgIW9wdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5jcm9zc09yaWdpbiAmJlxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkpXG4gICAgICAgICAgICAgICAgICAgID8gUFJFTE9BRF9OT19DUkVEU1xuICAgICAgICAgICAgICAgICAgICA6IFtvcHRpb25zLmNyb3NzT3JpZ2luLCBvcHRpb25zLmludGVncml0eV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoYXMpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICgoaW1hZ2VTcmNTZXQgPSByZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzW2FzXSksXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0Lmhhc093blByb3BlcnR5KGhyZWYpKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAoaW1hZ2VTcmNTZXQgPSB7fSksXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzW2FzXSA9IGltYWdlU3JjU2V0KTtcbiAgICAgICAgICAgICAgICBpbWFnZVNyY1NldFtocmVmXSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlID0gcmVuZGVyU3RhdGUuaGVhZGVycykgJiZcbiAgICAgICAgICAgICAgICAgIDAgPCByZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAmJlxuICAgICAgICAgICAgICAgICAgXCJmb250XCIgPT09IGFzICYmXG4gICAgICAgICAgICAgICAgICAoKGtleSA9IGdldFByZWxvYWRBc0hlYWRlcihocmVmLCBhcywgb3B0aW9ucykpLFxuICAgICAgICAgICAgICAgICAgMCA8PSAocmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgLT0ga2V5Lmxlbmd0aCArIDIpKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZXNldHMuZm9udFtocmVmXSA9IFBSRUxPQURfTk9fQ1JFRFMpLFxuICAgICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5mb250UHJlbG9hZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUuZm9udFByZWxvYWRzICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5mb250UHJlbG9hZHMgKz0ga2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgICAgICAgICAgICAoKHJlc3VtYWJsZVN0YXRlID0gW10pLFxuICAgICAgICAgICAgICAgICAgICAoaHJlZiA9IGFzc2lnbihcbiAgICAgICAgICAgICAgICAgICAgICB7IHJlbDogXCJwcmVsb2FkXCIsIGhyZWY6IGhyZWYsIGFzOiBhcyB9LFxuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChyZXN1bWFibGVTdGF0ZSwgaHJlZiksXG4gICAgICAgICAgICAgICAgICAgIGFzKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb250XCI6XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuZm9udFByZWxvYWRzLmFkZChyZXN1bWFibGVTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChyZXN1bWFibGVTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLkwoaHJlZiwgYXMsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgICAgdmFyIGFzID1cbiAgICAgICAgICAgICAgb3B0aW9ucyAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hcyA/IG9wdGlvbnMuYXMgOiBcInNjcmlwdFwiO1xuICAgICAgICAgICAgc3dpdGNoIChhcykge1xuICAgICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSlcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBhcyA9IFtdO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlc1tocmVmXSA9XG4gICAgICAgICAgICAgICAgICAhb3B0aW9ucyB8fFxuICAgICAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSlcbiAgICAgICAgICAgICAgICAgICAgPyBQUkVMT0FEX05PX0NSRURTXG4gICAgICAgICAgICAgICAgICAgIDogW29wdGlvbnMuY3Jvc3NPcmlnaW4sIG9wdGlvbnMuaW50ZWdyaXR5XTtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5tb2R1bGVTY3JpcHRzLnNldChocmVmLCBhcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLm1vZHVsZVVua25vd25SZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoYXMpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VzID0gcmVzdW1hYmxlU3RhdGUudW5rbm93blJlc291cmNlc1thc107XG4gICAgICAgICAgICAgICAgICBpZiAocmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAocmVzb3VyY2VzID0ge30pLFxuICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUubW9kdWxlVW5rbm93blJlc291cmNlc1thc10gPSByZXNvdXJjZXMpO1xuICAgICAgICAgICAgICAgIGFzID0gW107XG4gICAgICAgICAgICAgICAgcmVzb3VyY2VzW2hyZWZdID0gUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHB1c2hMaW5rSW1wbChcbiAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgIGFzc2lnbih7IHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsIGhyZWY6IGhyZWYgfSwgb3B0aW9ucylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKGFzKTtcbiAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIubShocmVmLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBYOiBmdW5jdGlvbiAoc3JjLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2VTdGF0ZSA9IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgc3JjXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgID8gcmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzW3NyY11cbiAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXNvdXJjZVN0YXRlICE9PSBFWElTVFMgJiZcbiAgICAgICAgICAgICAgKChyZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNbc3JjXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgIChvcHRpb25zID0gYXNzaWduKHsgc3JjOiBzcmMsIGFzeW5jOiAhMCB9LCBvcHRpb25zKSksXG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAoMiA9PT0gcmVzb3VyY2VTdGF0ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKG9wdGlvbnMsIHJlc291cmNlU3RhdGUpLFxuICAgICAgICAgICAgICAgIChzcmMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zY3JpcHRzLmdldChzcmMpKSkgJiZcbiAgICAgICAgICAgICAgICAoc3JjLmxlbmd0aCA9IDApLFxuICAgICAgICAgICAgICAoc3JjID0gW10pLFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmFkZChzcmMpLFxuICAgICAgICAgICAgICBwdXNoU2NyaXB0SW1wbChzcmMsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5YKHNyYywgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgUzogZnVuY3Rpb24gKGhyZWYsIHByZWNlZGVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICBwcmVjZWRlbmNlID0gcHJlY2VkZW5jZSB8fCBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgIHZhciBzdHlsZVF1ZXVlID0gcmVuZGVyU3RhdGUuc3R5bGVzLmdldChwcmVjZWRlbmNlKSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSA9IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpXG4gICAgICAgICAgICAgICAgPyByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tocmVmXVxuICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTICYmXG4gICAgICAgICAgICAgICgocmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNbaHJlZl0gPSBFWElTVFMpLFxuICAgICAgICAgICAgICBzdHlsZVF1ZXVlIHx8XG4gICAgICAgICAgICAgICAgKChzdHlsZVF1ZXVlID0ge1xuICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSksXG4gICAgICAgICAgICAgICAgICBydWxlczogW10sXG4gICAgICAgICAgICAgICAgICBocmVmczogW10sXG4gICAgICAgICAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5zZXQocHJlY2VkZW5jZSwgc3R5bGVRdWV1ZSkpLFxuICAgICAgICAgICAgICAocHJlY2VkZW5jZSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogUEVORElORyQxLFxuICAgICAgICAgICAgICAgIHByb3BzOiBhc3NpZ24oXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlbDogXCJzdHlsZXNoZWV0XCIsXG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgIFwiZGF0YS1wcmVjZWRlbmNlXCI6IHByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICgyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMocHJlY2VkZW5jZS5wcm9wcywgcmVzb3VyY2VTdGF0ZSksXG4gICAgICAgICAgICAgICAgKHJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuZ2V0KGhyZWYpKSAmJlxuICAgICAgICAgICAgICAgIDAgPCByZW5kZXJTdGF0ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gKHJlbmRlclN0YXRlLmxlbmd0aCA9IDApXG4gICAgICAgICAgICAgICAgICA6IChwcmVjZWRlbmNlLnN0YXRlID0gUFJFTE9BREVEKSksXG4gICAgICAgICAgICAgIHN0eWxlUXVldWUuc2hlZXRzLnNldChocmVmLCBwcmVjZWRlbmNlKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuUyhocmVmLCBwcmVjZWRlbmNlLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBNOiBmdW5jdGlvbiAoc3JjLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2VTdGF0ZSA9XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShzcmMpXG4gICAgICAgICAgICAgICAgPyByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXNbc3JjXVxuICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTICYmXG4gICAgICAgICAgICAgICgocmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW3NyY10gPSBFWElTVFMpLFxuICAgICAgICAgICAgICAob3B0aW9ucyA9IGFzc2lnbihcbiAgICAgICAgICAgICAgICB7IHNyYzogc3JjLCB0eXBlOiBcIm1vZHVsZVwiLCBhc3luYzogITAgfSxcbiAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgKDIgPT09IHJlc291cmNlU3RhdGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhvcHRpb25zLCByZXNvdXJjZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAoc3JjID0gcmVuZGVyU3RhdGUucHJlbG9hZHMubW9kdWxlU2NyaXB0cy5nZXQoc3JjKSkpICYmXG4gICAgICAgICAgICAgICAgKHNyYy5sZW5ndGggPSAwKSxcbiAgICAgICAgICAgICAgKHNyYyA9IFtdKSxcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2NyaXB0cy5hZGQoc3JjKSxcbiAgICAgICAgICAgICAgcHVzaFNjcmlwdEltcGwoc3JjLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuTShzcmMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIE5vdGhpbmdTZW50ID0gMCxcbiAgICAgIFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbiA9IDEsXG4gICAgICBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uID0gMixcbiAgICAgIFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbiA9IDQsXG4gICAgICBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbiA9IDgsXG4gICAgICBFWElTVFMgPSBudWxsLFxuICAgICAgUFJFTE9BRF9OT19DUkVEUyA9IFtdO1xuICAgIE9iamVjdC5mcmVlemUoUFJFTE9BRF9OT19DUkVEUyk7XG4gICAgdmFyIHNjcmlwdFJlZ2V4ID0gLyg8XFwvfDwpKHMpKGNyaXB0KS9naTtcbiAgICB2YXIgZGlkV2FybkZvck5ld0Jvb2xlYW5Qcm9wc1dpdGhFbXB0eVZhbHVlID0ge307XG4gICAgdmFyIE5vQ29udHJpYnV0aW9uID0gMCxcbiAgICAgIFJPT1RfSFRNTF9NT0RFID0gMCxcbiAgICAgIEhUTUxfSFRNTF9NT0RFID0gMSxcbiAgICAgIEhUTUxfTU9ERSA9IDIsXG4gICAgICBIVE1MX0hFQURfTU9ERSA9IDMsXG4gICAgICBTVkdfTU9ERSA9IDQsXG4gICAgICBNQVRITUxfTU9ERSA9IDUsXG4gICAgICBIVE1MX1RBQkxFX01PREUgPSA2LFxuICAgICAgSFRNTF9UQUJMRV9CT0RZX01PREUgPSA3LFxuICAgICAgSFRNTF9UQUJMRV9ST1dfTU9ERSA9IDgsXG4gICAgICBIVE1MX0NPTEdST1VQX01PREUgPSA5LFxuICAgICAgc3R5bGVOYW1lQ2FjaGUgPSBuZXcgTWFwKCksXG4gICAgICBzdHlsZUF0dHJpYnV0ZVN0YXJ0ID0gJyBzdHlsZT1cIicsXG4gICAgICBzdHlsZUFzc2lnbiA9IFwiOlwiLFxuICAgICAgc3R5bGVTZXBhcmF0b3IgPSBcIjtcIixcbiAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvciA9IFwiIFwiLFxuICAgICAgYXR0cmlidXRlQXNzaWduID0gJz1cIicsXG4gICAgICBhdHRyaWJ1dGVFbmQgPSAnXCInLFxuICAgICAgYXR0cmlidXRlRW1wdHlTdHJpbmcgPSAnPVwiXCInLFxuICAgICAgYWN0aW9uSmF2YVNjcmlwdFVSTCA9IGVzY2FwZVRleHRGb3JCcm93c2VyKFxuICAgICAgICBcImphdmFzY3JpcHQ6dGhyb3cgbmV3IEVycm9yKCdSZWFjdCBmb3JtIHVuZXhwZWN0ZWRseSBzdWJtaXR0ZWQuJylcIlxuICAgICAgKSxcbiAgICAgIGVuZE9mU3RhcnRUYWcgPSBcIj5cIixcbiAgICAgIGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyA9IFwiLz5cIixcbiAgICAgIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9ICExLFxuICAgICAgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gITEsXG4gICAgICBkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlID0gITEsXG4gICAgICBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSAhMSxcbiAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSAhMSxcbiAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MID0gITEsXG4gICAgICBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9ICExLFxuICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlID0gITEsXG4gICAgICBkaWRXYXJuRm9ybUFjdGlvbk5hbWUgPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gITEsXG4gICAgICBkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCA9ICExLFxuICAgICAgZm9ybVJlcGxheWluZ1J1bnRpbWVTY3JpcHQgPVxuICAgICAgICAnYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLGZ1bmN0aW9uKGEpe2lmKCFhLmRlZmF1bHRQcmV2ZW50ZWQpe3ZhciBjPWEudGFyZ2V0LGQ9YS5zdWJtaXR0ZXIsZT1jLmFjdGlvbixiPWQ7aWYoZCl7dmFyIGY9ZC5nZXRBdHRyaWJ1dGUoXCJmb3JtQWN0aW9uXCIpO251bGwhPWYmJihlPWYsYj1udWxsKX1cImphdmFzY3JpcHQ6dGhyb3cgbmV3IEVycm9yKFxcJ1JlYWN0IGZvcm0gdW5leHBlY3RlZGx5IHN1Ym1pdHRlZC5cXCcpXCI9PT1lJiYoYS5wcmV2ZW50RGVmYXVsdCgpLGI/KGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLGEubmFtZT1iLm5hbWUsYS52YWx1ZT1iLnZhbHVlLGIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxiKSxiPW5ldyBGb3JtRGF0YShjKSxhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSkpOmI9bmV3IEZvcm1EYXRhKGMpLGE9Yy5vd25lckRvY3VtZW50fHxjLChhLiQkcmVhY3RGb3JtUmVwbGF5PWEuJCRyZWFjdEZvcm1SZXBsYXl8fFtdKS5wdXNoKGMsZCxiKSl9fSk7JyxcbiAgICAgIHN0eWxlUmVnZXggPSAvKDxcXC98PCkocykodHlsZSkvZ2ksXG4gICAgICBsZWFkaW5nTmV3bGluZSA9IFwiXFxuXCIsXG4gICAgICBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLyxcbiAgICAgIHZhbGlkYXRlZFRhZ0NhY2hlID0gbmV3IE1hcCgpLFxuICAgICAgZW5kVGFnQ2FjaGUgPSBuZXcgTWFwKCksXG4gICAgICBwbGFjZWhvbGRlcjEgPSAnPHRlbXBsYXRlIGlkPVwiJyxcbiAgICAgIHBsYWNlaG9sZGVyMiA9ICdcIj48L3RlbXBsYXRlPicsXG4gICAgICBzdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkgPSBcIlxceDNjIS0tJC0tXFx4M2VcIixcbiAgICAgIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxID0gJ1xceDNjIS0tJD8tLVxceDNlPHRlbXBsYXRlIGlkPVwiJyxcbiAgICAgIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkyID0gJ1wiPjwvdGVtcGxhdGU+JyxcbiAgICAgIHN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5ID0gXCJcXHgzYyEtLSQhLS1cXHgzZVwiLFxuICAgICAgZW5kU3VzcGVuc2VCb3VuZGFyeSA9IFwiXFx4M2MhLS0vJC0tXFx4M2VcIixcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMSA9IFwiPHRlbXBsYXRlXCIsXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwgPSAnXCInLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQSA9ICcgZGF0YS1kZ3N0PVwiJyxcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUIgPSAnIGRhdGEtbXNnPVwiJyxcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMgPSAnIGRhdGEtc3Rjaz1cIicsXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFEID0gJyBkYXRhLWNzdGNrPVwiJyxcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMiA9IFwiPjwvdGVtcGxhdGU+XCIsXG4gICAgICBib3VuZGFyeVByZWFtYmxlQ29udHJpYnV0aW9uQ2h1bmtTdGFydCA9IFwiXFx4M2MhLS1cIixcbiAgICAgIGJvdW5kYXJ5UHJlYW1ibGVDb250cmlidXRpb25DaHVua0VuZCA9IFwiLS1cXHgzZVwiLFxuICAgICAgc3RhcnRTZWdtZW50SFRNTCA9ICc8ZGl2IGhpZGRlbiBpZD1cIicsXG4gICAgICBzdGFydFNlZ21lbnRIVE1MMiA9ICdcIj4nLFxuICAgICAgZW5kU2VnbWVudEhUTUwgPSBcIjwvZGl2PlwiLFxuICAgICAgc3RhcnRTZWdtZW50U1ZHID0gJzxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIicsXG4gICAgICBzdGFydFNlZ21lbnRTVkcyID0gJ1wiPicsXG4gICAgICBlbmRTZWdtZW50U1ZHID0gXCI8L3N2Zz5cIixcbiAgICAgIHN0YXJ0U2VnbWVudE1hdGhNTCA9ICc8bWF0aCBhcmlhLWhpZGRlbj1cInRydWVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGlkPVwiJyxcbiAgICAgIHN0YXJ0U2VnbWVudE1hdGhNTDIgPSAnXCI+JyxcbiAgICAgIGVuZFNlZ21lbnRNYXRoTUwgPSBcIjwvbWF0aD5cIixcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlID0gJzx0YWJsZSBoaWRkZW4gaWQ9XCInLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGUyID0gJ1wiPicsXG4gICAgICBlbmRTZWdtZW50VGFibGUgPSBcIjwvdGFibGU+XCIsXG4gICAgICBzdGFydFNlZ21lbnRUYWJsZUJvZHkgPSAnPHRhYmxlIGhpZGRlbj48dGJvZHkgaWQ9XCInLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGVCb2R5MiA9ICdcIj4nLFxuICAgICAgZW5kU2VnbWVudFRhYmxlQm9keSA9IFwiPC90Ym9keT48L3RhYmxlPlwiLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGVSb3cgPSAnPHRhYmxlIGhpZGRlbj48dHIgaWQ9XCInLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGVSb3cyID0gJ1wiPicsXG4gICAgICBlbmRTZWdtZW50VGFibGVSb3cgPSBcIjwvdHI+PC90YWJsZT5cIixcbiAgICAgIHN0YXJ0U2VnbWVudENvbEdyb3VwID0gJzx0YWJsZSBoaWRkZW4+PGNvbGdyb3VwIGlkPVwiJyxcbiAgICAgIHN0YXJ0U2VnbWVudENvbEdyb3VwMiA9ICdcIj4nLFxuICAgICAgZW5kU2VnbWVudENvbEdyb3VwID0gXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIsXG4gICAgICBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxRnVsbCA9XG4gICAgICAgICckUlM9ZnVuY3Rpb24oYSxiKXthPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpO2I9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7Zm9yKGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKTthLmZpcnN0Q2hpbGQ7KWIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYS5maXJzdENoaWxkLGIpO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKX07JFJTKFwiJyxcbiAgICAgIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFQYXJ0aWFsID0gJyRSUyhcIicsXG4gICAgICBjb21wbGV0ZVNlZ21lbnRTY3JpcHQyID0gJ1wiLFwiJyxcbiAgICAgIGNvbXBsZXRlU2VnbWVudFNjcmlwdEVuZCA9ICdcIilcXHgzYy9zY3JpcHQ+JyxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxRnVsbCA9XG4gICAgICAgICckUkM9ZnVuY3Rpb24oYixjLGUpe2M9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYyk7Yy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpO3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2lmKGEpe2I9YS5wcmV2aW91c1NpYmxpbmc7aWYoZSliLmRhdGE9XCIkIVwiLGEuc2V0QXR0cmlidXRlKFwiZGF0YS1kZ3N0XCIsZSk7ZWxzZXtlPWIucGFyZW50Tm9kZTthPWIubmV4dFNpYmxpbmc7dmFyIGY9MDtkb3tpZihhJiY4PT09YS5ub2RlVHlwZSl7dmFyIGQ9YS5kYXRhO2lmKFwiLyRcIj09PWQpaWYoMD09PWYpYnJlYWs7ZWxzZSBmLS07ZWxzZVwiJFwiIT09ZCYmXCIkP1wiIT09ZCYmXCIkIVwiIT09ZHx8ZisrfWQ9YS5uZXh0U2libGluZztlLnJlbW92ZUNoaWxkKGEpO2E9ZH13aGlsZShhKTtmb3IoO2MuZmlyc3RDaGlsZDspZS5pbnNlcnRCZWZvcmUoYy5maXJzdENoaWxkLGEpO2IuZGF0YT1cIiRcIn1iLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCl9fTskUkMoXCInLFxuICAgICAgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFQYXJ0aWFsID0gJyRSQyhcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsQm90aCA9XG4gICAgICAgICckUkM9ZnVuY3Rpb24oYixjLGUpe2M9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYyk7Yy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpO3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2lmKGEpe2I9YS5wcmV2aW91c1NpYmxpbmc7aWYoZSliLmRhdGE9XCIkIVwiLGEuc2V0QXR0cmlidXRlKFwiZGF0YS1kZ3N0XCIsZSk7ZWxzZXtlPWIucGFyZW50Tm9kZTthPWIubmV4dFNpYmxpbmc7dmFyIGY9MDtkb3tpZihhJiY4PT09YS5ub2RlVHlwZSl7dmFyIGQ9YS5kYXRhO2lmKFwiLyRcIj09PWQpaWYoMD09PWYpYnJlYWs7ZWxzZSBmLS07ZWxzZVwiJFwiIT09ZCYmXCIkP1wiIT09ZCYmXCIkIVwiIT09ZHx8ZisrfWQ9YS5uZXh0U2libGluZztlLnJlbW92ZUNoaWxkKGEpO2E9ZH13aGlsZShhKTtmb3IoO2MuZmlyc3RDaGlsZDspZS5pbnNlcnRCZWZvcmUoYy5maXJzdENoaWxkLGEpO2IuZGF0YT1cIiRcIn1iLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCl9fTskUk09bmV3IE1hcDtcXG4kUlI9ZnVuY3Rpb24odCx1LHkpe2Z1bmN0aW9uIHYobil7dGhpcy5fcD1udWxsO24oKX1mb3IodmFyIHc9JFJDLHA9JFJNLHE9bmV3IE1hcCxyPWRvY3VtZW50LGcsYixoPXIucXVlcnlTZWxlY3RvckFsbChcImxpbmtbZGF0YS1wcmVjZWRlbmNlXSxzdHlsZVtkYXRhLXByZWNlZGVuY2VdXCIpLHg9W10saz0wO2I9aFtrKytdOylcIm5vdCBhbGxcIj09PWIuZ2V0QXR0cmlidXRlKFwibWVkaWFcIik/eC5wdXNoKGIpOihcIkxJTktcIj09PWIudGFnTmFtZSYmcC5zZXQoYi5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLGIpLHEuc2V0KGIuZGF0YXNldC5wcmVjZWRlbmNlLGc9YikpO2I9MDtoPVtdO3ZhciBsLGE7Zm9yKGs9ITA7Oyl7aWYoayl7dmFyIGU9eVtiKytdO2lmKCFlKXtrPSExO2I9MDtjb250aW51ZX12YXIgYz0hMSxtPTA7dmFyIGQ9ZVttKytdO2lmKGE9cC5nZXQoZCkpe3ZhciBmPWEuX3A7Yz0hMH1lbHNle2E9ci5jcmVhdGVFbGVtZW50KFwibGlua1wiKTthLmhyZWY9XFxuZDthLnJlbD1cInN0eWxlc2hlZXRcIjtmb3IoYS5kYXRhc2V0LnByZWNlZGVuY2U9bD1lW20rK107Zj1lW20rK107KWEuc2V0QXR0cmlidXRlKGYsZVttKytdKTtmPWEuX3A9bmV3IFByb21pc2UoZnVuY3Rpb24obix6KXthLm9ubG9hZD12LmJpbmQoYSxuKTthLm9uZXJyb3I9di5iaW5kKGEseil9KTtwLnNldChkLGEpfWQ9YS5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKTshZnx8ZCYmIW1hdGNoTWVkaWEoZCkubWF0Y2hlc3x8aC5wdXNoKGYpO2lmKGMpY29udGludWV9ZWxzZXthPXhbYisrXTtpZighYSlicmVhaztsPWEuZ2V0QXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpO2EucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIil9Yz1xLmdldChsKXx8ZztjPT09ZyYmKGc9YSk7cS5zZXQobCxhKTtjP2MucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxjLm5leHRTaWJsaW5nKTooYz1yLmhlYWQsYy5pbnNlcnRCZWZvcmUoYSxjLmZpcnN0Q2hpbGQpKX1Qcm9taXNlLmFsbChoKS50aGVuKHcuYmluZChudWxsLFxcbnQsdSxcIlwiKSx3LmJpbmQobnVsbCx0LHUsXCJSZXNvdXJjZSBmYWlsZWQgdG8gbG9hZFwiKSl9OyRSUihcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsUGFydGlhbCA9XG4gICAgICAgICckUk09bmV3IE1hcDtcXG4kUlI9ZnVuY3Rpb24odCx1LHkpe2Z1bmN0aW9uIHYobil7dGhpcy5fcD1udWxsO24oKX1mb3IodmFyIHc9JFJDLHA9JFJNLHE9bmV3IE1hcCxyPWRvY3VtZW50LGcsYixoPXIucXVlcnlTZWxlY3RvckFsbChcImxpbmtbZGF0YS1wcmVjZWRlbmNlXSxzdHlsZVtkYXRhLXByZWNlZGVuY2VdXCIpLHg9W10saz0wO2I9aFtrKytdOylcIm5vdCBhbGxcIj09PWIuZ2V0QXR0cmlidXRlKFwibWVkaWFcIik/eC5wdXNoKGIpOihcIkxJTktcIj09PWIudGFnTmFtZSYmcC5zZXQoYi5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLGIpLHEuc2V0KGIuZGF0YXNldC5wcmVjZWRlbmNlLGc9YikpO2I9MDtoPVtdO3ZhciBsLGE7Zm9yKGs9ITA7Oyl7aWYoayl7dmFyIGU9eVtiKytdO2lmKCFlKXtrPSExO2I9MDtjb250aW51ZX12YXIgYz0hMSxtPTA7dmFyIGQ9ZVttKytdO2lmKGE9cC5nZXQoZCkpe3ZhciBmPWEuX3A7Yz0hMH1lbHNle2E9ci5jcmVhdGVFbGVtZW50KFwibGlua1wiKTthLmhyZWY9XFxuZDthLnJlbD1cInN0eWxlc2hlZXRcIjtmb3IoYS5kYXRhc2V0LnByZWNlZGVuY2U9bD1lW20rK107Zj1lW20rK107KWEuc2V0QXR0cmlidXRlKGYsZVttKytdKTtmPWEuX3A9bmV3IFByb21pc2UoZnVuY3Rpb24obix6KXthLm9ubG9hZD12LmJpbmQoYSxuKTthLm9uZXJyb3I9di5iaW5kKGEseil9KTtwLnNldChkLGEpfWQ9YS5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKTshZnx8ZCYmIW1hdGNoTWVkaWEoZCkubWF0Y2hlc3x8aC5wdXNoKGYpO2lmKGMpY29udGludWV9ZWxzZXthPXhbYisrXTtpZighYSlicmVhaztsPWEuZ2V0QXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpO2EucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIil9Yz1xLmdldChsKXx8ZztjPT09ZyYmKGc9YSk7cS5zZXQobCxhKTtjP2MucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxjLm5leHRTaWJsaW5nKTooYz1yLmhlYWQsYy5pbnNlcnRCZWZvcmUoYSxjLmZpcnN0Q2hpbGQpKX1Qcm9taXNlLmFsbChoKS50aGVuKHcuYmluZChudWxsLFxcbnQsdSxcIlwiKSx3LmJpbmQobnVsbCx0LHUsXCJSZXNvdXJjZSBmYWlsZWQgdG8gbG9hZFwiKSl9OyRSUihcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsID0gJyRSUihcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MiA9ICdcIixcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EgPSAnXCIsJyxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYiA9ICdcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kID0gXCIpXFx4M2Mvc2NyaXB0PlwiLFxuICAgICAgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwgPVxuICAgICAgICAnJFJYPWZ1bmN0aW9uKGIsYyxkLGUsZil7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7YSYmKGI9YS5wcmV2aW91c1NpYmxpbmcsYi5kYXRhPVwiJCFcIixhPWEuZGF0YXNldCxjJiYoYS5kZ3N0PWMpLGQmJihhLm1zZz1kKSxlJiYoYS5zdGNrPWUpLGYmJihhLmNzdGNrPWYpLGIuX3JlYWN0UmV0cnkmJmIuX3JlYWN0UmV0cnkoKSl9OzskUlgoXCInLFxuICAgICAgY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwgPSAnJFJYKFwiJyxcbiAgICAgIGNsaWVudFJlbmRlclNjcmlwdDFBID0gJ1wiJyxcbiAgICAgIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsID0gXCIsXCIsXG4gICAgICBjbGllbnRSZW5kZXJTY3JpcHRFbmQgPSBcIilcXHgzYy9zY3JpcHQ+XCIsXG4gICAgICByZWdleEZvckpTU3RyaW5nc0luSW5zdHJ1Y3Rpb25TY3JpcHRzID0gL1s8XFx1MjAyOFxcdTIwMjldL2csXG4gICAgICByZWdleEZvckpTU3RyaW5nc0luU2NyaXB0cyA9IC9bJj48XFx1MjAyOFxcdTIwMjldL2csXG4gICAgICBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xID0gJzxzdHlsZSBtZWRpYT1cIm5vdCBhbGxcIiBkYXRhLXByZWNlZGVuY2U9XCInLFxuICAgICAgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMiA9ICdcIiBkYXRhLWhyZWY9XCInLFxuICAgICAgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9ICdcIj4nLFxuICAgICAgbGF0ZVN0eWxlVGFnVGVtcGxhdGVDbG9zZSA9IFwiPC9zdHlsZT5cIixcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9ICExLFxuICAgICAgZGVzdGluYXRpb25IYXNDYXBhY2l0eSA9ICEwLFxuICAgICAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUgPSBbXSxcbiAgICAgIHN0eWxlVGFnUmVzb3VyY2VPcGVuMSA9ICc8c3R5bGUgZGF0YS1wcmVjZWRlbmNlPVwiJyxcbiAgICAgIHN0eWxlVGFnUmVzb3VyY2VPcGVuMiA9ICdcIiBkYXRhLWhyZWY9XCInLFxuICAgICAgc3BhY2VTZXBhcmF0b3IgPSBcIiBcIixcbiAgICAgIHN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9ICdcIj4nLFxuICAgICAgc3R5bGVUYWdSZXNvdXJjZUNsb3NlID0gXCI8L3N0eWxlPlwiLFxuICAgICAgYXJyYXlGaXJzdE9wZW5CcmFja2V0ID0gXCJbXCIsXG4gICAgICBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldCA9IFwiLFtcIixcbiAgICAgIGFycmF5SW50ZXJzdGl0aWFsID0gXCIsXCIsXG4gICAgICBhcnJheUNsb3NlQnJhY2tldCA9IFwiXVwiLFxuICAgICAgUEVORElORyQxID0gMCxcbiAgICAgIFBSRUxPQURFRCA9IDEsXG4gICAgICBQUkVBTUJMRSA9IDIsXG4gICAgICBMQVRFID0gMyxcbiAgICAgIHJlZ2V4Rm9ySHJlZkluTGlua0hlYWRlclVSTENvbnRleHQgPSAvWzw+XFxyXFxuXS9nLFxuICAgICAgcmVnZXhGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQgPSAvW1wiJzssXFxyXFxuXS9nLFxuICAgICAgZG9jdHlwZUNodW5rID0gXCJcIixcbiAgICAgIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuICAgIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbiAgICB2YXIgcmVuZGVyZXJTaWdpbCA9IHt9O1xuICAgIHZhciBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBudWxsLFxuICAgICAgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudCA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudCA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTtcbiAgICB2YXIgY2xhc3NDb21wb25lbnRVcGRhdGVyID0ge1xuICAgICAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBpbnRlcm5hbHMgPSBpbnN0Ll9yZWFjdEludGVybmFscztcbiAgICAgICAgICBudWxsID09PSBpbnRlcm5hbHMucXVldWVcbiAgICAgICAgICAgID8gd2Fybk5vb3AoaW5zdCwgXCJzZXRTdGF0ZVwiKVxuICAgICAgICAgICAgOiAoaW50ZXJuYWxzLnF1ZXVlLnB1c2gocGF5bG9hZCksXG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaykpO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICBpbnN0ID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICAgICAgaW5zdC5yZXBsYWNlID0gITA7XG4gICAgICAgICAgaW5zdC5xdWV1ZSA9IFtwYXlsb2FkXTtcbiAgICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICBudWxsID09PSBpbnN0Ll9yZWFjdEludGVybmFscy5xdWV1ZVxuICAgICAgICAgICAgPyB3YXJuTm9vcChpbnN0LCBcImZvcmNlVXBkYXRlXCIpXG4gICAgICAgICAgICA6IHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVtcHR5VHJlZUNvbnRleHQgPSB7IGlkOiAxLCBvdmVyZmxvdzogXCJcIiB9LFxuICAgICAgY2x6MzIgPSBNYXRoLmNsejMyID8gTWF0aC5jbHozMiA6IGNsejMyRmFsbGJhY2ssXG4gICAgICBsb2cgPSBNYXRoLmxvZyxcbiAgICAgIExOMiA9IE1hdGguTE4yLFxuICAgICAgU3VzcGVuc2VFeGNlcHRpb24gPSBFcnJvcihcbiAgICAgICAgXCJTdXNwZW5zZSBFeGNlcHRpb246IFRoaXMgaXMgbm90IGEgcmVhbCBlcnJvciEgSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgYHVzZWAgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IHJlbmRlci4gWW91IG11c3QgZWl0aGVyIHJldGhyb3cgaXQgaW1tZWRpYXRlbHksIG9yIG1vdmUgdGhlIGB1c2VgIGNhbGwgb3V0c2lkZSBvZiB0aGUgYHRyeS9jYXRjaGAgYmxvY2suIENhcHR1cmluZyB3aXRob3V0IHJldGhyb3dpbmcgd2lsbCBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXFxuXFxuVG8gaGFuZGxlIGFzeW5jIGVycm9ycywgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhbiBlcnJvciBib3VuZGFyeSwgb3IgY2FsbCB0aGUgcHJvbWlzZSdzIGAuY2F0Y2hgIG1ldGhvZCBhbmQgcGFzcyB0aGUgcmVzdWx0IHRvIGB1c2VgLlwiXG4gICAgICApLFxuICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsLFxuICAgICAgb2JqZWN0SXMgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBpcyxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGwsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID0gbnVsbCxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3QgPSBudWxsLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aCA9IG51bGwsXG4gICAgICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsLFxuICAgICAgaXNSZVJlbmRlciA9ICExLFxuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExLFxuICAgICAgbG9jYWxJZENvdW50ZXIgPSAwLFxuICAgICAgYWN0aW9uU3RhdGVDb3VudGVyID0gMCxcbiAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCA9IC0xLFxuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwLFxuICAgICAgdGhlbmFibGVTdGF0ZSA9IG51bGwsXG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsLFxuICAgICAgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwLFxuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITEsXG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldixcbiAgICAgIEhvb2tzRGlzcGF0Y2hlciA9IHtcbiAgICAgICAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICAgICAgICB1c2U6IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gdXNhYmxlICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiB1c2FibGUpIHtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB1c2FibGUudGhlbilcbiAgICAgICAgICAgICAgcmV0dXJuIHVud3JhcFRoZW5hYmxlKHVzYWJsZSk7XG4gICAgICAgICAgICBpZiAodXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICAgIHJldHVybiByZWFkQ29udGV4dCh1c2FibGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQW4gdW5zdXBwb3J0ZWQgdHlwZSB3YXMgcGFzc2VkIHRvIHVzZSgpOiBcIiArIFN0cmluZyh1c2FibGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICAgIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlTWVtbzogdXNlTWVtbyxcbiAgICAgICAgdXNlUmVkdWNlcjogdXNlUmVkdWNlcixcbiAgICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgICAgIHZhciBwcmV2aW91c1JlZiA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHJldHVybiBudWxsID09PSBwcmV2aW91c1JlZlxuICAgICAgICAgICAgPyAoKGluaXRpYWxWYWx1ZSA9IHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH0pLFxuICAgICAgICAgICAgICBPYmplY3Quc2VhbChpbml0aWFsVmFsdWUpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsVmFsdWUpKVxuICAgICAgICAgICAgOiBwcmV2aW91c1JlZjtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgICByZXR1cm4gdXNlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlciwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBub29wJDEsXG4gICAgICAgIHVzZUxheW91dEVmZmVjdDogbm9vcCQxLFxuICAgICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgICAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICAgIH0sIGRlcHMpO1xuICAgICAgICB9LFxuICAgICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBub29wJDEsXG4gICAgICAgIHVzZUVmZmVjdDogbm9vcCQxLFxuICAgICAgICB1c2VEZWJ1Z1ZhbHVlOiBub29wJDEsXG4gICAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHJldHVybiB2b2lkIDAgIT09IGluaXRpYWxWYWx1ZSA/IGluaXRpYWxWYWx1ZSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHJldHVybiBbITEsIHVuc3VwcG9ydGVkU3RhcnRUcmFuc2l0aW9uXTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdHJlZUlkID0gY3VycmVudGx5UmVuZGVyaW5nVGFzay50cmVlQ29udGV4dDtcbiAgICAgICAgICB2YXIgb3ZlcmZsb3cgPSB0cmVlSWQub3ZlcmZsb3c7XG4gICAgICAgICAgdHJlZUlkID0gdHJlZUlkLmlkO1xuICAgICAgICAgIHRyZWVJZCA9XG4gICAgICAgICAgICAodHJlZUlkICYgfigxIDw8ICgzMiAtIGNsejMyKHRyZWVJZCkgLSAxKSkpLnRvU3RyaW5nKDMyKSArIG92ZXJmbG93O1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IGN1cnJlbnRSZXN1bWFibGVTdGF0ZTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcmVzdW1hYmxlU3RhdGUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBvdmVyZmxvdyA9IGxvY2FsSWRDb3VudGVyKys7XG4gICAgICAgICAgdHJlZUlkID0gXCJcXHUwMGFiXCIgKyByZXN1bWFibGVTdGF0ZS5pZFByZWZpeCArIFwiUlwiICsgdHJlZUlkO1xuICAgICAgICAgIDAgPCBvdmVyZmxvdyAmJiAodHJlZUlkICs9IFwiSFwiICsgb3ZlcmZsb3cudG9TdHJpbmcoMzIpKTtcbiAgICAgICAgICByZXR1cm4gdHJlZUlkICsgXCJcXHUwMGJiXCI7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiTWlzc2luZyBnZXRTZXJ2ZXJTbmFwc2hvdCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIHNlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuICAgICAgICB9LFxuICAgICAgICB1c2VPcHRpbWlzdGljOiBmdW5jdGlvbiAocGFzc3Rocm91Z2gpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIFtwYXNzdGhyb3VnaCwgdW5zdXBwb3J0ZWRTZXRPcHRpbWlzdGljU3RhdGVdO1xuICAgICAgICB9LFxuICAgICAgICB1c2VBY3Rpb25TdGF0ZTogdXNlQWN0aW9uU3RhdGUsXG4gICAgICAgIHVzZUZvcm1TdGF0ZTogdXNlQWN0aW9uU3RhdGUsXG4gICAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHJldHVybiBOb3RQZW5kaW5nO1xuICAgICAgICB9LFxuICAgICAgICB1c2VNZW1vQ2FjaGU6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgICAgZm9yICh2YXIgZGF0YSA9IEFycmF5KHNpemUpLCBpID0gMDsgaSA8IHNpemU7IGkrKylcbiAgICAgICAgICAgIGRhdGFbaV0gPSBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdW5zdXBwb3J0ZWRSZWZyZXNoO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3VycmVudFJlc3VtYWJsZVN0YXRlID0gbnVsbCxcbiAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSBudWxsLFxuICAgICAgRGVmYXVsdEFzeW5jRGlzcGF0Y2hlciA9IHtcbiAgICAgICAgZ2V0Q2FjaGVGb3JUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRPd25lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBudWxsID09PSBjdXJyZW50VGFza0luREVWXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjaztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgY2FsbENvbXBvbmVudCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICAgICAgICAgIHJldHVybiBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50SW5ERVYgPVxuICAgICAgICBjYWxsQ29tcG9uZW50W1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbENvbXBvbmVudCksXG4gICAgICBjYWxsUmVuZGVyID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsUmVuZGVySW5ERVYgPSBjYWxsUmVuZGVyW1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbFJlbmRlciksXG4gICAgICBjYWxsTGF6eUluaXQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChsYXp5KSB7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Ll9pbml0O1xuICAgICAgICAgIHJldHVybiBpbml0KGxhenkuX3BheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbExhenlJbml0SW5ERVYgPVxuICAgICAgICBjYWxsTGF6eUluaXRbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsTGF6eUluaXQpLFxuICAgICAgQ0xJRU5UX1JFTkRFUkVEID0gNCxcbiAgICAgIFBFTkRJTkcgPSAwLFxuICAgICAgQ09NUExFVEVEID0gMSxcbiAgICAgIEZMVVNIRUQgPSAyLFxuICAgICAgUE9TVFBPTkVEID0gNSxcbiAgICAgIENMT1NFRCA9IDE0LFxuICAgICAgY3VycmVudFJlcXVlc3QgPSBudWxsLFxuICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fSxcbiAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gITEsXG4gICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gITEsXG4gICAgICBkaWRXYXJuQWJvdXRNYXBzID0gITE7XG4gICAgZXhwb3J0cy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlbmRlclRvU3RyaW5nSW1wbChcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgICEwLFxuICAgICAgICAnVGhlIHNlcnZlciB1c2VkIFwicmVuZGVyVG9TdGF0aWNNYXJrdXBcIiB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IFN1c3BlbnNlLiBJZiB5b3UgaW50ZW5kZWQgdG8gaGF2ZSB0aGUgc2VydmVyIHdhaXQgZm9yIHRoZSBzdXNwZW5kZWQgY29tcG9uZW50IHBsZWFzZSBzd2l0Y2ggdG8gXCJyZW5kZXJUb1BpcGVhYmxlU3RyZWFtXCIgd2hpY2ggc3VwcG9ydHMgU3VzcGVuc2Ugb24gdGhlIHNlcnZlcidcbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLnJlbmRlclRvU3RyaW5nID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVuZGVyVG9TdHJpbmdJbXBsKFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgITEsXG4gICAgICAgICdUaGUgc2VydmVyIHVzZWQgXCJyZW5kZXJUb1N0cmluZ1wiIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgU3VzcGVuc2UuIElmIHlvdSBpbnRlbmRlZCBmb3IgdGhpcyBTdXNwZW5zZSBib3VuZGFyeSB0byByZW5kZXIgdGhlIGZhbGxiYWNrIGNvbnRlbnQgb24gdGhlIHNlcnZlciBjb25zaWRlciB0aHJvd2luZyBhbiBFcnJvciBzb21ld2hlcmUgd2l0aGluIHRoZSBTdXNwZW5zZSBib3VuZGFyeS4gSWYgeW91IGludGVuZGVkIHRvIGhhdmUgdGhlIHNlcnZlciB3YWl0IGZvciB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCBwbGVhc2Ugc3dpdGNoIHRvIFwicmVuZGVyVG9QaXBlYWJsZVN0cmVhbVwiIHdoaWNoIHN1cHBvcnRzIFN1c3BlbnNlIG9uIHRoZSBzZXJ2ZXInXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy52ZXJzaW9uID0gXCIxOS4xLjAtY2FuYXJ5LTAyOWU4YmQ2LTIwMjUwMzA2XCI7XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.node.development.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.node.development.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.node.development.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @license React\n * react-dom-server.node.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function styleReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\73 \" : \"\\\\53 \") + suffix;\n    }\n    function scriptReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n    }\n    function objectName(object) {\n      return Object.prototype.toString\n        .call(object)\n        .replace(/^\\[object (.*)\\]$/, function (m, p0) {\n          return p0;\n        });\n    }\n    function describeKeyForErrorMessage(key) {\n      var encodedKey = JSON.stringify(key);\n      return '\"' + key + '\"' === encodedKey ? key : encodedKey;\n    }\n    function describeValueForErrorMessage(value) {\n      switch (typeof value) {\n        case \"string\":\n          return JSON.stringify(\n            10 >= value.length ? value : value.slice(0, 10) + \"...\"\n          );\n        case \"object\":\n          if (isArrayImpl(value)) return \"[...]\";\n          if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)\n            return \"client\";\n          value = objectName(value);\n          return \"Object\" === value ? \"{...}\" : value;\n        case \"function\":\n          return value.$$typeof === CLIENT_REFERENCE_TAG\n            ? \"client\"\n            : (value = value.displayName || value.name)\n              ? \"function \" + value\n              : \"function\";\n        default:\n          return String(value);\n      }\n    }\n    function describeElementType(type) {\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeElementType(type.render);\n          case REACT_MEMO_TYPE:\n            return describeElementType(type.type);\n          case REACT_LAZY_TYPE:\n            var payload = type._payload;\n            type = type._init;\n            try {\n              return describeElementType(type(payload));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function describeObjectForErrorMessage(objectOrArray, expandedName) {\n      var objKind = objectName(objectOrArray);\n      if (\"Object\" !== objKind && \"Array\" !== objKind) return objKind;\n      var start = -1,\n        length = 0;\n      if (isArrayImpl(objectOrArray))\n        if (jsxChildrenParents.has(objectOrArray)) {\n          var type = jsxChildrenParents.get(objectOrArray);\n          objKind = \"<\" + describeElementType(type) + \">\";\n          for (var i = 0; i < objectOrArray.length; i++) {\n            var value = objectOrArray[i];\n            value =\n              \"string\" === typeof value\n                ? value\n                : \"object\" === typeof value && null !== value\n                  ? \"{\" + describeObjectForErrorMessage(value) + \"}\"\n                  : \"{\" + describeValueForErrorMessage(value) + \"}\";\n            \"\" + i === expandedName\n              ? ((start = objKind.length),\n                (length = value.length),\n                (objKind += value))\n              : (objKind =\n                  15 > value.length && 40 > objKind.length + value.length\n                    ? objKind + value\n                    : objKind + \"{...}\");\n          }\n          objKind += \"</\" + describeElementType(type) + \">\";\n        } else {\n          objKind = \"[\";\n          for (type = 0; type < objectOrArray.length; type++)\n            0 < type && (objKind += \", \"),\n              (i = objectOrArray[type]),\n              (i =\n                \"object\" === typeof i && null !== i\n                  ? describeObjectForErrorMessage(i)\n                  : describeValueForErrorMessage(i)),\n              \"\" + type === expandedName\n                ? ((start = objKind.length),\n                  (length = i.length),\n                  (objKind += i))\n                : (objKind =\n                    10 > i.length && 40 > objKind.length + i.length\n                      ? objKind + i\n                      : objKind + \"...\");\n          objKind += \"]\";\n        }\n      else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)\n        objKind = \"<\" + describeElementType(objectOrArray.type) + \"/>\";\n      else {\n        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return \"client\";\n        if (jsxPropsParents.has(objectOrArray)) {\n          objKind = jsxPropsParents.get(objectOrArray);\n          objKind = \"<\" + (describeElementType(objKind) || \"...\");\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++) {\n            objKind += \" \";\n            value = type[i];\n            objKind += describeKeyForErrorMessage(value) + \"=\";\n            var _value2 = objectOrArray[value];\n            var _substr2 =\n              value === expandedName &&\n              \"object\" === typeof _value2 &&\n              null !== _value2\n                ? describeObjectForErrorMessage(_value2)\n                : describeValueForErrorMessage(_value2);\n            \"string\" !== typeof _value2 && (_substr2 = \"{\" + _substr2 + \"}\");\n            value === expandedName\n              ? ((start = objKind.length),\n                (length = _substr2.length),\n                (objKind += _substr2))\n              : (objKind =\n                  10 > _substr2.length && 40 > objKind.length + _substr2.length\n                    ? objKind + _substr2\n                    : objKind + \"...\");\n          }\n          objKind += \">\";\n        } else {\n          objKind = \"{\";\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++)\n            0 < i && (objKind += \", \"),\n              (value = type[i]),\n              (objKind += describeKeyForErrorMessage(value) + \": \"),\n              (_value2 = objectOrArray[value]),\n              (_value2 =\n                \"object\" === typeof _value2 && null !== _value2\n                  ? describeObjectForErrorMessage(_value2)\n                  : describeValueForErrorMessage(_value2)),\n              value === expandedName\n                ? ((start = objKind.length),\n                  (length = _value2.length),\n                  (objKind += _value2))\n                : (objKind =\n                    10 > _value2.length && 40 > objKind.length + _value2.length\n                      ? objKind + _value2\n                      : objKind + \"...\");\n          objKind += \"}\";\n        }\n      }\n      return void 0 === expandedName\n        ? objKind\n        : -1 < start && 0 < length\n          ? ((objectOrArray = \" \".repeat(start) + \"^\".repeat(length)),\n            \"\\n  \" + objKind + \"\\n  \" + objectOrArray)\n          : \"\\n  \" + objKind;\n    }\n    function flushBuffered(destination) {\n      \"function\" === typeof destination.flush && destination.flush();\n    }\n    function writeChunk(destination, chunk) {\n      if (\"string\" === typeof chunk) {\n        if (0 !== chunk.length)\n          if (2048 < 3 * chunk.length)\n            0 < writtenBytes &&\n              (writeToDestination(\n                destination,\n                currentView.subarray(0, writtenBytes)\n              ),\n              (currentView = new Uint8Array(2048)),\n              (writtenBytes = 0)),\n              writeToDestination(destination, chunk);\n          else {\n            var target = currentView;\n            0 < writtenBytes && (target = currentView.subarray(writtenBytes));\n            target = textEncoder.encodeInto(chunk, target);\n            var read = target.read;\n            writtenBytes += target.written;\n            read < chunk.length &&\n              (writeToDestination(\n                destination,\n                currentView.subarray(0, writtenBytes)\n              ),\n              (currentView = new Uint8Array(2048)),\n              (writtenBytes = textEncoder.encodeInto(\n                chunk.slice(read),\n                currentView\n              ).written));\n            2048 === writtenBytes &&\n              (writeToDestination(destination, currentView),\n              (currentView = new Uint8Array(2048)),\n              (writtenBytes = 0));\n          }\n      } else\n        0 !== chunk.byteLength &&\n          (2048 < chunk.byteLength\n            ? (0 < writtenBytes &&\n                (writeToDestination(\n                  destination,\n                  currentView.subarray(0, writtenBytes)\n                ),\n                (currentView = new Uint8Array(2048)),\n                (writtenBytes = 0)),\n              writeToDestination(destination, chunk))\n            : ((target = currentView.length - writtenBytes),\n              target < chunk.byteLength &&\n                (0 === target\n                  ? writeToDestination(destination, currentView)\n                  : (currentView.set(chunk.subarray(0, target), writtenBytes),\n                    (writtenBytes += target),\n                    writeToDestination(destination, currentView),\n                    (chunk = chunk.subarray(target))),\n                (currentView = new Uint8Array(2048)),\n                (writtenBytes = 0)),\n              currentView.set(chunk, writtenBytes),\n              (writtenBytes += chunk.byteLength),\n              2048 === writtenBytes &&\n                (writeToDestination(destination, currentView),\n                (currentView = new Uint8Array(2048)),\n                (writtenBytes = 0))));\n    }\n    function writeToDestination(destination, view) {\n      destination = destination.write(view);\n      destinationHasCapacity$1 = destinationHasCapacity$1 && destination;\n    }\n    function writeChunkAndReturn(destination, chunk) {\n      writeChunk(destination, chunk);\n      return destinationHasCapacity$1;\n    }\n    function completeWriting(destination) {\n      currentView &&\n        0 < writtenBytes &&\n        destination.write(currentView.subarray(0, writtenBytes));\n      currentView = null;\n      writtenBytes = 0;\n      destinationHasCapacity$1 = !0;\n    }\n    function stringToPrecomputedChunk(content) {\n      content = textEncoder.encode(content);\n      2048 < content.byteLength &&\n        console.error(\n          \"precomputed chunks must be smaller than the view size configured for this host. This is a bug in React.\"\n        );\n      return content;\n    }\n    function typeName(value) {\n      return (\n        (\"function\" === typeof Symbol &&\n          Symbol.toStringTag &&\n          value[Symbol.toStringTag]) ||\n        value.constructor.name ||\n        \"Object\"\n      );\n    }\n    function willCoercionThrow(value) {\n      try {\n        return testStringCoercion(value), !1;\n      } catch (e) {\n        return !0;\n      }\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkAttributeStringCoercion(value, attributeName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            attributeName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkCSSPropertyStringCoercion(value, propName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            propName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkHtmlStringCoercion(value) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.\",\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function isAttributeNameSafe(attributeName) {\n      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))\n        return !0;\n      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))\n        return !1;\n      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\n        return (validatedAttributeNameCache[attributeName] = !0);\n      illegalAttributeNameCache[attributeName] = !0;\n      console.error(\"Invalid attribute name: `%s`\", attributeName);\n      return !1;\n    }\n    function checkControlledValueProps(tagName, props) {\n      hasReadOnlyValue[props.type] ||\n        props.onChange ||\n        props.onInput ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.value ||\n        (\"select\" === tagName\n          ? console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.\"\n            )\n          : console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\"\n            ));\n      props.onChange ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.checked ||\n        console.error(\n          \"You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.\"\n        );\n    }\n    function validateProperty$1(tagName, name) {\n      if (\n        hasOwnProperty.call(warnedProperties$1, name) &&\n        warnedProperties$1[name]\n      )\n        return !0;\n      if (rARIACamel$1.test(name)) {\n        tagName = \"aria-\" + name.slice(4).toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\",\n              name\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n        if (name !== tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. Did you mean `%s`?\",\n              name,\n              tagName\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n      }\n      if (rARIA$1.test(name)) {\n        tagName = name.toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName) return (warnedProperties$1[name] = !0), !1;\n        name !== tagName &&\n          (console.error(\n            \"Unknown ARIA attribute `%s`. Did you mean `%s`?\",\n            name,\n            tagName\n          ),\n          (warnedProperties$1[name] = !0));\n      }\n      return !0;\n    }\n    function validateProperties$2(type, props) {\n      var invalidProps = [],\n        key;\n      for (key in props)\n        validateProperty$1(type, key) || invalidProps.push(key);\n      props = invalidProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === invalidProps.length\n        ? console.error(\n            \"Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          )\n        : 1 < invalidProps.length &&\n          console.error(\n            \"Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          );\n    }\n    function validateProperty(tagName, name, value, eventRegistry) {\n      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])\n        return !0;\n      var lowerCasedName = name.toLowerCase();\n      if (\"onfocusin\" === lowerCasedName || \"onfocusout\" === lowerCasedName)\n        return (\n          console.error(\n            \"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"function\" === typeof value &&\n        ((\"form\" === tagName && \"action\" === name) ||\n          (\"input\" === tagName && \"formAction\" === name) ||\n          (\"button\" === tagName && \"formAction\" === name))\n      )\n        return !0;\n      if (null != eventRegistry) {\n        tagName = eventRegistry.possibleRegistrationNames;\n        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))\n          return !0;\n        eventRegistry = tagName.hasOwnProperty(lowerCasedName)\n          ? tagName[lowerCasedName]\n          : null;\n        if (null != eventRegistry)\n          return (\n            console.error(\n              \"Invalid event handler property `%s`. Did you mean `%s`?\",\n              name,\n              eventRegistry\n            ),\n            (warnedProperties[name] = !0)\n          );\n        if (EVENT_NAME_REGEX.test(name))\n          return (\n            console.error(\n              \"Unknown event handler property `%s`. It will be ignored.\",\n              name\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (EVENT_NAME_REGEX.test(name))\n        return (\n          INVALID_EVENT_NAME_REGEX.test(name) &&\n            console.error(\n              \"Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.\",\n              name\n            ),\n          (warnedProperties[name] = !0)\n        );\n      if (rARIA.test(name) || rARIACamel.test(name)) return !0;\n      if (\"innerhtml\" === lowerCasedName)\n        return (\n          console.error(\n            \"Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"aria\" === lowerCasedName)\n        return (\n          console.error(\n            \"The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"is\" === lowerCasedName &&\n        null !== value &&\n        void 0 !== value &&\n        \"string\" !== typeof value\n      )\n        return (\n          console.error(\n            \"Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.\",\n            typeof value\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"number\" === typeof value && isNaN(value))\n        return (\n          console.error(\n            \"Received NaN for the `%s` attribute. If this is expected, cast the value to a string.\",\n            name\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n        if (\n          ((lowerCasedName = possibleStandardNames[lowerCasedName]),\n          lowerCasedName !== name)\n        )\n          return (\n            console.error(\n              \"Invalid DOM property `%s`. Did you mean `%s`?\",\n              name,\n              lowerCasedName\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (name !== lowerCasedName)\n        return (\n          console.error(\n            \"React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.\",\n            name,\n            lowerCasedName\n          ),\n          (warnedProperties[name] = !0)\n        );\n      switch (name) {\n        case \"dangerouslySetInnerHTML\":\n        case \"children\":\n        case \"style\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"ref\":\n          return !0;\n        case \"innerText\":\n        case \"textContent\":\n          return !0;\n      }\n      switch (typeof value) {\n        case \"boolean\":\n          switch (name) {\n            case \"autoFocus\":\n            case \"checked\":\n            case \"multiple\":\n            case \"muted\":\n            case \"selected\":\n            case \"contentEditable\":\n            case \"spellCheck\":\n            case \"draggable\":\n            case \"value\":\n            case \"autoReverse\":\n            case \"externalResourcesRequired\":\n            case \"focusable\":\n            case \"preserveAlpha\":\n            case \"allowFullScreen\":\n            case \"async\":\n            case \"autoPlay\":\n            case \"controls\":\n            case \"default\":\n            case \"defer\":\n            case \"disabled\":\n            case \"disablePictureInPicture\":\n            case \"disableRemotePlayback\":\n            case \"formNoValidate\":\n            case \"hidden\":\n            case \"loop\":\n            case \"noModule\":\n            case \"noValidate\":\n            case \"open\":\n            case \"playsInline\":\n            case \"readOnly\":\n            case \"required\":\n            case \"reversed\":\n            case \"scoped\":\n            case \"seamless\":\n            case \"itemScope\":\n            case \"capture\":\n            case \"download\":\n            case \"inert\":\n              return !0;\n            default:\n              lowerCasedName = name.toLowerCase().slice(0, 5);\n              if (\"data-\" === lowerCasedName || \"aria-\" === lowerCasedName)\n                return !0;\n              value\n                ? console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name\n                  )\n                : console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name,\n                    name,\n                    name\n                  );\n              return (warnedProperties[name] = !0);\n          }\n        case \"function\":\n        case \"symbol\":\n          return (warnedProperties[name] = !0), !1;\n        case \"string\":\n          if (\"false\" === value || \"true\" === value) {\n            switch (name) {\n              case \"checked\":\n              case \"selected\":\n              case \"multiple\":\n              case \"muted\":\n              case \"allowFullScreen\":\n              case \"async\":\n              case \"autoPlay\":\n              case \"controls\":\n              case \"default\":\n              case \"defer\":\n              case \"disabled\":\n              case \"disablePictureInPicture\":\n              case \"disableRemotePlayback\":\n              case \"formNoValidate\":\n              case \"hidden\":\n              case \"loop\":\n              case \"noModule\":\n              case \"noValidate\":\n              case \"open\":\n              case \"playsInline\":\n              case \"readOnly\":\n              case \"required\":\n              case \"reversed\":\n              case \"scoped\":\n              case \"seamless\":\n              case \"itemScope\":\n              case \"inert\":\n                break;\n              default:\n                return !0;\n            }\n            console.error(\n              \"Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?\",\n              value,\n              name,\n              \"false\" === value\n                ? \"The browser will interpret it as a truthy value.\"\n                : 'Although this works, it will not work as expected if you pass the string \"false\".',\n              name,\n              value\n            );\n            warnedProperties[name] = !0;\n          }\n      }\n      return !0;\n    }\n    function warnUnknownProperties(type, props, eventRegistry) {\n      var unknownProps = [],\n        key;\n      for (key in props)\n        validateProperty(type, key, props[key], eventRegistry) ||\n          unknownProps.push(key);\n      props = unknownProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === unknownProps.length\n        ? console.error(\n            \"Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          )\n        : 1 < unknownProps.length &&\n          console.error(\n            \"Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          );\n    }\n    function camelize(string) {\n      return string.replace(hyphenPattern, function (_, character) {\n        return character.toUpperCase();\n      });\n    }\n    function escapeTextForBrowser(text) {\n      if (\n        \"boolean\" === typeof text ||\n        \"number\" === typeof text ||\n        \"bigint\" === typeof text\n      )\n        return \"\" + text;\n      checkHtmlStringCoercion(text);\n      text = \"\" + text;\n      var match = matchHtmlRegExp.exec(text);\n      if (match) {\n        var html = \"\",\n          index,\n          lastIndex = 0;\n        for (index = match.index; index < text.length; index++) {\n          switch (text.charCodeAt(index)) {\n            case 34:\n              match = \"&quot;\";\n              break;\n            case 38:\n              match = \"&amp;\";\n              break;\n            case 39:\n              match = \"&#x27;\";\n              break;\n            case 60:\n              match = \"&lt;\";\n              break;\n            case 62:\n              match = \"&gt;\";\n              break;\n            default:\n              continue;\n          }\n          lastIndex !== index && (html += text.slice(lastIndex, index));\n          lastIndex = index + 1;\n          html += match;\n        }\n        text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;\n      }\n      return text;\n    }\n    function sanitizeURL(url) {\n      return isJavaScriptProtocol.test(\"\" + url)\n        ? \"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')\"\n        : url;\n    }\n    function escapeEntireInlineScriptContent(scriptText) {\n      checkHtmlStringCoercion(scriptText);\n      return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n    }\n    function createRenderState(\n      resumableState,\n      nonce,\n      externalRuntimeConfig,\n      importMap,\n      onHeaders,\n      maxHeadersLength\n    ) {\n      var inlineScriptWithNonce =\n          void 0 === nonce\n            ? startInlineScript\n            : stringToPrecomputedChunk(\n                '<script nonce=\"' + escapeTextForBrowser(nonce) + '\">'\n              ),\n        idPrefix = resumableState.idPrefix;\n      externalRuntimeConfig = [];\n      var bootstrapScriptContent = resumableState.bootstrapScriptContent,\n        bootstrapScripts = resumableState.bootstrapScripts,\n        bootstrapModules = resumableState.bootstrapModules;\n      void 0 !== bootstrapScriptContent &&\n        externalRuntimeConfig.push(\n          inlineScriptWithNonce,\n          escapeEntireInlineScriptContent(bootstrapScriptContent),\n          endInlineScript\n        );\n      bootstrapScriptContent = [];\n      void 0 !== importMap &&\n        (bootstrapScriptContent.push(importMapScriptStart),\n        bootstrapScriptContent.push(\n          escapeEntireInlineScriptContent(JSON.stringify(importMap))\n        ),\n        bootstrapScriptContent.push(importMapScriptEnd));\n      onHeaders &&\n        \"number\" === typeof maxHeadersLength &&\n        0 >= maxHeadersLength &&\n        console.error(\n          \"React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.\",\n          0 === maxHeadersLength ? \"zero\" : maxHeadersLength\n        );\n      importMap = onHeaders\n        ? {\n            preconnects: \"\",\n            fontPreloads: \"\",\n            highImagePreloads: \"\",\n            remainingCapacity:\n              2 +\n              (\"number\" === typeof maxHeadersLength ? maxHeadersLength : 2e3)\n          }\n        : null;\n      onHeaders = {\n        placeholderPrefix: stringToPrecomputedChunk(idPrefix + \"P:\"),\n        segmentPrefix: stringToPrecomputedChunk(idPrefix + \"S:\"),\n        boundaryPrefix: stringToPrecomputedChunk(idPrefix + \"B:\"),\n        startInlineScript: inlineScriptWithNonce,\n        preamble: createPreambleState(),\n        externalRuntimeScript: null,\n        bootstrapChunks: externalRuntimeConfig,\n        importMapChunks: bootstrapScriptContent,\n        onHeaders: onHeaders,\n        headers: importMap,\n        resets: {\n          font: {},\n          dns: {},\n          connect: { default: {}, anonymous: {}, credentials: {} },\n          image: {},\n          style: {}\n        },\n        charsetChunks: [],\n        viewportChunks: [],\n        hoistableChunks: [],\n        preconnects: new Set(),\n        fontPreloads: new Set(),\n        highImagePreloads: new Set(),\n        styles: new Map(),\n        bootstrapScripts: new Set(),\n        scripts: new Set(),\n        bulkPreloads: new Set(),\n        preloads: {\n          images: new Map(),\n          stylesheets: new Map(),\n          scripts: new Map(),\n          moduleScripts: new Map()\n        },\n        nonce: nonce,\n        hoistableState: null,\n        stylesToHoist: !1\n      };\n      if (void 0 !== bootstrapScripts)\n        for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {\n          maxHeadersLength = bootstrapScripts[importMap];\n          bootstrapScriptContent = idPrefix = void 0;\n          var props = {\n            rel: \"preload\",\n            as: \"script\",\n            fetchPriority: \"low\",\n            nonce: nonce\n          };\n          \"string\" === typeof maxHeadersLength\n            ? (props.href = inlineScriptWithNonce = maxHeadersLength)\n            : ((props.href = inlineScriptWithNonce = maxHeadersLength.src),\n              (props.integrity = bootstrapScriptContent =\n                \"string\" === typeof maxHeadersLength.integrity\n                  ? maxHeadersLength.integrity\n                  : void 0),\n              (props.crossOrigin = idPrefix =\n                \"string\" === typeof maxHeadersLength ||\n                null == maxHeadersLength.crossOrigin\n                  ? void 0\n                  : \"use-credentials\" === maxHeadersLength.crossOrigin\n                    ? \"use-credentials\"\n                    : \"\"));\n          preloadBootstrapScriptOrModule(\n            resumableState,\n            onHeaders,\n            inlineScriptWithNonce,\n            props\n          );\n          externalRuntimeConfig.push(\n            startScriptSrc,\n            escapeTextForBrowser(inlineScriptWithNonce)\n          );\n          nonce &&\n            externalRuntimeConfig.push(\n              scriptNonce,\n              escapeTextForBrowser(nonce)\n            );\n          \"string\" === typeof bootstrapScriptContent &&\n            externalRuntimeConfig.push(\n              scriptIntegirty,\n              escapeTextForBrowser(bootstrapScriptContent)\n            );\n          \"string\" === typeof idPrefix &&\n            externalRuntimeConfig.push(\n              scriptCrossOrigin,\n              escapeTextForBrowser(idPrefix)\n            );\n          externalRuntimeConfig.push(endAsyncScript);\n        }\n      if (void 0 !== bootstrapModules)\n        for (\n          bootstrapScripts = 0;\n          bootstrapScripts < bootstrapModules.length;\n          bootstrapScripts++\n        )\n          (importMap = bootstrapModules[bootstrapScripts]),\n            (idPrefix = inlineScriptWithNonce = void 0),\n            (bootstrapScriptContent = {\n              rel: \"modulepreload\",\n              fetchPriority: \"low\",\n              nonce: nonce\n            }),\n            \"string\" === typeof importMap\n              ? (bootstrapScriptContent.href = maxHeadersLength = importMap)\n              : ((bootstrapScriptContent.href = maxHeadersLength =\n                  importMap.src),\n                (bootstrapScriptContent.integrity = idPrefix =\n                  \"string\" === typeof importMap.integrity\n                    ? importMap.integrity\n                    : void 0),\n                (bootstrapScriptContent.crossOrigin = inlineScriptWithNonce =\n                  \"string\" === typeof importMap || null == importMap.crossOrigin\n                    ? void 0\n                    : \"use-credentials\" === importMap.crossOrigin\n                      ? \"use-credentials\"\n                      : \"\")),\n            preloadBootstrapScriptOrModule(\n              resumableState,\n              onHeaders,\n              maxHeadersLength,\n              bootstrapScriptContent\n            ),\n            externalRuntimeConfig.push(\n              startModuleSrc,\n              escapeTextForBrowser(maxHeadersLength)\n            ),\n            nonce &&\n              externalRuntimeConfig.push(\n                scriptNonce,\n                escapeTextForBrowser(nonce)\n              ),\n            \"string\" === typeof idPrefix &&\n              externalRuntimeConfig.push(\n                scriptIntegirty,\n                escapeTextForBrowser(idPrefix)\n              ),\n            \"string\" === typeof inlineScriptWithNonce &&\n              externalRuntimeConfig.push(\n                scriptCrossOrigin,\n                escapeTextForBrowser(inlineScriptWithNonce)\n              ),\n            externalRuntimeConfig.push(endAsyncScript);\n      return onHeaders;\n    }\n    function createResumableState(\n      identifierPrefix,\n      externalRuntimeConfig,\n      bootstrapScriptContent,\n      bootstrapScripts,\n      bootstrapModules\n    ) {\n      return {\n        idPrefix: void 0 === identifierPrefix ? \"\" : identifierPrefix,\n        nextFormID: 0,\n        streamingFormat: 0,\n        bootstrapScriptContent: bootstrapScriptContent,\n        bootstrapScripts: bootstrapScripts,\n        bootstrapModules: bootstrapModules,\n        instructions: NothingSent,\n        hasBody: !1,\n        hasHtml: !1,\n        unknownResources: {},\n        dnsResources: {},\n        connectResources: { default: {}, anonymous: {}, credentials: {} },\n        imageResources: {},\n        styleResources: {},\n        scriptResources: {},\n        moduleUnknownResources: {},\n        moduleScriptResources: {}\n      };\n    }\n    function createPreambleState() {\n      return {\n        htmlChunks: null,\n        headChunks: null,\n        bodyChunks: null,\n        contribution: NoContribution\n      };\n    }\n    function createFormatContext(insertionMode, selectedValue, tagScope) {\n      return {\n        insertionMode: insertionMode,\n        selectedValue: selectedValue,\n        tagScope: tagScope\n      };\n    }\n    function createRootFormatContext(namespaceURI) {\n      return createFormatContext(\n        \"http://www.w3.org/2000/svg\" === namespaceURI\n          ? SVG_MODE\n          : \"http://www.w3.org/1998/Math/MathML\" === namespaceURI\n            ? MATHML_MODE\n            : ROOT_HTML_MODE,\n        null,\n        0\n      );\n    }\n    function getChildFormatContext(parentContext, type, props) {\n      switch (type) {\n        case \"noscript\":\n          return createFormatContext(\n            HTML_MODE,\n            null,\n            parentContext.tagScope | 1\n          );\n        case \"select\":\n          return createFormatContext(\n            HTML_MODE,\n            null != props.value ? props.value : props.defaultValue,\n            parentContext.tagScope\n          );\n        case \"svg\":\n          return createFormatContext(SVG_MODE, null, parentContext.tagScope);\n        case \"picture\":\n          return createFormatContext(\n            HTML_MODE,\n            null,\n            parentContext.tagScope | 2\n          );\n        case \"math\":\n          return createFormatContext(MATHML_MODE, null, parentContext.tagScope);\n        case \"foreignObject\":\n          return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n        case \"table\":\n          return createFormatContext(\n            HTML_TABLE_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"thead\":\n        case \"tbody\":\n        case \"tfoot\":\n          return createFormatContext(\n            HTML_TABLE_BODY_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"colgroup\":\n          return createFormatContext(\n            HTML_COLGROUP_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"tr\":\n          return createFormatContext(\n            HTML_TABLE_ROW_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"head\":\n          if (parentContext.insertionMode < HTML_MODE)\n            return createFormatContext(\n              HTML_HEAD_MODE,\n              null,\n              parentContext.tagScope\n            );\n          break;\n        case \"html\":\n          if (parentContext.insertionMode === ROOT_HTML_MODE)\n            return createFormatContext(\n              HTML_HTML_MODE,\n              null,\n              parentContext.tagScope\n            );\n      }\n      return parentContext.insertionMode >= HTML_TABLE_MODE ||\n        parentContext.insertionMode < HTML_MODE\n        ? createFormatContext(HTML_MODE, null, parentContext.tagScope)\n        : parentContext;\n    }\n    function pushTextInstance(target, text, renderState, textEmbedded) {\n      if (\"\" === text) return textEmbedded;\n      textEmbedded && target.push(textSeparator);\n      target.push(escapeTextForBrowser(text));\n      return !0;\n    }\n    function pushStyleAttribute(target, style) {\n      if (\"object\" !== typeof style)\n        throw Error(\n          \"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\"\n        );\n      var isFirst = !0,\n        styleName;\n      for (styleName in style)\n        if (hasOwnProperty.call(style, styleName)) {\n          var styleValue = style[styleName];\n          if (\n            null != styleValue &&\n            \"boolean\" !== typeof styleValue &&\n            \"\" !== styleValue\n          ) {\n            if (0 === styleName.indexOf(\"--\")) {\n              var nameChunk = escapeTextForBrowser(styleName);\n              checkCSSPropertyStringCoercion(styleValue, styleName);\n              styleValue = escapeTextForBrowser((\"\" + styleValue).trim());\n            } else {\n              nameChunk = styleName;\n              var value = styleValue;\n              if (-1 < nameChunk.indexOf(\"-\")) {\n                var name = nameChunk;\n                (warnedStyleNames.hasOwnProperty(name) &&\n                  warnedStyleNames[name]) ||\n                  ((warnedStyleNames[name] = !0),\n                  console.error(\n                    \"Unsupported style property %s. Did you mean %s?\",\n                    name,\n                    camelize(name.replace(msPattern$1, \"ms-\"))\n                  ));\n              } else if (badVendoredStyleNamePattern.test(nameChunk))\n                (name = nameChunk),\n                  (warnedStyleNames.hasOwnProperty(name) &&\n                    warnedStyleNames[name]) ||\n                    ((warnedStyleNames[name] = !0),\n                    console.error(\n                      \"Unsupported vendor-prefixed style property %s. Did you mean %s?\",\n                      name,\n                      name.charAt(0).toUpperCase() + name.slice(1)\n                    ));\n              else if (badStyleValueWithSemicolonPattern.test(value)) {\n                name = nameChunk;\n                var value$jscomp$0 = value;\n                (warnedStyleValues.hasOwnProperty(value$jscomp$0) &&\n                  warnedStyleValues[value$jscomp$0]) ||\n                  ((warnedStyleValues[value$jscomp$0] = !0),\n                  console.error(\n                    'Style property values shouldn\\'t contain a semicolon. Try \"%s: %s\" instead.',\n                    name,\n                    value$jscomp$0.replace(\n                      badStyleValueWithSemicolonPattern,\n                      \"\"\n                    )\n                  ));\n              }\n              \"number\" === typeof value &&\n                (isNaN(value)\n                  ? warnedForNaNValue ||\n                    ((warnedForNaNValue = !0),\n                    console.error(\n                      \"`NaN` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    ))\n                  : isFinite(value) ||\n                    warnedForInfinityValue ||\n                    ((warnedForInfinityValue = !0),\n                    console.error(\n                      \"`Infinity` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    )));\n              nameChunk = styleName;\n              value = styleNameCache.get(nameChunk);\n              void 0 !== value\n                ? (nameChunk = value)\n                : ((value = stringToPrecomputedChunk(\n                    escapeTextForBrowser(\n                      nameChunk\n                        .replace(uppercasePattern, \"-$1\")\n                        .toLowerCase()\n                        .replace(msPattern, \"-ms-\")\n                    )\n                  )),\n                  styleNameCache.set(nameChunk, value),\n                  (nameChunk = value));\n              \"number\" === typeof styleValue\n                ? (styleValue =\n                    0 === styleValue || unitlessNumbers.has(styleName)\n                      ? \"\" + styleValue\n                      : styleValue + \"px\")\n                : (checkCSSPropertyStringCoercion(styleValue, styleName),\n                  (styleValue = escapeTextForBrowser(\n                    (\"\" + styleValue).trim()\n                  )));\n            }\n            isFirst\n              ? ((isFirst = !1),\n                target.push(\n                  styleAttributeStart,\n                  nameChunk,\n                  styleAssign,\n                  styleValue\n                ))\n              : target.push(styleSeparator, nameChunk, styleAssign, styleValue);\n          }\n        }\n      isFirst || target.push(attributeEnd);\n    }\n    function pushBooleanAttribute(target, name, value) {\n      value &&\n        \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        target.push(attributeSeparator, name, attributeEmptyString);\n    }\n    function pushStringAttribute(target, name, value) {\n      \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        \"boolean\" !== typeof value &&\n        target.push(\n          attributeSeparator,\n          name,\n          attributeAssign,\n          escapeTextForBrowser(value),\n          attributeEnd\n        );\n    }\n    function pushAdditionalFormField(value, key) {\n      this.push(startHiddenInputChunk);\n      validateAdditionalFormField(value);\n      pushStringAttribute(this, \"name\", key);\n      pushStringAttribute(this, \"value\", value);\n      this.push(endOfStartTagSelfClosing);\n    }\n    function validateAdditionalFormField(value) {\n      if (\"string\" !== typeof value)\n        throw Error(\n          \"File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.\"\n        );\n    }\n    function getCustomFormFields(resumableState, formAction) {\n      if (\"function\" === typeof formAction.$$FORM_ACTION) {\n        var id = resumableState.nextFormID++;\n        resumableState = resumableState.idPrefix + id;\n        try {\n          var customFields = formAction.$$FORM_ACTION(resumableState);\n          if (customFields) {\n            var formData = customFields.data;\n            null != formData && formData.forEach(validateAdditionalFormField);\n          }\n          return customFields;\n        } catch (x) {\n          if (\n            \"object\" === typeof x &&\n            null !== x &&\n            \"function\" === typeof x.then\n          )\n            throw x;\n          console.error(\n            \"Failed to serialize an action for progressive enhancement:\\n%s\",\n            x\n          );\n        }\n      }\n      return null;\n    }\n    function pushFormActionAttribute(\n      target,\n      resumableState,\n      renderState,\n      formAction,\n      formEncType,\n      formMethod,\n      formTarget,\n      name\n    ) {\n      var formData = null;\n      if (\"function\" === typeof formAction) {\n        null === name ||\n          didWarnFormActionName ||\n          ((didWarnFormActionName = !0),\n          console.error(\n            'Cannot specify a \"name\" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'\n          ));\n        (null === formEncType && null === formMethod) ||\n          didWarnFormActionMethod ||\n          ((didWarnFormActionMethod = !0),\n          console.error(\n            \"Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.\"\n          ));\n        null === formTarget ||\n          didWarnFormActionTarget ||\n          ((didWarnFormActionTarget = !0),\n          console.error(\n            \"Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window.\"\n          ));\n        var customFields = getCustomFormFields(resumableState, formAction);\n        null !== customFields\n          ? ((name = customFields.name),\n            (formAction = customFields.action || \"\"),\n            (formEncType = customFields.encType),\n            (formMethod = customFields.method),\n            (formTarget = customFields.target),\n            (formData = customFields.data))\n          : (target.push(\n              attributeSeparator,\n              \"formAction\",\n              attributeAssign,\n              actionJavaScriptURL,\n              attributeEnd\n            ),\n            (formTarget = formMethod = formEncType = formAction = name = null),\n            injectFormReplayingRuntime(resumableState, renderState));\n      }\n      null != name && pushAttribute(target, \"name\", name);\n      null != formAction && pushAttribute(target, \"formAction\", formAction);\n      null != formEncType && pushAttribute(target, \"formEncType\", formEncType);\n      null != formMethod && pushAttribute(target, \"formMethod\", formMethod);\n      null != formTarget && pushAttribute(target, \"formTarget\", formTarget);\n      return formData;\n    }\n    function pushAttribute(target, name, value) {\n      switch (name) {\n        case \"className\":\n          pushStringAttribute(target, \"class\", value);\n          break;\n        case \"tabIndex\":\n          pushStringAttribute(target, \"tabindex\", value);\n          break;\n        case \"dir\":\n        case \"role\":\n        case \"viewBox\":\n        case \"width\":\n        case \"height\":\n          pushStringAttribute(target, name, value);\n          break;\n        case \"style\":\n          pushStyleAttribute(target, value);\n          break;\n        case \"src\":\n        case \"href\":\n          if (\"\" === value) {\n            \"src\" === name\n              ? console.error(\n                  'An empty string (\"\") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                )\n              : console.error(\n                  'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                );\n            break;\n          }\n        case \"action\":\n        case \"formAction\":\n          if (\n            null == value ||\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            name,\n            attributeAssign,\n            escapeTextForBrowser(value),\n            attributeEnd\n          );\n          break;\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"ref\":\n          break;\n        case \"autoFocus\":\n        case \"multiple\":\n        case \"muted\":\n          pushBooleanAttribute(target, name.toLowerCase(), value);\n          break;\n        case \"xlinkHref\":\n          if (\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            \"xlink:href\",\n            attributeAssign,\n            escapeTextForBrowser(value),\n            attributeEnd\n          );\n          break;\n        case \"contentEditable\":\n        case \"spellCheck\":\n        case \"draggable\":\n        case \"value\":\n        case \"autoReverse\":\n        case \"externalResourcesRequired\":\n        case \"focusable\":\n        case \"preserveAlpha\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"inert\":\n          \"\" !== value ||\n            didWarnForNewBooleanPropsWithEmptyValue[name] ||\n            ((didWarnForNewBooleanPropsWithEmptyValue[name] = !0),\n            console.error(\n              \"Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.\",\n              name\n            ));\n        case \"allowFullScreen\":\n        case \"async\":\n        case \"autoPlay\":\n        case \"controls\":\n        case \"default\":\n        case \"defer\":\n        case \"disabled\":\n        case \"disablePictureInPicture\":\n        case \"disableRemotePlayback\":\n        case \"formNoValidate\":\n        case \"hidden\":\n        case \"loop\":\n        case \"noModule\":\n        case \"noValidate\":\n        case \"open\":\n        case \"playsInline\":\n        case \"readOnly\":\n        case \"required\":\n        case \"reversed\":\n        case \"scoped\":\n        case \"seamless\":\n        case \"itemScope\":\n          value &&\n            \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(attributeSeparator, name, attributeEmptyString);\n          break;\n        case \"capture\":\n        case \"download\":\n          !0 === value\n            ? target.push(attributeSeparator, name, attributeEmptyString)\n            : !1 !== value &&\n              \"function\" !== typeof value &&\n              \"symbol\" !== typeof value &&\n              target.push(\n                attributeSeparator,\n                name,\n                attributeAssign,\n                escapeTextForBrowser(value),\n                attributeEnd\n              );\n          break;\n        case \"cols\":\n        case \"rows\":\n        case \"size\":\n        case \"span\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            !isNaN(value) &&\n            1 <= value &&\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"rowSpan\":\n        case \"start\":\n          \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            isNaN(value) ||\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"xlinkActuate\":\n          pushStringAttribute(target, \"xlink:actuate\", value);\n          break;\n        case \"xlinkArcrole\":\n          pushStringAttribute(target, \"xlink:arcrole\", value);\n          break;\n        case \"xlinkRole\":\n          pushStringAttribute(target, \"xlink:role\", value);\n          break;\n        case \"xlinkShow\":\n          pushStringAttribute(target, \"xlink:show\", value);\n          break;\n        case \"xlinkTitle\":\n          pushStringAttribute(target, \"xlink:title\", value);\n          break;\n        case \"xlinkType\":\n          pushStringAttribute(target, \"xlink:type\", value);\n          break;\n        case \"xmlBase\":\n          pushStringAttribute(target, \"xml:base\", value);\n          break;\n        case \"xmlLang\":\n          pushStringAttribute(target, \"xml:lang\", value);\n          break;\n        case \"xmlSpace\":\n          pushStringAttribute(target, \"xml:space\", value);\n          break;\n        default:\n          if (\n            !(2 < name.length) ||\n            (\"o\" !== name[0] && \"O\" !== name[0]) ||\n            (\"n\" !== name[1] && \"N\" !== name[1])\n          )\n            if (\n              ((name = aliases.get(name) || name), isAttributeNameSafe(name))\n            ) {\n              switch (typeof value) {\n                case \"function\":\n                case \"symbol\":\n                  return;\n                case \"boolean\":\n                  var prefix = name.toLowerCase().slice(0, 5);\n                  if (\"data-\" !== prefix && \"aria-\" !== prefix) return;\n              }\n              target.push(\n                attributeSeparator,\n                name,\n                attributeAssign,\n                escapeTextForBrowser(value),\n                attributeEnd\n              );\n            }\n      }\n    }\n    function pushInnerHTML(target, innerHTML, children) {\n      if (null != innerHTML) {\n        if (null != children)\n          throw Error(\n            \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n          );\n        if (\"object\" !== typeof innerHTML || !(\"__html\" in innerHTML))\n          throw Error(\n            \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n          );\n        innerHTML = innerHTML.__html;\n        null !== innerHTML &&\n          void 0 !== innerHTML &&\n          (checkHtmlStringCoercion(innerHTML), target.push(\"\" + innerHTML));\n      }\n    }\n    function checkSelectProp(props, propName) {\n      var value = props[propName];\n      null != value &&\n        ((value = isArrayImpl(value)),\n        props.multiple && !value\n          ? console.error(\n              \"The `%s` prop supplied to <select> must be an array if `multiple` is true.\",\n              propName\n            )\n          : !props.multiple &&\n            value &&\n            console.error(\n              \"The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.\",\n              propName\n            ));\n    }\n    function flattenOptionChildren(children) {\n      var content = \"\";\n      React.Children.forEach(children, function (child) {\n        null != child &&\n          ((content += child),\n          didWarnInvalidOptionChildren ||\n            \"string\" === typeof child ||\n            \"number\" === typeof child ||\n            \"bigint\" === typeof child ||\n            ((didWarnInvalidOptionChildren = !0),\n            console.error(\n              \"Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.\"\n            )));\n      });\n      return content;\n    }\n    function injectFormReplayingRuntime(resumableState, renderState) {\n      (resumableState.instructions & 16) === NothingSent &&\n        ((resumableState.instructions |= 16),\n        renderState.bootstrapChunks.unshift(\n          renderState.startInlineScript,\n          formReplayingRuntimeScript,\n          endInlineScript\n        ));\n    }\n    function pushLinkImpl(target, props) {\n      target.push(startChunkForTag(\"link\"));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function escapeStyleTextContent(styleText) {\n      checkHtmlStringCoercion(styleText);\n      return (\"\" + styleText).replace(styleRegex, styleReplacer);\n    }\n    function pushSelfClosing(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  tag +\n                    \" is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function pushTitleImpl(target, props) {\n      target.push(startChunkForTag(\"title\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      props = Array.isArray(children)\n        ? 2 > children.length\n          ? children[0]\n          : null\n        : children;\n      \"function\" !== typeof props &&\n        \"symbol\" !== typeof props &&\n        null !== props &&\n        void 0 !== props &&\n        target.push(escapeTextForBrowser(\"\" + props));\n      pushInnerHTML(target, innerHTML, children);\n      target.push(endChunkForTag(\"title\"));\n      return null;\n    }\n    function pushScriptImpl(target, props) {\n      target.push(startChunkForTag(\"script\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      null != children &&\n        \"string\" !== typeof children &&\n        ((props =\n          \"number\" === typeof children\n            ? \"a number for children\"\n            : Array.isArray(children)\n              ? \"an array for children\"\n              : \"something unexpected for children\"),\n        console.error(\n          \"A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.\",\n          props\n        ));\n      pushInnerHTML(target, innerHTML, children);\n      \"string\" === typeof children &&\n        target.push(escapeEntireInlineScriptContent(children));\n      target.push(endChunkForTag(\"script\"));\n      return null;\n    }\n    function pushStartSingletonElement(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      var innerHTML = (tag = null),\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                tag = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      pushInnerHTML(target, innerHTML, tag);\n      return tag;\n    }\n    function pushStartGenericElement(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      var innerHTML = (tag = null),\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                tag = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      pushInnerHTML(target, innerHTML, tag);\n      return \"string\" === typeof tag\n        ? (target.push(escapeTextForBrowser(tag)), null)\n        : tag;\n    }\n    function startChunkForTag(tag) {\n      var tagStartChunk = validatedTagCache.get(tag);\n      if (void 0 === tagStartChunk) {\n        if (!VALID_TAG_REGEX.test(tag)) throw Error(\"Invalid tag: \" + tag);\n        tagStartChunk = stringToPrecomputedChunk(\"<\" + tag);\n        validatedTagCache.set(tag, tagStartChunk);\n      }\n      return tagStartChunk;\n    }\n    function pushStartInstance(\n      target$jscomp$0,\n      type,\n      props,\n      resumableState,\n      renderState,\n      preambleState,\n      hoistableState,\n      formatContext,\n      textEmbedded,\n      isFallback\n    ) {\n      validateProperties$2(type, props);\n      (\"input\" !== type && \"textarea\" !== type && \"select\" !== type) ||\n        null == props ||\n        null !== props.value ||\n        didWarnValueNull ||\n        ((didWarnValueNull = !0),\n        \"select\" === type && props.multiple\n          ? console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.\",\n              type\n            )\n          : console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.\",\n              type\n            ));\n      b: if (-1 === type.indexOf(\"-\")) var JSCompiler_inline_result = !1;\n      else\n        switch (type) {\n          case \"annotation-xml\":\n          case \"color-profile\":\n          case \"font-face\":\n          case \"font-face-src\":\n          case \"font-face-uri\":\n          case \"font-face-format\":\n          case \"font-face-name\":\n          case \"missing-glyph\":\n            JSCompiler_inline_result = !1;\n            break b;\n          default:\n            JSCompiler_inline_result = !0;\n        }\n      JSCompiler_inline_result ||\n        \"string\" === typeof props.is ||\n        warnUnknownProperties(type, props, null);\n      !props.suppressContentEditableWarning &&\n        props.contentEditable &&\n        null != props.children &&\n        console.error(\n          \"A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.\"\n        );\n      formatContext.insertionMode !== SVG_MODE &&\n        formatContext.insertionMode !== MATHML_MODE &&\n        -1 === type.indexOf(\"-\") &&\n        type.toLowerCase() !== type &&\n        console.error(\n          \"<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.\",\n          type\n        );\n      switch (type) {\n        case \"div\":\n        case \"span\":\n        case \"svg\":\n        case \"path\":\n          break;\n        case \"a\":\n          target$jscomp$0.push(startChunkForTag(\"a\"));\n          var children = null,\n            innerHTML = null,\n            propKey;\n          for (propKey in props)\n            if (hasOwnProperty.call(props, propKey)) {\n              var propValue = props[propKey];\n              if (null != propValue)\n                switch (propKey) {\n                  case \"children\":\n                    children = propValue;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML = propValue;\n                    break;\n                  case \"href\":\n                    \"\" === propValue\n                      ? pushStringAttribute(target$jscomp$0, \"href\", \"\")\n                      : pushAttribute(target$jscomp$0, propKey, propValue);\n                    break;\n                  default:\n                    pushAttribute(target$jscomp$0, propKey, propValue);\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML, children);\n          if (\"string\" === typeof children) {\n            target$jscomp$0.push(escapeTextForBrowser(children));\n            var JSCompiler_inline_result$jscomp$0 = null;\n          } else JSCompiler_inline_result$jscomp$0 = children;\n          return JSCompiler_inline_result$jscomp$0;\n        case \"g\":\n        case \"p\":\n        case \"li\":\n          break;\n        case \"select\":\n          checkControlledValueProps(\"select\", props);\n          checkSelectProp(props, \"value\");\n          checkSelectProp(props, \"defaultValue\");\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultSelectValue ||\n            (console.error(\n              \"Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultSelectValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"select\"));\n          var children$jscomp$0 = null,\n            innerHTML$jscomp$0 = null,\n            propKey$jscomp$0;\n          for (propKey$jscomp$0 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$0)) {\n              var propValue$jscomp$0 = props[propKey$jscomp$0];\n              if (null != propValue$jscomp$0)\n                switch (propKey$jscomp$0) {\n                  case \"children\":\n                    children$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"defaultValue\":\n                  case \"value\":\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$0,\n                      propValue$jscomp$0\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);\n          return children$jscomp$0;\n        case \"option\":\n          var selectedValue = formatContext.selectedValue;\n          target$jscomp$0.push(startChunkForTag(\"option\"));\n          var children$jscomp$1 = null,\n            value = null,\n            selected = null,\n            innerHTML$jscomp$1 = null,\n            propKey$jscomp$1;\n          for (propKey$jscomp$1 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$1)) {\n              var propValue$jscomp$1 = props[propKey$jscomp$1];\n              if (null != propValue$jscomp$1)\n                switch (propKey$jscomp$1) {\n                  case \"children\":\n                    children$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"selected\":\n                    selected = propValue$jscomp$1;\n                    didWarnSelectedSetOnOption ||\n                      (console.error(\n                        \"Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.\"\n                      ),\n                      (didWarnSelectedSetOnOption = !0));\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"value\":\n                    value = propValue$jscomp$1;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$1,\n                      propValue$jscomp$1\n                    );\n                }\n            }\n          if (null != selectedValue) {\n            if (null !== value) {\n              checkAttributeStringCoercion(value, \"value\");\n              var stringValue = \"\" + value;\n            } else\n              null === innerHTML$jscomp$1 ||\n                didWarnInvalidOptionInnerHTML ||\n                ((didWarnInvalidOptionInnerHTML = !0),\n                console.error(\n                  \"Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.\"\n                )),\n                (stringValue = flattenOptionChildren(children$jscomp$1));\n            if (isArrayImpl(selectedValue))\n              for (var i = 0; i < selectedValue.length; i++) {\n                if (\n                  (checkAttributeStringCoercion(selectedValue[i], \"value\"),\n                  \"\" + selectedValue[i] === stringValue)\n                ) {\n                  target$jscomp$0.push(selectedMarkerAttribute);\n                  break;\n                }\n              }\n            else\n              checkAttributeStringCoercion(selectedValue, \"select.value\"),\n                \"\" + selectedValue === stringValue &&\n                  target$jscomp$0.push(selectedMarkerAttribute);\n          } else selected && target$jscomp$0.push(selectedMarkerAttribute);\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);\n          return children$jscomp$1;\n        case \"textarea\":\n          checkControlledValueProps(\"textarea\", props);\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultTextareaValue ||\n            (console.error(\n              \"Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultTextareaValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"textarea\"));\n          var value$jscomp$0 = null,\n            defaultValue = null,\n            children$jscomp$2 = null,\n            propKey$jscomp$2;\n          for (propKey$jscomp$2 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$2)) {\n              var propValue$jscomp$2 = props[propKey$jscomp$2];\n              if (null != propValue$jscomp$2)\n                switch (propKey$jscomp$2) {\n                  case \"children\":\n                    children$jscomp$2 = propValue$jscomp$2;\n                    break;\n                  case \"value\":\n                    value$jscomp$0 = propValue$jscomp$2;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue = propValue$jscomp$2;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"`dangerouslySetInnerHTML` does not make sense on <textarea>.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$2,\n                      propValue$jscomp$2\n                    );\n                }\n            }\n          null === value$jscomp$0 &&\n            null !== defaultValue &&\n            (value$jscomp$0 = defaultValue);\n          target$jscomp$0.push(endOfStartTag);\n          if (null != children$jscomp$2) {\n            console.error(\n              \"Use the `defaultValue` or `value` props instead of setting children on <textarea>.\"\n            );\n            if (null != value$jscomp$0)\n              throw Error(\n                \"If you supply `defaultValue` on a <textarea>, do not pass children.\"\n              );\n            if (isArrayImpl(children$jscomp$2)) {\n              if (1 < children$jscomp$2.length)\n                throw Error(\"<textarea> can only have at most one child.\");\n              checkHtmlStringCoercion(children$jscomp$2[0]);\n              value$jscomp$0 = \"\" + children$jscomp$2[0];\n            }\n            checkHtmlStringCoercion(children$jscomp$2);\n            value$jscomp$0 = \"\" + children$jscomp$2;\n          }\n          \"string\" === typeof value$jscomp$0 &&\n            \"\\n\" === value$jscomp$0[0] &&\n            target$jscomp$0.push(leadingNewline);\n          null !== value$jscomp$0 &&\n            (checkAttributeStringCoercion(value$jscomp$0, \"value\"),\n            target$jscomp$0.push(escapeTextForBrowser(\"\" + value$jscomp$0)));\n          return null;\n        case \"input\":\n          checkControlledValueProps(\"input\", props);\n          target$jscomp$0.push(startChunkForTag(\"input\"));\n          var name = null,\n            formAction = null,\n            formEncType = null,\n            formMethod = null,\n            formTarget = null,\n            value$jscomp$1 = null,\n            defaultValue$jscomp$0 = null,\n            checked = null,\n            defaultChecked = null,\n            propKey$jscomp$3;\n          for (propKey$jscomp$3 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$3)) {\n              var propValue$jscomp$3 = props[propKey$jscomp$3];\n              if (null != propValue$jscomp$3)\n                switch (propKey$jscomp$3) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  case \"name\":\n                    name = propValue$jscomp$3;\n                    break;\n                  case \"formAction\":\n                    formAction = propValue$jscomp$3;\n                    break;\n                  case \"formEncType\":\n                    formEncType = propValue$jscomp$3;\n                    break;\n                  case \"formMethod\":\n                    formMethod = propValue$jscomp$3;\n                    break;\n                  case \"formTarget\":\n                    formTarget = propValue$jscomp$3;\n                    break;\n                  case \"defaultChecked\":\n                    defaultChecked = propValue$jscomp$3;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue$jscomp$0 = propValue$jscomp$3;\n                    break;\n                  case \"checked\":\n                    checked = propValue$jscomp$3;\n                    break;\n                  case \"value\":\n                    value$jscomp$1 = propValue$jscomp$3;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$3,\n                      propValue$jscomp$3\n                    );\n                }\n            }\n          null === formAction ||\n            \"image\" === props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'An input can only specify a formAction along with type=\"submit\" or type=\"image\".'\n            ));\n          var formData = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction,\n            formEncType,\n            formMethod,\n            formTarget,\n            name\n          );\n          null === checked ||\n            null === defaultChecked ||\n            didWarnDefaultChecked ||\n            (console.error(\n              \"%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultChecked = !0));\n          null === value$jscomp$1 ||\n            null === defaultValue$jscomp$0 ||\n            didWarnDefaultInputValue ||\n            (console.error(\n              \"%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultInputValue = !0));\n          null !== checked\n            ? pushBooleanAttribute(target$jscomp$0, \"checked\", checked)\n            : null !== defaultChecked &&\n              pushBooleanAttribute(target$jscomp$0, \"checked\", defaultChecked);\n          null !== value$jscomp$1\n            ? pushAttribute(target$jscomp$0, \"value\", value$jscomp$1)\n            : null !== defaultValue$jscomp$0 &&\n              pushAttribute(target$jscomp$0, \"value\", defaultValue$jscomp$0);\n          target$jscomp$0.push(endOfStartTagSelfClosing);\n          null != formData &&\n            formData.forEach(pushAdditionalFormField, target$jscomp$0);\n          return null;\n        case \"button\":\n          target$jscomp$0.push(startChunkForTag(\"button\"));\n          var children$jscomp$3 = null,\n            innerHTML$jscomp$2 = null,\n            name$jscomp$0 = null,\n            formAction$jscomp$0 = null,\n            formEncType$jscomp$0 = null,\n            formMethod$jscomp$0 = null,\n            formTarget$jscomp$0 = null,\n            propKey$jscomp$4;\n          for (propKey$jscomp$4 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$4)) {\n              var propValue$jscomp$4 = props[propKey$jscomp$4];\n              if (null != propValue$jscomp$4)\n                switch (propKey$jscomp$4) {\n                  case \"children\":\n                    children$jscomp$3 = propValue$jscomp$4;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$2 = propValue$jscomp$4;\n                    break;\n                  case \"name\":\n                    name$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formAction\":\n                    formAction$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formEncType\":\n                    formEncType$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formMethod\":\n                    formMethod$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formTarget\":\n                    formTarget$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$4,\n                      propValue$jscomp$4\n                    );\n                }\n            }\n          null === formAction$jscomp$0 ||\n            null == props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'A button can only specify a formAction along with type=\"submit\" or no type.'\n            ));\n          var formData$jscomp$0 = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction$jscomp$0,\n            formEncType$jscomp$0,\n            formMethod$jscomp$0,\n            formTarget$jscomp$0,\n            name$jscomp$0\n          );\n          target$jscomp$0.push(endOfStartTag);\n          null != formData$jscomp$0 &&\n            formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);\n          if (\"string\" === typeof children$jscomp$3) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));\n            var JSCompiler_inline_result$jscomp$1 = null;\n          } else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;\n          return JSCompiler_inline_result$jscomp$1;\n        case \"form\":\n          target$jscomp$0.push(startChunkForTag(\"form\"));\n          var children$jscomp$4 = null,\n            innerHTML$jscomp$3 = null,\n            formAction$jscomp$1 = null,\n            formEncType$jscomp$1 = null,\n            formMethod$jscomp$1 = null,\n            formTarget$jscomp$1 = null,\n            propKey$jscomp$5;\n          for (propKey$jscomp$5 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$5)) {\n              var propValue$jscomp$5 = props[propKey$jscomp$5];\n              if (null != propValue$jscomp$5)\n                switch (propKey$jscomp$5) {\n                  case \"children\":\n                    children$jscomp$4 = propValue$jscomp$5;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$3 = propValue$jscomp$5;\n                    break;\n                  case \"action\":\n                    formAction$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"encType\":\n                    formEncType$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"method\":\n                    formMethod$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"target\":\n                    formTarget$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$5,\n                      propValue$jscomp$5\n                    );\n                }\n            }\n          var formData$jscomp$1 = null,\n            formActionName = null;\n          if (\"function\" === typeof formAction$jscomp$1) {\n            (null === formEncType$jscomp$1 && null === formMethod$jscomp$1) ||\n              didWarnFormActionMethod ||\n              ((didWarnFormActionMethod = !0),\n              console.error(\n                \"Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.\"\n              ));\n            null === formTarget$jscomp$1 ||\n              didWarnFormActionTarget ||\n              ((didWarnFormActionTarget = !0),\n              console.error(\n                \"Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window.\"\n              ));\n            var customFields = getCustomFormFields(\n              resumableState,\n              formAction$jscomp$1\n            );\n            null !== customFields\n              ? ((formAction$jscomp$1 = customFields.action || \"\"),\n                (formEncType$jscomp$1 = customFields.encType),\n                (formMethod$jscomp$1 = customFields.method),\n                (formTarget$jscomp$1 = customFields.target),\n                (formData$jscomp$1 = customFields.data),\n                (formActionName = customFields.name))\n              : (target$jscomp$0.push(\n                  attributeSeparator,\n                  \"action\",\n                  attributeAssign,\n                  actionJavaScriptURL,\n                  attributeEnd\n                ),\n                (formTarget$jscomp$1 =\n                  formMethod$jscomp$1 =\n                  formEncType$jscomp$1 =\n                  formAction$jscomp$1 =\n                    null),\n                injectFormReplayingRuntime(resumableState, renderState));\n          }\n          null != formAction$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"action\", formAction$jscomp$1);\n          null != formEncType$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"encType\", formEncType$jscomp$1);\n          null != formMethod$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"method\", formMethod$jscomp$1);\n          null != formTarget$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"target\", formTarget$jscomp$1);\n          target$jscomp$0.push(endOfStartTag);\n          null !== formActionName &&\n            (target$jscomp$0.push(startHiddenInputChunk),\n            pushStringAttribute(target$jscomp$0, \"name\", formActionName),\n            target$jscomp$0.push(endOfStartTagSelfClosing),\n            null != formData$jscomp$1 &&\n              formData$jscomp$1.forEach(\n                pushAdditionalFormField,\n                target$jscomp$0\n              ));\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);\n          if (\"string\" === typeof children$jscomp$4) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));\n            var JSCompiler_inline_result$jscomp$2 = null;\n          } else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;\n          return JSCompiler_inline_result$jscomp$2;\n        case \"menuitem\":\n          target$jscomp$0.push(startChunkForTag(\"menuitem\"));\n          for (var propKey$jscomp$6 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$6)) {\n              var propValue$jscomp$6 = props[propKey$jscomp$6];\n              if (null != propValue$jscomp$6)\n                switch (propKey$jscomp$6) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$6,\n                      propValue$jscomp$6\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          return null;\n        case \"object\":\n          target$jscomp$0.push(startChunkForTag(\"object\"));\n          var children$jscomp$5 = null,\n            innerHTML$jscomp$4 = null,\n            propKey$jscomp$7;\n          for (propKey$jscomp$7 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$7)) {\n              var propValue$jscomp$7 = props[propKey$jscomp$7];\n              if (null != propValue$jscomp$7)\n                switch (propKey$jscomp$7) {\n                  case \"children\":\n                    children$jscomp$5 = propValue$jscomp$7;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$4 = propValue$jscomp$7;\n                    break;\n                  case \"data\":\n                    checkAttributeStringCoercion(propValue$jscomp$7, \"data\");\n                    var sanitizedValue = sanitizeURL(\"\" + propValue$jscomp$7);\n                    if (\"\" === sanitizedValue) {\n                      console.error(\n                        'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                        propKey$jscomp$7,\n                        propKey$jscomp$7\n                      );\n                      break;\n                    }\n                    target$jscomp$0.push(\n                      attributeSeparator,\n                      \"data\",\n                      attributeAssign,\n                      escapeTextForBrowser(sanitizedValue),\n                      attributeEnd\n                    );\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$7,\n                      propValue$jscomp$7\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);\n          if (\"string\" === typeof children$jscomp$5) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));\n            var JSCompiler_inline_result$jscomp$3 = null;\n          } else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;\n          return JSCompiler_inline_result$jscomp$3;\n        case \"title\":\n          var insertionMode = formatContext.insertionMode,\n            noscriptTagInScope = !!(formatContext.tagScope & 1);\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$6 = props.children,\n              child = Array.isArray(children$jscomp$6)\n                ? 2 > children$jscomp$6.length\n                  ? children$jscomp$6[0]\n                  : null\n                : children$jscomp$6;\n            Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length\n              ? console.error(\n                  \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.\",\n                  children$jscomp$6.length\n                )\n              : \"function\" === typeof child || \"symbol\" === typeof child\n                ? console.error(\n                    \"React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.\",\n                    \"function\" === typeof child ? \"a Function\" : \"a Sybmol\"\n                  )\n                : child &&\n                  child.toString === {}.toString &&\n                  (null != child.$$typeof\n                    ? console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.\"\n                      )\n                    : console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>.\"\n                      ));\n          }\n          if (\n            insertionMode === SVG_MODE ||\n            noscriptTagInScope ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(\n              target$jscomp$0,\n              props\n            );\n          else\n            isFallback\n              ? (JSCompiler_inline_result$jscomp$4 = null)\n              : (pushTitleImpl(renderState.hoistableChunks, props),\n                (JSCompiler_inline_result$jscomp$4 = void 0));\n          return JSCompiler_inline_result$jscomp$4;\n        case \"link\":\n          var rel = props.rel,\n            href = props.href,\n            precedence = props.precedence;\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp ||\n            \"string\" !== typeof rel ||\n            \"string\" !== typeof href ||\n            \"\" === href\n          ) {\n            \"stylesheet\" === rel &&\n              \"string\" === typeof props.precedence &&\n              ((\"string\" === typeof href && href) ||\n                console.error(\n                  'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',\n                  null === href\n                    ? \"`null`\"\n                    : void 0 === href\n                      ? \"`undefined`\"\n                      : \"\" === href\n                        ? \"an empty string\"\n                        : 'something with type \"' + typeof href + '\"'\n                ));\n            pushLinkImpl(target$jscomp$0, props);\n            var JSCompiler_inline_result$jscomp$5 = null;\n          } else if (\"stylesheet\" === props.rel)\n            if (\n              \"string\" !== typeof precedence ||\n              null != props.disabled ||\n              props.onLoad ||\n              props.onError\n            ) {\n              if (\"string\" === typeof precedence)\n                if (null != props.disabled)\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'\n                  );\n                else if (props.onLoad || props.onError) {\n                  var propDescription =\n                    props.onLoad && props.onError\n                      ? \"`onLoad` and `onError` props\"\n                      : props.onLoad\n                        ? \"`onLoad` prop\"\n                        : \"`onError` prop\";\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',\n                    propDescription,\n                    propDescription\n                  );\n                }\n              JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                target$jscomp$0,\n                props\n              );\n            } else {\n              var styleQueue = renderState.styles.get(precedence),\n                resourceState = resumableState.styleResources.hasOwnProperty(\n                  href\n                )\n                  ? resumableState.styleResources[href]\n                  : void 0;\n              if (resourceState !== EXISTS) {\n                resumableState.styleResources[href] = EXISTS;\n                styleQueue ||\n                  ((styleQueue = {\n                    precedence: escapeTextForBrowser(precedence),\n                    rules: [],\n                    hrefs: [],\n                    sheets: new Map()\n                  }),\n                  renderState.styles.set(precedence, styleQueue));\n                var resource = {\n                  state: PENDING$1,\n                  props: assign({}, props, {\n                    \"data-precedence\": props.precedence,\n                    precedence: null\n                  })\n                };\n                if (resourceState) {\n                  2 === resourceState.length &&\n                    adoptPreloadCredentials(resource.props, resourceState);\n                  var preloadResource =\n                    renderState.preloads.stylesheets.get(href);\n                  preloadResource && 0 < preloadResource.length\n                    ? (preloadResource.length = 0)\n                    : (resource.state = PRELOADED);\n                }\n                styleQueue.sheets.set(href, resource);\n                hoistableState && hoistableState.stylesheets.add(resource);\n              } else if (styleQueue) {\n                var _resource = styleQueue.sheets.get(href);\n                _resource &&\n                  hoistableState &&\n                  hoistableState.stylesheets.add(_resource);\n              }\n              textEmbedded && target$jscomp$0.push(textSeparator);\n              JSCompiler_inline_result$jscomp$5 = null;\n            }\n          else\n            props.onLoad || props.onError\n              ? (JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                  target$jscomp$0,\n                  props\n                ))\n              : (textEmbedded && target$jscomp$0.push(textSeparator),\n                (JSCompiler_inline_result$jscomp$5 = isFallback\n                  ? null\n                  : pushLinkImpl(renderState.hoistableChunks, props)));\n          return JSCompiler_inline_result$jscomp$5;\n        case \"script\":\n          var asyncProp = props.async;\n          if (\n            \"string\" !== typeof props.src ||\n            !props.src ||\n            !asyncProp ||\n            \"function\" === typeof asyncProp ||\n            \"symbol\" === typeof asyncProp ||\n            props.onLoad ||\n            props.onError ||\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(\n              target$jscomp$0,\n              props\n            );\n          else {\n            var key = props.src;\n            if (\"module\" === props.type) {\n              var resources = resumableState.moduleScriptResources;\n              var preloads = renderState.preloads.moduleScripts;\n            } else\n              (resources = resumableState.scriptResources),\n                (preloads = renderState.preloads.scripts);\n            var resourceState$jscomp$0 = resources.hasOwnProperty(key)\n              ? resources[key]\n              : void 0;\n            if (resourceState$jscomp$0 !== EXISTS) {\n              resources[key] = EXISTS;\n              var scriptProps = props;\n              if (resourceState$jscomp$0) {\n                2 === resourceState$jscomp$0.length &&\n                  ((scriptProps = assign({}, props)),\n                  adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));\n                var preloadResource$jscomp$0 = preloads.get(key);\n                preloadResource$jscomp$0 &&\n                  (preloadResource$jscomp$0.length = 0);\n              }\n              var resource$jscomp$0 = [];\n              renderState.scripts.add(resource$jscomp$0);\n              pushScriptImpl(resource$jscomp$0, scriptProps);\n            }\n            textEmbedded && target$jscomp$0.push(textSeparator);\n            JSCompiler_inline_result$jscomp$6 = null;\n          }\n          return JSCompiler_inline_result$jscomp$6;\n        case \"style\":\n          var insertionMode$jscomp$0 = formatContext.insertionMode,\n            noscriptTagInScope$jscomp$0 = !!(formatContext.tagScope & 1);\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$7 = props.children,\n              child$jscomp$0 = Array.isArray(children$jscomp$7)\n                ? 2 > children$jscomp$7.length\n                  ? children$jscomp$7[0]\n                  : null\n                : children$jscomp$7;\n            (\"function\" === typeof child$jscomp$0 ||\n              \"symbol\" === typeof child$jscomp$0 ||\n              Array.isArray(child$jscomp$0)) &&\n              console.error(\n                \"React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.\",\n                \"function\" === typeof child$jscomp$0\n                  ? \"a Function\"\n                  : \"symbol\" === typeof child$jscomp$0\n                    ? \"a Sybmol\"\n                    : \"an Array\"\n              );\n          }\n          var precedence$jscomp$0 = props.precedence,\n            href$jscomp$0 = props.href;\n          if (\n            insertionMode$jscomp$0 === SVG_MODE ||\n            noscriptTagInScope$jscomp$0 ||\n            null != props.itemProp ||\n            \"string\" !== typeof precedence$jscomp$0 ||\n            \"string\" !== typeof href$jscomp$0 ||\n            \"\" === href$jscomp$0\n          ) {\n            target$jscomp$0.push(startChunkForTag(\"style\"));\n            var children$jscomp$8 = null,\n              innerHTML$jscomp$5 = null,\n              propKey$jscomp$8;\n            for (propKey$jscomp$8 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$8)) {\n                var propValue$jscomp$8 = props[propKey$jscomp$8];\n                if (null != propValue$jscomp$8)\n                  switch (propKey$jscomp$8) {\n                    case \"children\":\n                      children$jscomp$8 = propValue$jscomp$8;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$5 = propValue$jscomp$8;\n                      break;\n                    default:\n                      pushAttribute(\n                        target$jscomp$0,\n                        propKey$jscomp$8,\n                        propValue$jscomp$8\n                      );\n                  }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            var child$jscomp$1 = Array.isArray(children$jscomp$8)\n              ? 2 > children$jscomp$8.length\n                ? children$jscomp$8[0]\n                : null\n              : children$jscomp$8;\n            \"function\" !== typeof child$jscomp$1 &&\n              \"symbol\" !== typeof child$jscomp$1 &&\n              null !== child$jscomp$1 &&\n              void 0 !== child$jscomp$1 &&\n              target$jscomp$0.push(escapeStyleTextContent(child$jscomp$1));\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$5,\n              children$jscomp$8\n            );\n            target$jscomp$0.push(endChunkForTag(\"style\"));\n            var JSCompiler_inline_result$jscomp$7 = null;\n          } else {\n            href$jscomp$0.includes(\" \") &&\n              console.error(\n                'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".',\n                href$jscomp$0\n              );\n            var styleQueue$jscomp$0 =\n                renderState.styles.get(precedence$jscomp$0),\n              resourceState$jscomp$1 =\n                resumableState.styleResources.hasOwnProperty(href$jscomp$0)\n                  ? resumableState.styleResources[href$jscomp$0]\n                  : void 0;\n            if (resourceState$jscomp$1 !== EXISTS) {\n              resumableState.styleResources[href$jscomp$0] = EXISTS;\n              resourceState$jscomp$1 &&\n                console.error(\n                  'React encountered a hoistable style tag for the same href as a preload: \"%s\". When using a style tag to inline styles you should not also preload it as a stylsheet.',\n                  href$jscomp$0\n                );\n              styleQueue$jscomp$0\n                ? styleQueue$jscomp$0.hrefs.push(\n                    escapeTextForBrowser(href$jscomp$0)\n                  )\n                : ((styleQueue$jscomp$0 = {\n                    precedence: escapeTextForBrowser(precedence$jscomp$0),\n                    rules: [],\n                    hrefs: [escapeTextForBrowser(href$jscomp$0)],\n                    sheets: new Map()\n                  }),\n                  renderState.styles.set(\n                    precedence$jscomp$0,\n                    styleQueue$jscomp$0\n                  ));\n              var target = styleQueue$jscomp$0.rules,\n                children$jscomp$9 = null,\n                innerHTML$jscomp$6 = null,\n                propKey$jscomp$9;\n              for (propKey$jscomp$9 in props)\n                if (hasOwnProperty.call(props, propKey$jscomp$9)) {\n                  var propValue$jscomp$9 = props[propKey$jscomp$9];\n                  if (null != propValue$jscomp$9)\n                    switch (propKey$jscomp$9) {\n                      case \"children\":\n                        children$jscomp$9 = propValue$jscomp$9;\n                        break;\n                      case \"dangerouslySetInnerHTML\":\n                        innerHTML$jscomp$6 = propValue$jscomp$9;\n                    }\n                }\n              var child$jscomp$2 = Array.isArray(children$jscomp$9)\n                ? 2 > children$jscomp$9.length\n                  ? children$jscomp$9[0]\n                  : null\n                : children$jscomp$9;\n              \"function\" !== typeof child$jscomp$2 &&\n                \"symbol\" !== typeof child$jscomp$2 &&\n                null !== child$jscomp$2 &&\n                void 0 !== child$jscomp$2 &&\n                target.push(escapeStyleTextContent(child$jscomp$2));\n              pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);\n            }\n            styleQueue$jscomp$0 &&\n              hoistableState &&\n              hoistableState.styles.add(styleQueue$jscomp$0);\n            textEmbedded && target$jscomp$0.push(textSeparator);\n            JSCompiler_inline_result$jscomp$7 = void 0;\n          }\n          return JSCompiler_inline_result$jscomp$7;\n        case \"meta\":\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(\n              target$jscomp$0,\n              props,\n              \"meta\"\n            );\n          else\n            textEmbedded && target$jscomp$0.push(textSeparator),\n              (JSCompiler_inline_result$jscomp$8 = isFallback\n                ? null\n                : \"string\" === typeof props.charSet\n                  ? pushSelfClosing(renderState.charsetChunks, props, \"meta\")\n                  : \"viewport\" === props.name\n                    ? pushSelfClosing(renderState.viewportChunks, props, \"meta\")\n                    : pushSelfClosing(\n                        renderState.hoistableChunks,\n                        props,\n                        \"meta\"\n                      ));\n          return JSCompiler_inline_result$jscomp$8;\n        case \"listing\":\n        case \"pre\":\n          target$jscomp$0.push(startChunkForTag(type));\n          var children$jscomp$10 = null,\n            innerHTML$jscomp$7 = null,\n            propKey$jscomp$10;\n          for (propKey$jscomp$10 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$10)) {\n              var propValue$jscomp$10 = props[propKey$jscomp$10];\n              if (null != propValue$jscomp$10)\n                switch (propKey$jscomp$10) {\n                  case \"children\":\n                    children$jscomp$10 = propValue$jscomp$10;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$7 = propValue$jscomp$10;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$10,\n                      propValue$jscomp$10\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          if (null != innerHTML$jscomp$7) {\n            if (null != children$jscomp$10)\n              throw Error(\n                \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n              );\n            if (\n              \"object\" !== typeof innerHTML$jscomp$7 ||\n              !(\"__html\" in innerHTML$jscomp$7)\n            )\n              throw Error(\n                \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n              );\n            var html = innerHTML$jscomp$7.__html;\n            null !== html &&\n              void 0 !== html &&\n              (\"string\" === typeof html && 0 < html.length && \"\\n\" === html[0]\n                ? target$jscomp$0.push(leadingNewline, html)\n                : (checkHtmlStringCoercion(html),\n                  target$jscomp$0.push(\"\" + html)));\n          }\n          \"string\" === typeof children$jscomp$10 &&\n            \"\\n\" === children$jscomp$10[0] &&\n            target$jscomp$0.push(leadingNewline);\n          return children$jscomp$10;\n        case \"img\":\n          var src = props.src,\n            srcSet = props.srcSet;\n          if (\n            !(\n              \"lazy\" === props.loading ||\n              (!src && !srcSet) ||\n              (\"string\" !== typeof src && null != src) ||\n              (\"string\" !== typeof srcSet && null != srcSet)\n            ) &&\n            \"low\" !== props.fetchPriority &&\n            !1 === !!(formatContext.tagScope & 3) &&\n            (\"string\" !== typeof src ||\n              \":\" !== src[4] ||\n              (\"d\" !== src[0] && \"D\" !== src[0]) ||\n              (\"a\" !== src[1] && \"A\" !== src[1]) ||\n              (\"t\" !== src[2] && \"T\" !== src[2]) ||\n              (\"a\" !== src[3] && \"A\" !== src[3])) &&\n            (\"string\" !== typeof srcSet ||\n              \":\" !== srcSet[4] ||\n              (\"d\" !== srcSet[0] && \"D\" !== srcSet[0]) ||\n              (\"a\" !== srcSet[1] && \"A\" !== srcSet[1]) ||\n              (\"t\" !== srcSet[2] && \"T\" !== srcSet[2]) ||\n              (\"a\" !== srcSet[3] && \"A\" !== srcSet[3]))\n          ) {\n            var sizes = \"string\" === typeof props.sizes ? props.sizes : void 0,\n              key$jscomp$0 = srcSet ? srcSet + \"\\n\" + (sizes || \"\") : src,\n              promotablePreloads = renderState.preloads.images,\n              resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);\n            if (resource$jscomp$1) {\n              if (\n                \"high\" === props.fetchPriority ||\n                10 > renderState.highImagePreloads.size\n              )\n                promotablePreloads.delete(key$jscomp$0),\n                  renderState.highImagePreloads.add(resource$jscomp$1);\n            } else if (\n              !resumableState.imageResources.hasOwnProperty(key$jscomp$0)\n            ) {\n              resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;\n              var input = props.crossOrigin;\n              var crossOrigin =\n                \"string\" === typeof input\n                  ? \"use-credentials\" === input\n                    ? input\n                    : \"\"\n                  : void 0;\n              var headers = renderState.headers,\n                header;\n              headers &&\n              0 < headers.remainingCapacity &&\n              \"string\" !== typeof props.srcSet &&\n              (\"high\" === props.fetchPriority ||\n                500 > headers.highImagePreloads.length) &&\n              ((header = getPreloadAsHeader(src, \"image\", {\n                imageSrcSet: props.srcSet,\n                imageSizes: props.sizes,\n                crossOrigin: crossOrigin,\n                integrity: props.integrity,\n                nonce: props.nonce,\n                type: props.type,\n                fetchPriority: props.fetchPriority,\n                referrerPolicy: props.refererPolicy\n              })),\n              0 <= (headers.remainingCapacity -= header.length + 2))\n                ? ((renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS),\n                  headers.highImagePreloads &&\n                    (headers.highImagePreloads += \", \"),\n                  (headers.highImagePreloads += header))\n                : ((resource$jscomp$1 = []),\n                  pushLinkImpl(resource$jscomp$1, {\n                    rel: \"preload\",\n                    as: \"image\",\n                    href: srcSet ? void 0 : src,\n                    imageSrcSet: srcSet,\n                    imageSizes: sizes,\n                    crossOrigin: crossOrigin,\n                    integrity: props.integrity,\n                    type: props.type,\n                    fetchPriority: props.fetchPriority,\n                    referrerPolicy: props.referrerPolicy\n                  }),\n                  \"high\" === props.fetchPriority ||\n                  10 > renderState.highImagePreloads.size\n                    ? renderState.highImagePreloads.add(resource$jscomp$1)\n                    : (renderState.bulkPreloads.add(resource$jscomp$1),\n                      promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));\n            }\n          }\n          return pushSelfClosing(target$jscomp$0, props, \"img\");\n        case \"base\":\n        case \"area\":\n        case \"br\":\n        case \"col\":\n        case \"embed\":\n        case \"hr\":\n        case \"keygen\":\n        case \"param\":\n        case \"source\":\n        case \"track\":\n        case \"wbr\":\n          return pushSelfClosing(target$jscomp$0, props, type);\n        case \"annotation-xml\":\n        case \"color-profile\":\n        case \"font-face\":\n        case \"font-face-src\":\n        case \"font-face-uri\":\n        case \"font-face-format\":\n        case \"font-face-name\":\n        case \"missing-glyph\":\n          break;\n        case \"head\":\n          if (formatContext.insertionMode < HTML_MODE) {\n            var preamble = preambleState || renderState.preamble;\n            if (preamble.headChunks)\n              throw Error(\"The `<head>` tag may only be rendered once.\");\n            preamble.headChunks = [];\n            var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(\n              preamble.headChunks,\n              props,\n              \"head\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"head\"\n            );\n          return JSCompiler_inline_result$jscomp$9;\n        case \"body\":\n          if (formatContext.insertionMode < HTML_MODE) {\n            var preamble$jscomp$0 = preambleState || renderState.preamble;\n            if (preamble$jscomp$0.bodyChunks)\n              throw Error(\"The `<body>` tag may only be rendered once.\");\n            preamble$jscomp$0.bodyChunks = [];\n            var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(\n              preamble$jscomp$0.bodyChunks,\n              props,\n              \"body\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"body\"\n            );\n          return JSCompiler_inline_result$jscomp$10;\n        case \"html\":\n          if (formatContext.insertionMode === ROOT_HTML_MODE) {\n            var preamble$jscomp$1 = preambleState || renderState.preamble;\n            if (preamble$jscomp$1.htmlChunks)\n              throw Error(\"The `<html>` tag may only be rendered once.\");\n            preamble$jscomp$1.htmlChunks = [doctypeChunk];\n            var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(\n              preamble$jscomp$1.htmlChunks,\n              props,\n              \"html\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"html\"\n            );\n          return JSCompiler_inline_result$jscomp$11;\n        default:\n          if (-1 !== type.indexOf(\"-\")) {\n            target$jscomp$0.push(startChunkForTag(type));\n            var children$jscomp$11 = null,\n              innerHTML$jscomp$8 = null,\n              propKey$jscomp$11;\n            for (propKey$jscomp$11 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$11)) {\n                var propValue$jscomp$11 = props[propKey$jscomp$11];\n                if (null != propValue$jscomp$11) {\n                  var attributeName = propKey$jscomp$11;\n                  switch (propKey$jscomp$11) {\n                    case \"children\":\n                      children$jscomp$11 = propValue$jscomp$11;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$8 = propValue$jscomp$11;\n                      break;\n                    case \"style\":\n                      pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);\n                      break;\n                    case \"suppressContentEditableWarning\":\n                    case \"suppressHydrationWarning\":\n                    case \"ref\":\n                      break;\n                    case \"className\":\n                      attributeName = \"class\";\n                    default:\n                      if (\n                        isAttributeNameSafe(propKey$jscomp$11) &&\n                        \"function\" !== typeof propValue$jscomp$11 &&\n                        \"symbol\" !== typeof propValue$jscomp$11 &&\n                        !1 !== propValue$jscomp$11\n                      ) {\n                        if (!0 === propValue$jscomp$11)\n                          propValue$jscomp$11 = \"\";\n                        else if (\"object\" === typeof propValue$jscomp$11)\n                          continue;\n                        target$jscomp$0.push(\n                          attributeSeparator,\n                          attributeName,\n                          attributeAssign,\n                          escapeTextForBrowser(propValue$jscomp$11),\n                          attributeEnd\n                        );\n                      }\n                  }\n                }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$8,\n              children$jscomp$11\n            );\n            return children$jscomp$11;\n          }\n      }\n      return pushStartGenericElement(target$jscomp$0, props, type);\n    }\n    function endChunkForTag(tag) {\n      var chunk = endTagCache.get(tag);\n      void 0 === chunk &&\n        ((chunk = stringToPrecomputedChunk(\"</\" + tag + \">\")),\n        endTagCache.set(tag, chunk));\n      return chunk;\n    }\n    function hoistPreambleState(renderState, preambleState) {\n      renderState = renderState.preamble;\n      null === renderState.htmlChunks &&\n        preambleState.htmlChunks &&\n        ((renderState.htmlChunks = preambleState.htmlChunks),\n        (preambleState.contribution |= 1));\n      null === renderState.headChunks &&\n        preambleState.headChunks &&\n        ((renderState.headChunks = preambleState.headChunks),\n        (preambleState.contribution |= 4));\n      null === renderState.bodyChunks &&\n        preambleState.bodyChunks &&\n        ((renderState.bodyChunks = preambleState.bodyChunks),\n        (preambleState.contribution |= 2));\n    }\n    function writeBootstrap(destination, renderState) {\n      renderState = renderState.bootstrapChunks;\n      for (var i = 0; i < renderState.length - 1; i++)\n        writeChunk(destination, renderState[i]);\n      return i < renderState.length\n        ? ((i = renderState[i]),\n          (renderState.length = 0),\n          writeChunkAndReturn(destination, i))\n        : !0;\n    }\n    function writeStartPendingSuspenseBoundary(destination, renderState, id) {\n      writeChunk(destination, startPendingSuspenseBoundary1);\n      if (null === id)\n        throw Error(\n          \"An ID must have been assigned before we can complete the boundary.\"\n        );\n      writeChunk(destination, renderState.boundaryPrefix);\n      writeChunk(destination, id.toString(16));\n      return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);\n    }\n    function writePreambleContribution(destination, preambleState) {\n      preambleState = preambleState.contribution;\n      preambleState !== NoContribution &&\n        (writeChunk(destination, boundaryPreambleContributionChunkStart),\n        writeChunk(destination, \"\" + preambleState),\n        writeChunk(destination, boundaryPreambleContributionChunkEnd));\n    }\n    function writeStartSegment(destination, renderState, formatContext, id) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_HEAD_MODE:\n        case HTML_MODE:\n          return (\n            writeChunk(destination, startSegmentHTML),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, id.toString(16)),\n            writeChunkAndReturn(destination, startSegmentHTML2)\n          );\n        case SVG_MODE:\n          return (\n            writeChunk(destination, startSegmentSVG),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, id.toString(16)),\n            writeChunkAndReturn(destination, startSegmentSVG2)\n          );\n        case MATHML_MODE:\n          return (\n            writeChunk(destination, startSegmentMathML),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, id.toString(16)),\n            writeChunkAndReturn(destination, startSegmentMathML2)\n          );\n        case HTML_TABLE_MODE:\n          return (\n            writeChunk(destination, startSegmentTable),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, id.toString(16)),\n            writeChunkAndReturn(destination, startSegmentTable2)\n          );\n        case HTML_TABLE_BODY_MODE:\n          return (\n            writeChunk(destination, startSegmentTableBody),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, id.toString(16)),\n            writeChunkAndReturn(destination, startSegmentTableBody2)\n          );\n        case HTML_TABLE_ROW_MODE:\n          return (\n            writeChunk(destination, startSegmentTableRow),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, id.toString(16)),\n            writeChunkAndReturn(destination, startSegmentTableRow2)\n          );\n        case HTML_COLGROUP_MODE:\n          return (\n            writeChunk(destination, startSegmentColGroup),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, id.toString(16)),\n            writeChunkAndReturn(destination, startSegmentColGroup2)\n          );\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function writeEndSegment(destination, formatContext) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_HEAD_MODE:\n        case HTML_MODE:\n          return writeChunkAndReturn(destination, endSegmentHTML);\n        case SVG_MODE:\n          return writeChunkAndReturn(destination, endSegmentSVG);\n        case MATHML_MODE:\n          return writeChunkAndReturn(destination, endSegmentMathML);\n        case HTML_TABLE_MODE:\n          return writeChunkAndReturn(destination, endSegmentTable);\n        case HTML_TABLE_BODY_MODE:\n          return writeChunkAndReturn(destination, endSegmentTableBody);\n        case HTML_TABLE_ROW_MODE:\n          return writeChunkAndReturn(destination, endSegmentTableRow);\n        case HTML_COLGROUP_MODE:\n          return writeChunkAndReturn(destination, endSegmentColGroup);\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function escapeJSStringsForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInInstructionScripts,\n        function (match) {\n          switch (match) {\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function escapeJSObjectForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInScripts,\n        function (match) {\n          switch (match) {\n            case \"&\":\n              return \"\\\\u0026\";\n            case \">\":\n              return \"\\\\u003e\";\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function flushStyleTagsLateForBoundary(styleQueue) {\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      0 < rules.length &&\n        0 === hrefs.length &&\n        console.error(\n          \"React expected to have at least one href for an a hoistable style but found none. This is a bug in React.\"\n        );\n      var i = 0;\n      if (hrefs.length) {\n        writeChunk(this, lateStyleTagResourceOpen1);\n        writeChunk(this, styleQueue.precedence);\n        for (\n          writeChunk(this, lateStyleTagResourceOpen2);\n          i < hrefs.length - 1;\n          i++\n        )\n          writeChunk(this, hrefs[i]), writeChunk(this, spaceSeparator);\n        writeChunk(this, hrefs[i]);\n        writeChunk(this, lateStyleTagResourceOpen3);\n        for (i = 0; i < rules.length; i++) writeChunk(this, rules[i]);\n        destinationHasCapacity = writeChunkAndReturn(\n          this,\n          lateStyleTagTemplateClose\n        );\n        currentlyRenderingBoundaryHasStylesToHoist = !0;\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function hasStylesToHoist(stylesheet) {\n      return stylesheet.state !== PREAMBLE\n        ? (currentlyRenderingBoundaryHasStylesToHoist = !0)\n        : !1;\n    }\n    function writeHoistablesForBoundary(\n      destination,\n      hoistableState,\n      renderState\n    ) {\n      currentlyRenderingBoundaryHasStylesToHoist = !1;\n      destinationHasCapacity = !0;\n      hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);\n      hoistableState.stylesheets.forEach(hasStylesToHoist);\n      currentlyRenderingBoundaryHasStylesToHoist &&\n        (renderState.stylesToHoist = !0);\n      return destinationHasCapacity;\n    }\n    function flushResource(resource) {\n      for (var i = 0; i < resource.length; i++) writeChunk(this, resource[i]);\n      resource.length = 0;\n    }\n    function flushStyleInPreamble(stylesheet) {\n      pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);\n      for (var i = 0; i < stylesheetFlushingQueue.length; i++)\n        writeChunk(this, stylesheetFlushingQueue[i]);\n      stylesheetFlushingQueue.length = 0;\n      stylesheet.state = PREAMBLE;\n    }\n    function flushStylesInPreamble(styleQueue) {\n      var hasStylesheets = 0 < styleQueue.sheets.size;\n      styleQueue.sheets.forEach(flushStyleInPreamble, this);\n      styleQueue.sheets.clear();\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      if (!hasStylesheets || hrefs.length) {\n        writeChunk(this, styleTagResourceOpen1);\n        writeChunk(this, styleQueue.precedence);\n        styleQueue = 0;\n        if (hrefs.length) {\n          for (\n            writeChunk(this, styleTagResourceOpen2);\n            styleQueue < hrefs.length - 1;\n            styleQueue++\n          )\n            writeChunk(this, hrefs[styleQueue]),\n              writeChunk(this, spaceSeparator);\n          writeChunk(this, hrefs[styleQueue]);\n        }\n        writeChunk(this, styleTagResourceOpen3);\n        for (styleQueue = 0; styleQueue < rules.length; styleQueue++)\n          writeChunk(this, rules[styleQueue]);\n        writeChunk(this, styleTagResourceClose);\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function preloadLateStyle(stylesheet) {\n      if (stylesheet.state === PENDING$1) {\n        stylesheet.state = PRELOADED;\n        var props = stylesheet.props;\n        pushLinkImpl(stylesheetFlushingQueue, {\n          rel: \"preload\",\n          as: \"style\",\n          href: stylesheet.props.href,\n          crossOrigin: props.crossOrigin,\n          fetchPriority: props.fetchPriority,\n          integrity: props.integrity,\n          media: props.media,\n          hrefLang: props.hrefLang,\n          referrerPolicy: props.referrerPolicy\n        });\n        for (\n          stylesheet = 0;\n          stylesheet < stylesheetFlushingQueue.length;\n          stylesheet++\n        )\n          writeChunk(this, stylesheetFlushingQueue[stylesheet]);\n        stylesheetFlushingQueue.length = 0;\n      }\n    }\n    function preloadLateStyles(styleQueue) {\n      styleQueue.sheets.forEach(preloadLateStyle, this);\n      styleQueue.sheets.clear();\n    }\n    function writeStyleResourceDependenciesInJS(destination, hoistableState) {\n      writeChunk(destination, arrayFirstOpenBracket);\n      var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n      hoistableState.stylesheets.forEach(function (resource) {\n        if (resource.state !== PREAMBLE)\n          if (resource.state === LATE)\n            writeChunk(destination, nextArrayOpenBrackChunk),\n              (resource = resource.props.href),\n              checkAttributeStringCoercion(resource, \"href\"),\n              writeChunk(\n                destination,\n                escapeJSObjectForInstructionScripts(\"\" + resource)\n              ),\n              writeChunk(destination, arrayCloseBracket),\n              (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);\n          else {\n            writeChunk(destination, nextArrayOpenBrackChunk);\n            var precedence = resource.props[\"data-precedence\"],\n              props = resource.props,\n              coercedHref = sanitizeURL(\"\" + resource.props.href);\n            writeChunk(\n              destination,\n              escapeJSObjectForInstructionScripts(coercedHref)\n            );\n            checkAttributeStringCoercion(precedence, \"precedence\");\n            precedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(\n              destination,\n              escapeJSObjectForInstructionScripts(precedence)\n            );\n            for (var propKey in props)\n              if (\n                hasOwnProperty.call(props, propKey) &&\n                ((precedence = props[propKey]), null != precedence)\n              )\n                switch (propKey) {\n                  case \"href\":\n                  case \"rel\":\n                  case \"precedence\":\n                  case \"data-precedence\":\n                    break;\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    writeStyleResourceAttributeInJS(\n                      destination,\n                      propKey,\n                      precedence\n                    );\n                }\n            writeChunk(destination, arrayCloseBracket);\n            nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n            resource.state = LATE;\n          }\n      });\n      writeChunk(destination, arrayCloseBracket);\n    }\n    function writeStyleResourceAttributeInJS(destination, name, value) {\n      var attributeName = name.toLowerCase();\n      switch (typeof value) {\n        case \"function\":\n        case \"symbol\":\n          return;\n      }\n      switch (name) {\n        case \"innerHTML\":\n        case \"dangerouslySetInnerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"style\":\n        case \"ref\":\n          return;\n        case \"className\":\n          attributeName = \"class\";\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        case \"hidden\":\n          if (!1 === value) return;\n          name = \"\";\n          break;\n        case \"src\":\n        case \"href\":\n          value = sanitizeURL(value);\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        default:\n          if (\n            (2 < name.length &&\n              (\"o\" === name[0] || \"O\" === name[0]) &&\n              (\"n\" === name[1] || \"N\" === name[1])) ||\n            !isAttributeNameSafe(name)\n          )\n            return;\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n      }\n      writeChunk(destination, arrayInterstitial);\n      writeChunk(\n        destination,\n        escapeJSObjectForInstructionScripts(attributeName)\n      );\n      writeChunk(destination, arrayInterstitial);\n      writeChunk(destination, escapeJSObjectForInstructionScripts(name));\n    }\n    function createHoistableState() {\n      return { styles: new Set(), stylesheets: new Set() };\n    }\n    function preloadBootstrapScriptOrModule(\n      resumableState,\n      renderState,\n      href,\n      props\n    ) {\n      (resumableState.scriptResources.hasOwnProperty(href) ||\n        resumableState.moduleScriptResources.hasOwnProperty(href)) &&\n        console.error(\n          'Internal React Error: React expected bootstrap script or module with src \"%s\" to not have been preloaded already. please file an issue',\n          href\n        );\n      resumableState.scriptResources[href] = EXISTS;\n      resumableState.moduleScriptResources[href] = EXISTS;\n      resumableState = [];\n      pushLinkImpl(resumableState, props);\n      renderState.bootstrapScripts.add(resumableState);\n    }\n    function adoptPreloadCredentials(target, preloadState) {\n      null == target.crossOrigin && (target.crossOrigin = preloadState[0]);\n      null == target.integrity && (target.integrity = preloadState[1]);\n    }\n    function getPreloadAsHeader(href, as, params) {\n      href = escapeHrefForLinkHeaderURLContext(href);\n      as = escapeStringForLinkHeaderQuotedParamValueContext(as, \"as\");\n      as = \"<\" + href + '>; rel=preload; as=\"' + as + '\"';\n      for (var paramName in params)\n        hasOwnProperty.call(params, paramName) &&\n          ((href = params[paramName]),\n          \"string\" === typeof href &&\n            (as +=\n              \"; \" +\n              paramName.toLowerCase() +\n              '=\"' +\n              escapeStringForLinkHeaderQuotedParamValueContext(\n                href,\n                paramName\n              ) +\n              '\"'));\n      return as;\n    }\n    function escapeHrefForLinkHeaderURLContext(hrefInput) {\n      checkAttributeStringCoercion(hrefInput, \"href\");\n      return (\"\" + hrefInput).replace(\n        regexForHrefInLinkHeaderURLContext,\n        escapeHrefForLinkHeaderURLContextReplacer\n      );\n    }\n    function escapeHrefForLinkHeaderURLContextReplacer(match) {\n      switch (match) {\n        case \"<\":\n          return \"%3C\";\n        case \">\":\n          return \"%3E\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {\n      willCoercionThrow(value) &&\n        (console.error(\n          \"The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          name,\n          typeName(value)\n        ),\n        testStringCoercion(value));\n      return (\"\" + value).replace(\n        regexForLinkHeaderQuotedParamValueContext,\n        escapeStringForLinkHeaderQuotedParamValueContextReplacer\n      );\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {\n      switch (match) {\n        case '\"':\n          return \"%22\";\n        case \"'\":\n          return \"%27\";\n        case \";\":\n          return \"%3B\";\n        case \",\":\n          return \"%2C\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function hoistStyleQueueDependency(styleQueue) {\n      this.styles.add(styleQueue);\n    }\n    function hoistStylesheetDependency(stylesheet) {\n      this.stylesheets.add(stylesheet);\n    }\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function popToNearestCommonAncestor(prev, next) {\n      if (prev !== next) {\n        prev.context._currentValue = prev.parentValue;\n        prev = prev.parent;\n        var parentNext = next.parent;\n        if (null === prev) {\n          if (null !== parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n        } else {\n          if (null === parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n          popToNearestCommonAncestor(prev, parentNext);\n        }\n        next.context._currentValue = next.value;\n      }\n    }\n    function popAllPrevious(prev) {\n      prev.context._currentValue = prev.parentValue;\n      prev = prev.parent;\n      null !== prev && popAllPrevious(prev);\n    }\n    function pushAllNext(next) {\n      var parentNext = next.parent;\n      null !== parentNext && pushAllNext(parentNext);\n      next.context._currentValue = next.value;\n    }\n    function popPreviousToCommonLevel(prev, next) {\n      prev.context._currentValue = prev.parentValue;\n      prev = prev.parent;\n      if (null === prev)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === next.depth\n        ? popToNearestCommonAncestor(prev, next)\n        : popPreviousToCommonLevel(prev, next);\n    }\n    function popNextToCommonLevel(prev, next) {\n      var parentNext = next.parent;\n      if (null === parentNext)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === parentNext.depth\n        ? popToNearestCommonAncestor(prev, parentNext)\n        : popNextToCommonLevel(prev, parentNext);\n      next.context._currentValue = next.value;\n    }\n    function switchContext(newSnapshot) {\n      var prev = currentActiveSnapshot;\n      prev !== newSnapshot &&\n        (null === prev\n          ? pushAllNext(newSnapshot)\n          : null === newSnapshot\n            ? popAllPrevious(prev)\n            : prev.depth === newSnapshot.depth\n              ? popToNearestCommonAncestor(prev, newSnapshot)\n              : prev.depth > newSnapshot.depth\n                ? popPreviousToCommonLevel(prev, newSnapshot)\n                : popNextToCommonLevel(prev, newSnapshot),\n        (currentActiveSnapshot = newSnapshot));\n    }\n    function warnOnInvalidCallback(callback) {\n      if (null !== callback && \"function\" !== typeof callback) {\n        var key = String(callback);\n        didWarnOnInvalidCallback.has(key) ||\n          (didWarnOnInvalidCallback.add(key),\n          console.error(\n            \"Expected the last optional `callback` argument to be a function. Instead received: %s.\",\n            callback\n          ));\n      }\n    }\n    function warnNoop(publicInstance, callerName) {\n      publicInstance =\n        ((publicInstance = publicInstance.constructor) &&\n          getComponentNameFromType(publicInstance)) ||\n        \"ReactClass\";\n      var warningKey = publicInstance + \".\" + callerName;\n      didWarnAboutNoopUpdateForComponent[warningKey] ||\n        (console.error(\n          \"Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\\n\\nPlease check the code for the %s component.\",\n          callerName,\n          publicInstance\n        ),\n        (didWarnAboutNoopUpdateForComponent[warningKey] = !0));\n    }\n    function pushTreeContext(baseContext, totalChildren, index) {\n      var baseIdWithLeadingBit = baseContext.id;\n      baseContext = baseContext.overflow;\n      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n      baseIdWithLeadingBit &= ~(1 << baseLength);\n      index += 1;\n      var length = 32 - clz32(totalChildren) + baseLength;\n      if (30 < length) {\n        var numberOfOverflowBits = baseLength - (baseLength % 5);\n        length = (\n          baseIdWithLeadingBit &\n          ((1 << numberOfOverflowBits) - 1)\n        ).toString(32);\n        baseIdWithLeadingBit >>= numberOfOverflowBits;\n        baseLength -= numberOfOverflowBits;\n        return {\n          id:\n            (1 << (32 - clz32(totalChildren) + baseLength)) |\n            (index << baseLength) |\n            baseIdWithLeadingBit,\n          overflow: length + baseContext\n        };\n      }\n      return {\n        id: (1 << length) | (index << baseLength) | baseIdWithLeadingBit,\n        overflow: baseContext\n      };\n    }\n    function clz32Fallback(x) {\n      x >>>= 0;\n      return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;\n    }\n    function noop$2() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n      index = thenableState[index];\n      void 0 === index\n        ? thenableState.push(thenable)\n        : index !== thenable &&\n          (thenable.then(noop$2, noop$2), (thenable = index));\n      switch (thenable.status) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n        default:\n          \"string\" === typeof thenable.status\n            ? thenable.then(noop$2, noop$2)\n            : ((thenableState = thenable),\n              (thenableState.status = \"pending\"),\n              thenableState.then(\n                function (fulfilledValue) {\n                  if (\"pending\" === thenable.status) {\n                    var fulfilledThenable = thenable;\n                    fulfilledThenable.status = \"fulfilled\";\n                    fulfilledThenable.value = fulfilledValue;\n                  }\n                },\n                function (error) {\n                  if (\"pending\" === thenable.status) {\n                    var rejectedThenable = thenable;\n                    rejectedThenable.status = \"rejected\";\n                    rejectedThenable.reason = error;\n                  }\n                }\n              ));\n          switch (thenable.status) {\n            case \"fulfilled\":\n              return thenable.value;\n            case \"rejected\":\n              throw thenable.reason;\n          }\n          suspendedThenable = thenable;\n          throw SuspenseException;\n      }\n    }\n    function getSuspendedThenable() {\n      if (null === suspendedThenable)\n        throw Error(\n          \"Expected a suspended thenable. This is a bug in React. Please file an issue.\"\n        );\n      var thenable = suspendedThenable;\n      suspendedThenable = null;\n      return thenable;\n    }\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function resolveCurrentlyRenderingComponent() {\n      if (null === currentlyRenderingComponent)\n        throw Error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\"\n        );\n      return currentlyRenderingComponent;\n    }\n    function createHook() {\n      if (0 < numberOfReRenders)\n        throw Error(\"Rendered more hooks than during the previous render\");\n      return { memoizedState: null, queue: null, next: null };\n    }\n    function createWorkInProgressHook() {\n      null === workInProgressHook\n        ? null === firstWorkInProgressHook\n          ? ((isReRender = !1),\n            (firstWorkInProgressHook = workInProgressHook = createHook()))\n          : ((isReRender = !0), (workInProgressHook = firstWorkInProgressHook))\n        : null === workInProgressHook.next\n          ? ((isReRender = !1),\n            (workInProgressHook = workInProgressHook.next = createHook()))\n          : ((isReRender = !0), (workInProgressHook = workInProgressHook.next));\n      return workInProgressHook;\n    }\n    function getThenableStateAfterSuspending() {\n      var state = thenableState;\n      thenableState = null;\n      return state;\n    }\n    function resetHooksState() {\n      isInHookUserCodeInDev = !1;\n      currentlyRenderingKeyPath =\n        currentlyRenderingRequest =\n        currentlyRenderingTask =\n        currentlyRenderingComponent =\n          null;\n      didScheduleRenderPhaseUpdate = !1;\n      firstWorkInProgressHook = null;\n      numberOfReRenders = 0;\n      workInProgressHook = renderPhaseUpdates = null;\n    }\n    function readContext(context) {\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\"\n        );\n      return context._currentValue;\n    }\n    function basicStateReducer(state, action) {\n      return \"function\" === typeof action ? action(state) : action;\n    }\n    function useReducer(reducer, initialArg, init) {\n      reducer !== basicStateReducer && (currentHookNameInDev = \"useReducer\");\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      if (isReRender) {\n        init = workInProgressHook.queue;\n        initialArg = init.dispatch;\n        if (null !== renderPhaseUpdates) {\n          var firstRenderPhaseUpdate = renderPhaseUpdates.get(init);\n          if (void 0 !== firstRenderPhaseUpdate) {\n            renderPhaseUpdates.delete(init);\n            init = workInProgressHook.memoizedState;\n            do {\n              var action = firstRenderPhaseUpdate.action;\n              isInHookUserCodeInDev = !0;\n              init = reducer(init, action);\n              isInHookUserCodeInDev = !1;\n              firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;\n            } while (null !== firstRenderPhaseUpdate);\n            workInProgressHook.memoizedState = init;\n            return [init, initialArg];\n          }\n        }\n        return [workInProgressHook.memoizedState, initialArg];\n      }\n      isInHookUserCodeInDev = !0;\n      reducer =\n        reducer === basicStateReducer\n          ? \"function\" === typeof initialArg\n            ? initialArg()\n            : initialArg\n          : void 0 !== init\n            ? init(initialArg)\n            : initialArg;\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = reducer;\n      reducer = workInProgressHook.queue = { last: null, dispatch: null };\n      reducer = reducer.dispatch = dispatchAction.bind(\n        null,\n        currentlyRenderingComponent,\n        reducer\n      );\n      return [workInProgressHook.memoizedState, reducer];\n    }\n    function useMemo(nextCreate, deps) {\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      deps = void 0 === deps ? null : deps;\n      if (null !== workInProgressHook) {\n        var prevState = workInProgressHook.memoizedState;\n        if (null !== prevState && null !== deps) {\n          a: {\n            var JSCompiler_inline_result = prevState[1];\n            if (null === JSCompiler_inline_result)\n              console.error(\n                \"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\",\n                currentHookNameInDev\n              ),\n                (JSCompiler_inline_result = !1);\n            else {\n              deps.length !== JSCompiler_inline_result.length &&\n                console.error(\n                  \"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\",\n                  currentHookNameInDev,\n                  \"[\" + deps.join(\", \") + \"]\",\n                  \"[\" + JSCompiler_inline_result.join(\", \") + \"]\"\n                );\n              for (\n                var i = 0;\n                i < JSCompiler_inline_result.length && i < deps.length;\n                i++\n              )\n                if (!objectIs(deps[i], JSCompiler_inline_result[i])) {\n                  JSCompiler_inline_result = !1;\n                  break a;\n                }\n              JSCompiler_inline_result = !0;\n            }\n          }\n          if (JSCompiler_inline_result) return prevState[0];\n        }\n      }\n      isInHookUserCodeInDev = !0;\n      nextCreate = nextCreate();\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = [nextCreate, deps];\n      return nextCreate;\n    }\n    function dispatchAction(componentIdentity, queue, action) {\n      if (25 <= numberOfReRenders)\n        throw Error(\n          \"Too many re-renders. React limits the number of renders to prevent an infinite loop.\"\n        );\n      if (componentIdentity === currentlyRenderingComponent)\n        if (\n          ((didScheduleRenderPhaseUpdate = !0),\n          (componentIdentity = { action: action, next: null }),\n          null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),\n          (action = renderPhaseUpdates.get(queue)),\n          void 0 === action)\n        )\n          renderPhaseUpdates.set(queue, componentIdentity);\n        else {\n          for (queue = action; null !== queue.next; ) queue = queue.next;\n          queue.next = componentIdentity;\n        }\n    }\n    function unsupportedStartTransition() {\n      throw Error(\"startTransition cannot be called during server rendering.\");\n    }\n    function unsupportedSetOptimisticState() {\n      throw Error(\"Cannot update optimistic state while rendering.\");\n    }\n    function createPostbackActionStateKey(\n      permalink,\n      componentKeyPath,\n      hookIndex\n    ) {\n      if (void 0 !== permalink) return \"p\" + permalink;\n      permalink = JSON.stringify([componentKeyPath, null, hookIndex]);\n      componentKeyPath = crypto.createHash(\"md5\");\n      componentKeyPath.update(permalink);\n      return \"k\" + componentKeyPath.digest(\"hex\");\n    }\n    function useActionState(action, initialState, permalink) {\n      resolveCurrentlyRenderingComponent();\n      var actionStateHookIndex = actionStateCounter++,\n        request = currentlyRenderingRequest;\n      if (\"function\" === typeof action.$$FORM_ACTION) {\n        var nextPostbackStateKey = null,\n          componentKeyPath = currentlyRenderingKeyPath;\n        request = request.formState;\n        var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;\n        if (null !== request && \"function\" === typeof isSignatureEqual) {\n          var postbackKey = request[1];\n          isSignatureEqual.call(action, request[2], request[3]) &&\n            ((nextPostbackStateKey = createPostbackActionStateKey(\n              permalink,\n              componentKeyPath,\n              actionStateHookIndex\n            )),\n            postbackKey === nextPostbackStateKey &&\n              ((actionStateMatchingIndex = actionStateHookIndex),\n              (initialState = request[0])));\n        }\n        var boundAction = action.bind(null, initialState);\n        action = function (payload) {\n          boundAction(payload);\n        };\n        \"function\" === typeof boundAction.$$FORM_ACTION &&\n          (action.$$FORM_ACTION = function (prefix) {\n            prefix = boundAction.$$FORM_ACTION(prefix);\n            void 0 !== permalink &&\n              (checkAttributeStringCoercion(permalink, \"target\"),\n              (permalink += \"\"),\n              (prefix.action = permalink));\n            var formData = prefix.data;\n            formData &&\n              (null === nextPostbackStateKey &&\n                (nextPostbackStateKey = createPostbackActionStateKey(\n                  permalink,\n                  componentKeyPath,\n                  actionStateHookIndex\n                )),\n              formData.append(\"$ACTION_KEY\", nextPostbackStateKey));\n            return prefix;\n          });\n        return [initialState, action, !1];\n      }\n      var _boundAction = action.bind(null, initialState);\n      return [\n        initialState,\n        function (payload) {\n          _boundAction(payload);\n        },\n        !1\n      ];\n    }\n    function unwrapThenable(thenable) {\n      var index = thenableIndexCounter;\n      thenableIndexCounter += 1;\n      null === thenableState && (thenableState = []);\n      return trackUsedThenable(thenableState, thenable, index);\n    }\n    function unsupportedRefresh() {\n      throw Error(\"Cache cannot be refreshed during server rendering.\");\n    }\n    function noop$1() {}\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function prepareStackTrace(error, structuredStackTrace) {\n      error = (error.name || \"Error\") + \": \" + (error.message || \"\");\n      for (var i = 0; i < structuredStackTrace.length; i++)\n        error += \"\\n    at \" + structuredStackTrace[i].toString();\n      return error;\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = prepareStackTrace;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function formatOwnerStack(error) {\n      var prevPrepareStackTrace = Error.prepareStackTrace;\n      Error.prepareStackTrace = prepareStackTrace;\n      error = error.stack;\n      Error.prepareStackTrace = prevPrepareStackTrace;\n      error.startsWith(\"Error: react-stack-top-frame\\n\") &&\n        (error = error.slice(29));\n      prevPrepareStackTrace = error.indexOf(\"\\n\");\n      -1 !== prevPrepareStackTrace &&\n        (error = error.slice(prevPrepareStackTrace + 1));\n      prevPrepareStackTrace = error.indexOf(\"react-stack-bottom-frame\");\n      -1 !== prevPrepareStackTrace &&\n        (prevPrepareStackTrace = error.lastIndexOf(\n          \"\\n\",\n          prevPrepareStackTrace\n        ));\n      if (-1 !== prevPrepareStackTrace)\n        error = error.slice(0, prevPrepareStackTrace);\n      else return \"\";\n      return error;\n    }\n    function describeComponentStackByType(type) {\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      if (\"function\" === typeof type)\n        return type.prototype && type.prototype.isReactComponent\n          ? describeNativeComponentFrame(type, !0)\n          : describeNativeComponentFrame(type, !1);\n      if (\"object\" === typeof type && null !== type) {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeNativeComponentFrame(type.render, !1);\n          case REACT_MEMO_TYPE:\n            return describeNativeComponentFrame(type.type, !1);\n          case REACT_LAZY_TYPE:\n            var lazyComponent = type,\n              payload = lazyComponent._payload;\n            lazyComponent = lazyComponent._init;\n            try {\n              type = lazyComponent(payload);\n            } catch (x) {\n              return describeBuiltInComponentFrame(\"Lazy\");\n            }\n            return describeComponentStackByType(type);\n        }\n        if (\"string\" === typeof type.name)\n          return (\n            (payload = type.env),\n            describeBuiltInComponentFrame(\n              type.name + (payload ? \" [\" + payload + \"]\" : \"\")\n            )\n          );\n      }\n      switch (type) {\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n      }\n      return \"\";\n    }\n    function defaultErrorHandler(error) {\n      if (\n        \"object\" === typeof error &&\n        null !== error &&\n        \"string\" === typeof error.environmentName\n      ) {\n        var JSCompiler_inline_result = error.environmentName;\n        error = [error].slice(0);\n        \"string\" === typeof error[0]\n          ? error.splice(\n              0,\n              1,\n              \"\\u001b[0m\\u001b[7m%c%s\\u001b[0m%c \" + error[0],\n              \"background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px\",\n              \" \" + JSCompiler_inline_result + \" \",\n              \"\"\n            )\n          : error.splice(\n              0,\n              0,\n              \"\\u001b[0m\\u001b[7m%c%s\\u001b[0m%c \",\n              \"background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px\",\n              \" \" + JSCompiler_inline_result + \" \",\n              \"\"\n            );\n        error.unshift(console);\n        JSCompiler_inline_result = bind.apply(console.error, error);\n        JSCompiler_inline_result();\n      } else console.error(error);\n      return null;\n    }\n    function noop() {}\n    function RequestInstance(\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      var abortSet = new Set();\n      this.destination = null;\n      this.flushScheduled = !1;\n      this.resumableState = resumableState;\n      this.renderState = renderState;\n      this.rootFormatContext = rootFormatContext;\n      this.progressiveChunkSize =\n        void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;\n      this.status = 10;\n      this.fatalError = null;\n      this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;\n      this.completedPreambleSegments = this.completedRootSegment = null;\n      this.abortableTasks = abortSet;\n      this.pingedTasks = [];\n      this.clientRenderedBoundaries = [];\n      this.completedBoundaries = [];\n      this.partialBoundaries = [];\n      this.trackedPostpones = null;\n      this.onError = void 0 === onError ? defaultErrorHandler : onError;\n      this.onPostpone = void 0 === onPostpone ? noop : onPostpone;\n      this.onAllReady = void 0 === onAllReady ? noop : onAllReady;\n      this.onShellReady = void 0 === onShellReady ? noop : onShellReady;\n      this.onShellError = void 0 === onShellError ? noop : onShellError;\n      this.onFatalError = void 0 === onFatalError ? noop : onFatalError;\n      this.formState = void 0 === formState ? null : formState;\n      this.didWarnForKey = null;\n    }\n    function createRequest(\n      children,\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      resumableState = new RequestInstance(\n        resumableState,\n        renderState,\n        rootFormatContext,\n        progressiveChunkSize,\n        onError,\n        onAllReady,\n        onShellReady,\n        onShellError,\n        onFatalError,\n        onPostpone,\n        formState\n      );\n      renderState = createPendingSegment(\n        resumableState,\n        0,\n        null,\n        rootFormatContext,\n        !1,\n        !1\n      );\n      renderState.parentFlushed = !0;\n      children = createRenderTask(\n        resumableState,\n        null,\n        children,\n        -1,\n        null,\n        renderState,\n        null,\n        null,\n        resumableState.abortableTasks,\n        null,\n        rootFormatContext,\n        null,\n        emptyTreeContext,\n        null,\n        !1,\n        emptyContextObject,\n        null\n      );\n      pushComponentStack(children);\n      resumableState.pingedTasks.push(children);\n      return resumableState;\n    }\n    function createPrerenderRequest(\n      children,\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone\n    ) {\n      children = createRequest(\n        children,\n        resumableState,\n        renderState,\n        rootFormatContext,\n        progressiveChunkSize,\n        onError,\n        onAllReady,\n        onShellReady,\n        onShellError,\n        onFatalError,\n        onPostpone,\n        void 0\n      );\n      children.trackedPostpones = {\n        workingMap: new Map(),\n        rootNodes: [],\n        rootSlots: null\n      };\n      return children;\n    }\n    function resolveRequest() {\n      if (currentRequest) return currentRequest;\n      var store = requestStorage.getStore();\n      return store ? store : null;\n    }\n    function pingTask(request, task) {\n      request.pingedTasks.push(task);\n      1 === request.pingedTasks.length &&\n        ((request.flushScheduled = null !== request.destination),\n        null !== request.trackedPostpones || 10 === request.status\n          ? scheduleMicrotask(function () {\n              return performWork(request);\n            })\n          : setImmediate(function () {\n              return performWork(request);\n            }));\n    }\n    function createSuspenseBoundary(\n      request,\n      fallbackAbortableTasks,\n      contentPreamble,\n      fallbackPreamble\n    ) {\n      return {\n        status: PENDING,\n        rootSegmentID: -1,\n        parentFlushed: !1,\n        pendingTasks: 0,\n        completedSegments: [],\n        byteSize: 0,\n        fallbackAbortableTasks: fallbackAbortableTasks,\n        errorDigest: null,\n        contentState: createHoistableState(),\n        fallbackState: createHoistableState(),\n        contentPreamble: contentPreamble,\n        fallbackPreamble: fallbackPreamble,\n        trackedContentKeyPath: null,\n        trackedFallbackNode: null,\n        errorMessage: null,\n        errorStack: null,\n        errorComponentStack: null\n      };\n    }\n    function createRenderTask(\n      request,\n      thenableState,\n      node,\n      childIndex,\n      blockedBoundary,\n      blockedSegment,\n      blockedPreamble,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      componentStack,\n      isFallback,\n      legacyContext,\n      debugTask\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      var task = {\n        replay: null,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: blockedSegment,\n        blockedPreamble: blockedPreamble,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        componentStack: componentStack,\n        thenableState: thenableState,\n        isFallback: isFallback\n      };\n      task.debugTask = debugTask;\n      abortSet.add(task);\n      return task;\n    }\n    function createReplayTask(\n      request,\n      thenableState,\n      replay,\n      node,\n      childIndex,\n      blockedBoundary,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      componentStack,\n      isFallback,\n      legacyContext,\n      debugTask\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      replay.pendingTasks++;\n      var task = {\n        replay: replay,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: null,\n        blockedPreamble: null,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        componentStack: componentStack,\n        thenableState: thenableState,\n        isFallback: isFallback\n      };\n      task.debugTask = debugTask;\n      abortSet.add(task);\n      return task;\n    }\n    function createPendingSegment(\n      request,\n      index,\n      boundary,\n      parentFormatContext,\n      lastPushedText,\n      textEmbedded\n    ) {\n      return {\n        status: PENDING,\n        parentFlushed: !1,\n        id: -1,\n        index: index,\n        chunks: [],\n        children: [],\n        preambleChildren: [],\n        parentFormatContext: parentFormatContext,\n        boundary: boundary,\n        lastPushedText: lastPushedText,\n        textEmbedded: textEmbedded\n      };\n    }\n    function getCurrentStackInDEV() {\n      if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)\n        return \"\";\n      var componentStack = currentTaskInDEV.componentStack;\n      try {\n        var info = \"\";\n        if (\"string\" === typeof componentStack.type)\n          info += describeBuiltInComponentFrame(componentStack.type);\n        else if (\"function\" === typeof componentStack.type) {\n          if (!componentStack.owner) {\n            var JSCompiler_temp_const = info,\n              fn = componentStack.type,\n              name = fn ? fn.displayName || fn.name : \"\";\n            var JSCompiler_inline_result = name\n              ? describeBuiltInComponentFrame(name)\n              : \"\";\n            info = JSCompiler_temp_const + JSCompiler_inline_result;\n          }\n        } else\n          componentStack.owner ||\n            (info += describeComponentStackByType(componentStack.type));\n        for (; componentStack; )\n          (JSCompiler_temp_const = null),\n            null != componentStack.debugStack\n              ? (JSCompiler_temp_const = formatOwnerStack(\n                  componentStack.debugStack\n                ))\n              : ((JSCompiler_inline_result = componentStack),\n                null != JSCompiler_inline_result.stack &&\n                  (JSCompiler_temp_const =\n                    \"string\" !== typeof JSCompiler_inline_result.stack\n                      ? (JSCompiler_inline_result.stack = formatOwnerStack(\n                          JSCompiler_inline_result.stack\n                        ))\n                      : JSCompiler_inline_result.stack)),\n            (componentStack = componentStack.owner) &&\n              JSCompiler_temp_const &&\n              (info += \"\\n\" + JSCompiler_temp_const);\n        var JSCompiler_inline_result$jscomp$0 = info;\n      } catch (x) {\n        JSCompiler_inline_result$jscomp$0 =\n          \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n      }\n      return JSCompiler_inline_result$jscomp$0;\n    }\n    function pushServerComponentStack(task, debugInfo) {\n      if (null != debugInfo)\n        for (var i = 0; i < debugInfo.length; i++) {\n          var componentInfo = debugInfo[i];\n          \"string\" === typeof componentInfo.name &&\n            void 0 !== componentInfo.debugStack &&\n            ((task.componentStack = {\n              parent: task.componentStack,\n              type: componentInfo,\n              owner: componentInfo.owner,\n              stack: componentInfo.debugStack\n            }),\n            (task.debugTask = componentInfo.debugTask));\n        }\n    }\n    function pushComponentStack(task) {\n      var node = task.node;\n      if (\"object\" === typeof node && null !== node)\n        switch (node.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n            var type = node.type,\n              owner = node._owner,\n              stack = node._debugStack;\n            pushServerComponentStack(task, node._debugInfo);\n            task.debugTask = node._debugTask;\n            task.componentStack = {\n              parent: task.componentStack,\n              type: type,\n              owner: owner,\n              stack: stack\n            };\n            break;\n          case REACT_LAZY_TYPE:\n            pushServerComponentStack(task, node._debugInfo);\n            break;\n          default:\n            \"function\" === typeof node.then &&\n              pushServerComponentStack(task, node._debugInfo);\n        }\n    }\n    function getThrownInfo(node$jscomp$0) {\n      var errorInfo = {};\n      node$jscomp$0 &&\n        Object.defineProperty(errorInfo, \"componentStack\", {\n          configurable: !0,\n          enumerable: !0,\n          get: function () {\n            try {\n              var info = \"\",\n                node = node$jscomp$0;\n              do\n                (info += describeComponentStackByType(node.type)),\n                  (node = node.parent);\n              while (node);\n              var stack = info;\n            } catch (x) {\n              stack = \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n            Object.defineProperty(errorInfo, \"componentStack\", {\n              value: stack\n            });\n            return stack;\n          }\n        });\n      return errorInfo;\n    }\n    function encodeErrorForBoundary(\n      boundary,\n      digest,\n      error,\n      thrownInfo,\n      wasAborted\n    ) {\n      boundary.errorDigest = digest;\n      error instanceof Error\n        ? ((digest = String(error.message)), (error = String(error.stack)))\n        : ((digest =\n            \"object\" === typeof error && null !== error\n              ? describeObjectForErrorMessage(error)\n              : String(error)),\n          (error = null));\n      wasAborted = wasAborted\n        ? \"Switched to client rendering because the server rendering aborted due to:\\n\\n\"\n        : \"Switched to client rendering because the server rendering errored:\\n\\n\";\n      boundary.errorMessage = wasAborted + digest;\n      boundary.errorStack = null !== error ? wasAborted + error : null;\n      boundary.errorComponentStack = thrownInfo.componentStack;\n    }\n    function logRecoverableError(request, error, errorInfo, debugTask) {\n      request = request.onError;\n      error = debugTask\n        ? debugTask.run(request.bind(null, error, errorInfo))\n        : request(error, errorInfo);\n      if (null != error && \"string\" !== typeof error)\n        console.error(\n          'onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"%s\" instead',\n          typeof error\n        );\n      else return error;\n    }\n    function fatalError(request, error, errorInfo, debugTask) {\n      errorInfo = request.onShellError;\n      var onFatalError = request.onFatalError;\n      debugTask\n        ? (debugTask.run(errorInfo.bind(null, error)),\n          debugTask.run(onFatalError.bind(null, error)))\n        : (errorInfo(error), onFatalError(error));\n      null !== request.destination\n        ? ((request.status = CLOSED), request.destination.destroy(error))\n        : ((request.status = 13), (request.fatalError = error));\n    }\n    function renderWithHooks(\n      request,\n      task,\n      keyPath,\n      Component,\n      props,\n      secondArg\n    ) {\n      var prevThenableState = task.thenableState;\n      task.thenableState = null;\n      currentlyRenderingComponent = {};\n      currentlyRenderingTask = task;\n      currentlyRenderingRequest = request;\n      currentlyRenderingKeyPath = keyPath;\n      isInHookUserCodeInDev = !1;\n      actionStateCounter = localIdCounter = 0;\n      actionStateMatchingIndex = -1;\n      thenableIndexCounter = 0;\n      thenableState = prevThenableState;\n      for (\n        request = callComponentInDEV(Component, props, secondArg);\n        didScheduleRenderPhaseUpdate;\n\n      )\n        (didScheduleRenderPhaseUpdate = !1),\n          (actionStateCounter = localIdCounter = 0),\n          (actionStateMatchingIndex = -1),\n          (thenableIndexCounter = 0),\n          (numberOfReRenders += 1),\n          (workInProgressHook = null),\n          (request = Component(props, secondArg));\n      resetHooksState();\n      return request;\n    }\n    function finishFunctionComponent(\n      request,\n      task,\n      keyPath,\n      children,\n      hasId,\n      actionStateCount,\n      actionStateMatchingIndex\n    ) {\n      var didEmitActionStateMarkers = !1;\n      if (0 !== actionStateCount && null !== request.formState) {\n        var segment = task.blockedSegment;\n        if (null !== segment) {\n          didEmitActionStateMarkers = !0;\n          segment = segment.chunks;\n          for (var i = 0; i < actionStateCount; i++)\n            i === actionStateMatchingIndex\n              ? segment.push(formStateMarkerIsMatching)\n              : segment.push(formStateMarkerIsNotMatching);\n        }\n      }\n      actionStateCount = task.keyPath;\n      task.keyPath = keyPath;\n      hasId\n        ? ((keyPath = task.treeContext),\n          (task.treeContext = pushTreeContext(keyPath, 1, 0)),\n          renderNode(request, task, children, -1),\n          (task.treeContext = keyPath))\n        : didEmitActionStateMarkers\n          ? renderNode(request, task, children, -1)\n          : renderNodeDestructive(request, task, children, -1);\n      task.keyPath = actionStateCount;\n    }\n    function renderElement(request, task, keyPath, type, props, ref) {\n      if (\"function\" === typeof type)\n        if (type.prototype && type.prototype.isReactComponent) {\n          var newProps = props;\n          if (\"ref\" in props) {\n            newProps = {};\n            for (var propName in props)\n              \"ref\" !== propName && (newProps[propName] = props[propName]);\n          }\n          var defaultProps = type.defaultProps;\n          if (defaultProps) {\n            newProps === props && (newProps = assign({}, newProps, props));\n            for (var _propName in defaultProps)\n              void 0 === newProps[_propName] &&\n                (newProps[_propName] = defaultProps[_propName]);\n          }\n          var resolvedProps = newProps;\n          var context = emptyContextObject,\n            contextType = type.contextType;\n          if (\n            \"contextType\" in type &&\n            null !== contextType &&\n            (void 0 === contextType ||\n              contextType.$$typeof !== REACT_CONTEXT_TYPE) &&\n            !didWarnAboutInvalidateContextType.has(type)\n          ) {\n            didWarnAboutInvalidateContextType.add(type);\n            var addendum =\n              void 0 === contextType\n                ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\"\n                : \"object\" !== typeof contextType\n                  ? \" However, it is set to a \" + typeof contextType + \".\"\n                  : contextType.$$typeof === REACT_CONSUMER_TYPE\n                    ? \" Did you accidentally pass the Context.Consumer instead?\"\n                    : \" However, it is set to an object with keys {\" +\n                      Object.keys(contextType).join(\", \") +\n                      \"}.\";\n            console.error(\n              \"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\",\n              getComponentNameFromType(type) || \"Component\",\n              addendum\n            );\n          }\n          \"object\" === typeof contextType &&\n            null !== contextType &&\n            (context = contextType._currentValue);\n          var instance = new type(resolvedProps, context);\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps &&\n            (null === instance.state || void 0 === instance.state)\n          ) {\n            var componentName = getComponentNameFromType(type) || \"Component\";\n            didWarnAboutUninitializedState.has(componentName) ||\n              (didWarnAboutUninitializedState.add(componentName),\n              console.error(\n                \"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\",\n                componentName,\n                null === instance.state ? \"null\" : \"undefined\",\n                componentName\n              ));\n          }\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps ||\n            \"function\" === typeof instance.getSnapshotBeforeUpdate\n          ) {\n            var foundWillMountName = null,\n              foundWillReceivePropsName = null,\n              foundWillUpdateName = null;\n            \"function\" === typeof instance.componentWillMount &&\n            !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ? (foundWillMountName = \"componentWillMount\")\n              : \"function\" === typeof instance.UNSAFE_componentWillMount &&\n                (foundWillMountName = \"UNSAFE_componentWillMount\");\n            \"function\" === typeof instance.componentWillReceiveProps &&\n            !0 !==\n              instance.componentWillReceiveProps.__suppressDeprecationWarning\n              ? (foundWillReceivePropsName = \"componentWillReceiveProps\")\n              : \"function\" ===\n                  typeof instance.UNSAFE_componentWillReceiveProps &&\n                (foundWillReceivePropsName =\n                  \"UNSAFE_componentWillReceiveProps\");\n            \"function\" === typeof instance.componentWillUpdate &&\n            !0 !== instance.componentWillUpdate.__suppressDeprecationWarning\n              ? (foundWillUpdateName = \"componentWillUpdate\")\n              : \"function\" === typeof instance.UNSAFE_componentWillUpdate &&\n                (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n            if (\n              null !== foundWillMountName ||\n              null !== foundWillReceivePropsName ||\n              null !== foundWillUpdateName\n            ) {\n              var _componentName =\n                  getComponentNameFromType(type) || \"Component\",\n                newApiName =\n                  \"function\" === typeof type.getDerivedStateFromProps\n                    ? \"getDerivedStateFromProps()\"\n                    : \"getSnapshotBeforeUpdate()\";\n              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) ||\n                (didWarnAboutLegacyLifecyclesAndDerivedState.add(\n                  _componentName\n                ),\n                console.error(\n                  \"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\",\n                  _componentName,\n                  newApiName,\n                  null !== foundWillMountName\n                    ? \"\\n  \" + foundWillMountName\n                    : \"\",\n                  null !== foundWillReceivePropsName\n                    ? \"\\n  \" + foundWillReceivePropsName\n                    : \"\",\n                  null !== foundWillUpdateName\n                    ? \"\\n  \" + foundWillUpdateName\n                    : \"\"\n                ));\n            }\n          }\n          var name = getComponentNameFromType(type) || \"Component\";\n          instance.render ||\n            (type.prototype && \"function\" === typeof type.prototype.render\n              ? console.error(\n                  \"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\",\n                  name\n                )\n              : console.error(\n                  \"No `render` method found on the %s instance: you may have forgotten to define `render`.\",\n                  name\n                ));\n          !instance.getInitialState ||\n            instance.getInitialState.isReactClassApproved ||\n            instance.state ||\n            console.error(\n              \"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\",\n              name\n            );\n          instance.getDefaultProps &&\n            !instance.getDefaultProps.isReactClassApproved &&\n            console.error(\n              \"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\",\n              name\n            );\n          instance.contextType &&\n            console.error(\n              \"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\",\n              name\n            );\n          type.childContextTypes &&\n            !didWarnAboutChildContextTypes.has(type) &&\n            (didWarnAboutChildContextTypes.add(type),\n            console.error(\n              \"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          type.contextTypes &&\n            !didWarnAboutContextTypes$1.has(type) &&\n            (didWarnAboutContextTypes$1.add(type),\n            console.error(\n              \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          \"function\" === typeof instance.componentShouldUpdate &&\n            console.error(\n              \"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\",\n              name\n            );\n          type.prototype &&\n            type.prototype.isPureReactComponent &&\n            \"undefined\" !== typeof instance.shouldComponentUpdate &&\n            console.error(\n              \"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\",\n              getComponentNameFromType(type) || \"A pure component\"\n            );\n          \"function\" === typeof instance.componentDidUnmount &&\n            console.error(\n              \"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\",\n              name\n            );\n          \"function\" === typeof instance.componentDidReceiveProps &&\n            console.error(\n              \"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\",\n              name\n            );\n          \"function\" === typeof instance.componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",\n              name\n            );\n          \"function\" === typeof instance.UNSAFE_componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\",\n              name\n            );\n          var hasMutatedProps = instance.props !== resolvedProps;\n          void 0 !== instance.props &&\n            hasMutatedProps &&\n            console.error(\n              \"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\",\n              name\n            );\n          instance.defaultProps &&\n            console.error(\n              \"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\",\n              name,\n              name\n            );\n          \"function\" !== typeof instance.getSnapshotBeforeUpdate ||\n            \"function\" === typeof instance.componentDidUpdate ||\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) ||\n            (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type),\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\",\n              getComponentNameFromType(type)\n            ));\n          \"function\" === typeof instance.getDerivedStateFromProps &&\n            console.error(\n              \"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof instance.getDerivedStateFromError &&\n            console.error(\n              \"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof type.getSnapshotBeforeUpdate &&\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\",\n              name\n            );\n          var state = instance.state;\n          state &&\n            (\"object\" !== typeof state || isArrayImpl(state)) &&\n            console.error(\"%s.state: must be set to an object or null\", name);\n          \"function\" === typeof instance.getChildContext &&\n            \"object\" !== typeof type.childContextTypes &&\n            console.error(\n              \"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\",\n              name\n            );\n          var initialState = void 0 !== instance.state ? instance.state : null;\n          instance.updater = classComponentUpdater;\n          instance.props = resolvedProps;\n          instance.state = initialState;\n          var internalInstance = { queue: [], replace: !1 };\n          instance._reactInternals = internalInstance;\n          var contextType$jscomp$0 = type.contextType;\n          instance.context =\n            \"object\" === typeof contextType$jscomp$0 &&\n            null !== contextType$jscomp$0\n              ? contextType$jscomp$0._currentValue\n              : emptyContextObject;\n          if (instance.state === resolvedProps) {\n            var componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Component\";\n            didWarnAboutDirectlyAssigningPropsToState.has(\n              componentName$jscomp$0\n            ) ||\n              (didWarnAboutDirectlyAssigningPropsToState.add(\n                componentName$jscomp$0\n              ),\n              console.error(\n                \"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\",\n                componentName$jscomp$0\n              ));\n          }\n          var getDerivedStateFromProps = type.getDerivedStateFromProps;\n          if (\"function\" === typeof getDerivedStateFromProps) {\n            var partialState = getDerivedStateFromProps(\n              resolvedProps,\n              initialState\n            );\n            if (void 0 === partialState) {\n              var componentName$jscomp$1 =\n                getComponentNameFromType(type) || \"Component\";\n              didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) ||\n                (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1),\n                console.error(\n                  \"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\",\n                  componentName$jscomp$1\n                ));\n            }\n            var JSCompiler_inline_result =\n              null === partialState || void 0 === partialState\n                ? initialState\n                : assign({}, initialState, partialState);\n            instance.state = JSCompiler_inline_result;\n          }\n          if (\n            \"function\" !== typeof type.getDerivedStateFromProps &&\n            \"function\" !== typeof instance.getSnapshotBeforeUpdate &&\n            (\"function\" === typeof instance.UNSAFE_componentWillMount ||\n              \"function\" === typeof instance.componentWillMount)\n          ) {\n            var oldState = instance.state;\n            if (\"function\" === typeof instance.componentWillMount) {\n              if (\n                !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ) {\n                var componentName$jscomp$2 =\n                  getComponentNameFromType(type) || \"Unknown\";\n                didWarnAboutDeprecatedWillMount[componentName$jscomp$2] ||\n                  (console.warn(\n                    \"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\\n\\nPlease update the following components: %s\",\n                    componentName$jscomp$2\n                  ),\n                  (didWarnAboutDeprecatedWillMount[componentName$jscomp$2] =\n                    !0));\n              }\n              instance.componentWillMount();\n            }\n            \"function\" === typeof instance.UNSAFE_componentWillMount &&\n              instance.UNSAFE_componentWillMount();\n            oldState !== instance.state &&\n              (console.error(\n                \"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\",\n                getComponentNameFromType(type) || \"Component\"\n              ),\n              classComponentUpdater.enqueueReplaceState(\n                instance,\n                instance.state,\n                null\n              ));\n            if (\n              null !== internalInstance.queue &&\n              0 < internalInstance.queue.length\n            ) {\n              var oldQueue = internalInstance.queue,\n                oldReplace = internalInstance.replace;\n              internalInstance.queue = null;\n              internalInstance.replace = !1;\n              if (oldReplace && 1 === oldQueue.length)\n                instance.state = oldQueue[0];\n              else {\n                for (\n                  var nextState = oldReplace ? oldQueue[0] : instance.state,\n                    dontMutate = !0,\n                    i = oldReplace ? 1 : 0;\n                  i < oldQueue.length;\n                  i++\n                ) {\n                  var partial = oldQueue[i],\n                    partialState$jscomp$0 =\n                      \"function\" === typeof partial\n                        ? partial.call(\n                            instance,\n                            nextState,\n                            resolvedProps,\n                            void 0\n                          )\n                        : partial;\n                  null != partialState$jscomp$0 &&\n                    (dontMutate\n                      ? ((dontMutate = !1),\n                        (nextState = assign(\n                          {},\n                          nextState,\n                          partialState$jscomp$0\n                        )))\n                      : assign(nextState, partialState$jscomp$0));\n                }\n                instance.state = nextState;\n              }\n            } else internalInstance.queue = null;\n          }\n          var nextChildren = callRenderInDEV(instance);\n          if (12 === request.status) throw null;\n          instance.props !== resolvedProps &&\n            (didWarnAboutReassigningProps ||\n              console.error(\n                \"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\",\n                getComponentNameFromType(type) || \"a component\"\n              ),\n            (didWarnAboutReassigningProps = !0));\n          var prevKeyPath = task.keyPath;\n          task.keyPath = keyPath;\n          renderNodeDestructive(request, task, nextChildren, -1);\n          task.keyPath = prevKeyPath;\n        } else {\n          if (type.prototype && \"function\" === typeof type.prototype.render) {\n            var componentName$jscomp$3 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutBadClass[componentName$jscomp$3] ||\n              (console.error(\n                \"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\",\n                componentName$jscomp$3,\n                componentName$jscomp$3\n              ),\n              (didWarnAboutBadClass[componentName$jscomp$3] = !0));\n          }\n          var value = renderWithHooks(\n            request,\n            task,\n            keyPath,\n            type,\n            props,\n            void 0\n          );\n          if (12 === request.status) throw null;\n          var hasId = 0 !== localIdCounter,\n            actionStateCount = actionStateCounter,\n            actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;\n          if (type.contextTypes) {\n            var _componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypes[_componentName$jscomp$0] ||\n              ((didWarnAboutContextTypes[_componentName$jscomp$0] = !0),\n              console.error(\n                \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\",\n                _componentName$jscomp$0\n              ));\n          }\n          type &&\n            type.childContextTypes &&\n            console.error(\n              \"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\",\n              type.displayName || type.name || \"Component\"\n            );\n          if (\"function\" === typeof type.getDerivedStateFromProps) {\n            var _componentName2 = getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] ||\n              (console.error(\n                \"%s: Function components do not support getDerivedStateFromProps.\",\n                _componentName2\n              ),\n              (didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] =\n                !0));\n          }\n          if (\n            \"object\" === typeof type.contextType &&\n            null !== type.contextType\n          ) {\n            var _componentName3 = getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypeOnFunctionComponent[_componentName3] ||\n              (console.error(\n                \"%s: Function components do not support contextType.\",\n                _componentName3\n              ),\n              (didWarnAboutContextTypeOnFunctionComponent[_componentName3] =\n                !0));\n          }\n          finishFunctionComponent(\n            request,\n            task,\n            keyPath,\n            value,\n            hasId,\n            actionStateCount,\n            actionStateMatchingIndex$jscomp$0\n          );\n        }\n      else if (\"string\" === typeof type) {\n        var segment = task.blockedSegment;\n        if (null === segment) {\n          var children = props.children,\n            prevContext = task.formatContext,\n            prevKeyPath$jscomp$0 = task.keyPath;\n          task.formatContext = getChildFormatContext(prevContext, type, props);\n          task.keyPath = keyPath;\n          renderNode(request, task, children, -1);\n          task.formatContext = prevContext;\n          task.keyPath = prevKeyPath$jscomp$0;\n        } else {\n          var _children = pushStartInstance(\n            segment.chunks,\n            type,\n            props,\n            request.resumableState,\n            request.renderState,\n            task.blockedPreamble,\n            task.hoistableState,\n            task.formatContext,\n            segment.lastPushedText,\n            task.isFallback\n          );\n          segment.lastPushedText = !1;\n          var _prevContext = task.formatContext,\n            _prevKeyPath2 = task.keyPath;\n          task.keyPath = keyPath;\n          if (\n            (task.formatContext = getChildFormatContext(\n              _prevContext,\n              type,\n              props\n            )).insertionMode === HTML_HEAD_MODE\n          ) {\n            var preambleSegment = createPendingSegment(\n              request,\n              0,\n              null,\n              task.formatContext,\n              !1,\n              !1\n            );\n            segment.preambleChildren.push(preambleSegment);\n            var preambleTask = createRenderTask(\n              request,\n              null,\n              _children,\n              -1,\n              task.blockedBoundary,\n              preambleSegment,\n              task.blockedPreamble,\n              task.hoistableState,\n              request.abortableTasks,\n              task.keyPath,\n              task.formatContext,\n              task.context,\n              task.treeContext,\n              task.componentStack,\n              task.isFallback,\n              emptyContextObject,\n              task.debugTask\n            );\n            pushComponentStack(preambleTask);\n            request.pingedTasks.push(preambleTask);\n          } else renderNode(request, task, _children, -1);\n          task.formatContext = _prevContext;\n          task.keyPath = _prevKeyPath2;\n          a: {\n            var target = segment.chunks,\n              resumableState = request.resumableState;\n            switch (type) {\n              case \"title\":\n              case \"style\":\n              case \"script\":\n              case \"area\":\n              case \"base\":\n              case \"br\":\n              case \"col\":\n              case \"embed\":\n              case \"hr\":\n              case \"img\":\n              case \"input\":\n              case \"keygen\":\n              case \"link\":\n              case \"meta\":\n              case \"param\":\n              case \"source\":\n              case \"track\":\n              case \"wbr\":\n                break a;\n              case \"body\":\n                if (_prevContext.insertionMode <= HTML_HTML_MODE) {\n                  resumableState.hasBody = !0;\n                  break a;\n                }\n                break;\n              case \"html\":\n                if (_prevContext.insertionMode === ROOT_HTML_MODE) {\n                  resumableState.hasHtml = !0;\n                  break a;\n                }\n                break;\n              case \"head\":\n                if (_prevContext.insertionMode <= HTML_HTML_MODE) break a;\n            }\n            target.push(endChunkForTag(type));\n          }\n          segment.lastPushedText = !1;\n        }\n      } else {\n        switch (type) {\n          case REACT_LEGACY_HIDDEN_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_FRAGMENT_TYPE:\n            var prevKeyPath$jscomp$1 = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, props.children, -1);\n            task.keyPath = prevKeyPath$jscomp$1;\n            return;\n          case REACT_OFFSCREEN_TYPE:\n            if (\"hidden\" !== props.mode) {\n              var prevKeyPath$jscomp$2 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, props.children, -1);\n              task.keyPath = prevKeyPath$jscomp$2;\n            }\n            return;\n          case REACT_SUSPENSE_LIST_TYPE:\n            var _prevKeyPath3 = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, props.children, -1);\n            task.keyPath = _prevKeyPath3;\n            return;\n          case REACT_VIEW_TRANSITION_TYPE:\n          case REACT_SCOPE_TYPE:\n            throw Error(\n              \"ReactDOMServer does not yet support scope components.\"\n            );\n          case REACT_SUSPENSE_TYPE:\n            a: if (null !== task.replay) {\n              var _prevKeyPath = task.keyPath;\n              task.keyPath = keyPath;\n              var _content = props.children;\n              try {\n                renderNode(request, task, _content, -1);\n              } finally {\n                task.keyPath = _prevKeyPath;\n              }\n            } else {\n              var prevKeyPath$jscomp$3 = task.keyPath,\n                parentBoundary = task.blockedBoundary,\n                parentPreamble = task.blockedPreamble,\n                parentHoistableState = task.hoistableState,\n                parentSegment = task.blockedSegment,\n                fallback = props.fallback,\n                content = props.children,\n                fallbackAbortSet = new Set();\n              var newBoundary =\n                task.formatContext.insertionMode < HTML_MODE\n                  ? createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      createPreambleState(),\n                      createPreambleState()\n                    )\n                  : createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      null,\n                      null\n                    );\n              null !== request.trackedPostpones &&\n                (newBoundary.trackedContentKeyPath = keyPath);\n              var boundarySegment = createPendingSegment(\n                request,\n                parentSegment.chunks.length,\n                newBoundary,\n                task.formatContext,\n                !1,\n                !1\n              );\n              parentSegment.children.push(boundarySegment);\n              parentSegment.lastPushedText = !1;\n              var contentRootSegment = createPendingSegment(\n                request,\n                0,\n                null,\n                task.formatContext,\n                !1,\n                !1\n              );\n              contentRootSegment.parentFlushed = !0;\n              if (null !== request.trackedPostpones) {\n                var fallbackKeyPath = [\n                    keyPath[0],\n                    \"Suspense Fallback\",\n                    keyPath[2]\n                  ],\n                  fallbackReplayNode = [\n                    fallbackKeyPath[1],\n                    fallbackKeyPath[2],\n                    [],\n                    null\n                  ];\n                request.trackedPostpones.workingMap.set(\n                  fallbackKeyPath,\n                  fallbackReplayNode\n                );\n                newBoundary.trackedFallbackNode = fallbackReplayNode;\n                task.blockedSegment = boundarySegment;\n                task.blockedPreamble = newBoundary.fallbackPreamble;\n                task.keyPath = fallbackKeyPath;\n                boundarySegment.status = 6;\n                try {\n                  renderNode(request, task, fallback, -1),\n                    boundarySegment.lastPushedText &&\n                      boundarySegment.textEmbedded &&\n                      boundarySegment.chunks.push(textSeparator),\n                    (boundarySegment.status = COMPLETED);\n                } catch (thrownValue) {\n                  throw (\n                    ((boundarySegment.status = 12 === request.status ? 3 : 4),\n                    thrownValue)\n                  );\n                } finally {\n                  (task.blockedSegment = parentSegment),\n                    (task.blockedPreamble = parentPreamble),\n                    (task.keyPath = prevKeyPath$jscomp$3);\n                }\n                var suspendedPrimaryTask = createRenderTask(\n                  request,\n                  null,\n                  content,\n                  -1,\n                  newBoundary,\n                  contentRootSegment,\n                  newBoundary.contentPreamble,\n                  newBoundary.contentState,\n                  task.abortSet,\n                  keyPath,\n                  task.formatContext,\n                  task.context,\n                  task.treeContext,\n                  task.componentStack,\n                  task.isFallback,\n                  emptyContextObject,\n                  task.debugTask\n                );\n                pushComponentStack(suspendedPrimaryTask);\n                request.pingedTasks.push(suspendedPrimaryTask);\n              } else {\n                task.blockedBoundary = newBoundary;\n                task.blockedPreamble = newBoundary.contentPreamble;\n                task.hoistableState = newBoundary.contentState;\n                task.blockedSegment = contentRootSegment;\n                task.keyPath = keyPath;\n                contentRootSegment.status = 6;\n                try {\n                  if (\n                    (renderNode(request, task, content, -1),\n                    contentRootSegment.lastPushedText &&\n                      contentRootSegment.textEmbedded &&\n                      contentRootSegment.chunks.push(textSeparator),\n                    (contentRootSegment.status = COMPLETED),\n                    queueCompletedSegment(newBoundary, contentRootSegment),\n                    0 === newBoundary.pendingTasks &&\n                      newBoundary.status === PENDING)\n                  ) {\n                    newBoundary.status = COMPLETED;\n                    0 === request.pendingRootTasks &&\n                      task.blockedPreamble &&\n                      preparePreamble(request);\n                    break a;\n                  }\n                } catch (thrownValue$2) {\n                  newBoundary.status = CLIENT_RENDERED;\n                  if (12 === request.status) {\n                    contentRootSegment.status = 3;\n                    var error = request.fatalError;\n                  } else\n                    (contentRootSegment.status = 4), (error = thrownValue$2);\n                  var thrownInfo = getThrownInfo(task.componentStack);\n                  var errorDigest = logRecoverableError(\n                    request,\n                    error,\n                    thrownInfo,\n                    task.debugTask\n                  );\n                  encodeErrorForBoundary(\n                    newBoundary,\n                    errorDigest,\n                    error,\n                    thrownInfo,\n                    !1\n                  );\n                  untrackBoundary(request, newBoundary);\n                } finally {\n                  (task.blockedBoundary = parentBoundary),\n                    (task.blockedPreamble = parentPreamble),\n                    (task.hoistableState = parentHoistableState),\n                    (task.blockedSegment = parentSegment),\n                    (task.keyPath = prevKeyPath$jscomp$3);\n                }\n                var suspendedFallbackTask = createRenderTask(\n                  request,\n                  null,\n                  fallback,\n                  -1,\n                  parentBoundary,\n                  boundarySegment,\n                  newBoundary.fallbackPreamble,\n                  newBoundary.fallbackState,\n                  fallbackAbortSet,\n                  [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                  task.formatContext,\n                  task.context,\n                  task.treeContext,\n                  task.componentStack,\n                  !0,\n                  emptyContextObject,\n                  task.debugTask\n                );\n                pushComponentStack(suspendedFallbackTask);\n                request.pingedTasks.push(suspendedFallbackTask);\n              }\n            }\n            return;\n        }\n        if (\"object\" === typeof type && null !== type)\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              if (\"ref\" in props) {\n                var propsWithoutRef = {};\n                for (var key in props)\n                  \"ref\" !== key && (propsWithoutRef[key] = props[key]);\n              } else propsWithoutRef = props;\n              var children$jscomp$0 = renderWithHooks(\n                request,\n                task,\n                keyPath,\n                type.render,\n                propsWithoutRef,\n                ref\n              );\n              finishFunctionComponent(\n                request,\n                task,\n                keyPath,\n                children$jscomp$0,\n                0 !== localIdCounter,\n                actionStateCounter,\n                actionStateMatchingIndex\n              );\n              return;\n            case REACT_MEMO_TYPE:\n              renderElement(request, task, keyPath, type.type, props, ref);\n              return;\n            case REACT_PROVIDER_TYPE:\n            case REACT_CONTEXT_TYPE:\n              var value$jscomp$0 = props.value,\n                children$jscomp$1 = props.children;\n              var prevSnapshot = task.context;\n              var prevKeyPath$jscomp$4 = task.keyPath;\n              var prevValue = type._currentValue;\n              type._currentValue = value$jscomp$0;\n              void 0 !== type._currentRenderer &&\n                null !== type._currentRenderer &&\n                type._currentRenderer !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer = rendererSigil;\n              var prevNode = currentActiveSnapshot,\n                newNode = {\n                  parent: prevNode,\n                  depth: null === prevNode ? 0 : prevNode.depth + 1,\n                  context: type,\n                  parentValue: prevValue,\n                  value: value$jscomp$0\n                };\n              currentActiveSnapshot = newNode;\n              task.context = newNode;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, children$jscomp$1, -1);\n              var prevSnapshot$jscomp$0 = currentActiveSnapshot;\n              if (null === prevSnapshot$jscomp$0)\n                throw Error(\n                  \"Tried to pop a Context at the root of the app. This is a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context !== type &&\n                console.error(\n                  \"The parent context is not the expected context. This is probably a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context._currentValue =\n                prevSnapshot$jscomp$0.parentValue;\n              void 0 !== type._currentRenderer &&\n                null !== type._currentRenderer &&\n                type._currentRenderer !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer = rendererSigil;\n              var JSCompiler_inline_result$jscomp$0 = (currentActiveSnapshot =\n                prevSnapshot$jscomp$0.parent);\n              task.context = JSCompiler_inline_result$jscomp$0;\n              task.keyPath = prevKeyPath$jscomp$4;\n              prevSnapshot !== task.context &&\n                console.error(\n                  \"Popping the context provider did not return back to the original snapshot. This is a bug in React.\"\n                );\n              return;\n            case REACT_CONSUMER_TYPE:\n              var context$jscomp$0 = type._context,\n                render = props.children;\n              \"function\" !== typeof render &&\n                console.error(\n                  \"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"\n                );\n              var newChildren = render(context$jscomp$0._currentValue),\n                prevKeyPath$jscomp$5 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, newChildren, -1);\n              task.keyPath = prevKeyPath$jscomp$5;\n              return;\n            case REACT_LAZY_TYPE:\n              var Component = callLazyInitInDEV(type);\n              if (12 === request.status) throw null;\n              renderElement(request, task, keyPath, Component, props, ref);\n              return;\n          }\n        var info = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          info +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        throw Error(\n          \"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" +\n            ((null == type ? type : typeof type) + \".\" + info)\n        );\n      }\n    }\n    function resumeNode(request, task, segmentId, node, childIndex) {\n      var prevReplay = task.replay,\n        blockedBoundary = task.blockedBoundary,\n        resumedSegment = createPendingSegment(\n          request,\n          0,\n          null,\n          task.formatContext,\n          !1,\n          !1\n        );\n      resumedSegment.id = segmentId;\n      resumedSegment.parentFlushed = !0;\n      try {\n        (task.replay = null),\n          (task.blockedSegment = resumedSegment),\n          renderNode(request, task, node, childIndex),\n          (resumedSegment.status = COMPLETED),\n          null === blockedBoundary\n            ? (request.completedRootSegment = resumedSegment)\n            : (queueCompletedSegment(blockedBoundary, resumedSegment),\n              blockedBoundary.parentFlushed &&\n                request.partialBoundaries.push(blockedBoundary));\n      } finally {\n        (task.replay = prevReplay), (task.blockedSegment = null);\n      }\n    }\n    function replayElement(\n      request,\n      task,\n      keyPath,\n      name,\n      keyOrIndex,\n      childIndex,\n      type,\n      props,\n      ref,\n      replay\n    ) {\n      childIndex = replay.nodes;\n      for (var i = 0; i < childIndex.length; i++) {\n        var node = childIndex[i];\n        if (keyOrIndex === node[1]) {\n          if (4 === node.length) {\n            if (null !== name && name !== node[0])\n              throw Error(\n                \"Expected the resume to render <\" +\n                  node[0] +\n                  \"> in this slot but instead it rendered <\" +\n                  name +\n                  \">. The tree doesn't match so React will fallback to client rendering.\"\n              );\n            var childNodes = node[2];\n            node = node[3];\n            name = task.node;\n            task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };\n            try {\n              renderElement(request, task, keyPath, type, props, ref);\n              if (\n                1 === task.replay.pendingTasks &&\n                0 < task.replay.nodes.length\n              )\n                throw Error(\n                  \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                );\n              task.replay.pendingTasks--;\n            } catch (x) {\n              if (\n                \"object\" === typeof x &&\n                null !== x &&\n                (x === SuspenseException || \"function\" === typeof x.then)\n              )\n                throw (task.node === name && (task.replay = replay), x);\n              task.replay.pendingTasks--;\n              type = getThrownInfo(task.componentStack);\n              props = request;\n              request = task.blockedBoundary;\n              keyPath = x;\n              ref = node;\n              node = logRecoverableError(props, keyPath, type, task.debugTask);\n              abortRemainingReplayNodes(\n                props,\n                request,\n                childNodes,\n                ref,\n                keyPath,\n                node,\n                type,\n                !1\n              );\n            }\n            task.replay = replay;\n          } else {\n            if (type !== REACT_SUSPENSE_TYPE)\n              throw Error(\n                \"Expected the resume to render <Suspense> in this slot but instead it rendered <\" +\n                  (getComponentNameFromType(type) || \"Unknown\") +\n                  \">. The tree doesn't match so React will fallback to client rendering.\"\n              );\n            a: {\n              replay = void 0;\n              type = node[5];\n              ref = node[2];\n              name = node[3];\n              keyOrIndex = null === node[4] ? [] : node[4][2];\n              node = null === node[4] ? null : node[4][3];\n              var prevKeyPath = task.keyPath,\n                previousReplaySet = task.replay,\n                parentBoundary = task.blockedBoundary,\n                parentHoistableState = task.hoistableState,\n                content = props.children,\n                fallback = props.fallback,\n                fallbackAbortSet = new Set();\n              props =\n                task.formatContext.insertionMode < HTML_MODE\n                  ? createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      createPreambleState(),\n                      createPreambleState()\n                    )\n                  : createSuspenseBoundary(\n                      request,\n                      fallbackAbortSet,\n                      null,\n                      null\n                    );\n              props.parentFlushed = !0;\n              props.rootSegmentID = type;\n              task.blockedBoundary = props;\n              task.hoistableState = props.contentState;\n              task.keyPath = keyPath;\n              task.replay = { nodes: ref, slots: name, pendingTasks: 1 };\n              try {\n                renderNode(request, task, content, -1);\n                if (\n                  1 === task.replay.pendingTasks &&\n                  0 < task.replay.nodes.length\n                )\n                  throw Error(\n                    \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                  );\n                task.replay.pendingTasks--;\n                if (0 === props.pendingTasks && props.status === PENDING) {\n                  props.status = COMPLETED;\n                  request.completedBoundaries.push(props);\n                  break a;\n                }\n              } catch (error) {\n                (props.status = CLIENT_RENDERED),\n                  (childNodes = getThrownInfo(task.componentStack)),\n                  (replay = logRecoverableError(\n                    request,\n                    error,\n                    childNodes,\n                    task.debugTask\n                  )),\n                  encodeErrorForBoundary(props, replay, error, childNodes, !1),\n                  task.replay.pendingTasks--,\n                  request.clientRenderedBoundaries.push(props);\n              } finally {\n                (task.blockedBoundary = parentBoundary),\n                  (task.hoistableState = parentHoistableState),\n                  (task.replay = previousReplaySet),\n                  (task.keyPath = prevKeyPath);\n              }\n              props = createReplayTask(\n                request,\n                null,\n                { nodes: keyOrIndex, slots: node, pendingTasks: 0 },\n                fallback,\n                -1,\n                parentBoundary,\n                props.fallbackState,\n                fallbackAbortSet,\n                [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                task.formatContext,\n                task.context,\n                task.treeContext,\n                task.componentStack,\n                !0,\n                emptyContextObject,\n                task.debugTask\n              );\n              pushComponentStack(props);\n              request.pingedTasks.push(props);\n            }\n          }\n          childIndex.splice(i, 1);\n          break;\n        }\n      }\n    }\n    function renderNodeDestructive(request, task, node, childIndex) {\n      null !== task.replay && \"number\" === typeof task.replay.slots\n        ? resumeNode(request, task, task.replay.slots, node, childIndex)\n        : ((task.node = node),\n          (task.childIndex = childIndex),\n          (node = task.componentStack),\n          (childIndex = task.debugTask),\n          pushComponentStack(task),\n          retryNode(request, task),\n          (task.componentStack = node),\n          (task.debugTask = childIndex));\n    }\n    function retryNode(request, task) {\n      var node = task.node,\n        childIndex = task.childIndex;\n      if (null !== node) {\n        if (\"object\" === typeof node) {\n          switch (node.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              var type = node.type,\n                key = node.key;\n              node = node.props;\n              var refProp = node.ref;\n              refProp = void 0 !== refProp ? refProp : null;\n              var debugTask = task.debugTask,\n                name = getComponentNameFromType(type);\n              key = null == key ? (-1 === childIndex ? 0 : childIndex) : key;\n              var keyPath = [task.keyPath, name, key];\n              null !== task.replay\n                ? debugTask\n                  ? debugTask.run(\n                      replayElement.bind(\n                        null,\n                        request,\n                        task,\n                        keyPath,\n                        name,\n                        key,\n                        childIndex,\n                        type,\n                        node,\n                        refProp,\n                        task.replay\n                      )\n                    )\n                  : replayElement(\n                      request,\n                      task,\n                      keyPath,\n                      name,\n                      key,\n                      childIndex,\n                      type,\n                      node,\n                      refProp,\n                      task.replay\n                    )\n                : debugTask\n                  ? debugTask.run(\n                      renderElement.bind(\n                        null,\n                        request,\n                        task,\n                        keyPath,\n                        type,\n                        node,\n                        refProp\n                      )\n                    )\n                  : renderElement(request, task, keyPath, type, node, refProp);\n              return;\n            case REACT_PORTAL_TYPE:\n              throw Error(\n                \"Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.\"\n              );\n            case REACT_LAZY_TYPE:\n              node = callLazyInitInDEV(node);\n              if (12 === request.status) throw null;\n              renderNodeDestructive(request, task, node, childIndex);\n              return;\n          }\n          if (isArrayImpl(node)) {\n            renderChildrenArray(request, task, node, childIndex);\n            return;\n          }\n          null === node || \"object\" !== typeof node\n            ? (key = null)\n            : ((type =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (key = \"function\" === typeof type ? type : null));\n          if (key && (type = key.call(node))) {\n            if (type === node) {\n              if (\n                -1 !== childIndex ||\n                null === task.componentStack ||\n                \"function\" !== typeof task.componentStack.type ||\n                \"[object GeneratorFunction]\" !==\n                  Object.prototype.toString.call(task.componentStack.type) ||\n                \"[object Generator]\" !== Object.prototype.toString.call(type)\n              )\n                didWarnAboutGenerators ||\n                  console.error(\n                    \"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"\n                  ),\n                  (didWarnAboutGenerators = !0);\n            } else\n              node.entries !== key ||\n                didWarnAboutMaps ||\n                (console.error(\n                  \"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"\n                ),\n                (didWarnAboutMaps = !0));\n            node = type.next();\n            if (!node.done) {\n              key = [];\n              do key.push(node.value), (node = type.next());\n              while (!node.done);\n              renderChildrenArray(request, task, key, childIndex);\n            }\n            return;\n          }\n          if (\"function\" === typeof node.then)\n            return (\n              (task.thenableState = null),\n              renderNodeDestructive(\n                request,\n                task,\n                unwrapThenable(node),\n                childIndex\n              )\n            );\n          if (node.$$typeof === REACT_CONTEXT_TYPE)\n            return renderNodeDestructive(\n              request,\n              task,\n              node._currentValue,\n              childIndex\n            );\n          request = Object.prototype.toString.call(node);\n          throw Error(\n            \"Objects are not valid as a React child (found: \" +\n              (\"[object Object]\" === request\n                ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\"\n                : request) +\n              \"). If you meant to render a collection of children, use an array instead.\"\n          );\n        }\n        \"string\" === typeof node\n          ? ((task = task.blockedSegment),\n            null !== task &&\n              (task.lastPushedText = pushTextInstance(\n                task.chunks,\n                node,\n                request.renderState,\n                task.lastPushedText\n              )))\n          : \"number\" === typeof node || \"bigint\" === typeof node\n            ? ((task = task.blockedSegment),\n              null !== task &&\n                (task.lastPushedText = pushTextInstance(\n                  task.chunks,\n                  \"\" + node,\n                  request.renderState,\n                  task.lastPushedText\n                )))\n            : (\"function\" === typeof node &&\n                ((request = node.displayName || node.name || \"Component\"),\n                console.error(\n                  \"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\",\n                  request,\n                  request\n                )),\n              \"symbol\" === typeof node &&\n                console.error(\n                  \"Symbols are not valid as a React child.\\n  %s\",\n                  String(node)\n                ));\n      }\n    }\n    function renderChildrenArray(request, task, children, childIndex) {\n      var prevKeyPath = task.keyPath,\n        previousComponentStack = task.componentStack;\n      var previousDebugTask = task.debugTask;\n      pushServerComponentStack(task, task.node._debugInfo);\n      if (\n        -1 !== childIndex &&\n        ((task.keyPath = [task.keyPath, \"Fragment\", childIndex]),\n        null !== task.replay)\n      ) {\n        for (\n          var replay = task.replay, replayNodes = replay.nodes, j = 0;\n          j < replayNodes.length;\n          j++\n        ) {\n          var node = replayNodes[j];\n          if (node[1] === childIndex) {\n            childIndex = node[2];\n            node = node[3];\n            task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };\n            try {\n              renderChildrenArray(request, task, children, -1);\n              if (\n                1 === task.replay.pendingTasks &&\n                0 < task.replay.nodes.length\n              )\n                throw Error(\n                  \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                );\n              task.replay.pendingTasks--;\n            } catch (x) {\n              if (\n                \"object\" === typeof x &&\n                null !== x &&\n                (x === SuspenseException || \"function\" === typeof x.then)\n              )\n                throw x;\n              task.replay.pendingTasks--;\n              var thrownInfo = getThrownInfo(task.componentStack);\n              children = task.blockedBoundary;\n              var error = x,\n                resumeSlots = node;\n              node = logRecoverableError(\n                request,\n                error,\n                thrownInfo,\n                task.debugTask\n              );\n              abortRemainingReplayNodes(\n                request,\n                children,\n                childIndex,\n                resumeSlots,\n                error,\n                node,\n                thrownInfo,\n                !1\n              );\n            }\n            task.replay = replay;\n            replayNodes.splice(j, 1);\n            break;\n          }\n        }\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        task.debugTask = previousDebugTask;\n        return;\n      }\n      replay = task.treeContext;\n      replayNodes = children.length;\n      if (\n        null !== task.replay &&\n        ((j = task.replay.slots), null !== j && \"object\" === typeof j)\n      ) {\n        for (childIndex = 0; childIndex < replayNodes; childIndex++)\n          (node = children[childIndex]),\n            (task.treeContext = pushTreeContext(\n              replay,\n              replayNodes,\n              childIndex\n            )),\n            (error = j[childIndex]),\n            \"number\" === typeof error\n              ? (resumeNode(request, task, error, node, childIndex),\n                delete j[childIndex])\n              : renderNode(request, task, node, childIndex);\n        task.treeContext = replay;\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        task.debugTask = previousDebugTask;\n        return;\n      }\n      for (j = 0; j < replayNodes; j++) {\n        childIndex = children[j];\n        resumeSlots = request;\n        node = task;\n        error = childIndex;\n        if (\n          null !== error &&\n          \"object\" === typeof error &&\n          (error.$$typeof === REACT_ELEMENT_TYPE ||\n            error.$$typeof === REACT_PORTAL_TYPE) &&\n          error._store &&\n          ((!error._store.validated && null == error.key) ||\n            2 === error._store.validated)\n        ) {\n          if (\"object\" !== typeof error._store)\n            throw Error(\n              \"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\"\n            );\n          error._store.validated = 1;\n          thrownInfo = resumeSlots.didWarnForKey;\n          null == thrownInfo &&\n            (thrownInfo = resumeSlots.didWarnForKey = new WeakSet());\n          resumeSlots = node.componentStack;\n          if (null !== resumeSlots && !thrownInfo.has(resumeSlots)) {\n            thrownInfo.add(resumeSlots);\n            var componentName = getComponentNameFromType(error.type);\n            thrownInfo = error._owner;\n            var parentOwner = resumeSlots.owner;\n            resumeSlots = \"\";\n            if (parentOwner && \"undefined\" !== typeof parentOwner.type) {\n              var name = getComponentNameFromType(parentOwner.type);\n              name &&\n                (resumeSlots =\n                  \"\\n\\nCheck the render method of `\" + name + \"`.\");\n            }\n            resumeSlots ||\n              (componentName &&\n                (resumeSlots =\n                  \"\\n\\nCheck the top-level render call using <\" +\n                  componentName +\n                  \">.\"));\n            componentName = \"\";\n            null != thrownInfo &&\n              parentOwner !== thrownInfo &&\n              ((parentOwner = null),\n              \"undefined\" !== typeof thrownInfo.type\n                ? (parentOwner = getComponentNameFromType(thrownInfo.type))\n                : \"string\" === typeof thrownInfo.name &&\n                  (parentOwner = thrownInfo.name),\n              parentOwner &&\n                (componentName =\n                  \" It was passed a child from \" + parentOwner + \".\"));\n            thrownInfo = node.componentStack;\n            node.componentStack = {\n              parent: node.componentStack,\n              type: error.type,\n              owner: error._owner,\n              stack: error._debugStack\n            };\n            console.error(\n              'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n              resumeSlots,\n              componentName\n            );\n            node.componentStack = thrownInfo;\n          }\n        }\n        task.treeContext = pushTreeContext(replay, replayNodes, j);\n        renderNode(request, task, childIndex, j);\n      }\n      task.treeContext = replay;\n      task.keyPath = prevKeyPath;\n      task.componentStack = previousComponentStack;\n      task.debugTask = previousDebugTask;\n    }\n    function untrackBoundary(request, boundary) {\n      request = request.trackedPostpones;\n      null !== request &&\n        ((boundary = boundary.trackedContentKeyPath),\n        null !== boundary &&\n          ((boundary = request.workingMap.get(boundary)),\n          void 0 !== boundary &&\n            ((boundary.length = 4), (boundary[2] = []), (boundary[3] = null))));\n    }\n    function spawnNewSuspendedReplayTask(request, task, thenableState) {\n      return createReplayTask(\n        request,\n        thenableState,\n        task.replay,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.componentStack,\n        task.isFallback,\n        emptyContextObject,\n        task.debugTask\n      );\n    }\n    function spawnNewSuspendedRenderTask(request, task, thenableState) {\n      var segment = task.blockedSegment,\n        newSegment = createPendingSegment(\n          request,\n          segment.chunks.length,\n          null,\n          task.formatContext,\n          segment.lastPushedText,\n          !0\n        );\n      segment.children.push(newSegment);\n      segment.lastPushedText = !1;\n      return createRenderTask(\n        request,\n        thenableState,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        newSegment,\n        task.blockedPreamble,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.componentStack,\n        task.isFallback,\n        emptyContextObject,\n        task.debugTask\n      );\n    }\n    function renderNode(request, task, node, childIndex) {\n      var previousFormatContext = task.formatContext,\n        previousContext = task.context,\n        previousKeyPath = task.keyPath,\n        previousTreeContext = task.treeContext,\n        previousComponentStack = task.componentStack,\n        previousDebugTask = task.debugTask,\n        segment = task.blockedSegment;\n      if (null === segment)\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue) {\n          if (\n            (resetHooksState(),\n            (node =\n              thrownValue === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue),\n            \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              childIndex = getThenableStateAfterSuspending();\n              request = spawnNewSuspendedReplayTask(\n                request,\n                task,\n                childIndex\n              ).ping;\n              node.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              node = getThenableStateAfterSuspending();\n              node = spawnNewSuspendedReplayTask(request, task, node);\n              request.pingedTasks.push(node);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      else {\n        var childrenLength = segment.children.length,\n          chunkLength = segment.chunks.length;\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue$3) {\n          if (\n            (resetHooksState(),\n            (segment.children.length = childrenLength),\n            (segment.chunks.length = chunkLength),\n            (node =\n              thrownValue$3 === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue$3),\n            \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              childIndex = getThenableStateAfterSuspending();\n              request = spawnNewSuspendedRenderTask(\n                request,\n                task,\n                childIndex\n              ).ping;\n              node.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              node = getThenableStateAfterSuspending();\n              node = spawnNewSuspendedRenderTask(request, task, node);\n              request.pingedTasks.push(node);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      }\n      task.formatContext = previousFormatContext;\n      task.context = previousContext;\n      task.keyPath = previousKeyPath;\n      task.treeContext = previousTreeContext;\n      switchContext(previousContext);\n      throw node;\n    }\n    function abortTaskSoft(task) {\n      var boundary = task.blockedBoundary;\n      task = task.blockedSegment;\n      null !== task && ((task.status = 3), finishedTask(this, boundary, task));\n    }\n    function abortRemainingReplayNodes(\n      request$jscomp$0,\n      boundary,\n      nodes,\n      slots,\n      error$jscomp$0,\n      errorDigest$jscomp$0,\n      errorInfo$jscomp$0,\n      aborted\n    ) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        if (4 === node.length)\n          abortRemainingReplayNodes(\n            request$jscomp$0,\n            boundary,\n            node[2],\n            node[3],\n            error$jscomp$0,\n            errorDigest$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          );\n        else {\n          var request = request$jscomp$0;\n          node = node[5];\n          var error = error$jscomp$0,\n            errorDigest = errorDigest$jscomp$0,\n            errorInfo = errorInfo$jscomp$0,\n            wasAborted = aborted,\n            resumedBoundary = createSuspenseBoundary(\n              request,\n              new Set(),\n              null,\n              null\n            );\n          resumedBoundary.parentFlushed = !0;\n          resumedBoundary.rootSegmentID = node;\n          resumedBoundary.status = CLIENT_RENDERED;\n          encodeErrorForBoundary(\n            resumedBoundary,\n            errorDigest,\n            error,\n            errorInfo,\n            wasAborted\n          );\n          resumedBoundary.parentFlushed &&\n            request.clientRenderedBoundaries.push(resumedBoundary);\n        }\n      }\n      nodes.length = 0;\n      if (null !== slots) {\n        if (null === boundary)\n          throw Error(\n            \"We should not have any resumable nodes in the shell. This is a bug in React.\"\n          );\n        boundary.status !== CLIENT_RENDERED &&\n          ((boundary.status = CLIENT_RENDERED),\n          encodeErrorForBoundary(\n            boundary,\n            errorDigest$jscomp$0,\n            error$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          ),\n          boundary.parentFlushed &&\n            request$jscomp$0.clientRenderedBoundaries.push(boundary));\n        if (\"object\" === typeof slots)\n          for (var index in slots) delete slots[index];\n      }\n    }\n    function abortTask(task, request, error) {\n      var boundary = task.blockedBoundary,\n        segment = task.blockedSegment;\n      if (null !== segment) {\n        if (6 === segment.status) return;\n        segment.status = 3;\n      }\n      segment = getThrownInfo(task.componentStack);\n      if (null === boundary) {\n        if (13 !== request.status && request.status !== CLOSED) {\n          boundary = task.replay;\n          if (null === boundary) {\n            logRecoverableError(request, error, segment, null);\n            fatalError(request, error, segment, null);\n            return;\n          }\n          boundary.pendingTasks--;\n          0 === boundary.pendingTasks &&\n            0 < boundary.nodes.length &&\n            ((task = logRecoverableError(request, error, segment, null)),\n            abortRemainingReplayNodes(\n              request,\n              null,\n              boundary.nodes,\n              boundary.slots,\n              error,\n              task,\n              segment,\n              !0\n            ));\n          request.pendingRootTasks--;\n          0 === request.pendingRootTasks && completeShell(request);\n        }\n      } else\n        boundary.pendingTasks--,\n          boundary.status !== CLIENT_RENDERED &&\n            ((boundary.status = CLIENT_RENDERED),\n            (task = logRecoverableError(request, error, segment, null)),\n            (boundary.status = CLIENT_RENDERED),\n            encodeErrorForBoundary(boundary, task, error, segment, !0),\n            untrackBoundary(request, boundary),\n            boundary.parentFlushed &&\n              request.clientRenderedBoundaries.push(boundary)),\n          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n            return abortTask(fallbackTask, request, error);\n          }),\n          boundary.fallbackAbortableTasks.clear();\n      request.allPendingTasks--;\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function safelyEmitEarlyPreloads(request, shellComplete) {\n      try {\n        var renderState = request.renderState,\n          onHeaders = renderState.onHeaders;\n        if (onHeaders) {\n          var headers = renderState.headers;\n          if (headers) {\n            renderState.headers = null;\n            var linkHeader = headers.preconnects;\n            headers.fontPreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.fontPreloads));\n            headers.highImagePreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.highImagePreloads));\n            if (!shellComplete) {\n              var queueIter = renderState.styles.values(),\n                queueStep = queueIter.next();\n              b: for (\n                ;\n                0 < headers.remainingCapacity && !queueStep.done;\n                queueStep = queueIter.next()\n              )\n                for (\n                  var sheetIter = queueStep.value.sheets.values(),\n                    sheetStep = sheetIter.next();\n                  0 < headers.remainingCapacity && !sheetStep.done;\n                  sheetStep = sheetIter.next()\n                ) {\n                  var sheet = sheetStep.value,\n                    props = sheet.props,\n                    key = props.href,\n                    props$jscomp$0 = sheet.props;\n                  var header = getPreloadAsHeader(\n                    props$jscomp$0.href,\n                    \"style\",\n                    {\n                      crossOrigin: props$jscomp$0.crossOrigin,\n                      integrity: props$jscomp$0.integrity,\n                      nonce: props$jscomp$0.nonce,\n                      type: props$jscomp$0.type,\n                      fetchPriority: props$jscomp$0.fetchPriority,\n                      referrerPolicy: props$jscomp$0.referrerPolicy,\n                      media: props$jscomp$0.media\n                    }\n                  );\n                  if (0 <= (headers.remainingCapacity -= header.length + 2))\n                    (renderState.resets.style[key] = PRELOAD_NO_CREDS),\n                      linkHeader && (linkHeader += \", \"),\n                      (linkHeader += header),\n                      (renderState.resets.style[key] =\n                        \"string\" === typeof props.crossOrigin ||\n                        \"string\" === typeof props.integrity\n                          ? [props.crossOrigin, props.integrity]\n                          : PRELOAD_NO_CREDS);\n                  else break b;\n                }\n            }\n            linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});\n          }\n        }\n      } catch (error) {\n        logRecoverableError(request, error, {}, null);\n      }\n    }\n    function completeShell(request) {\n      null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);\n      null === request.trackedPostpones && preparePreamble(request);\n      request.onShellError = noop;\n      request = request.onShellReady;\n      request();\n    }\n    function completeAll(request) {\n      safelyEmitEarlyPreloads(\n        request,\n        null === request.trackedPostpones\n          ? !0\n          : null === request.completedRootSegment ||\n              request.completedRootSegment.status !== POSTPONED\n      );\n      preparePreamble(request);\n      request = request.onAllReady;\n      request();\n    }\n    function queueCompletedSegment(boundary, segment) {\n      if (\n        0 === segment.chunks.length &&\n        1 === segment.children.length &&\n        null === segment.children[0].boundary &&\n        -1 === segment.children[0].id\n      ) {\n        var childSegment = segment.children[0];\n        childSegment.id = segment.id;\n        childSegment.parentFlushed = !0;\n        childSegment.status === COMPLETED &&\n          queueCompletedSegment(boundary, childSegment);\n      } else boundary.completedSegments.push(segment);\n    }\n    function finishedTask(request, boundary, segment) {\n      if (null === boundary) {\n        if (null !== segment && segment.parentFlushed) {\n          if (null !== request.completedRootSegment)\n            throw Error(\n              \"There can only be one root segment. This is a bug in React.\"\n            );\n          request.completedRootSegment = segment;\n        }\n        request.pendingRootTasks--;\n        0 === request.pendingRootTasks && completeShell(request);\n      } else\n        boundary.pendingTasks--,\n          boundary.status !== CLIENT_RENDERED &&\n            (0 === boundary.pendingTasks\n              ? (boundary.status === PENDING && (boundary.status = COMPLETED),\n                null !== segment &&\n                  segment.parentFlushed &&\n                  segment.status === COMPLETED &&\n                  queueCompletedSegment(boundary, segment),\n                boundary.parentFlushed &&\n                  request.completedBoundaries.push(boundary),\n                boundary.status === COMPLETED &&\n                  (boundary.fallbackAbortableTasks.forEach(\n                    abortTaskSoft,\n                    request\n                  ),\n                  boundary.fallbackAbortableTasks.clear(),\n                  0 === request.pendingRootTasks &&\n                    null === request.trackedPostpones &&\n                    null !== boundary.contentPreamble &&\n                    preparePreamble(request)))\n              : null !== segment &&\n                segment.parentFlushed &&\n                segment.status === COMPLETED &&\n                (queueCompletedSegment(boundary, segment),\n                1 === boundary.completedSegments.length &&\n                  boundary.parentFlushed &&\n                  request.partialBoundaries.push(boundary)));\n      request.allPendingTasks--;\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function performWork(request$jscomp$2) {\n      if (\n        request$jscomp$2.status !== CLOSED &&\n        13 !== request$jscomp$2.status\n      ) {\n        var prevContext = currentActiveSnapshot,\n          prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = HooksDispatcher;\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        var prevRequest = currentRequest;\n        currentRequest = request$jscomp$2;\n        var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;\n        var prevResumableState = currentResumableState;\n        currentResumableState = request$jscomp$2.resumableState;\n        try {\n          var pingedTasks = request$jscomp$2.pingedTasks,\n            i;\n          for (i = 0; i < pingedTasks.length; i++) {\n            var request = request$jscomp$2,\n              task = pingedTasks[i],\n              segment = task.blockedSegment;\n            if (null === segment) {\n              var prevTaskInDEV = void 0,\n                request$jscomp$0 = request;\n              request = task;\n              if (0 !== request.replay.pendingTasks) {\n                switchContext(request.context);\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = request;\n                try {\n                  \"number\" === typeof request.replay.slots\n                    ? resumeNode(\n                        request$jscomp$0,\n                        request,\n                        request.replay.slots,\n                        request.node,\n                        request.childIndex\n                      )\n                    : retryNode(request$jscomp$0, request);\n                  if (\n                    1 === request.replay.pendingTasks &&\n                    0 < request.replay.nodes.length\n                  )\n                    throw Error(\n                      \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                    );\n                  request.replay.pendingTasks--;\n                  request.abortSet.delete(request);\n                  finishedTask(request$jscomp$0, request.blockedBoundary, null);\n                } catch (thrownValue) {\n                  resetHooksState();\n                  var x =\n                    thrownValue === SuspenseException\n                      ? getSuspendedThenable()\n                      : thrownValue;\n                  if (\n                    \"object\" === typeof x &&\n                    null !== x &&\n                    \"function\" === typeof x.then\n                  ) {\n                    var ping = request.ping;\n                    x.then(ping, ping);\n                    request.thenableState = getThenableStateAfterSuspending();\n                  } else {\n                    request.replay.pendingTasks--;\n                    request.abortSet.delete(request);\n                    var errorInfo = getThrownInfo(request.componentStack),\n                      errorDigest = void 0,\n                      request$jscomp$1 = request$jscomp$0,\n                      boundary = request.blockedBoundary,\n                      error$jscomp$0 =\n                        12 === request$jscomp$0.status\n                          ? request$jscomp$0.fatalError\n                          : x,\n                      errorInfo$jscomp$0 = errorInfo,\n                      replayNodes = request.replay.nodes,\n                      resumeSlots = request.replay.slots;\n                    errorDigest = logRecoverableError(\n                      request$jscomp$1,\n                      error$jscomp$0,\n                      errorInfo$jscomp$0,\n                      request.debugTask\n                    );\n                    abortRemainingReplayNodes(\n                      request$jscomp$1,\n                      boundary,\n                      replayNodes,\n                      resumeSlots,\n                      error$jscomp$0,\n                      errorDigest,\n                      errorInfo$jscomp$0,\n                      !1\n                    );\n                    request$jscomp$0.pendingRootTasks--;\n                    0 === request$jscomp$0.pendingRootTasks &&\n                      completeShell(request$jscomp$0);\n                    request$jscomp$0.allPendingTasks--;\n                    0 === request$jscomp$0.allPendingTasks &&\n                      completeAll(request$jscomp$0);\n                  }\n                } finally {\n                  currentTaskInDEV = prevTaskInDEV;\n                }\n              }\n            } else if (\n              ((request$jscomp$0 = prevTaskInDEV = void 0),\n              (errorDigest = task),\n              (request$jscomp$1 = segment),\n              request$jscomp$1.status === PENDING)\n            ) {\n              request$jscomp$1.status = 6;\n              switchContext(errorDigest.context);\n              request$jscomp$0 = currentTaskInDEV;\n              currentTaskInDEV = errorDigest;\n              var childrenLength = request$jscomp$1.children.length,\n                chunkLength = request$jscomp$1.chunks.length;\n              try {\n                retryNode(request, errorDigest),\n                  request$jscomp$1.lastPushedText &&\n                    request$jscomp$1.textEmbedded &&\n                    request$jscomp$1.chunks.push(textSeparator),\n                  errorDigest.abortSet.delete(errorDigest),\n                  (request$jscomp$1.status = COMPLETED),\n                  finishedTask(\n                    request,\n                    errorDigest.blockedBoundary,\n                    request$jscomp$1\n                  );\n              } catch (thrownValue) {\n                resetHooksState();\n                request$jscomp$1.children.length = childrenLength;\n                request$jscomp$1.chunks.length = chunkLength;\n                var x$jscomp$0 =\n                  thrownValue === SuspenseException\n                    ? getSuspendedThenable()\n                    : 12 === request.status\n                      ? request.fatalError\n                      : thrownValue;\n                if (\n                  \"object\" === typeof x$jscomp$0 &&\n                  null !== x$jscomp$0 &&\n                  \"function\" === typeof x$jscomp$0.then\n                ) {\n                  request$jscomp$1.status = PENDING;\n                  errorDigest.thenableState = getThenableStateAfterSuspending();\n                  var ping$jscomp$0 = errorDigest.ping;\n                  x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);\n                } else {\n                  var errorInfo$jscomp$1 = getThrownInfo(\n                    errorDigest.componentStack\n                  );\n                  errorDigest.abortSet.delete(errorDigest);\n                  request$jscomp$1.status = 4;\n                  var boundary$jscomp$0 = errorDigest.blockedBoundary,\n                    debugTask = errorDigest.debugTask;\n                  prevTaskInDEV = logRecoverableError(\n                    request,\n                    x$jscomp$0,\n                    errorInfo$jscomp$1,\n                    debugTask\n                  );\n                  null === boundary$jscomp$0\n                    ? fatalError(\n                        request,\n                        x$jscomp$0,\n                        errorInfo$jscomp$1,\n                        debugTask\n                      )\n                    : (boundary$jscomp$0.pendingTasks--,\n                      boundary$jscomp$0.status !== CLIENT_RENDERED &&\n                        ((boundary$jscomp$0.status = CLIENT_RENDERED),\n                        encodeErrorForBoundary(\n                          boundary$jscomp$0,\n                          prevTaskInDEV,\n                          x$jscomp$0,\n                          errorInfo$jscomp$1,\n                          !1\n                        ),\n                        untrackBoundary(request, boundary$jscomp$0),\n                        boundary$jscomp$0.parentFlushed &&\n                          request.clientRenderedBoundaries.push(\n                            boundary$jscomp$0\n                          ),\n                        0 === request.pendingRootTasks &&\n                          null === request.trackedPostpones &&\n                          null !== boundary$jscomp$0.contentPreamble &&\n                          preparePreamble(request)));\n                  request.allPendingTasks--;\n                  0 === request.allPendingTasks && completeAll(request);\n                }\n              } finally {\n                currentTaskInDEV = request$jscomp$0;\n              }\n            }\n          }\n          pingedTasks.splice(0, i);\n          null !== request$jscomp$2.destination &&\n            flushCompletedQueues(\n              request$jscomp$2,\n              request$jscomp$2.destination\n            );\n        } catch (error) {\n          (pingedTasks = {}),\n            logRecoverableError(request$jscomp$2, error, pingedTasks, null),\n            fatalError(request$jscomp$2, error, pingedTasks, null);\n        } finally {\n          (currentResumableState = prevResumableState),\n            (ReactSharedInternals.H = prevDispatcher),\n            (ReactSharedInternals.A = prevAsyncDispatcher),\n            (ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl),\n            prevDispatcher === HooksDispatcher && switchContext(prevContext),\n            (currentRequest = prevRequest);\n        }\n      }\n    }\n    function preparePreambleFromSubtree(\n      request,\n      segment,\n      collectedPreambleSegments\n    ) {\n      segment.preambleChildren.length &&\n        collectedPreambleSegments.push(segment.preambleChildren);\n      for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)\n        pendingPreambles =\n          preparePreambleFromSegment(\n            request,\n            segment.children[i],\n            collectedPreambleSegments\n          ) || pendingPreambles;\n      return pendingPreambles;\n    }\n    function preparePreambleFromSegment(\n      request,\n      segment,\n      collectedPreambleSegments\n    ) {\n      var boundary = segment.boundary;\n      if (null === boundary)\n        return preparePreambleFromSubtree(\n          request,\n          segment,\n          collectedPreambleSegments\n        );\n      var preamble = boundary.contentPreamble,\n        fallbackPreamble = boundary.fallbackPreamble;\n      if (null === preamble || null === fallbackPreamble) return !1;\n      switch (boundary.status) {\n        case COMPLETED:\n          hoistPreambleState(request.renderState, preamble);\n          segment = boundary.completedSegments[0];\n          if (!segment)\n            throw Error(\n              \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n            );\n          return preparePreambleFromSubtree(\n            request,\n            segment,\n            collectedPreambleSegments\n          );\n        case POSTPONED:\n          if (null !== request.trackedPostpones) return !0;\n        case CLIENT_RENDERED:\n          if (segment.status === COMPLETED)\n            return (\n              hoistPreambleState(request.renderState, fallbackPreamble),\n              preparePreambleFromSubtree(\n                request,\n                segment,\n                collectedPreambleSegments\n              )\n            );\n        default:\n          return !0;\n      }\n    }\n    function preparePreamble(request) {\n      if (\n        request.completedRootSegment &&\n        null === request.completedPreambleSegments\n      ) {\n        var collectedPreambleSegments = [],\n          hasPendingPreambles = preparePreambleFromSegment(\n            request,\n            request.completedRootSegment,\n            collectedPreambleSegments\n          ),\n          preamble = request.renderState.preamble;\n        if (\n          !1 === hasPendingPreambles ||\n          (preamble.headChunks && preamble.bodyChunks)\n        )\n          request.completedPreambleSegments = collectedPreambleSegments;\n      }\n    }\n    function flushSubtree(request, destination, segment, hoistableState) {\n      segment.parentFlushed = !0;\n      switch (segment.status) {\n        case PENDING:\n          segment.id = request.nextSegmentId++;\n        case POSTPONED:\n          return (\n            (hoistableState = segment.id),\n            (segment.lastPushedText = !1),\n            (segment.textEmbedded = !1),\n            (request = request.renderState),\n            writeChunk(destination, placeholder1),\n            writeChunk(destination, request.placeholderPrefix),\n            (request = hoistableState.toString(16)),\n            writeChunk(destination, request),\n            writeChunkAndReturn(destination, placeholder2)\n          );\n        case COMPLETED:\n          segment.status = FLUSHED;\n          var r = !0,\n            chunks = segment.chunks,\n            chunkIdx = 0;\n          segment = segment.children;\n          for (var childIdx = 0; childIdx < segment.length; childIdx++) {\n            for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++)\n              writeChunk(destination, chunks[chunkIdx]);\n            r = flushSegment(request, destination, r, hoistableState);\n          }\n          for (; chunkIdx < chunks.length - 1; chunkIdx++)\n            writeChunk(destination, chunks[chunkIdx]);\n          chunkIdx < chunks.length &&\n            (r = writeChunkAndReturn(destination, chunks[chunkIdx]));\n          return r;\n        default:\n          throw Error(\n            \"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\"\n          );\n      }\n    }\n    function flushSegment(request, destination, segment, hoistableState) {\n      var boundary = segment.boundary;\n      if (null === boundary)\n        return flushSubtree(request, destination, segment, hoistableState);\n      boundary.parentFlushed = !0;\n      if (boundary.status === CLIENT_RENDERED) {\n        var errorDigest = boundary.errorDigest,\n          errorMessage = boundary.errorMessage,\n          errorStack = boundary.errorStack,\n          errorComponentStack = boundary.errorComponentStack;\n        writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);\n        writeChunk(destination, clientRenderedSuspenseBoundaryError1);\n        errorDigest &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1A),\n          writeChunk(destination, escapeTextForBrowser(errorDigest)),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        errorMessage &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1B),\n          writeChunk(destination, escapeTextForBrowser(errorMessage)),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        errorStack &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1C),\n          writeChunk(destination, escapeTextForBrowser(errorStack)),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        errorComponentStack &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1D),\n          writeChunk(destination, escapeTextForBrowser(errorComponentStack)),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);\n        flushSubtree(request, destination, segment, hoistableState);\n        (request = boundary.fallbackPreamble) &&\n          writePreambleContribution(destination, request);\n        return writeChunkAndReturn(destination, endSuspenseBoundary);\n      }\n      if (boundary.status !== COMPLETED)\n        return (\n          boundary.status === PENDING &&\n            (boundary.rootSegmentID = request.nextSegmentId++),\n          0 < boundary.completedSegments.length &&\n            request.partialBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          hoistableState &&\n            ((boundary = boundary.fallbackState),\n            boundary.styles.forEach(hoistStyleQueueDependency, hoistableState),\n            boundary.stylesheets.forEach(\n              hoistStylesheetDependency,\n              hoistableState\n            )),\n          flushSubtree(request, destination, segment, hoistableState),\n          writeChunkAndReturn(destination, endSuspenseBoundary)\n        );\n      if (boundary.byteSize > request.progressiveChunkSize)\n        return (\n          (boundary.rootSegmentID = request.nextSegmentId++),\n          request.completedBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          flushSubtree(request, destination, segment, hoistableState),\n          writeChunkAndReturn(destination, endSuspenseBoundary)\n        );\n      hoistableState &&\n        ((segment = boundary.contentState),\n        segment.styles.forEach(hoistStyleQueueDependency, hoistableState),\n        segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));\n      writeChunkAndReturn(destination, startCompletedSuspenseBoundary);\n      segment = boundary.completedSegments;\n      if (1 !== segment.length)\n        throw Error(\n          \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n        );\n      flushSegment(request, destination, segment[0], hoistableState);\n      (request = boundary.contentPreamble) &&\n        writePreambleContribution(destination, request);\n      return writeChunkAndReturn(destination, endSuspenseBoundary);\n    }\n    function flushSegmentContainer(\n      request,\n      destination,\n      segment,\n      hoistableState\n    ) {\n      writeStartSegment(\n        destination,\n        request.renderState,\n        segment.parentFormatContext,\n        segment.id\n      );\n      flushSegment(request, destination, segment, hoistableState);\n      return writeEndSegment(destination, segment.parentFormatContext);\n    }\n    function flushCompletedBoundary(request, destination, boundary) {\n      for (\n        var completedSegments = boundary.completedSegments, i = 0;\n        i < completedSegments.length;\n        i++\n      )\n        flushPartiallyCompletedSegment(\n          request,\n          destination,\n          boundary,\n          completedSegments[i]\n        );\n      completedSegments.length = 0;\n      writeHoistablesForBoundary(\n        destination,\n        boundary.contentState,\n        request.renderState\n      );\n      completedSegments = request.resumableState;\n      request = request.renderState;\n      i = boundary.rootSegmentID;\n      boundary = boundary.contentState;\n      var requiresStyleInsertion = request.stylesToHoist;\n      request.stylesToHoist = !1;\n      writeChunk(destination, request.startInlineScript);\n      requiresStyleInsertion\n        ? (completedSegments.instructions & SentCompleteBoundaryFunction) ===\n          NothingSent\n          ? ((completedSegments.instructions =\n              completedSegments.instructions |\n              SentStyleInsertionFunction |\n              SentCompleteBoundaryFunction),\n            writeChunk(destination, completeBoundaryWithStylesScript1FullBoth))\n          : (completedSegments.instructions & SentStyleInsertionFunction) ===\n              NothingSent\n            ? ((completedSegments.instructions |= SentStyleInsertionFunction),\n              writeChunk(\n                destination,\n                completeBoundaryWithStylesScript1FullPartial\n              ))\n            : writeChunk(destination, completeBoundaryWithStylesScript1Partial)\n        : (completedSegments.instructions & SentCompleteBoundaryFunction) ===\n            NothingSent\n          ? ((completedSegments.instructions |= SentCompleteBoundaryFunction),\n            writeChunk(destination, completeBoundaryScript1Full))\n          : writeChunk(destination, completeBoundaryScript1Partial);\n      completedSegments = i.toString(16);\n      writeChunk(destination, request.boundaryPrefix);\n      writeChunk(destination, completedSegments);\n      writeChunk(destination, completeBoundaryScript2);\n      writeChunk(destination, request.segmentPrefix);\n      writeChunk(destination, completedSegments);\n      requiresStyleInsertion\n        ? (writeChunk(destination, completeBoundaryScript3a),\n          writeStyleResourceDependenciesInJS(destination, boundary))\n        : writeChunk(destination, completeBoundaryScript3b);\n      boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);\n      return writeBootstrap(destination, request) && boundary;\n    }\n    function flushPartiallyCompletedSegment(\n      request,\n      destination,\n      boundary,\n      segment\n    ) {\n      if (segment.status === FLUSHED) return !0;\n      var hoistableState = boundary.contentState,\n        segmentID = segment.id;\n      if (-1 === segmentID) {\n        if (-1 === (segment.id = boundary.rootSegmentID))\n          throw Error(\n            \"A root segment ID must have been assigned by now. This is a bug in React.\"\n          );\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      }\n      if (segmentID === boundary.rootSegmentID)\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      flushSegmentContainer(request, destination, segment, hoistableState);\n      boundary = request.resumableState;\n      request = request.renderState;\n      writeChunk(destination, request.startInlineScript);\n      (boundary.instructions & SentCompleteSegmentFunction) === NothingSent\n        ? ((boundary.instructions |= SentCompleteSegmentFunction),\n          writeChunk(destination, completeSegmentScript1Full))\n        : writeChunk(destination, completeSegmentScript1Partial);\n      writeChunk(destination, request.segmentPrefix);\n      segmentID = segmentID.toString(16);\n      writeChunk(destination, segmentID);\n      writeChunk(destination, completeSegmentScript2);\n      writeChunk(destination, request.placeholderPrefix);\n      writeChunk(destination, segmentID);\n      destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);\n      return destination;\n    }\n    function flushCompletedQueues(request, destination) {\n      currentView = new Uint8Array(2048);\n      writtenBytes = 0;\n      destinationHasCapacity$1 = !0;\n      try {\n        if (!(0 < request.pendingRootTasks)) {\n          var i,\n            completedRootSegment = request.completedRootSegment;\n          if (null !== completedRootSegment) {\n            if (completedRootSegment.status === POSTPONED) return;\n            var completedPreambleSegments = request.completedPreambleSegments;\n            if (null === completedPreambleSegments) return;\n            var renderState = request.renderState,\n              preamble = renderState.preamble,\n              htmlChunks = preamble.htmlChunks,\n              headChunks = preamble.headChunks,\n              i$jscomp$0;\n            if (htmlChunks) {\n              for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)\n                writeChunk(destination, htmlChunks[i$jscomp$0]);\n              if (headChunks)\n                for (\n                  i$jscomp$0 = 0;\n                  i$jscomp$0 < headChunks.length;\n                  i$jscomp$0++\n                )\n                  writeChunk(destination, headChunks[i$jscomp$0]);\n              else\n                writeChunk(destination, startChunkForTag(\"head\")),\n                  writeChunk(destination, endOfStartTag);\n            } else if (headChunks)\n              for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)\n                writeChunk(destination, headChunks[i$jscomp$0]);\n            var charsetChunks = renderState.charsetChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < charsetChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, charsetChunks[i$jscomp$0]);\n            charsetChunks.length = 0;\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var viewportChunks = renderState.viewportChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < viewportChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, viewportChunks[i$jscomp$0]);\n            viewportChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear();\n            renderState.styles.forEach(flushStylesInPreamble, destination);\n            var importMapChunks = renderState.importMapChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < importMapChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, importMapChunks[i$jscomp$0]);\n            importMapChunks.length = 0;\n            renderState.bootstrapScripts.forEach(flushResource, destination);\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear();\n            var hoistableChunks = renderState.hoistableChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < hoistableChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, hoistableChunks[i$jscomp$0]);\n            for (\n              renderState = hoistableChunks.length = 0;\n              renderState < completedPreambleSegments.length;\n              renderState++\n            ) {\n              var segments = completedPreambleSegments[renderState];\n              for (preamble = 0; preamble < segments.length; preamble++)\n                flushSegment(request, destination, segments[preamble], null);\n            }\n            var preamble$jscomp$0 = request.renderState.preamble,\n              headChunks$jscomp$0 = preamble$jscomp$0.headChunks;\n            (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) &&\n              writeChunk(destination, endChunkForTag(\"head\"));\n            var bodyChunks = preamble$jscomp$0.bodyChunks;\n            if (bodyChunks)\n              for (\n                completedPreambleSegments = 0;\n                completedPreambleSegments < bodyChunks.length;\n                completedPreambleSegments++\n              )\n                writeChunk(destination, bodyChunks[completedPreambleSegments]);\n            flushSegment(request, destination, completedRootSegment, null);\n            request.completedRootSegment = null;\n            writeBootstrap(destination, request.renderState);\n          }\n          var renderState$jscomp$0 = request.renderState;\n          completedRootSegment = 0;\n          var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < viewportChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            writeChunk(\n              destination,\n              viewportChunks$jscomp$0[completedRootSegment]\n            );\n          viewportChunks$jscomp$0.length = 0;\n          renderState$jscomp$0.preconnects.forEach(flushResource, destination);\n          renderState$jscomp$0.preconnects.clear();\n          renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);\n          renderState$jscomp$0.fontPreloads.clear();\n          renderState$jscomp$0.highImagePreloads.forEach(\n            flushResource,\n            destination\n          );\n          renderState$jscomp$0.highImagePreloads.clear();\n          renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);\n          renderState$jscomp$0.scripts.forEach(flushResource, destination);\n          renderState$jscomp$0.scripts.clear();\n          renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);\n          renderState$jscomp$0.bulkPreloads.clear();\n          var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < hoistableChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            writeChunk(\n              destination,\n              hoistableChunks$jscomp$0[completedRootSegment]\n            );\n          hoistableChunks$jscomp$0.length = 0;\n          var clientRenderedBoundaries = request.clientRenderedBoundaries;\n          for (i = 0; i < clientRenderedBoundaries.length; i++) {\n            var boundary = clientRenderedBoundaries[i];\n            renderState$jscomp$0 = destination;\n            var resumableState = request.resumableState,\n              renderState$jscomp$1 = request.renderState,\n              id = boundary.rootSegmentID,\n              errorDigest = boundary.errorDigest,\n              errorMessage = boundary.errorMessage,\n              errorStack = boundary.errorStack,\n              errorComponentStack = boundary.errorComponentStack;\n            writeChunk(\n              renderState$jscomp$0,\n              renderState$jscomp$1.startInlineScript\n            );\n            (resumableState.instructions & SentClientRenderFunction) ===\n            NothingSent\n              ? ((resumableState.instructions |= SentClientRenderFunction),\n                writeChunk(renderState$jscomp$0, clientRenderScript1Full))\n              : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);\n            writeChunk(\n              renderState$jscomp$0,\n              renderState$jscomp$1.boundaryPrefix\n            );\n            writeChunk(renderState$jscomp$0, id.toString(16));\n            writeChunk(renderState$jscomp$0, clientRenderScript1A);\n            if (\n              errorDigest ||\n              errorMessage ||\n              errorStack ||\n              errorComponentStack\n            )\n              writeChunk(\n                renderState$jscomp$0,\n                clientRenderErrorScriptArgInterstitial\n              ),\n                writeChunk(\n                  renderState$jscomp$0,\n                  escapeJSStringsForInstructionScripts(errorDigest || \"\")\n                );\n            if (errorMessage || errorStack || errorComponentStack)\n              writeChunk(\n                renderState$jscomp$0,\n                clientRenderErrorScriptArgInterstitial\n              ),\n                writeChunk(\n                  renderState$jscomp$0,\n                  escapeJSStringsForInstructionScripts(errorMessage || \"\")\n                );\n            if (errorStack || errorComponentStack)\n              writeChunk(\n                renderState$jscomp$0,\n                clientRenderErrorScriptArgInterstitial\n              ),\n                writeChunk(\n                  renderState$jscomp$0,\n                  escapeJSStringsForInstructionScripts(errorStack || \"\")\n                );\n            errorComponentStack &&\n              (writeChunk(\n                renderState$jscomp$0,\n                clientRenderErrorScriptArgInterstitial\n              ),\n              writeChunk(\n                renderState$jscomp$0,\n                escapeJSStringsForInstructionScripts(errorComponentStack)\n              ));\n            var JSCompiler_inline_result = writeChunkAndReturn(\n              renderState$jscomp$0,\n              clientRenderScriptEnd\n            );\n            if (!JSCompiler_inline_result) {\n              request.destination = null;\n              i++;\n              clientRenderedBoundaries.splice(0, i);\n              return;\n            }\n          }\n          clientRenderedBoundaries.splice(0, i);\n          var completedBoundaries = request.completedBoundaries;\n          for (i = 0; i < completedBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(\n                request,\n                destination,\n                completedBoundaries[i]\n              )\n            ) {\n              request.destination = null;\n              i++;\n              completedBoundaries.splice(0, i);\n              return;\n            }\n          completedBoundaries.splice(0, i);\n          completeWriting(destination);\n          currentView = new Uint8Array(2048);\n          writtenBytes = 0;\n          destinationHasCapacity$1 = !0;\n          var partialBoundaries = request.partialBoundaries;\n          for (i = 0; i < partialBoundaries.length; i++) {\n            a: {\n              clientRenderedBoundaries = request;\n              boundary = destination;\n              var boundary$jscomp$0 = partialBoundaries[i],\n                completedSegments = boundary$jscomp$0.completedSegments;\n              for (\n                JSCompiler_inline_result = 0;\n                JSCompiler_inline_result < completedSegments.length;\n                JSCompiler_inline_result++\n              )\n                if (\n                  !flushPartiallyCompletedSegment(\n                    clientRenderedBoundaries,\n                    boundary,\n                    boundary$jscomp$0,\n                    completedSegments[JSCompiler_inline_result]\n                  )\n                ) {\n                  JSCompiler_inline_result++;\n                  completedSegments.splice(0, JSCompiler_inline_result);\n                  var JSCompiler_inline_result$jscomp$0 = !1;\n                  break a;\n                }\n              completedSegments.splice(0, JSCompiler_inline_result);\n              JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n                boundary,\n                boundary$jscomp$0.contentState,\n                clientRenderedBoundaries.renderState\n              );\n            }\n            if (!JSCompiler_inline_result$jscomp$0) {\n              request.destination = null;\n              i++;\n              partialBoundaries.splice(0, i);\n              return;\n            }\n          }\n          partialBoundaries.splice(0, i);\n          var largeBoundaries = request.completedBoundaries;\n          for (i = 0; i < largeBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(request, destination, largeBoundaries[i])\n            ) {\n              request.destination = null;\n              i++;\n              largeBoundaries.splice(0, i);\n              return;\n            }\n          largeBoundaries.splice(0, i);\n        }\n      } finally {\n        0 === request.allPendingTasks &&\n        0 === request.pingedTasks.length &&\n        0 === request.clientRenderedBoundaries.length &&\n        0 === request.completedBoundaries.length\n          ? ((request.flushScheduled = !1),\n            (i = request.resumableState),\n            i.hasBody && writeChunk(destination, endChunkForTag(\"body\")),\n            i.hasHtml && writeChunk(destination, endChunkForTag(\"html\")),\n            completeWriting(destination),\n            flushBuffered(destination),\n            0 !== request.abortableTasks.size &&\n              console.error(\n                \"There was still abortable task at the root when we closed. This is a bug in React.\"\n              ),\n            (request.status = CLOSED),\n            destination.end(),\n            (request.destination = null))\n          : (completeWriting(destination), flushBuffered(destination));\n      }\n    }\n    function startWork(request) {\n      request.flushScheduled = null !== request.destination;\n      scheduleMicrotask(function () {\n        return requestStorage.run(request, performWork, request);\n      });\n      setImmediate(function () {\n        10 === request.status && (request.status = 11);\n        null === request.trackedPostpones &&\n          requestStorage.run(\n            request,\n            enqueueEarlyPreloadsAfterInitialWork,\n            request\n          );\n      });\n    }\n    function enqueueEarlyPreloadsAfterInitialWork(request) {\n      safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);\n    }\n    function enqueueFlush(request) {\n      !1 === request.flushScheduled &&\n        0 === request.pingedTasks.length &&\n        null !== request.destination &&\n        ((request.flushScheduled = !0),\n        setImmediate(function () {\n          var destination = request.destination;\n          destination\n            ? flushCompletedQueues(request, destination)\n            : (request.flushScheduled = !1);\n        }));\n    }\n    function startFlowing(request, destination) {\n      if (13 === request.status)\n        (request.status = CLOSED), destination.destroy(request.fatalError);\n      else if (request.status !== CLOSED && null === request.destination) {\n        request.destination = destination;\n        try {\n          flushCompletedQueues(request, destination);\n        } catch (error) {\n          (destination = {}),\n            logRecoverableError(request, error, destination, null),\n            fatalError(request, error, destination, null);\n        }\n      }\n    }\n    function abort(request, reason) {\n      if (11 === request.status || 10 === request.status) request.status = 12;\n      try {\n        var abortableTasks = request.abortableTasks;\n        if (0 < abortableTasks.size) {\n          var error =\n            void 0 === reason\n              ? Error(\"The render was aborted by the server without a reason.\")\n              : \"object\" === typeof reason &&\n                  null !== reason &&\n                  \"function\" === typeof reason.then\n                ? Error(\"The render was aborted by the server with a promise.\")\n                : reason;\n          request.fatalError = error;\n          abortableTasks.forEach(function (task) {\n            return abortTask(task, request, error);\n          });\n          abortableTasks.clear();\n        }\n        null !== request.destination &&\n          flushCompletedQueues(request, request.destination);\n      } catch (error$4) {\n        (reason = {}),\n          logRecoverableError(request, error$4, reason, null),\n          fatalError(request, error$4, reason, null);\n      }\n    }\n    function ensureCorrectIsomorphicReactVersion() {\n      var isomorphicReactPackageVersion = React.version;\n      if (\"19.1.0-canary-029e8bd6-20250306\" !== isomorphicReactPackageVersion)\n        throw Error(\n          'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n            (isomorphicReactPackageVersion +\n              \"\\n  - react-dom:  19.1.0-canary-029e8bd6-20250306\\nLearn more: https://react.dev/warnings/version-mismatch\")\n        );\n    }\n    function createDrainHandler(destination, request) {\n      return function () {\n        return startFlowing(request, destination);\n      };\n    }\n    function createCancelHandler(request, reason) {\n      return function () {\n        request.destination = null;\n        abort(request, Error(reason));\n      };\n    }\n    function createRequestImpl(children, options) {\n      var resumableState = createResumableState(\n        options ? options.identifierPrefix : void 0,\n        options ? options.unstable_externalRuntimeSrc : void 0,\n        options ? options.bootstrapScriptContent : void 0,\n        options ? options.bootstrapScripts : void 0,\n        options ? options.bootstrapModules : void 0\n      );\n      return createRequest(\n        children,\n        resumableState,\n        createRenderState(\n          resumableState,\n          options ? options.nonce : void 0,\n          options ? options.unstable_externalRuntimeSrc : void 0,\n          options ? options.importMap : void 0,\n          options ? options.onHeaders : void 0,\n          options ? options.maxHeadersLength : void 0\n        ),\n        createRootFormatContext(options ? options.namespaceURI : void 0),\n        options ? options.progressiveChunkSize : void 0,\n        options ? options.onError : void 0,\n        options ? options.onAllReady : void 0,\n        options ? options.onShellReady : void 0,\n        options ? options.onShellError : void 0,\n        void 0,\n        options ? options.onPostpone : void 0,\n        options ? options.formState : void 0\n      );\n    }\n    function createFakeWritable(readable) {\n      return {\n        write: function (chunk) {\n          return readable.push(chunk);\n        },\n        end: function () {\n          readable.push(null);\n        },\n        destroy: function (error) {\n          readable.destroy(error);\n        }\n      };\n    }\n    var util = __webpack_require__(/*! util */ \"util\"),\n      crypto = __webpack_require__(/*! crypto */ \"crypto\"),\n      async_hooks = __webpack_require__(/*! async_hooks */ \"async_hooks\"),\n      React = __webpack_require__(/*! next/dist/compiled/react */ \"(rsc)/./node_modules/next/dist/compiled/react/index.js\"),\n      ReactDOM = __webpack_require__(/*! next/dist/compiled/react-dom */ \"(rsc)/./node_modules/next/dist/compiled/react-dom/index.js\"),\n      stream = __webpack_require__(/*! stream */ \"stream\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_SCOPE_TYPE = Symbol.for(\"react.scope\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\"),\n      REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"),\n      REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      isArrayImpl = Array.isArray,\n      jsxPropsParents = new WeakMap(),\n      jsxChildrenParents = new WeakMap(),\n      CLIENT_REFERENCE_TAG = Symbol.for(\"react.client.reference\"),\n      scheduleMicrotask = queueMicrotask,\n      currentView = null,\n      writtenBytes = 0,\n      destinationHasCapacity$1 = !0,\n      textEncoder = new util.TextEncoder(),\n      assign = Object.assign,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      VALID_ATTRIBUTE_NAME_REGEX = RegExp(\n        \"^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      illegalAttributeNameCache = {},\n      validatedAttributeNameCache = {},\n      unitlessNumbers = new Set(\n        \"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\n          \" \"\n        )\n      ),\n      aliases = new Map([\n        [\"acceptCharset\", \"accept-charset\"],\n        [\"htmlFor\", \"for\"],\n        [\"httpEquiv\", \"http-equiv\"],\n        [\"crossOrigin\", \"crossorigin\"],\n        [\"accentHeight\", \"accent-height\"],\n        [\"alignmentBaseline\", \"alignment-baseline\"],\n        [\"arabicForm\", \"arabic-form\"],\n        [\"baselineShift\", \"baseline-shift\"],\n        [\"capHeight\", \"cap-height\"],\n        [\"clipPath\", \"clip-path\"],\n        [\"clipRule\", \"clip-rule\"],\n        [\"colorInterpolation\", \"color-interpolation\"],\n        [\"colorInterpolationFilters\", \"color-interpolation-filters\"],\n        [\"colorProfile\", \"color-profile\"],\n        [\"colorRendering\", \"color-rendering\"],\n        [\"dominantBaseline\", \"dominant-baseline\"],\n        [\"enableBackground\", \"enable-background\"],\n        [\"fillOpacity\", \"fill-opacity\"],\n        [\"fillRule\", \"fill-rule\"],\n        [\"floodColor\", \"flood-color\"],\n        [\"floodOpacity\", \"flood-opacity\"],\n        [\"fontFamily\", \"font-family\"],\n        [\"fontSize\", \"font-size\"],\n        [\"fontSizeAdjust\", \"font-size-adjust\"],\n        [\"fontStretch\", \"font-stretch\"],\n        [\"fontStyle\", \"font-style\"],\n        [\"fontVariant\", \"font-variant\"],\n        [\"fontWeight\", \"font-weight\"],\n        [\"glyphName\", \"glyph-name\"],\n        [\"glyphOrientationHorizontal\", \"glyph-orientation-horizontal\"],\n        [\"glyphOrientationVertical\", \"glyph-orientation-vertical\"],\n        [\"horizAdvX\", \"horiz-adv-x\"],\n        [\"horizOriginX\", \"horiz-origin-x\"],\n        [\"imageRendering\", \"image-rendering\"],\n        [\"letterSpacing\", \"letter-spacing\"],\n        [\"lightingColor\", \"lighting-color\"],\n        [\"markerEnd\", \"marker-end\"],\n        [\"markerMid\", \"marker-mid\"],\n        [\"markerStart\", \"marker-start\"],\n        [\"overlinePosition\", \"overline-position\"],\n        [\"overlineThickness\", \"overline-thickness\"],\n        [\"paintOrder\", \"paint-order\"],\n        [\"panose-1\", \"panose-1\"],\n        [\"pointerEvents\", \"pointer-events\"],\n        [\"renderingIntent\", \"rendering-intent\"],\n        [\"shapeRendering\", \"shape-rendering\"],\n        [\"stopColor\", \"stop-color\"],\n        [\"stopOpacity\", \"stop-opacity\"],\n        [\"strikethroughPosition\", \"strikethrough-position\"],\n        [\"strikethroughThickness\", \"strikethrough-thickness\"],\n        [\"strokeDasharray\", \"stroke-dasharray\"],\n        [\"strokeDashoffset\", \"stroke-dashoffset\"],\n        [\"strokeLinecap\", \"stroke-linecap\"],\n        [\"strokeLinejoin\", \"stroke-linejoin\"],\n        [\"strokeMiterlimit\", \"stroke-miterlimit\"],\n        [\"strokeOpacity\", \"stroke-opacity\"],\n        [\"strokeWidth\", \"stroke-width\"],\n        [\"textAnchor\", \"text-anchor\"],\n        [\"textDecoration\", \"text-decoration\"],\n        [\"textRendering\", \"text-rendering\"],\n        [\"transformOrigin\", \"transform-origin\"],\n        [\"underlinePosition\", \"underline-position\"],\n        [\"underlineThickness\", \"underline-thickness\"],\n        [\"unicodeBidi\", \"unicode-bidi\"],\n        [\"unicodeRange\", \"unicode-range\"],\n        [\"unitsPerEm\", \"units-per-em\"],\n        [\"vAlphabetic\", \"v-alphabetic\"],\n        [\"vHanging\", \"v-hanging\"],\n        [\"vIdeographic\", \"v-ideographic\"],\n        [\"vMathematical\", \"v-mathematical\"],\n        [\"vectorEffect\", \"vector-effect\"],\n        [\"vertAdvY\", \"vert-adv-y\"],\n        [\"vertOriginX\", \"vert-origin-x\"],\n        [\"vertOriginY\", \"vert-origin-y\"],\n        [\"wordSpacing\", \"word-spacing\"],\n        [\"writingMode\", \"writing-mode\"],\n        [\"xmlnsXlink\", \"xmlns:xlink\"],\n        [\"xHeight\", \"x-height\"]\n      ]),\n      hasReadOnlyValue = {\n        button: !0,\n        checkbox: !0,\n        image: !0,\n        hidden: !0,\n        radio: !0,\n        reset: !0,\n        submit: !0\n      },\n      ariaProperties = {\n        \"aria-current\": 0,\n        \"aria-description\": 0,\n        \"aria-details\": 0,\n        \"aria-disabled\": 0,\n        \"aria-hidden\": 0,\n        \"aria-invalid\": 0,\n        \"aria-keyshortcuts\": 0,\n        \"aria-label\": 0,\n        \"aria-roledescription\": 0,\n        \"aria-autocomplete\": 0,\n        \"aria-checked\": 0,\n        \"aria-expanded\": 0,\n        \"aria-haspopup\": 0,\n        \"aria-level\": 0,\n        \"aria-modal\": 0,\n        \"aria-multiline\": 0,\n        \"aria-multiselectable\": 0,\n        \"aria-orientation\": 0,\n        \"aria-placeholder\": 0,\n        \"aria-pressed\": 0,\n        \"aria-readonly\": 0,\n        \"aria-required\": 0,\n        \"aria-selected\": 0,\n        \"aria-sort\": 0,\n        \"aria-valuemax\": 0,\n        \"aria-valuemin\": 0,\n        \"aria-valuenow\": 0,\n        \"aria-valuetext\": 0,\n        \"aria-atomic\": 0,\n        \"aria-busy\": 0,\n        \"aria-live\": 0,\n        \"aria-relevant\": 0,\n        \"aria-dropeffect\": 0,\n        \"aria-grabbed\": 0,\n        \"aria-activedescendant\": 0,\n        \"aria-colcount\": 0,\n        \"aria-colindex\": 0,\n        \"aria-colspan\": 0,\n        \"aria-controls\": 0,\n        \"aria-describedby\": 0,\n        \"aria-errormessage\": 0,\n        \"aria-flowto\": 0,\n        \"aria-labelledby\": 0,\n        \"aria-owns\": 0,\n        \"aria-posinset\": 0,\n        \"aria-rowcount\": 0,\n        \"aria-rowindex\": 0,\n        \"aria-rowspan\": 0,\n        \"aria-setsize\": 0\n      },\n      warnedProperties$1 = {},\n      rARIA$1 = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel$1 = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      didWarnValueNull = !1,\n      possibleStandardNames = {\n        accept: \"accept\",\n        acceptcharset: \"acceptCharset\",\n        \"accept-charset\": \"acceptCharset\",\n        accesskey: \"accessKey\",\n        action: \"action\",\n        allowfullscreen: \"allowFullScreen\",\n        alt: \"alt\",\n        as: \"as\",\n        async: \"async\",\n        autocapitalize: \"autoCapitalize\",\n        autocomplete: \"autoComplete\",\n        autocorrect: \"autoCorrect\",\n        autofocus: \"autoFocus\",\n        autoplay: \"autoPlay\",\n        autosave: \"autoSave\",\n        capture: \"capture\",\n        cellpadding: \"cellPadding\",\n        cellspacing: \"cellSpacing\",\n        challenge: \"challenge\",\n        charset: \"charSet\",\n        checked: \"checked\",\n        children: \"children\",\n        cite: \"cite\",\n        class: \"className\",\n        classid: \"classID\",\n        classname: \"className\",\n        cols: \"cols\",\n        colspan: \"colSpan\",\n        content: \"content\",\n        contenteditable: \"contentEditable\",\n        contextmenu: \"contextMenu\",\n        controls: \"controls\",\n        controlslist: \"controlsList\",\n        coords: \"coords\",\n        crossorigin: \"crossOrigin\",\n        dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n        data: \"data\",\n        datetime: \"dateTime\",\n        default: \"default\",\n        defaultchecked: \"defaultChecked\",\n        defaultvalue: \"defaultValue\",\n        defer: \"defer\",\n        dir: \"dir\",\n        disabled: \"disabled\",\n        disablepictureinpicture: \"disablePictureInPicture\",\n        disableremoteplayback: \"disableRemotePlayback\",\n        download: \"download\",\n        draggable: \"draggable\",\n        enctype: \"encType\",\n        enterkeyhint: \"enterKeyHint\",\n        fetchpriority: \"fetchPriority\",\n        for: \"htmlFor\",\n        form: \"form\",\n        formmethod: \"formMethod\",\n        formaction: \"formAction\",\n        formenctype: \"formEncType\",\n        formnovalidate: \"formNoValidate\",\n        formtarget: \"formTarget\",\n        frameborder: \"frameBorder\",\n        headers: \"headers\",\n        height: \"height\",\n        hidden: \"hidden\",\n        high: \"high\",\n        href: \"href\",\n        hreflang: \"hrefLang\",\n        htmlfor: \"htmlFor\",\n        httpequiv: \"httpEquiv\",\n        \"http-equiv\": \"httpEquiv\",\n        icon: \"icon\",\n        id: \"id\",\n        imagesizes: \"imageSizes\",\n        imagesrcset: \"imageSrcSet\",\n        inert: \"inert\",\n        innerhtml: \"innerHTML\",\n        inputmode: \"inputMode\",\n        integrity: \"integrity\",\n        is: \"is\",\n        itemid: \"itemID\",\n        itemprop: \"itemProp\",\n        itemref: \"itemRef\",\n        itemscope: \"itemScope\",\n        itemtype: \"itemType\",\n        keyparams: \"keyParams\",\n        keytype: \"keyType\",\n        kind: \"kind\",\n        label: \"label\",\n        lang: \"lang\",\n        list: \"list\",\n        loop: \"loop\",\n        low: \"low\",\n        manifest: \"manifest\",\n        marginwidth: \"marginWidth\",\n        marginheight: \"marginHeight\",\n        max: \"max\",\n        maxlength: \"maxLength\",\n        media: \"media\",\n        mediagroup: \"mediaGroup\",\n        method: \"method\",\n        min: \"min\",\n        minlength: \"minLength\",\n        multiple: \"multiple\",\n        muted: \"muted\",\n        name: \"name\",\n        nomodule: \"noModule\",\n        nonce: \"nonce\",\n        novalidate: \"noValidate\",\n        open: \"open\",\n        optimum: \"optimum\",\n        pattern: \"pattern\",\n        placeholder: \"placeholder\",\n        playsinline: \"playsInline\",\n        poster: \"poster\",\n        preload: \"preload\",\n        profile: \"profile\",\n        radiogroup: \"radioGroup\",\n        readonly: \"readOnly\",\n        referrerpolicy: \"referrerPolicy\",\n        rel: \"rel\",\n        required: \"required\",\n        reversed: \"reversed\",\n        role: \"role\",\n        rows: \"rows\",\n        rowspan: \"rowSpan\",\n        sandbox: \"sandbox\",\n        scope: \"scope\",\n        scoped: \"scoped\",\n        scrolling: \"scrolling\",\n        seamless: \"seamless\",\n        selected: \"selected\",\n        shape: \"shape\",\n        size: \"size\",\n        sizes: \"sizes\",\n        span: \"span\",\n        spellcheck: \"spellCheck\",\n        src: \"src\",\n        srcdoc: \"srcDoc\",\n        srclang: \"srcLang\",\n        srcset: \"srcSet\",\n        start: \"start\",\n        step: \"step\",\n        style: \"style\",\n        summary: \"summary\",\n        tabindex: \"tabIndex\",\n        target: \"target\",\n        title: \"title\",\n        type: \"type\",\n        usemap: \"useMap\",\n        value: \"value\",\n        width: \"width\",\n        wmode: \"wmode\",\n        wrap: \"wrap\",\n        about: \"about\",\n        accentheight: \"accentHeight\",\n        \"accent-height\": \"accentHeight\",\n        accumulate: \"accumulate\",\n        additive: \"additive\",\n        alignmentbaseline: \"alignmentBaseline\",\n        \"alignment-baseline\": \"alignmentBaseline\",\n        allowreorder: \"allowReorder\",\n        alphabetic: \"alphabetic\",\n        amplitude: \"amplitude\",\n        arabicform: \"arabicForm\",\n        \"arabic-form\": \"arabicForm\",\n        ascent: \"ascent\",\n        attributename: \"attributeName\",\n        attributetype: \"attributeType\",\n        autoreverse: \"autoReverse\",\n        azimuth: \"azimuth\",\n        basefrequency: \"baseFrequency\",\n        baselineshift: \"baselineShift\",\n        \"baseline-shift\": \"baselineShift\",\n        baseprofile: \"baseProfile\",\n        bbox: \"bbox\",\n        begin: \"begin\",\n        bias: \"bias\",\n        by: \"by\",\n        calcmode: \"calcMode\",\n        capheight: \"capHeight\",\n        \"cap-height\": \"capHeight\",\n        clip: \"clip\",\n        clippath: \"clipPath\",\n        \"clip-path\": \"clipPath\",\n        clippathunits: \"clipPathUnits\",\n        cliprule: \"clipRule\",\n        \"clip-rule\": \"clipRule\",\n        color: \"color\",\n        colorinterpolation: \"colorInterpolation\",\n        \"color-interpolation\": \"colorInterpolation\",\n        colorinterpolationfilters: \"colorInterpolationFilters\",\n        \"color-interpolation-filters\": \"colorInterpolationFilters\",\n        colorprofile: \"colorProfile\",\n        \"color-profile\": \"colorProfile\",\n        colorrendering: \"colorRendering\",\n        \"color-rendering\": \"colorRendering\",\n        contentscripttype: \"contentScriptType\",\n        contentstyletype: \"contentStyleType\",\n        cursor: \"cursor\",\n        cx: \"cx\",\n        cy: \"cy\",\n        d: \"d\",\n        datatype: \"datatype\",\n        decelerate: \"decelerate\",\n        descent: \"descent\",\n        diffuseconstant: \"diffuseConstant\",\n        direction: \"direction\",\n        display: \"display\",\n        divisor: \"divisor\",\n        dominantbaseline: \"dominantBaseline\",\n        \"dominant-baseline\": \"dominantBaseline\",\n        dur: \"dur\",\n        dx: \"dx\",\n        dy: \"dy\",\n        edgemode: \"edgeMode\",\n        elevation: \"elevation\",\n        enablebackground: \"enableBackground\",\n        \"enable-background\": \"enableBackground\",\n        end: \"end\",\n        exponent: \"exponent\",\n        externalresourcesrequired: \"externalResourcesRequired\",\n        fill: \"fill\",\n        fillopacity: \"fillOpacity\",\n        \"fill-opacity\": \"fillOpacity\",\n        fillrule: \"fillRule\",\n        \"fill-rule\": \"fillRule\",\n        filter: \"filter\",\n        filterres: \"filterRes\",\n        filterunits: \"filterUnits\",\n        floodopacity: \"floodOpacity\",\n        \"flood-opacity\": \"floodOpacity\",\n        floodcolor: \"floodColor\",\n        \"flood-color\": \"floodColor\",\n        focusable: \"focusable\",\n        fontfamily: \"fontFamily\",\n        \"font-family\": \"fontFamily\",\n        fontsize: \"fontSize\",\n        \"font-size\": \"fontSize\",\n        fontsizeadjust: \"fontSizeAdjust\",\n        \"font-size-adjust\": \"fontSizeAdjust\",\n        fontstretch: \"fontStretch\",\n        \"font-stretch\": \"fontStretch\",\n        fontstyle: \"fontStyle\",\n        \"font-style\": \"fontStyle\",\n        fontvariant: \"fontVariant\",\n        \"font-variant\": \"fontVariant\",\n        fontweight: \"fontWeight\",\n        \"font-weight\": \"fontWeight\",\n        format: \"format\",\n        from: \"from\",\n        fx: \"fx\",\n        fy: \"fy\",\n        g1: \"g1\",\n        g2: \"g2\",\n        glyphname: \"glyphName\",\n        \"glyph-name\": \"glyphName\",\n        glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n        \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n        glyphorientationvertical: \"glyphOrientationVertical\",\n        \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n        glyphref: \"glyphRef\",\n        gradienttransform: \"gradientTransform\",\n        gradientunits: \"gradientUnits\",\n        hanging: \"hanging\",\n        horizadvx: \"horizAdvX\",\n        \"horiz-adv-x\": \"horizAdvX\",\n        horizoriginx: \"horizOriginX\",\n        \"horiz-origin-x\": \"horizOriginX\",\n        ideographic: \"ideographic\",\n        imagerendering: \"imageRendering\",\n        \"image-rendering\": \"imageRendering\",\n        in2: \"in2\",\n        in: \"in\",\n        inlist: \"inlist\",\n        intercept: \"intercept\",\n        k1: \"k1\",\n        k2: \"k2\",\n        k3: \"k3\",\n        k4: \"k4\",\n        k: \"k\",\n        kernelmatrix: \"kernelMatrix\",\n        kernelunitlength: \"kernelUnitLength\",\n        kerning: \"kerning\",\n        keypoints: \"keyPoints\",\n        keysplines: \"keySplines\",\n        keytimes: \"keyTimes\",\n        lengthadjust: \"lengthAdjust\",\n        letterspacing: \"letterSpacing\",\n        \"letter-spacing\": \"letterSpacing\",\n        lightingcolor: \"lightingColor\",\n        \"lighting-color\": \"lightingColor\",\n        limitingconeangle: \"limitingConeAngle\",\n        local: \"local\",\n        markerend: \"markerEnd\",\n        \"marker-end\": \"markerEnd\",\n        markerheight: \"markerHeight\",\n        markermid: \"markerMid\",\n        \"marker-mid\": \"markerMid\",\n        markerstart: \"markerStart\",\n        \"marker-start\": \"markerStart\",\n        markerunits: \"markerUnits\",\n        markerwidth: \"markerWidth\",\n        mask: \"mask\",\n        maskcontentunits: \"maskContentUnits\",\n        maskunits: \"maskUnits\",\n        mathematical: \"mathematical\",\n        mode: \"mode\",\n        numoctaves: \"numOctaves\",\n        offset: \"offset\",\n        opacity: \"opacity\",\n        operator: \"operator\",\n        order: \"order\",\n        orient: \"orient\",\n        orientation: \"orientation\",\n        origin: \"origin\",\n        overflow: \"overflow\",\n        overlineposition: \"overlinePosition\",\n        \"overline-position\": \"overlinePosition\",\n        overlinethickness: \"overlineThickness\",\n        \"overline-thickness\": \"overlineThickness\",\n        paintorder: \"paintOrder\",\n        \"paint-order\": \"paintOrder\",\n        panose1: \"panose1\",\n        \"panose-1\": \"panose1\",\n        pathlength: \"pathLength\",\n        patterncontentunits: \"patternContentUnits\",\n        patterntransform: \"patternTransform\",\n        patternunits: \"patternUnits\",\n        pointerevents: \"pointerEvents\",\n        \"pointer-events\": \"pointerEvents\",\n        points: \"points\",\n        pointsatx: \"pointsAtX\",\n        pointsaty: \"pointsAtY\",\n        pointsatz: \"pointsAtZ\",\n        popover: \"popover\",\n        popovertarget: \"popoverTarget\",\n        popovertargetaction: \"popoverTargetAction\",\n        prefix: \"prefix\",\n        preservealpha: \"preserveAlpha\",\n        preserveaspectratio: \"preserveAspectRatio\",\n        primitiveunits: \"primitiveUnits\",\n        property: \"property\",\n        r: \"r\",\n        radius: \"radius\",\n        refx: \"refX\",\n        refy: \"refY\",\n        renderingintent: \"renderingIntent\",\n        \"rendering-intent\": \"renderingIntent\",\n        repeatcount: \"repeatCount\",\n        repeatdur: \"repeatDur\",\n        requiredextensions: \"requiredExtensions\",\n        requiredfeatures: \"requiredFeatures\",\n        resource: \"resource\",\n        restart: \"restart\",\n        result: \"result\",\n        results: \"results\",\n        rotate: \"rotate\",\n        rx: \"rx\",\n        ry: \"ry\",\n        scale: \"scale\",\n        security: \"security\",\n        seed: \"seed\",\n        shaperendering: \"shapeRendering\",\n        \"shape-rendering\": \"shapeRendering\",\n        slope: \"slope\",\n        spacing: \"spacing\",\n        specularconstant: \"specularConstant\",\n        specularexponent: \"specularExponent\",\n        speed: \"speed\",\n        spreadmethod: \"spreadMethod\",\n        startoffset: \"startOffset\",\n        stddeviation: \"stdDeviation\",\n        stemh: \"stemh\",\n        stemv: \"stemv\",\n        stitchtiles: \"stitchTiles\",\n        stopcolor: \"stopColor\",\n        \"stop-color\": \"stopColor\",\n        stopopacity: \"stopOpacity\",\n        \"stop-opacity\": \"stopOpacity\",\n        strikethroughposition: \"strikethroughPosition\",\n        \"strikethrough-position\": \"strikethroughPosition\",\n        strikethroughthickness: \"strikethroughThickness\",\n        \"strikethrough-thickness\": \"strikethroughThickness\",\n        string: \"string\",\n        stroke: \"stroke\",\n        strokedasharray: \"strokeDasharray\",\n        \"stroke-dasharray\": \"strokeDasharray\",\n        strokedashoffset: \"strokeDashoffset\",\n        \"stroke-dashoffset\": \"strokeDashoffset\",\n        strokelinecap: \"strokeLinecap\",\n        \"stroke-linecap\": \"strokeLinecap\",\n        strokelinejoin: \"strokeLinejoin\",\n        \"stroke-linejoin\": \"strokeLinejoin\",\n        strokemiterlimit: \"strokeMiterlimit\",\n        \"stroke-miterlimit\": \"strokeMiterlimit\",\n        strokewidth: \"strokeWidth\",\n        \"stroke-width\": \"strokeWidth\",\n        strokeopacity: \"strokeOpacity\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n        suppresshydrationwarning: \"suppressHydrationWarning\",\n        surfacescale: \"surfaceScale\",\n        systemlanguage: \"systemLanguage\",\n        tablevalues: \"tableValues\",\n        targetx: \"targetX\",\n        targety: \"targetY\",\n        textanchor: \"textAnchor\",\n        \"text-anchor\": \"textAnchor\",\n        textdecoration: \"textDecoration\",\n        \"text-decoration\": \"textDecoration\",\n        textlength: \"textLength\",\n        textrendering: \"textRendering\",\n        \"text-rendering\": \"textRendering\",\n        to: \"to\",\n        transform: \"transform\",\n        transformorigin: \"transformOrigin\",\n        \"transform-origin\": \"transformOrigin\",\n        typeof: \"typeof\",\n        u1: \"u1\",\n        u2: \"u2\",\n        underlineposition: \"underlinePosition\",\n        \"underline-position\": \"underlinePosition\",\n        underlinethickness: \"underlineThickness\",\n        \"underline-thickness\": \"underlineThickness\",\n        unicode: \"unicode\",\n        unicodebidi: \"unicodeBidi\",\n        \"unicode-bidi\": \"unicodeBidi\",\n        unicoderange: \"unicodeRange\",\n        \"unicode-range\": \"unicodeRange\",\n        unitsperem: \"unitsPerEm\",\n        \"units-per-em\": \"unitsPerEm\",\n        unselectable: \"unselectable\",\n        valphabetic: \"vAlphabetic\",\n        \"v-alphabetic\": \"vAlphabetic\",\n        values: \"values\",\n        vectoreffect: \"vectorEffect\",\n        \"vector-effect\": \"vectorEffect\",\n        version: \"version\",\n        vertadvy: \"vertAdvY\",\n        \"vert-adv-y\": \"vertAdvY\",\n        vertoriginx: \"vertOriginX\",\n        \"vert-origin-x\": \"vertOriginX\",\n        vertoriginy: \"vertOriginY\",\n        \"vert-origin-y\": \"vertOriginY\",\n        vhanging: \"vHanging\",\n        \"v-hanging\": \"vHanging\",\n        videographic: \"vIdeographic\",\n        \"v-ideographic\": \"vIdeographic\",\n        viewbox: \"viewBox\",\n        viewtarget: \"viewTarget\",\n        visibility: \"visibility\",\n        vmathematical: \"vMathematical\",\n        \"v-mathematical\": \"vMathematical\",\n        vocab: \"vocab\",\n        widths: \"widths\",\n        wordspacing: \"wordSpacing\",\n        \"word-spacing\": \"wordSpacing\",\n        writingmode: \"writingMode\",\n        \"writing-mode\": \"writingMode\",\n        x1: \"x1\",\n        x2: \"x2\",\n        x: \"x\",\n        xchannelselector: \"xChannelSelector\",\n        xheight: \"xHeight\",\n        \"x-height\": \"xHeight\",\n        xlinkactuate: \"xlinkActuate\",\n        \"xlink:actuate\": \"xlinkActuate\",\n        xlinkarcrole: \"xlinkArcrole\",\n        \"xlink:arcrole\": \"xlinkArcrole\",\n        xlinkhref: \"xlinkHref\",\n        \"xlink:href\": \"xlinkHref\",\n        xlinkrole: \"xlinkRole\",\n        \"xlink:role\": \"xlinkRole\",\n        xlinkshow: \"xlinkShow\",\n        \"xlink:show\": \"xlinkShow\",\n        xlinktitle: \"xlinkTitle\",\n        \"xlink:title\": \"xlinkTitle\",\n        xlinktype: \"xlinkType\",\n        \"xlink:type\": \"xlinkType\",\n        xmlbase: \"xmlBase\",\n        \"xml:base\": \"xmlBase\",\n        xmllang: \"xmlLang\",\n        \"xml:lang\": \"xmlLang\",\n        xmlns: \"xmlns\",\n        \"xml:space\": \"xmlSpace\",\n        xmlnsxlink: \"xmlnsXlink\",\n        \"xmlns:xlink\": \"xmlnsXlink\",\n        xmlspace: \"xmlSpace\",\n        y1: \"y1\",\n        y2: \"y2\",\n        y: \"y\",\n        ychannelselector: \"yChannelSelector\",\n        z: \"z\",\n        zoomandpan: \"zoomAndPan\"\n      },\n      warnedProperties = {},\n      EVENT_NAME_REGEX = /^on./,\n      INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,\n      rARIA = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,\n      msPattern$1 = /^-ms-/,\n      hyphenPattern = /-(.)/g,\n      badStyleValueWithSemicolonPattern = /;\\s*$/,\n      warnedStyleNames = {},\n      warnedStyleValues = {},\n      warnedForNaNValue = !1,\n      warnedForInfinityValue = !1,\n      matchHtmlRegExp = /[\"'&<>]/,\n      uppercasePattern = /([A-Z])/g,\n      msPattern = /^ms-/,\n      isJavaScriptProtocol =\n        /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i,\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      ReactDOMSharedInternals =\n        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      NotPending = Object.freeze({\n        pending: !1,\n        data: null,\n        method: null,\n        action: null\n      }),\n      previousDispatcher = ReactDOMSharedInternals.d;\n    ReactDOMSharedInternals.d = {\n      f: previousDispatcher.f,\n      r: previousDispatcher.r,\n      D: function (href) {\n        var request = resolveRequest();\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            if (!resumableState.dnsResources.hasOwnProperty(href)) {\n              resumableState.dnsResources[href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              )\n                JSCompiler_temp =\n                  ((header =\n                    \"<\" +\n                    escapeHrefForLinkHeaderURLContext(href) +\n                    \">; rel=dns-prefetch\"),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              JSCompiler_temp\n                ? ((renderState.resets.dns[href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((header = []),\n                  pushLinkImpl(header, { href: href, rel: \"dns-prefetch\" }),\n                  renderState.preconnects.add(header));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.D(href);\n      },\n      C: function (href, crossOrigin) {\n        var request = resolveRequest();\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            var bucket =\n              \"use-credentials\" === crossOrigin\n                ? \"credentials\"\n                : \"string\" === typeof crossOrigin\n                  ? \"anonymous\"\n                  : \"default\";\n            if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {\n              resumableState.connectResources[bucket][href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              ) {\n                JSCompiler_temp =\n                  \"<\" +\n                  escapeHrefForLinkHeaderURLContext(href) +\n                  \">; rel=preconnect\";\n                if (\"string\" === typeof crossOrigin) {\n                  var escapedCrossOrigin =\n                    escapeStringForLinkHeaderQuotedParamValueContext(\n                      crossOrigin,\n                      \"crossOrigin\"\n                    );\n                  JSCompiler_temp +=\n                    '; crossorigin=\"' + escapedCrossOrigin + '\"';\n                }\n                JSCompiler_temp =\n                  ((header = JSCompiler_temp),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              }\n              JSCompiler_temp\n                ? ((renderState.resets.connect[bucket][href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((bucket = []),\n                  pushLinkImpl(bucket, {\n                    rel: \"preconnect\",\n                    href: href,\n                    crossOrigin: crossOrigin\n                  }),\n                  renderState.preconnects.add(bucket));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.C(href, crossOrigin);\n      },\n      L: function (href, as, options) {\n        var request = resolveRequest();\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (as && href) {\n            switch (as) {\n              case \"image\":\n                if (options) {\n                  var imageSrcSet = options.imageSrcSet;\n                  var imageSizes = options.imageSizes;\n                  var fetchPriority = options.fetchPriority;\n                }\n                var key = imageSrcSet\n                  ? imageSrcSet + \"\\n\" + (imageSizes || \"\")\n                  : href;\n                if (resumableState.imageResources.hasOwnProperty(key)) return;\n                resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                resumableState = renderState.headers;\n                var header;\n                resumableState &&\n                0 < resumableState.remainingCapacity &&\n                \"string\" !== typeof imageSrcSet &&\n                \"high\" === fetchPriority &&\n                ((header = getPreloadAsHeader(href, as, options)),\n                0 <= (resumableState.remainingCapacity -= header.length + 2))\n                  ? ((renderState.resets.image[key] = PRELOAD_NO_CREDS),\n                    resumableState.highImagePreloads &&\n                      (resumableState.highImagePreloads += \", \"),\n                    (resumableState.highImagePreloads += header))\n                  : ((resumableState = []),\n                    pushLinkImpl(\n                      resumableState,\n                      assign(\n                        {\n                          rel: \"preload\",\n                          href: imageSrcSet ? void 0 : href,\n                          as: as\n                        },\n                        options\n                      )\n                    ),\n                    \"high\" === fetchPriority\n                      ? renderState.highImagePreloads.add(resumableState)\n                      : (renderState.bulkPreloads.add(resumableState),\n                        renderState.preloads.images.set(key, resumableState)));\n                break;\n              case \"style\":\n                if (resumableState.styleResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.styleResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.stylesheets.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                break;\n              case \"script\":\n                if (resumableState.scriptResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                renderState.preloads.scripts.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.scriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                break;\n              default:\n                if (resumableState.unknownResources.hasOwnProperty(as)) {\n                  if (\n                    ((imageSrcSet = resumableState.unknownResources[as]),\n                    imageSrcSet.hasOwnProperty(href))\n                  )\n                    return;\n                } else\n                  (imageSrcSet = {}),\n                    (resumableState.unknownResources[as] = imageSrcSet);\n                imageSrcSet[href] = PRELOAD_NO_CREDS;\n                if (\n                  (resumableState = renderState.headers) &&\n                  0 < resumableState.remainingCapacity &&\n                  \"font\" === as &&\n                  ((key = getPreloadAsHeader(href, as, options)),\n                  0 <= (resumableState.remainingCapacity -= key.length + 2))\n                )\n                  (renderState.resets.font[href] = PRELOAD_NO_CREDS),\n                    resumableState.fontPreloads &&\n                      (resumableState.fontPreloads += \", \"),\n                    (resumableState.fontPreloads += key);\n                else\n                  switch (\n                    ((resumableState = []),\n                    (href = assign(\n                      { rel: \"preload\", href: href, as: as },\n                      options\n                    )),\n                    pushLinkImpl(resumableState, href),\n                    as)\n                  ) {\n                    case \"font\":\n                      renderState.fontPreloads.add(resumableState);\n                      break;\n                    default:\n                      renderState.bulkPreloads.add(resumableState);\n                  }\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.L(href, as, options);\n      },\n      m: function (href, options) {\n        var request = resolveRequest();\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            var as =\n              options && \"string\" === typeof options.as ? options.as : \"script\";\n            switch (as) {\n              case \"script\":\n                if (resumableState.moduleScriptResources.hasOwnProperty(href))\n                  return;\n                as = [];\n                resumableState.moduleScriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.moduleScripts.set(href, as);\n                break;\n              default:\n                if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {\n                  var resources = resumableState.unknownResources[as];\n                  if (resources.hasOwnProperty(href)) return;\n                } else\n                  (resources = {}),\n                    (resumableState.moduleUnknownResources[as] = resources);\n                as = [];\n                resources[href] = PRELOAD_NO_CREDS;\n            }\n            pushLinkImpl(\n              as,\n              assign({ rel: \"modulepreload\", href: href }, options)\n            );\n            renderState.bulkPreloads.add(as);\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.m(href, options);\n      },\n      X: function (src, options) {\n        var request = resolveRequest();\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState = resumableState.scriptResources.hasOwnProperty(\n              src\n            )\n              ? resumableState.scriptResources[src]\n              : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.scriptResources[src] = EXISTS),\n              (options = assign({ src: src, async: !0 }, options)),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.scripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.X(src, options);\n      },\n      S: function (href, precedence, options) {\n        var request = resolveRequest();\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            precedence = precedence || \"default\";\n            var styleQueue = renderState.styles.get(precedence),\n              resourceState = resumableState.styleResources.hasOwnProperty(href)\n                ? resumableState.styleResources[href]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.styleResources[href] = EXISTS),\n              styleQueue ||\n                ((styleQueue = {\n                  precedence: escapeTextForBrowser(precedence),\n                  rules: [],\n                  hrefs: [],\n                  sheets: new Map()\n                }),\n                renderState.styles.set(precedence, styleQueue)),\n              (precedence = {\n                state: PENDING$1,\n                props: assign(\n                  {\n                    rel: \"stylesheet\",\n                    href: href,\n                    \"data-precedence\": precedence\n                  },\n                  options\n                )\n              }),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(precedence.props, resourceState),\n                (renderState = renderState.preloads.stylesheets.get(href)) &&\n                0 < renderState.length\n                  ? (renderState.length = 0)\n                  : (precedence.state = PRELOADED)),\n              styleQueue.sheets.set(href, precedence),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.S(href, precedence, options);\n      },\n      M: function (src, options) {\n        var request = resolveRequest();\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState =\n              resumableState.moduleScriptResources.hasOwnProperty(src)\n                ? resumableState.moduleScriptResources[src]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.moduleScriptResources[src] = EXISTS),\n              (options = assign(\n                { src: src, type: \"module\", async: !0 },\n                options\n              )),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.moduleScripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.M(src, options);\n      }\n    };\n    var NothingSent = 0,\n      SentCompleteSegmentFunction = 1,\n      SentCompleteBoundaryFunction = 2,\n      SentClientRenderFunction = 4,\n      SentStyleInsertionFunction = 8,\n      EXISTS = null,\n      PRELOAD_NO_CREDS = [];\n    Object.freeze(PRELOAD_NO_CREDS);\n    stringToPrecomputedChunk('\"></template>');\n    var startInlineScript = stringToPrecomputedChunk(\"<script>\"),\n      endInlineScript = stringToPrecomputedChunk(\"\\x3c/script>\"),\n      startScriptSrc = stringToPrecomputedChunk('<script src=\"'),\n      startModuleSrc = stringToPrecomputedChunk('<script type=\"module\" src=\"'),\n      scriptNonce = stringToPrecomputedChunk('\" nonce=\"'),\n      scriptIntegirty = stringToPrecomputedChunk('\" integrity=\"'),\n      scriptCrossOrigin = stringToPrecomputedChunk('\" crossorigin=\"'),\n      endAsyncScript = stringToPrecomputedChunk('\" async=\"\">\\x3c/script>'),\n      scriptRegex = /(<\\/|<)(s)(cript)/gi,\n      importMapScriptStart = stringToPrecomputedChunk(\n        '<script type=\"importmap\">'\n      ),\n      importMapScriptEnd = stringToPrecomputedChunk(\"\\x3c/script>\");\n    var didWarnForNewBooleanPropsWithEmptyValue = {};\n    var NoContribution = 0,\n      ROOT_HTML_MODE = 0,\n      HTML_HTML_MODE = 1,\n      HTML_MODE = 2,\n      HTML_HEAD_MODE = 3,\n      SVG_MODE = 4,\n      MATHML_MODE = 5,\n      HTML_TABLE_MODE = 6,\n      HTML_TABLE_BODY_MODE = 7,\n      HTML_TABLE_ROW_MODE = 8,\n      HTML_COLGROUP_MODE = 9,\n      textSeparator = stringToPrecomputedChunk(\"\\x3c!-- --\\x3e\"),\n      styleNameCache = new Map(),\n      styleAttributeStart = stringToPrecomputedChunk(' style=\"'),\n      styleAssign = stringToPrecomputedChunk(\":\"),\n      styleSeparator = stringToPrecomputedChunk(\";\"),\n      attributeSeparator = stringToPrecomputedChunk(\" \"),\n      attributeAssign = stringToPrecomputedChunk('=\"'),\n      attributeEnd = stringToPrecomputedChunk('\"'),\n      attributeEmptyString = stringToPrecomputedChunk('=\"\"'),\n      actionJavaScriptURL = stringToPrecomputedChunk(\n        escapeTextForBrowser(\n          \"javascript:throw new Error('React form unexpectedly submitted.')\"\n        )\n      ),\n      startHiddenInputChunk = stringToPrecomputedChunk('<input type=\"hidden\"'),\n      endOfStartTag = stringToPrecomputedChunk(\">\"),\n      endOfStartTagSelfClosing = stringToPrecomputedChunk(\"/>\"),\n      didWarnDefaultInputValue = !1,\n      didWarnDefaultChecked = !1,\n      didWarnDefaultSelectValue = !1,\n      didWarnDefaultTextareaValue = !1,\n      didWarnInvalidOptionChildren = !1,\n      didWarnInvalidOptionInnerHTML = !1,\n      didWarnSelectedSetOnOption = !1,\n      didWarnFormActionType = !1,\n      didWarnFormActionName = !1,\n      didWarnFormActionTarget = !1,\n      didWarnFormActionMethod = !1,\n      selectedMarkerAttribute = stringToPrecomputedChunk(' selected=\"\"'),\n      formReplayingRuntimeScript = stringToPrecomputedChunk(\n        'addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error(\\'React form unexpectedly submitted.\\')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});'\n      ),\n      formStateMarkerIsMatching = stringToPrecomputedChunk(\"\\x3c!--F!--\\x3e\"),\n      formStateMarkerIsNotMatching = stringToPrecomputedChunk(\"\\x3c!--F--\\x3e\"),\n      styleRegex = /(<\\/|<)(s)(tyle)/gi,\n      leadingNewline = stringToPrecomputedChunk(\"\\n\"),\n      VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/,\n      validatedTagCache = new Map(),\n      doctypeChunk = stringToPrecomputedChunk(\"<!DOCTYPE html>\"),\n      endTagCache = new Map(),\n      placeholder1 = stringToPrecomputedChunk('<template id=\"'),\n      placeholder2 = stringToPrecomputedChunk('\"></template>'),\n      startCompletedSuspenseBoundary =\n        stringToPrecomputedChunk(\"\\x3c!--$--\\x3e\"),\n      startPendingSuspenseBoundary1 = stringToPrecomputedChunk(\n        '\\x3c!--$?--\\x3e<template id=\"'\n      ),\n      startPendingSuspenseBoundary2 = stringToPrecomputedChunk('\"></template>'),\n      startClientRenderedSuspenseBoundary =\n        stringToPrecomputedChunk(\"\\x3c!--$!--\\x3e\"),\n      endSuspenseBoundary = stringToPrecomputedChunk(\"\\x3c!--/$--\\x3e\"),\n      clientRenderedSuspenseBoundaryError1 =\n        stringToPrecomputedChunk(\"<template\"),\n      clientRenderedSuspenseBoundaryErrorAttrInterstitial =\n        stringToPrecomputedChunk('\"'),\n      clientRenderedSuspenseBoundaryError1A =\n        stringToPrecomputedChunk(' data-dgst=\"'),\n      clientRenderedSuspenseBoundaryError1B =\n        stringToPrecomputedChunk(' data-msg=\"'),\n      clientRenderedSuspenseBoundaryError1C =\n        stringToPrecomputedChunk(' data-stck=\"'),\n      clientRenderedSuspenseBoundaryError1D =\n        stringToPrecomputedChunk(' data-cstck=\"'),\n      clientRenderedSuspenseBoundaryError2 =\n        stringToPrecomputedChunk(\"></template>\"),\n      boundaryPreambleContributionChunkStart =\n        stringToPrecomputedChunk(\"\\x3c!--\"),\n      boundaryPreambleContributionChunkEnd = stringToPrecomputedChunk(\"--\\x3e\"),\n      startSegmentHTML = stringToPrecomputedChunk('<div hidden id=\"'),\n      startSegmentHTML2 = stringToPrecomputedChunk('\">'),\n      endSegmentHTML = stringToPrecomputedChunk(\"</div>\"),\n      startSegmentSVG = stringToPrecomputedChunk(\n        '<svg aria-hidden=\"true\" style=\"display:none\" id=\"'\n      ),\n      startSegmentSVG2 = stringToPrecomputedChunk('\">'),\n      endSegmentSVG = stringToPrecomputedChunk(\"</svg>\"),\n      startSegmentMathML = stringToPrecomputedChunk(\n        '<math aria-hidden=\"true\" style=\"display:none\" id=\"'\n      ),\n      startSegmentMathML2 = stringToPrecomputedChunk('\">'),\n      endSegmentMathML = stringToPrecomputedChunk(\"</math>\"),\n      startSegmentTable = stringToPrecomputedChunk('<table hidden id=\"'),\n      startSegmentTable2 = stringToPrecomputedChunk('\">'),\n      endSegmentTable = stringToPrecomputedChunk(\"</table>\"),\n      startSegmentTableBody = stringToPrecomputedChunk(\n        '<table hidden><tbody id=\"'\n      ),\n      startSegmentTableBody2 = stringToPrecomputedChunk('\">'),\n      endSegmentTableBody = stringToPrecomputedChunk(\"</tbody></table>\"),\n      startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id=\"'),\n      startSegmentTableRow2 = stringToPrecomputedChunk('\">'),\n      endSegmentTableRow = stringToPrecomputedChunk(\"</tr></table>\"),\n      startSegmentColGroup = stringToPrecomputedChunk(\n        '<table hidden><colgroup id=\"'\n      ),\n      startSegmentColGroup2 = stringToPrecomputedChunk('\">'),\n      endSegmentColGroup = stringToPrecomputedChunk(\"</colgroup></table>\"),\n      completeSegmentScript1Full = stringToPrecomputedChunk(\n        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(\"'\n      ),\n      completeSegmentScript1Partial = stringToPrecomputedChunk('$RS(\"'),\n      completeSegmentScript2 = stringToPrecomputedChunk('\",\"'),\n      completeSegmentScriptEnd = stringToPrecomputedChunk('\")\\x3c/script>');\n    stringToPrecomputedChunk('<template data-rsi=\"\" data-sid=\"');\n    stringToPrecomputedChunk('\" data-pid=\"');\n    var completeBoundaryScript1Full = stringToPrecomputedChunk(\n        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RC(\"'\n      ),\n      completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC(\"'),\n      completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(\n        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"'\n      ),\n      completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(\n        '$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"'\n      ),\n      completeBoundaryWithStylesScript1Partial =\n        stringToPrecomputedChunk('$RR(\"'),\n      completeBoundaryScript2 = stringToPrecomputedChunk('\",\"'),\n      completeBoundaryScript3a = stringToPrecomputedChunk('\",'),\n      completeBoundaryScript3b = stringToPrecomputedChunk('\"'),\n      completeBoundaryScriptEnd = stringToPrecomputedChunk(\")\\x3c/script>\");\n    stringToPrecomputedChunk('<template data-rci=\"\" data-bid=\"');\n    stringToPrecomputedChunk('<template data-rri=\"\" data-bid=\"');\n    stringToPrecomputedChunk('\" data-sid=\"');\n    stringToPrecomputedChunk('\" data-sty=\"');\n    var clientRenderScript1Full = stringToPrecomputedChunk(\n        '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX(\"'\n      ),\n      clientRenderScript1Partial = stringToPrecomputedChunk('$RX(\"'),\n      clientRenderScript1A = stringToPrecomputedChunk('\"'),\n      clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(\",\"),\n      clientRenderScriptEnd = stringToPrecomputedChunk(\")\\x3c/script>\");\n    stringToPrecomputedChunk('<template data-rxi=\"\" data-bid=\"');\n    stringToPrecomputedChunk('\" data-dgst=\"');\n    stringToPrecomputedChunk('\" data-msg=\"');\n    stringToPrecomputedChunk('\" data-stck=\"');\n    stringToPrecomputedChunk('\" data-cstck=\"');\n    var regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g,\n      regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g,\n      lateStyleTagResourceOpen1 = stringToPrecomputedChunk(\n        '<style media=\"not all\" data-precedence=\"'\n      ),\n      lateStyleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"'),\n      lateStyleTagResourceOpen3 = stringToPrecomputedChunk('\">'),\n      lateStyleTagTemplateClose = stringToPrecomputedChunk(\"</style>\"),\n      currentlyRenderingBoundaryHasStylesToHoist = !1,\n      destinationHasCapacity = !0,\n      stylesheetFlushingQueue = [],\n      styleTagResourceOpen1 = stringToPrecomputedChunk(\n        '<style data-precedence=\"'\n      ),\n      styleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"'),\n      spaceSeparator = stringToPrecomputedChunk(\" \"),\n      styleTagResourceOpen3 = stringToPrecomputedChunk('\">'),\n      styleTagResourceClose = stringToPrecomputedChunk(\"</style>\"),\n      arrayFirstOpenBracket = stringToPrecomputedChunk(\"[\"),\n      arraySubsequentOpenBracket = stringToPrecomputedChunk(\",[\"),\n      arrayInterstitial = stringToPrecomputedChunk(\",\"),\n      arrayCloseBracket = stringToPrecomputedChunk(\"]\"),\n      PENDING$1 = 0,\n      PRELOADED = 1,\n      PREAMBLE = 2,\n      LATE = 3,\n      regexForHrefInLinkHeaderURLContext = /[<>\\r\\n]/g,\n      regexForLinkHeaderQuotedParamValueContext = /[\"';,\\r\\n]/g,\n      bind = Function.prototype.bind,\n      requestStorage = new async_hooks.AsyncLocalStorage(),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var rendererSigil = {};\n    var currentActiveSnapshot = null,\n      didWarnAboutNoopUpdateForComponent = {},\n      didWarnAboutDeprecatedWillMount = {};\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    var classComponentUpdater = {\n        enqueueSetState: function (inst, payload, callback) {\n          var internals = inst._reactInternals;\n          null === internals.queue\n            ? warnNoop(inst, \"setState\")\n            : (internals.queue.push(payload),\n              void 0 !== callback &&\n                null !== callback &&\n                warnOnInvalidCallback(callback));\n        },\n        enqueueReplaceState: function (inst, payload, callback) {\n          inst = inst._reactInternals;\n          inst.replace = !0;\n          inst.queue = [payload];\n          void 0 !== callback &&\n            null !== callback &&\n            warnOnInvalidCallback(callback);\n        },\n        enqueueForceUpdate: function (inst, callback) {\n          null === inst._reactInternals.queue\n            ? warnNoop(inst, \"forceUpdate\")\n            : void 0 !== callback &&\n              null !== callback &&\n              warnOnInvalidCallback(callback);\n        }\n      },\n      emptyTreeContext = { id: 1, overflow: \"\" },\n      clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,\n      log = Math.log,\n      LN2 = Math.LN2,\n      SuspenseException = Error(\n        \"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.\"\n      ),\n      suspendedThenable = null,\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      currentlyRenderingComponent = null,\n      currentlyRenderingTask = null,\n      currentlyRenderingRequest = null,\n      currentlyRenderingKeyPath = null,\n      firstWorkInProgressHook = null,\n      workInProgressHook = null,\n      isReRender = !1,\n      didScheduleRenderPhaseUpdate = !1,\n      localIdCounter = 0,\n      actionStateCounter = 0,\n      actionStateMatchingIndex = -1,\n      thenableIndexCounter = 0,\n      thenableState = null,\n      renderPhaseUpdates = null,\n      numberOfReRenders = 0,\n      isInHookUserCodeInDev = !1,\n      currentHookNameInDev,\n      HooksDispatcher = {\n        readContext: readContext,\n        use: function (usable) {\n          if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then)\n              return unwrapThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE)\n              return readContext(usable);\n          }\n          throw Error(\n            \"An unsupported type was passed to use(): \" + String(usable)\n          );\n        },\n        useContext: function (context) {\n          currentHookNameInDev = \"useContext\";\n          resolveCurrentlyRenderingComponent();\n          return context._currentValue;\n        },\n        useMemo: useMemo,\n        useReducer: useReducer,\n        useRef: function (initialValue) {\n          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n          workInProgressHook = createWorkInProgressHook();\n          var previousRef = workInProgressHook.memoizedState;\n          return null === previousRef\n            ? ((initialValue = { current: initialValue }),\n              Object.seal(initialValue),\n              (workInProgressHook.memoizedState = initialValue))\n            : previousRef;\n        },\n        useState: function (initialState) {\n          currentHookNameInDev = \"useState\";\n          return useReducer(basicStateReducer, initialState);\n        },\n        useInsertionEffect: noop$1,\n        useLayoutEffect: noop$1,\n        useCallback: function (callback, deps) {\n          return useMemo(function () {\n            return callback;\n          }, deps);\n        },\n        useImperativeHandle: noop$1,\n        useEffect: noop$1,\n        useDebugValue: noop$1,\n        useDeferredValue: function (value, initialValue) {\n          resolveCurrentlyRenderingComponent();\n          return void 0 !== initialValue ? initialValue : value;\n        },\n        useTransition: function () {\n          resolveCurrentlyRenderingComponent();\n          return [!1, unsupportedStartTransition];\n        },\n        useId: function () {\n          var treeId = currentlyRenderingTask.treeContext;\n          var overflow = treeId.overflow;\n          treeId = treeId.id;\n          treeId =\n            (treeId & ~(1 << (32 - clz32(treeId) - 1))).toString(32) + overflow;\n          var resumableState = currentResumableState;\n          if (null === resumableState)\n            throw Error(\n              \"Invalid hook call. Hooks can only be called inside of the body of a function component.\"\n            );\n          overflow = localIdCounter++;\n          treeId = \"\\u00ab\" + resumableState.idPrefix + \"R\" + treeId;\n          0 < overflow && (treeId += \"H\" + overflow.toString(32));\n          return treeId + \"\\u00bb\";\n        },\n        useSyncExternalStore: function (\n          subscribe,\n          getSnapshot,\n          getServerSnapshot\n        ) {\n          if (void 0 === getServerSnapshot)\n            throw Error(\n              \"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\"\n            );\n          return getServerSnapshot();\n        },\n        useOptimistic: function (passthrough) {\n          resolveCurrentlyRenderingComponent();\n          return [passthrough, unsupportedSetOptimisticState];\n        },\n        useActionState: useActionState,\n        useFormState: useActionState,\n        useHostTransitionStatus: function () {\n          resolveCurrentlyRenderingComponent();\n          return NotPending;\n        },\n        useMemoCache: function (size) {\n          for (var data = Array(size), i = 0; i < size; i++)\n            data[i] = REACT_MEMO_CACHE_SENTINEL;\n          return data;\n        },\n        useCacheRefresh: function () {\n          return unsupportedRefresh;\n        }\n      },\n      currentResumableState = null,\n      currentTaskInDEV = null,\n      DefaultAsyncDispatcher = {\n        getCacheForType: function () {\n          throw Error(\"Not implemented.\");\n        },\n        getOwner: function () {\n          return null === currentTaskInDEV\n            ? null\n            : currentTaskInDEV.componentStack;\n        }\n      },\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var callComponent = {\n        \"react-stack-bottom-frame\": function (Component, props, secondArg) {\n          return Component(props, secondArg);\n        }\n      },\n      callComponentInDEV =\n        callComponent[\"react-stack-bottom-frame\"].bind(callComponent),\n      callRender = {\n        \"react-stack-bottom-frame\": function (instance) {\n          return instance.render();\n        }\n      },\n      callRenderInDEV = callRender[\"react-stack-bottom-frame\"].bind(callRender),\n      callLazyInit = {\n        \"react-stack-bottom-frame\": function (lazy) {\n          var init = lazy._init;\n          return init(lazy._payload);\n        }\n      },\n      callLazyInitInDEV =\n        callLazyInit[\"react-stack-bottom-frame\"].bind(callLazyInit),\n      CLIENT_RENDERED = 4,\n      PENDING = 0,\n      COMPLETED = 1,\n      FLUSHED = 2,\n      POSTPONED = 5,\n      CLOSED = 14,\n      currentRequest = null,\n      didWarnAboutBadClass = {},\n      didWarnAboutContextTypes = {},\n      didWarnAboutContextTypeOnFunctionComponent = {},\n      didWarnAboutGetDerivedStateOnFunctionComponent = {},\n      didWarnAboutReassigningProps = !1,\n      didWarnAboutGenerators = !1,\n      didWarnAboutMaps = !1;\n    ensureCorrectIsomorphicReactVersion();\n    ensureCorrectIsomorphicReactVersion();\n    exports.prerenderToNodeStream = function (children, options) {\n      return new Promise(function (resolve, reject) {\n        var resumableState = createResumableState(\n            options ? options.identifierPrefix : void 0,\n            options ? options.unstable_externalRuntimeSrc : void 0,\n            options ? options.bootstrapScriptContent : void 0,\n            options ? options.bootstrapScripts : void 0,\n            options ? options.bootstrapModules : void 0\n          ),\n          request = createPrerenderRequest(\n            children,\n            resumableState,\n            createRenderState(\n              resumableState,\n              void 0,\n              options ? options.unstable_externalRuntimeSrc : void 0,\n              options ? options.importMap : void 0,\n              options ? options.onHeaders : void 0,\n              options ? options.maxHeadersLength : void 0\n            ),\n            createRootFormatContext(options ? options.namespaceURI : void 0),\n            options ? options.progressiveChunkSize : void 0,\n            options ? options.onError : void 0,\n            function () {\n              var readable = new stream.Readable({\n                  read: function () {\n                    startFlowing(request, writable);\n                  }\n                }),\n                writable = createFakeWritable(readable);\n              resolve({ prelude: readable });\n            },\n            void 0,\n            void 0,\n            reject,\n            options ? options.onPostpone : void 0\n          );\n        if (options && options.signal) {\n          var signal = options.signal;\n          if (signal.aborted) abort(request, signal.reason);\n          else {\n            var listener = function () {\n              abort(request, signal.reason);\n              signal.removeEventListener(\"abort\", listener);\n            };\n            signal.addEventListener(\"abort\", listener);\n          }\n        }\n        startWork(request);\n      });\n    };\n    exports.renderToPipeableStream = function (children, options) {\n      var request = createRequestImpl(children, options),\n        hasStartedFlowing = !1;\n      startWork(request);\n      return {\n        pipe: function (destination) {\n          if (hasStartedFlowing)\n            throw Error(\n              \"React currently only supports piping to one writable stream.\"\n            );\n          hasStartedFlowing = !0;\n          safelyEmitEarlyPreloads(\n            request,\n            null === request.trackedPostpones\n              ? 0 === request.pendingRootTasks\n              : null === request.completedRootSegment\n                ? 0 === request.pendingRootTasks\n                : request.completedRootSegment.status !== POSTPONED\n          );\n          startFlowing(request, destination);\n          destination.on(\"drain\", createDrainHandler(destination, request));\n          destination.on(\n            \"error\",\n            createCancelHandler(\n              request,\n              \"The destination stream errored while writing data.\"\n            )\n          );\n          destination.on(\n            \"close\",\n            createCancelHandler(request, \"The destination stream closed early.\")\n          );\n          return destination;\n        },\n        abort: function (reason) {\n          abort(request, reason);\n        }\n      };\n    };\n    exports.version = \"19.1.0-canary-029e8bd6-20250306\";\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiLEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUE2QztBQUNuRSxzQkFBc0IsNENBQTRDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKLGlCQUFpQjtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtKQUFrSixpQkFBaUIsbURBQW1ELG1CQUFtQixXQUFXLCtCQUErQjtBQUNuUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsR0FBRztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQixxQkFBcUIsV0FBVyxlQUFlLG1CQUFtQjtBQUNsRSxtQkFBbUI7QUFDbkI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsd0JBQXdCO0FBQ3hCLDRCQUE0QixXQUFXLGVBQWUsbUJBQW1CO0FBQ3pFLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSEFBa0gsOEJBQThCO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsWUFBWTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNmQUFzZixXQUFXLDBMQUEwTCxTQUFTLFdBQVcsRUFBRTtBQUNqdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxZQUFZO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0NBQW9DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSx3QkFBd0IsV0FBVyxnQkFBZ0I7QUFDbkQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELHlCQUF5QixXQUFXLGlCQUFpQjtBQUNyRCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsMEJBQTBCLFdBQVcsa0JBQWtCO0FBQ3ZELG1DQUFtQyxXQUFXLDJCQUEyQjtBQUN6RSw2QkFBNkIsV0FBVyxxQkFBcUI7QUFDN0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0VBQWdFLGVBQWUsb0NBQW9DO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdFQUFnRSxlQUFlLG9DQUFvQztBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFpRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFDQUFxQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBCQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQixnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBLFFBQVE7QUFDUiw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNkJBQTZCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQjtBQUM1RCx3Q0FBd0Msb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0NBQWdDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRCQUE0QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsa0JBQU07QUFDN0IsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLG9CQUFvQixtQkFBTyxDQUFDLGdDQUFhO0FBQ3pDLGNBQWMsbUJBQU8sQ0FBQyx3RkFBMEI7QUFDaEQsaUJBQWlCLG1CQUFPLENBQUMsZ0dBQThCO0FBQ3ZELGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUNBQWlDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9DQUFvQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFDQUFxQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0JBQXdCLDRDQUE0QyxNQUFNLG1DQUFtQyxzQkFBc0Isa1ZBQWtWLEVBQUU7QUFDdGdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsZ0NBQWdDLGFBQWEsMkNBQTJDLDZCQUE2QjtBQUMxTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2QkFBNkIsNEJBQTRCLGlDQUFpQyxNQUFNLG9CQUFvQiwrQ0FBK0MsS0FBSyxlQUFlLGdCQUFnQixRQUFRLEdBQUcsc0JBQXNCLGFBQWEsMkJBQTJCLFNBQVMscUNBQXFDLGdCQUFnQixpQkFBaUIsSUFBSSxTQUFTLEtBQUssYUFBYSxnQ0FBZ0MsV0FBVyxpQ0FBaUM7QUFDdmU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZCQUE2Qiw0QkFBNEIsaUNBQWlDLE1BQU0sb0JBQW9CLCtDQUErQyxLQUFLLGVBQWUsZ0JBQWdCLFFBQVEsR0FBRyxzQkFBc0IsYUFBYSwyQkFBMkIsU0FBUyxxQ0FBcUMsZ0JBQWdCLGlCQUFpQixJQUFJLFNBQVMsS0FBSyxhQUFhLGdDQUFnQyxXQUFXLGlDQUFpQyxZQUFZLHNCQUFzQixjQUFjLGFBQWEsSUFBSSwySEFBMkgsU0FBUyxxSUFBcUksSUFBSSxLQUFLLFFBQVEsVUFBVSxFQUFFLE1BQU0sYUFBYSxPQUFPLEtBQUssSUFBSSxTQUFTLGFBQWEsYUFBYSxlQUFlLFdBQVcsS0FBSyxLQUFLLDBCQUEwQixXQUFXLG1CQUFtQixrQ0FBa0MsU0FBUywwQkFBMEIsaUNBQWlDLHFCQUFxQixzQkFBc0IsRUFBRSxXQUFXLDBCQUEwQix5Q0FBeUMsY0FBYyxLQUFLLFNBQVMsWUFBWSxvQ0FBb0MsMkJBQTJCLGNBQWMsYUFBYSxXQUFXLHVGQUF1Rix1RkFBdUY7QUFDNWdEO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCLGNBQWMsYUFBYSxJQUFJLDJIQUEySCxTQUFTLHFJQUFxSSxJQUFJLEtBQUssUUFBUSxVQUFVLEVBQUUsTUFBTSxhQUFhLE9BQU8sS0FBSyxJQUFJLFNBQVMsYUFBYSxhQUFhLGVBQWUsV0FBVyxLQUFLLEtBQUssMEJBQTBCLFdBQVcsbUJBQW1CLGtDQUFrQyxTQUFTLDBCQUEwQixpQ0FBaUMscUJBQXFCLHNCQUFzQixFQUFFLFdBQVcsMEJBQTBCLHlDQUF5QyxjQUFjLEtBQUssU0FBUyxZQUFZLG9DQUFvQywyQkFBMkIsY0FBYyxhQUFhLFdBQVcsdUZBQXVGLHVGQUF1RjtBQUM5aUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlDQUFpQywwSUFBMEk7QUFDNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMscURBQXFEO0FBQ3JELHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2QkFBNkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUksOEJBQThCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQixHQUFHIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHJlYWN0LWRvbVxcY2pzXFxyZWFjdC1kb20tc2VydmVyLm5vZGUuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHN0eWxlUmVwbGFjZXIobWF0Y2gsIHByZWZpeCwgcywgc3VmZml4KSB7XG4gICAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIChcInNcIiA9PT0gcyA/IFwiXFxcXDczIFwiIDogXCJcXFxcNTMgXCIpICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY3JpcHRSZXBsYWNlcihtYXRjaCwgcHJlZml4LCBzLCBzdWZmaXgpIHtcbiAgICAgIHJldHVybiBcIlwiICsgcHJlZml4ICsgKFwic1wiID09PSBzID8gXCJcXFxcdTAwNzNcIiA6IFwiXFxcXHUwMDUzXCIpICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBvYmplY3ROYW1lKG9iamVjdCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgLmNhbGwob2JqZWN0KVxuICAgICAgICAucmVwbGFjZSgvXlxcW29iamVjdCAoLiopXFxdJC8sIGZ1bmN0aW9uIChtLCBwMCkge1xuICAgICAgICAgIHJldHVybiBwMDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKGtleSkge1xuICAgICAgdmFyIGVuY29kZWRLZXkgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgICAgcmV0dXJuICdcIicgKyBrZXkgKyAnXCInID09PSBlbmNvZGVkS2V5ID8ga2V5IDogZW5jb2RlZEtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZSh2YWx1ZSkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIDEwID49IHZhbHVlLmxlbmd0aCA/IHZhbHVlIDogdmFsdWUuc2xpY2UoMCwgMTApICsgXCIuLi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwodmFsdWUpKSByZXR1cm4gXCJbLi4uXVwiO1xuICAgICAgICAgIGlmIChudWxsICE9PSB2YWx1ZSAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gQ0xJRU5UX1JFRkVSRU5DRV9UQUcpXG4gICAgICAgICAgICByZXR1cm4gXCJjbGllbnRcIjtcbiAgICAgICAgICB2YWx1ZSA9IG9iamVjdE5hbWUodmFsdWUpO1xuICAgICAgICAgIHJldHVybiBcIk9iamVjdFwiID09PSB2YWx1ZSA/IFwiey4uLn1cIiA6IHZhbHVlO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHXG4gICAgICAgICAgICA/IFwiY2xpZW50XCJcbiAgICAgICAgICAgIDogKHZhbHVlID0gdmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubmFtZSlcbiAgICAgICAgICAgICAgPyBcImZ1bmN0aW9uIFwiICsgdmFsdWVcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZSkge1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUocGF5bG9hZCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKG9iamVjdE9yQXJyYXksIGV4cGFuZGVkTmFtZSkge1xuICAgICAgdmFyIG9iaktpbmQgPSBvYmplY3ROYW1lKG9iamVjdE9yQXJyYXkpO1xuICAgICAgaWYgKFwiT2JqZWN0XCIgIT09IG9iaktpbmQgJiYgXCJBcnJheVwiICE9PSBvYmpLaW5kKSByZXR1cm4gb2JqS2luZDtcbiAgICAgIHZhciBzdGFydCA9IC0xLFxuICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgaWYgKGlzQXJyYXlJbXBsKG9iamVjdE9yQXJyYXkpKVxuICAgICAgICBpZiAoanN4Q2hpbGRyZW5QYXJlbnRzLmhhcyhvYmplY3RPckFycmF5KSkge1xuICAgICAgICAgIHZhciB0eXBlID0ganN4Q2hpbGRyZW5QYXJlbnRzLmdldChvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBvYmpLaW5kID0gXCI8XCIgKyBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpICsgXCI+XCI7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RPckFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3RPckFycmF5W2ldO1xuICAgICAgICAgICAgdmFsdWUgPVxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICAgICAgOiBcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiYgbnVsbCAhPT0gdmFsdWVcbiAgICAgICAgICAgICAgICAgID8gXCJ7XCIgKyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIn1cIlxuICAgICAgICAgICAgICAgICAgOiBcIntcIiArIGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCJ9XCI7XG4gICAgICAgICAgICBcIlwiICsgaSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAobGVuZ3RoID0gdmFsdWUubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAob2JqS2luZCArPSB2YWx1ZSkpXG4gICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgMTUgPiB2YWx1ZS5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIHZhbHVlLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcInsuLi59XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpLaW5kICs9IFwiPC9cIiArIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZSkgKyBcIj5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpLaW5kID0gXCJbXCI7XG4gICAgICAgICAgZm9yICh0eXBlID0gMDsgdHlwZSA8IG9iamVjdE9yQXJyYXkubGVuZ3RoOyB0eXBlKyspXG4gICAgICAgICAgICAwIDwgdHlwZSAmJiAob2JqS2luZCArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAoaSA9IG9iamVjdE9yQXJyYXlbdHlwZV0pLFxuICAgICAgICAgICAgICAoaSA9XG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGkgJiYgbnVsbCAhPT0gaVxuICAgICAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShpKVxuICAgICAgICAgICAgICAgICAgOiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKGkpKSxcbiAgICAgICAgICAgICAgXCJcIiArIHR5cGUgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChsZW5ndGggPSBpLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAob2JqS2luZCArPSBpKSlcbiAgICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgICAgMTAgPiBpLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgaS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyBpXG4gICAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCIuLi5cIik7XG4gICAgICAgICAgb2JqS2luZCArPSBcIl1cIjtcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0T3JBcnJheS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKVxuICAgICAgICBvYmpLaW5kID0gXCI8XCIgKyBkZXNjcmliZUVsZW1lbnRUeXBlKG9iamVjdE9yQXJyYXkudHlwZSkgKyBcIi8+XCI7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9iamVjdE9yQXJyYXkuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHKSByZXR1cm4gXCJjbGllbnRcIjtcbiAgICAgICAgaWYgKGpzeFByb3BzUGFyZW50cy5oYXMob2JqZWN0T3JBcnJheSkpIHtcbiAgICAgICAgICBvYmpLaW5kID0ganN4UHJvcHNQYXJlbnRzLmdldChvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBvYmpLaW5kID0gXCI8XCIgKyAoZGVzY3JpYmVFbGVtZW50VHlwZShvYmpLaW5kKSB8fCBcIi4uLlwiKTtcbiAgICAgICAgICB0eXBlID0gT2JqZWN0LmtleXMob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9iaktpbmQgKz0gXCIgXCI7XG4gICAgICAgICAgICB2YWx1ZSA9IHR5cGVbaV07XG4gICAgICAgICAgICBvYmpLaW5kICs9IGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwiPVwiO1xuICAgICAgICAgICAgdmFyIF92YWx1ZTIgPSBvYmplY3RPckFycmF5W3ZhbHVlXTtcbiAgICAgICAgICAgIHZhciBfc3Vic3RyMiA9XG4gICAgICAgICAgICAgIHZhbHVlID09PSBleHBhbmRlZE5hbWUgJiZcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIF92YWx1ZTIgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gX3ZhbHVlMlxuICAgICAgICAgICAgICAgID8gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMilcbiAgICAgICAgICAgICAgICA6IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMik7XG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgX3ZhbHVlMiAmJiAoX3N1YnN0cjIgPSBcIntcIiArIF9zdWJzdHIyICsgXCJ9XCIpO1xuICAgICAgICAgICAgdmFsdWUgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKGxlbmd0aCA9IF9zdWJzdHIyLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gX3N1YnN0cjIpKVxuICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgIDEwID4gX3N1YnN0cjIubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyBfc3Vic3RyMi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgX3N1YnN0cjJcbiAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCIuLi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iaktpbmQgKz0gXCI+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqS2luZCA9IFwie1wiO1xuICAgICAgICAgIHR5cGUgPSBPYmplY3Qua2V5cyhvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIDAgPCBpICYmIChvYmpLaW5kICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICh2YWx1ZSA9IHR5cGVbaV0pLFxuICAgICAgICAgICAgICAob2JqS2luZCArPSBkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIjogXCIpLFxuICAgICAgICAgICAgICAoX3ZhbHVlMiA9IG9iamVjdE9yQXJyYXlbdmFsdWVdKSxcbiAgICAgICAgICAgICAgKF92YWx1ZTIgPVxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBfdmFsdWUyICYmIG51bGwgIT09IF92YWx1ZTJcbiAgICAgICAgICAgICAgICAgID8gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMilcbiAgICAgICAgICAgICAgICAgIDogZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZShfdmFsdWUyKSksXG4gICAgICAgICAgICAgIHZhbHVlID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAobGVuZ3RoID0gX3ZhbHVlMi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gX3ZhbHVlMikpXG4gICAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAgIDEwID4gX3ZhbHVlMi5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIF92YWx1ZTIubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgX3ZhbHVlMlxuICAgICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiLi4uXCIpO1xuICAgICAgICAgIG9iaktpbmQgKz0gXCJ9XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICA/IG9iaktpbmRcbiAgICAgICAgOiAtMSA8IHN0YXJ0ICYmIDAgPCBsZW5ndGhcbiAgICAgICAgICA/ICgob2JqZWN0T3JBcnJheSA9IFwiIFwiLnJlcGVhdChzdGFydCkgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSksXG4gICAgICAgICAgICBcIlxcbiAgXCIgKyBvYmpLaW5kICsgXCJcXG4gIFwiICsgb2JqZWN0T3JBcnJheSlcbiAgICAgICAgICA6IFwiXFxuICBcIiArIG9iaktpbmQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoQnVmZmVyZWQoZGVzdGluYXRpb24pIHtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGRlc3RpbmF0aW9uLmZsdXNoICYmIGRlc3RpbmF0aW9uLmZsdXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rKSB7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNodW5rKSB7XG4gICAgICAgIGlmICgwICE9PSBjaHVuay5sZW5ndGgpXG4gICAgICAgICAgaWYgKDIwNDggPCAzICogY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgMCA8IHdyaXR0ZW5CeXRlcyAmJlxuICAgICAgICAgICAgICAod3JpdGVUb0Rlc3RpbmF0aW9uKFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRWaWV3LnN1YmFycmF5KDAsIHdyaXR0ZW5CeXRlcylcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMjA0OCkpLFxuICAgICAgICAgICAgICAod3JpdHRlbkJ5dGVzID0gMCkpLFxuICAgICAgICAgICAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGNodW5rKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBjdXJyZW50VmlldztcbiAgICAgICAgICAgIDAgPCB3cml0dGVuQnl0ZXMgJiYgKHRhcmdldCA9IGN1cnJlbnRWaWV3LnN1YmFycmF5KHdyaXR0ZW5CeXRlcykpO1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGV4dEVuY29kZXIuZW5jb2RlSW50byhjaHVuaywgdGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciByZWFkID0gdGFyZ2V0LnJlYWQ7XG4gICAgICAgICAgICB3cml0dGVuQnl0ZXMgKz0gdGFyZ2V0LndyaXR0ZW47XG4gICAgICAgICAgICByZWFkIDwgY2h1bmsubGVuZ3RoICYmXG4gICAgICAgICAgICAgICh3cml0ZVRvRGVzdGluYXRpb24oXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgY3VycmVudFZpZXcuc3ViYXJyYXkoMCwgd3JpdHRlbkJ5dGVzKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheSgyMDQ4KSksXG4gICAgICAgICAgICAgICh3cml0dGVuQnl0ZXMgPSB0ZXh0RW5jb2Rlci5lbmNvZGVJbnRvKFxuICAgICAgICAgICAgICAgIGNodW5rLnNsaWNlKHJlYWQpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRWaWV3XG4gICAgICAgICAgICAgICkud3JpdHRlbikpO1xuICAgICAgICAgICAgMjA0OCA9PT0gd3JpdHRlbkJ5dGVzICYmXG4gICAgICAgICAgICAgICh3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGN1cnJlbnRWaWV3KSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMjA0OCkpLFxuICAgICAgICAgICAgICAod3JpdHRlbkJ5dGVzID0gMCkpO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICAwICE9PSBjaHVuay5ieXRlTGVuZ3RoICYmXG4gICAgICAgICAgKDIwNDggPCBjaHVuay5ieXRlTGVuZ3RoXG4gICAgICAgICAgICA/ICgwIDwgd3JpdHRlbkJ5dGVzICYmXG4gICAgICAgICAgICAgICAgKHdyaXRlVG9EZXN0aW5hdGlvbihcbiAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFZpZXcuc3ViYXJyYXkoMCwgd3JpdHRlbkJ5dGVzKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMjA0OCkpLFxuICAgICAgICAgICAgICAgICh3cml0dGVuQnl0ZXMgPSAwKSksXG4gICAgICAgICAgICAgIHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgY2h1bmspKVxuICAgICAgICAgICAgOiAoKHRhcmdldCA9IGN1cnJlbnRWaWV3Lmxlbmd0aCAtIHdyaXR0ZW5CeXRlcyksXG4gICAgICAgICAgICAgIHRhcmdldCA8IGNodW5rLmJ5dGVMZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoMCA9PT0gdGFyZ2V0XG4gICAgICAgICAgICAgICAgICA/IHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgY3VycmVudFZpZXcpXG4gICAgICAgICAgICAgICAgICA6IChjdXJyZW50Vmlldy5zZXQoY2h1bmsuc3ViYXJyYXkoMCwgdGFyZ2V0KSwgd3JpdHRlbkJ5dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgKHdyaXR0ZW5CeXRlcyArPSB0YXJnZXQpLFxuICAgICAgICAgICAgICAgICAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGN1cnJlbnRWaWV3KSxcbiAgICAgICAgICAgICAgICAgICAgKGNodW5rID0gY2h1bmsuc3ViYXJyYXkodGFyZ2V0KSkpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KDIwNDgpKSxcbiAgICAgICAgICAgICAgICAod3JpdHRlbkJ5dGVzID0gMCkpLFxuICAgICAgICAgICAgICBjdXJyZW50Vmlldy5zZXQoY2h1bmssIHdyaXR0ZW5CeXRlcyksXG4gICAgICAgICAgICAgICh3cml0dGVuQnl0ZXMgKz0gY2h1bmsuYnl0ZUxlbmd0aCksXG4gICAgICAgICAgICAgIDIwNDggPT09IHdyaXR0ZW5CeXRlcyAmJlxuICAgICAgICAgICAgICAgICh3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGN1cnJlbnRWaWV3KSxcbiAgICAgICAgICAgICAgICAoY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheSgyMDQ4KSksXG4gICAgICAgICAgICAgICAgKHdyaXR0ZW5CeXRlcyA9IDApKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIHZpZXcpIHtcbiAgICAgIGRlc3RpbmF0aW9uID0gZGVzdGluYXRpb24ud3JpdGUodmlldyk7XG4gICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5JDEgPSBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5JDEgJiYgZGVzdGluYXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNodW5rKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVuayk7XG4gICAgICByZXR1cm4gZGVzdGluYXRpb25IYXNDYXBhY2l0eSQxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pIHtcbiAgICAgIGN1cnJlbnRWaWV3ICYmXG4gICAgICAgIDAgPCB3cml0dGVuQnl0ZXMgJiZcbiAgICAgICAgZGVzdGluYXRpb24ud3JpdGUoY3VycmVudFZpZXcuc3ViYXJyYXkoMCwgd3JpdHRlbkJ5dGVzKSk7XG4gICAgICBjdXJyZW50VmlldyA9IG51bGw7XG4gICAgICB3cml0dGVuQnl0ZXMgPSAwO1xuICAgICAgZGVzdGluYXRpb25IYXNDYXBhY2l0eSQxID0gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb250ZW50KSB7XG4gICAgICBjb250ZW50ID0gdGV4dEVuY29kZXIuZW5jb2RlKGNvbnRlbnQpO1xuICAgICAgMjA0OCA8IGNvbnRlbnQuYnl0ZUxlbmd0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwicHJlY29tcHV0ZWQgY2h1bmtzIG11c3QgYmUgc21hbGxlciB0aGFuIHRoZSB2aWV3IHNpemUgY29uZmlndXJlZCBmb3IgdGhpcyBob3N0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgIFwiT2JqZWN0XCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSwgITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBwcm92aWRlZCBgJXNgIGF0dHJpYnV0ZSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUsXG4gICAgICAgICAgICB0eXBlTmFtZSh2YWx1ZSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICAgICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcHJvdmlkZWQgYCVzYCBDU1MgcHJvcGVydHkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgIHR5cGVOYW1lKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcHJvdmlkZWQgSFRNTCBtYXJrdXAgdXNlcyBhIHZhbHVlIG9mIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgICAgdHlwZU5hbWUodmFsdWUpXG4gICAgICAgICAgKSxcbiAgICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKVxuICAgICAgICByZXR1cm4gKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9ICEwKTtcbiAgICAgIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSAhMDtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgXCIsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKHRhZ05hbWUsIHByb3BzKSB7XG4gICAgICBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8XG4gICAgICAgIHByb3BzLm9uQ2hhbmdlIHx8XG4gICAgICAgIHByb3BzLm9uSW5wdXQgfHxcbiAgICAgICAgcHJvcHMucmVhZE9ubHkgfHxcbiAgICAgICAgcHJvcHMuZGlzYWJsZWQgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICAoXCJzZWxlY3RcIiA9PT0gdGFnTmFtZVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiB0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsIHNldCBgb25DaGFuZ2VgLlwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIllvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiBgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmIHRoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuXCJcbiAgICAgICAgICAgICkpO1xuICAgICAgcHJvcHMub25DaGFuZ2UgfHxcbiAgICAgICAgcHJvcHMucmVhZE9ubHkgfHxcbiAgICAgICAgcHJvcHMuZGlzYWJsZWQgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcy5jaGVja2VkIHx8XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiBgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmIHRoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCBzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5JDEodGFnTmFtZSwgbmFtZSkge1xuICAgICAgaWYgKFxuICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMkMSwgbmFtZSkgJiZcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdXG4gICAgICApXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChyQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgICB0YWdOYW1lID0gXCJhcmlhLVwiICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0YWdOYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkgPyB0YWdOYW1lIDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgPT0gdGFnTmFtZSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgICBpZiAobmFtZSAhPT0gdGFnTmFtZSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgP1wiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICB0YWdOYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRhZ05hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRhZ05hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSA/IHRhZ05hbWUgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCA9PSB0YWdOYW1lKSByZXR1cm4gKHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9ICEwKSwgITE7XG4gICAgICAgIG5hbWUgIT09IHRhZ05hbWUgJiZcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD9cIixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0YWdOYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gITApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpIHtcbiAgICAgIHZhciBpbnZhbGlkUHJvcHMgPSBbXSxcbiAgICAgICAga2V5O1xuICAgICAgZm9yIChrZXkgaW4gcHJvcHMpXG4gICAgICAgIHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXkpIHx8IGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgICBwcm9wcyA9IGludmFsaWRQcm9wc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYFwiICsgcHJvcCArIFwiYFwiO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbihcIiwgXCIpO1xuICAgICAgMSA9PT0gaW52YWxpZFByb3BzLmxlbmd0aFxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1hcmlhLXByb3BzXCIsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICApXG4gICAgICAgIDogMSA8IGludmFsaWRQcm9wcy5sZW5ndGggJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWFyaWEtcHJvcHNcIixcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChcIm9uZm9jdXNpblwiID09PSBsb3dlckNhc2VkTmFtZSB8fCBcIm9uZm9jdXNvdXRcIiA9PT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuIEFsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAoKFwiZm9ybVwiID09PSB0YWdOYW1lICYmIFwiYWN0aW9uXCIgPT09IG5hbWUpIHx8XG4gICAgICAgICAgKFwiaW5wdXRcIiA9PT0gdGFnTmFtZSAmJiBcImZvcm1BY3Rpb25cIiA9PT0gbmFtZSkgfHxcbiAgICAgICAgICAoXCJidXR0b25cIiA9PT0gdGFnTmFtZSAmJiBcImZvcm1BY3Rpb25cIiA9PT0gbmFtZSkpXG4gICAgICApXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChudWxsICE9IGV2ZW50UmVnaXN0cnkpIHtcbiAgICAgICAgdGFnTmFtZSA9IGV2ZW50UmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcbiAgICAgICAgaWYgKGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGV2ZW50UmVnaXN0cnkgPSB0YWdOYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICAgID8gdGFnTmFtZVtsb3dlckNhc2VkTmFtZV1cbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9IGV2ZW50UmVnaXN0cnkpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgP1wiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBldmVudFJlZ2lzdHJ5XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlVua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwudGVzdChuYW1lKSkgcmV0dXJuICEwO1xuICAgICAgaWYgKFwiaW5uZXJodG1sXCIgPT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkRpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAoXCJhcmlhXCIgPT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiBQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuXCJcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIFwiaXNcIiA9PT0gbG93ZXJDYXNlZE5hbWUgJiZcbiAgICAgICAgbnVsbCAhPT0gdmFsdWUgJiZcbiAgICAgICAgdm9pZCAwICE9PSB2YWx1ZSAmJlxuICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgdmFsdWVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0IHRoZSB2YWx1ZSB0byBhIHN0cmluZy5cIixcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcIm51bWJlclwiID09PSB0eXBlb2YgdmFsdWUgJiYgaXNOYU4odmFsdWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0IHRoZSB2YWx1ZSB0byBhIHN0cmluZy5cIixcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKChsb3dlckNhc2VkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV0pLFxuICAgICAgICAgIGxvd2VyQ2FzZWROYW1lICE9PSBuYW1lKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/XCIsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGxvd2VyQ2FzZWROYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChuYW1lICE9PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tIGF0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSBpdCBmcm9tIHRoZSBET00gZWxlbWVudC5cIixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBsb3dlckNhc2VkTmFtZVxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdENoZWNrZWRcIjpcbiAgICAgICAgY2FzZSBcImlubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwicmVmXCI6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBjYXNlIFwiaW5uZXJUZXh0XCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0Q29udGVudFwiOlxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiYXV0b0ZvY3VzXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgICAgICBjYXNlIFwibXV0ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImNvbnRlbnRFZGl0YWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcInNwZWxsQ2hlY2tcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkcmFnZ2FibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgY2FzZSBcImF1dG9SZXZlcnNlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImZvY3VzYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcInByZXNlcnZlQWxwaGFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJhbGxvd0Z1bGxTY3JlZW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJhc3luY1wiOlxuICAgICAgICAgICAgY2FzZSBcImF1dG9QbGF5XCI6XG4gICAgICAgICAgICBjYXNlIFwiY29udHJvbHNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZGVmZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCI6XG4gICAgICAgICAgICBjYXNlIFwiZm9ybU5vVmFsaWRhdGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJsb29wXCI6XG4gICAgICAgICAgICBjYXNlIFwibm9Nb2R1bGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJub1ZhbGlkYXRlXCI6XG4gICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgY2FzZSBcInBsYXlzSW5saW5lXCI6XG4gICAgICAgICAgICBjYXNlIFwicmVhZE9ubHlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInJldmVyc2VkXCI6XG4gICAgICAgICAgICBjYXNlIFwic2NvcGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwic2VhbWxlc3NcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpdGVtU2NvcGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjYXB0dXJlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZG93bmxvYWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpbmVydFwiOlxuICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICAgICAgaWYgKFwiZGF0YS1cIiA9PT0gbG93ZXJDYXNlZE5hbWUgfHwgXCJhcmlhLVwiID09PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG5JZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG5JZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sIHBhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICByZXR1cm4gKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMCksICExO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgaWYgKFwiZmFsc2VcIiA9PT0gdmFsdWUgfHwgXCJ0cnVlXCIgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwibXV0ZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImFsbG93RnVsbFNjcmVlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYXN5bmNcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImF1dG9QbGF5XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJjb250cm9sc1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGVmZXJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRpc2FibGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmb3JtTm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJsb29wXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJub01vZHVsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwibm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwicGxheXNJbmxpbmVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInJlYWRPbmx5XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmV2ZXJzZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNjb3BlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2VhbWxlc3NcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIml0ZW1TY29wZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiaW5lcnRcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICVzIERpZCB5b3UgbWVhbiAlcz17JXN9P1wiLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgXCJmYWxzZVwiID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gXCJUaGUgYnJvd3NlciB3aWxsIGludGVycHJldCBpdCBhcyBhIHRydXRoeSB2YWx1ZS5cIlxuICAgICAgICAgICAgICAgIDogJ0FsdGhvdWdoIHRoaXMgd29ya3MsIGl0IHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaWYgeW91IHBhc3MgdGhlIHN0cmluZyBcImZhbHNlXCIuJyxcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITA7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICAgIHZhciB1bmtub3duUHJvcHMgPSBbXSxcbiAgICAgICAga2V5O1xuICAgICAgZm9yIChrZXkgaW4gcHJvcHMpXG4gICAgICAgIHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5LCBwcm9wc1trZXldLCBldmVudFJlZ2lzdHJ5KSB8fFxuICAgICAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgICBwcm9wcyA9IHVua25vd25Qcm9wc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYFwiICsgcHJvcCArIFwiYFwiO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbihcIiwgXCIpO1xuICAgICAgMSA9PT0gdW5rbm93blByb3BzLmxlbmd0aFxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yIFwiLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgKVxuICAgICAgICA6IDEgPCB1bmtub3duUHJvcHMubGVuZ3RoICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgXCIsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgdGV4dCB8fFxuICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgdGV4dCB8fFxuICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgdGV4dFxuICAgICAgKVxuICAgICAgICByZXR1cm4gXCJcIiArIHRleHQ7XG4gICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbih0ZXh0KTtcbiAgICAgIHRleHQgPSBcIlwiICsgdGV4dDtcbiAgICAgIHZhciBtYXRjaCA9IG1hdGNoSHRtbFJlZ0V4cC5leGVjKHRleHQpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBodG1sID0gXCJcIixcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBsYXN0SW5kZXggPSAwO1xuICAgICAgICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgdGV4dC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBzd2l0Y2ggKHRleHQuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgIG1hdGNoID0gXCImcXVvdDtcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICBtYXRjaCA9IFwiJmFtcDtcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICBtYXRjaCA9IFwiJiN4Mjc7XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBcIiZsdDtcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYyOlxuICAgICAgICAgICAgICBtYXRjaCA9IFwiJmd0O1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0SW5kZXggIT09IGluZGV4ICYmIChodG1sICs9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICBodG1sICs9IG1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhbml0aXplVVJMKHVybCkge1xuICAgICAgcmV0dXJuIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3QoXCJcIiArIHVybClcbiAgICAgICAgPyBcImphdmFzY3JpcHQ6dGhyb3cgbmV3IEVycm9yKCdSZWFjdCBoYXMgYmxvY2tlZCBhIGphdmFzY3JpcHQ6IFVSTCBhcyBhIHNlY3VyaXR5IHByZWNhdXRpb24uJylcIlxuICAgICAgICA6IHVybDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlRW50aXJlSW5saW5lU2NyaXB0Q29udGVudChzY3JpcHRUZXh0KSB7XG4gICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihzY3JpcHRUZXh0KTtcbiAgICAgIHJldHVybiAoXCJcIiArIHNjcmlwdFRleHQpLnJlcGxhY2Uoc2NyaXB0UmVnZXgsIHNjcmlwdFJlcGxhY2VyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyU3RhdGUoXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIG5vbmNlLFxuICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLFxuICAgICAgaW1wb3J0TWFwLFxuICAgICAgb25IZWFkZXJzLFxuICAgICAgbWF4SGVhZGVyc0xlbmd0aFxuICAgICkge1xuICAgICAgdmFyIGlubGluZVNjcmlwdFdpdGhOb25jZSA9XG4gICAgICAgICAgdm9pZCAwID09PSBub25jZVxuICAgICAgICAgICAgPyBzdGFydElubGluZVNjcmlwdFxuICAgICAgICAgICAgOiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICAgICAgICAgJzxzY3JpcHQgbm9uY2U9XCInICsgZXNjYXBlVGV4dEZvckJyb3dzZXIobm9uY2UpICsgJ1wiPidcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgaWRQcmVmaXggPSByZXN1bWFibGVTdGF0ZS5pZFByZWZpeDtcbiAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZyA9IFtdO1xuICAgICAgdmFyIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgPSByZXN1bWFibGVTdGF0ZS5ib290c3RyYXBTY3JpcHRDb250ZW50LFxuICAgICAgICBib290c3RyYXBTY3JpcHRzID0gcmVzdW1hYmxlU3RhdGUuYm9vdHN0cmFwU2NyaXB0cyxcbiAgICAgICAgYm9vdHN0cmFwTW9kdWxlcyA9IHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcE1vZHVsZXM7XG4gICAgICB2b2lkIDAgIT09IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgJiZcbiAgICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLnB1c2goXG4gICAgICAgICAgaW5saW5lU2NyaXB0V2l0aE5vbmNlLFxuICAgICAgICAgIGVzY2FwZUVudGlyZUlubGluZVNjcmlwdENvbnRlbnQoYm9vdHN0cmFwU2NyaXB0Q29udGVudCksXG4gICAgICAgICAgZW5kSW5saW5lU2NyaXB0XG4gICAgICAgICk7XG4gICAgICBib290c3RyYXBTY3JpcHRDb250ZW50ID0gW107XG4gICAgICB2b2lkIDAgIT09IGltcG9ydE1hcCAmJlxuICAgICAgICAoYm9vdHN0cmFwU2NyaXB0Q29udGVudC5wdXNoKGltcG9ydE1hcFNjcmlwdFN0YXJ0KSxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudC5wdXNoKFxuICAgICAgICAgIGVzY2FwZUVudGlyZUlubGluZVNjcmlwdENvbnRlbnQoSlNPTi5zdHJpbmdpZnkoaW1wb3J0TWFwKSlcbiAgICAgICAgKSxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudC5wdXNoKGltcG9ydE1hcFNjcmlwdEVuZCkpO1xuICAgICAgb25IZWFkZXJzICYmXG4gICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBtYXhIZWFkZXJzTGVuZ3RoICYmXG4gICAgICAgIDAgPj0gbWF4SGVhZGVyc0xlbmd0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3QgZXhwZWN0ZWQgYSBwb3NpdGl2ZSBub24temVybyBgbWF4SGVhZGVyc0xlbmd0aGAgb3B0aW9uIGJ1dCBmb3VuZCAlcyBpbnN0ZWFkLiBXaGVuIHVzaW5nIHRoZSBgb25IZWFkZXJzYCBvcHRpb24geW91IG1heSBzdXBwbHkgYW4gb3B0aW9uYWwgYG1heEhlYWRlcnNMZW5ndGhgIG9wdGlvbiBhcyB3ZWxsIGhvd2V2ZXIsIHdoZW4gc2V0dGluZyB0aGlzIHZhbHVlIHRvIHplcm8gb3IgbGVzcyBubyBoZWFkZXJzIHdpbGwgYmUgY2FwdHVyZWQuXCIsXG4gICAgICAgICAgMCA9PT0gbWF4SGVhZGVyc0xlbmd0aCA/IFwiemVyb1wiIDogbWF4SGVhZGVyc0xlbmd0aFxuICAgICAgICApO1xuICAgICAgaW1wb3J0TWFwID0gb25IZWFkZXJzXG4gICAgICAgID8ge1xuICAgICAgICAgICAgcHJlY29ubmVjdHM6IFwiXCIsXG4gICAgICAgICAgICBmb250UHJlbG9hZHM6IFwiXCIsXG4gICAgICAgICAgICBoaWdoSW1hZ2VQcmVsb2FkczogXCJcIixcbiAgICAgICAgICAgIHJlbWFpbmluZ0NhcGFjaXR5OlxuICAgICAgICAgICAgICAyICtcbiAgICAgICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiBtYXhIZWFkZXJzTGVuZ3RoID8gbWF4SGVhZGVyc0xlbmd0aCA6IDJlMylcbiAgICAgICAgICB9XG4gICAgICAgIDogbnVsbDtcbiAgICAgIG9uSGVhZGVycyA9IHtcbiAgICAgICAgcGxhY2Vob2xkZXJQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArIFwiUDpcIiksXG4gICAgICAgIHNlZ21lbnRQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArIFwiUzpcIiksXG4gICAgICAgIGJvdW5kYXJ5UHJlZml4OiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoaWRQcmVmaXggKyBcIkI6XCIpLFxuICAgICAgICBzdGFydElubGluZVNjcmlwdDogaW5saW5lU2NyaXB0V2l0aE5vbmNlLFxuICAgICAgICBwcmVhbWJsZTogY3JlYXRlUHJlYW1ibGVTdGF0ZSgpLFxuICAgICAgICBleHRlcm5hbFJ1bnRpbWVTY3JpcHQ6IG51bGwsXG4gICAgICAgIGJvb3RzdHJhcENodW5rczogZXh0ZXJuYWxSdW50aW1lQ29uZmlnLFxuICAgICAgICBpbXBvcnRNYXBDaHVua3M6IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgICAgIG9uSGVhZGVyczogb25IZWFkZXJzLFxuICAgICAgICBoZWFkZXJzOiBpbXBvcnRNYXAsXG4gICAgICAgIHJlc2V0czoge1xuICAgICAgICAgIGZvbnQ6IHt9LFxuICAgICAgICAgIGRuczoge30sXG4gICAgICAgICAgY29ubmVjdDogeyBkZWZhdWx0OiB7fSwgYW5vbnltb3VzOiB7fSwgY3JlZGVudGlhbHM6IHt9IH0sXG4gICAgICAgICAgaW1hZ2U6IHt9LFxuICAgICAgICAgIHN0eWxlOiB7fVxuICAgICAgICB9LFxuICAgICAgICBjaGFyc2V0Q2h1bmtzOiBbXSxcbiAgICAgICAgdmlld3BvcnRDaHVua3M6IFtdLFxuICAgICAgICBob2lzdGFibGVDaHVua3M6IFtdLFxuICAgICAgICBwcmVjb25uZWN0czogbmV3IFNldCgpLFxuICAgICAgICBmb250UHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgaGlnaEltYWdlUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgc3R5bGVzOiBuZXcgTWFwKCksXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHM6IG5ldyBTZXQoKSxcbiAgICAgICAgc2NyaXB0czogbmV3IFNldCgpLFxuICAgICAgICBidWxrUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgcHJlbG9hZHM6IHtcbiAgICAgICAgICBpbWFnZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgICBzdHlsZXNoZWV0czogbmV3IE1hcCgpLFxuICAgICAgICAgIHNjcmlwdHM6IG5ldyBNYXAoKSxcbiAgICAgICAgICBtb2R1bGVTY3JpcHRzOiBuZXcgTWFwKClcbiAgICAgICAgfSxcbiAgICAgICAgbm9uY2U6IG5vbmNlLFxuICAgICAgICBob2lzdGFibGVTdGF0ZTogbnVsbCxcbiAgICAgICAgc3R5bGVzVG9Ib2lzdDogITFcbiAgICAgIH07XG4gICAgICBpZiAodm9pZCAwICE9PSBib290c3RyYXBTY3JpcHRzKVxuICAgICAgICBmb3IgKGltcG9ydE1hcCA9IDA7IGltcG9ydE1hcCA8IGJvb3RzdHJhcFNjcmlwdHMubGVuZ3RoOyBpbXBvcnRNYXArKykge1xuICAgICAgICAgIG1heEhlYWRlcnNMZW5ndGggPSBib290c3RyYXBTY3JpcHRzW2ltcG9ydE1hcF07XG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudCA9IGlkUHJlZml4ID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgICAgICBhczogXCJzY3JpcHRcIixcbiAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IFwibG93XCIsXG4gICAgICAgICAgICBub25jZTogbm9uY2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBtYXhIZWFkZXJzTGVuZ3RoXG4gICAgICAgICAgICA/IChwcm9wcy5ocmVmID0gaW5saW5lU2NyaXB0V2l0aE5vbmNlID0gbWF4SGVhZGVyc0xlbmd0aClcbiAgICAgICAgICAgIDogKChwcm9wcy5ocmVmID0gaW5saW5lU2NyaXB0V2l0aE5vbmNlID0gbWF4SGVhZGVyc0xlbmd0aC5zcmMpLFxuICAgICAgICAgICAgICAocHJvcHMuaW50ZWdyaXR5ID0gYm9vdHN0cmFwU2NyaXB0Q29udGVudCA9XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG1heEhlYWRlcnNMZW5ndGguaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICA/IG1heEhlYWRlcnNMZW5ndGguaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMCksXG4gICAgICAgICAgICAgIChwcm9wcy5jcm9zc09yaWdpbiA9IGlkUHJlZml4ID1cbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgbWF4SGVhZGVyc0xlbmd0aCB8fFxuICAgICAgICAgICAgICAgIG51bGwgPT0gbWF4SGVhZGVyc0xlbmd0aC5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICAgICAgICAgIDogXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gbWF4SGVhZGVyc0xlbmd0aC5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgICA/IFwidXNlLWNyZWRlbnRpYWxzXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiKSk7XG4gICAgICAgICAgcHJlbG9hZEJvb3RzdHJhcFNjcmlwdE9yTW9kdWxlKFxuICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICBvbkhlYWRlcnMsXG4gICAgICAgICAgICBpbmxpbmVTY3JpcHRXaXRoTm9uY2UsXG4gICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLnB1c2goXG4gICAgICAgICAgICBzdGFydFNjcmlwdFNyYyxcbiAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKGlubGluZVNjcmlwdFdpdGhOb25jZSlcbiAgICAgICAgICApO1xuICAgICAgICAgIG5vbmNlICYmXG4gICAgICAgICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcucHVzaChcbiAgICAgICAgICAgICAgc2NyaXB0Tm9uY2UsXG4gICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKG5vbmNlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgYm9vdHN0cmFwU2NyaXB0Q29udGVudCAmJlxuICAgICAgICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLnB1c2goXG4gICAgICAgICAgICAgIHNjcmlwdEludGVnaXJ0eSxcbiAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoYm9vdHN0cmFwU2NyaXB0Q29udGVudClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlkUHJlZml4ICYmXG4gICAgICAgICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcucHVzaChcbiAgICAgICAgICAgICAgc2NyaXB0Q3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKGlkUHJlZml4KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcucHVzaChlbmRBc3luY1NjcmlwdCk7XG4gICAgICAgIH1cbiAgICAgIGlmICh2b2lkIDAgIT09IGJvb3RzdHJhcE1vZHVsZXMpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0cyA9IDA7XG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0cyA8IGJvb3RzdHJhcE1vZHVsZXMubGVuZ3RoO1xuICAgICAgICAgIGJvb3RzdHJhcFNjcmlwdHMrK1xuICAgICAgICApXG4gICAgICAgICAgKGltcG9ydE1hcCA9IGJvb3RzdHJhcE1vZHVsZXNbYm9vdHN0cmFwU2NyaXB0c10pLFxuICAgICAgICAgICAgKGlkUHJlZml4ID0gaW5saW5lU2NyaXB0V2l0aE5vbmNlID0gdm9pZCAwKSxcbiAgICAgICAgICAgIChib290c3RyYXBTY3JpcHRDb250ZW50ID0ge1xuICAgICAgICAgICAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBcImxvd1wiLFxuICAgICAgICAgICAgICBub25jZTogbm9uY2VcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGltcG9ydE1hcFxuICAgICAgICAgICAgICA/IChib290c3RyYXBTY3JpcHRDb250ZW50LmhyZWYgPSBtYXhIZWFkZXJzTGVuZ3RoID0gaW1wb3J0TWFwKVxuICAgICAgICAgICAgICA6ICgoYm9vdHN0cmFwU2NyaXB0Q29udGVudC5ocmVmID0gbWF4SGVhZGVyc0xlbmd0aCA9XG4gICAgICAgICAgICAgICAgICBpbXBvcnRNYXAuc3JjKSxcbiAgICAgICAgICAgICAgICAoYm9vdHN0cmFwU2NyaXB0Q29udGVudC5pbnRlZ3JpdHkgPSBpZFByZWZpeCA9XG4gICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaW1wb3J0TWFwLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgICA/IGltcG9ydE1hcC5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDApLFxuICAgICAgICAgICAgICAgIChib290c3RyYXBTY3JpcHRDb250ZW50LmNyb3NzT3JpZ2luID0gaW5saW5lU2NyaXB0V2l0aE5vbmNlID1cbiAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbXBvcnRNYXAgfHwgbnVsbCA9PSBpbXBvcnRNYXAuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgOiBcInVzZS1jcmVkZW50aWFsc1wiID09PSBpbXBvcnRNYXAuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgICA/IFwidXNlLWNyZWRlbnRpYWxzXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiXCIpKSxcbiAgICAgICAgICAgIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIG9uSGVhZGVycyxcbiAgICAgICAgICAgICAgbWF4SGVhZGVyc0xlbmd0aCxcbiAgICAgICAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZy5wdXNoKFxuICAgICAgICAgICAgICBzdGFydE1vZHVsZVNyYyxcbiAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIobWF4SGVhZGVyc0xlbmd0aClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBub25jZSAmJlxuICAgICAgICAgICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcucHVzaChcbiAgICAgICAgICAgICAgICBzY3JpcHROb25jZSxcbiAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihub25jZSlcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpZFByZWZpeCAmJlxuICAgICAgICAgICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcucHVzaChcbiAgICAgICAgICAgICAgICBzY3JpcHRJbnRlZ2lydHksXG4gICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoaWRQcmVmaXgpXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaW5saW5lU2NyaXB0V2l0aE5vbmNlICYmXG4gICAgICAgICAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZy5wdXNoKFxuICAgICAgICAgICAgICAgIHNjcmlwdENyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKGlubGluZVNjcmlwdFdpdGhOb25jZSlcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZy5wdXNoKGVuZEFzeW5jU2NyaXB0KTtcbiAgICAgIHJldHVybiBvbkhlYWRlcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlc3VtYWJsZVN0YXRlKFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZyxcbiAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgICBib290c3RyYXBTY3JpcHRzLFxuICAgICAgYm9vdHN0cmFwTW9kdWxlc1xuICAgICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWRQcmVmaXg6IHZvaWQgMCA9PT0gaWRlbnRpZmllclByZWZpeCA/IFwiXCIgOiBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgICBuZXh0Rm9ybUlEOiAwLFxuICAgICAgICBzdHJlYW1pbmdGb3JtYXQ6IDAsXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQ6IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHM6IGJvb3RzdHJhcFNjcmlwdHMsXG4gICAgICAgIGJvb3RzdHJhcE1vZHVsZXM6IGJvb3RzdHJhcE1vZHVsZXMsXG4gICAgICAgIGluc3RydWN0aW9uczogTm90aGluZ1NlbnQsXG4gICAgICAgIGhhc0JvZHk6ICExLFxuICAgICAgICBoYXNIdG1sOiAhMSxcbiAgICAgICAgdW5rbm93blJlc291cmNlczoge30sXG4gICAgICAgIGRuc1Jlc291cmNlczoge30sXG4gICAgICAgIGNvbm5lY3RSZXNvdXJjZXM6IHsgZGVmYXVsdDoge30sIGFub255bW91czoge30sIGNyZWRlbnRpYWxzOiB7fSB9LFxuICAgICAgICBpbWFnZVJlc291cmNlczoge30sXG4gICAgICAgIHN0eWxlUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgc2NyaXB0UmVzb3VyY2VzOiB7fSxcbiAgICAgICAgbW9kdWxlVW5rbm93blJlc291cmNlczoge30sXG4gICAgICAgIG1vZHVsZVNjcmlwdFJlc291cmNlczoge31cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVByZWFtYmxlU3RhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBodG1sQ2h1bmtzOiBudWxsLFxuICAgICAgICBoZWFkQ2h1bmtzOiBudWxsLFxuICAgICAgICBib2R5Q2h1bmtzOiBudWxsLFxuICAgICAgICBjb250cmlidXRpb246IE5vQ29udHJpYnV0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGb3JtYXRDb250ZXh0KGluc2VydGlvbk1vZGUsIHNlbGVjdGVkVmFsdWUsIHRhZ1Njb3BlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNlcnRpb25Nb2RlOiBpbnNlcnRpb25Nb2RlLFxuICAgICAgICBzZWxlY3RlZFZhbHVlOiBzZWxlY3RlZFZhbHVlLFxuICAgICAgICB0YWdTY29wZTogdGFnU2NvcGVcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvb3RGb3JtYXRDb250ZXh0KG5hbWVzcGFjZVVSSSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiA9PT0gbmFtZXNwYWNlVVJJXG4gICAgICAgICAgPyBTVkdfTU9ERVxuICAgICAgICAgIDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIgPT09IG5hbWVzcGFjZVVSSVxuICAgICAgICAgICAgPyBNQVRITUxfTU9ERVxuICAgICAgICAgICAgOiBST09UX0hUTUxfTU9ERSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q2hpbGRGb3JtYXRDb250ZXh0KHBhcmVudENvbnRleHQsIHR5cGUsIHByb3BzKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm5vc2NyaXB0XCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX01PREUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZSB8IDFcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX01PREUsXG4gICAgICAgICAgICBudWxsICE9IHByb3BzLnZhbHVlID8gcHJvcHMudmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcInN2Z1wiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFNWR19NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcbiAgICAgICAgY2FzZSBcInBpY3R1cmVcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlIHwgMlxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJtYXRoXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoTUFUSE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuICAgICAgICBjYXNlIFwiZm9yZWlnbk9iamVjdFwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gICAgICAgIGNhc2UgXCJ0YWJsZVwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgSFRNTF9UQUJMRV9NT0RFLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGVcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwidGhlYWRcIjpcbiAgICAgICAgY2FzZSBcInRib2R5XCI6XG4gICAgICAgIGNhc2UgXCJ0Zm9vdFwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgSFRNTF9UQUJMRV9CT0RZX01PREUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJjb2xncm91cFwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgSFRNTF9DT0xHUk9VUF9NT0RFLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGVcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfVEFCTEVfUk9XX01PREUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJoZWFkXCI6XG4gICAgICAgICAgaWYgKHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8IEhUTUxfTU9ERSlcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgICBIVE1MX0hFQURfTU9ERSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICBpZiAocGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSlcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgICBIVE1MX0hUTUxfTU9ERSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZVxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPj0gSFRNTF9UQUJMRV9NT0RFIHx8XG4gICAgICAgIHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8IEhUTUxfTU9ERVxuICAgICAgICA/IGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKVxuICAgICAgICA6IHBhcmVudENvbnRleHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hUZXh0SW5zdGFuY2UodGFyZ2V0LCB0ZXh0LCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkKSB7XG4gICAgICBpZiAoXCJcIiA9PT0gdGV4dCkgcmV0dXJuIHRleHRFbWJlZGRlZDtcbiAgICAgIHRleHRFbWJlZGRlZCAmJiB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICAgIHRhcmdldC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpKTtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0eWxlQXR0cmlidXRlKHRhcmdldCwgc3R5bGUpIHtcbiAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2Ygc3R5bGUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgJ2VtJ319IHdoZW4gdXNpbmcgSlNYLlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgaXNGaXJzdCA9ICEwLFxuICAgICAgICBzdHlsZU5hbWU7XG4gICAgICBmb3IgKHN0eWxlTmFtZSBpbiBzdHlsZSlcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc3R5bGUsIHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlW3N0eWxlTmFtZV07XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCAhPSBzdHlsZVZhbHVlICYmXG4gICAgICAgICAgICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIHN0eWxlVmFsdWUgJiZcbiAgICAgICAgICAgIFwiXCIgIT09IHN0eWxlVmFsdWVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICgwID09PSBzdHlsZU5hbWUuaW5kZXhPZihcIi0tXCIpKSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lQ2h1bmsgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcihzdHlsZU5hbWUpO1xuICAgICAgICAgICAgICBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24oc3R5bGVWYWx1ZSwgc3R5bGVOYW1lKTtcbiAgICAgICAgICAgICAgc3R5bGVWYWx1ZSA9IGVzY2FwZVRleHRGb3JCcm93c2VyKChcIlwiICsgc3R5bGVWYWx1ZSkudHJpbSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWVDaHVuayA9IHN0eWxlTmFtZTtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKC0xIDwgbmFtZUNodW5rLmluZGV4T2YoXCItXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lQ2h1bms7XG4gICAgICAgICAgICAgICAgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHx8XG4gICAgICAgICAgICAgICAgICAoKHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSAhMCksXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlVuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/XCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbWVsaXplKG5hbWUucmVwbGFjZShtc1BhdHRlcm4kMSwgXCJtcy1cIikpXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lQ2h1bmspKVxuICAgICAgICAgICAgICAgIChuYW1lID0gbmFtZUNodW5rKSxcbiAgICAgICAgICAgICAgICAgICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICgod2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlVuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzP1wiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSlcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lQ2h1bms7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlJGpzY29tcCQwID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlJGpzY29tcCQwKSAmJlxuICAgICAgICAgICAgICAgICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWUkanNjb21wJDBdKSB8fFxuICAgICAgICAgICAgICAgICAgKCh3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZSRqc2NvbXAkMF0gPSAhMCksXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG5cXCd0IGNvbnRhaW4gYSBzZW1pY29sb24uIFRyeSBcIiVzOiAlc1wiIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUkanNjb21wJDAucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgICAoaXNOYU4odmFsdWUpXG4gICAgICAgICAgICAgICAgICA/IHdhcm5lZEZvck5hTlZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgICgod2FybmVkRm9yTmFOVmFsdWUgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZUNodW5rXG4gICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA6IGlzRmluaXRlKHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgICgod2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImBJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LlwiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWVDaHVua1xuICAgICAgICAgICAgICAgICAgICApKSk7XG4gICAgICAgICAgICAgIG5hbWVDaHVuayA9IHN0eWxlTmFtZTtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdHlsZU5hbWVDYWNoZS5nZXQobmFtZUNodW5rKTtcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gKG5hbWVDaHVuayA9IHZhbHVlKVxuICAgICAgICAgICAgICAgIDogKCh2YWx1ZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZUNodW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCBcIi0kMVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG1zUGF0dGVybiwgXCItbXMtXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgc3R5bGVOYW1lQ2FjaGUuc2V0KG5hbWVDaHVuaywgdmFsdWUpLFxuICAgICAgICAgICAgICAgICAgKG5hbWVDaHVuayA9IHZhbHVlKSk7XG4gICAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBzdHlsZVZhbHVlXG4gICAgICAgICAgICAgICAgPyAoc3R5bGVWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgIDAgPT09IHN0eWxlVmFsdWUgfHwgdW5pdGxlc3NOdW1iZXJzLmhhcyhzdHlsZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgPyBcIlwiICsgc3R5bGVWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgIDogc3R5bGVWYWx1ZSArIFwicHhcIilcbiAgICAgICAgICAgICAgICA6IChjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24oc3R5bGVWYWx1ZSwgc3R5bGVOYW1lKSxcbiAgICAgICAgICAgICAgICAgIChzdHlsZVZhbHVlID0gZXNjYXBlVGV4dEZvckJyb3dzZXIoXG4gICAgICAgICAgICAgICAgICAgIChcIlwiICsgc3R5bGVWYWx1ZSkudHJpbSgpXG4gICAgICAgICAgICAgICAgICApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0ZpcnN0XG4gICAgICAgICAgICAgID8gKChpc0ZpcnN0ID0gITEpLFxuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICAgICAgc3R5bGVBdHRyaWJ1dGVTdGFydCxcbiAgICAgICAgICAgICAgICAgIG5hbWVDaHVuayxcbiAgICAgICAgICAgICAgICAgIHN0eWxlQXNzaWduLFxuICAgICAgICAgICAgICAgICAgc3R5bGVWYWx1ZVxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgIDogdGFyZ2V0LnB1c2goc3R5bGVTZXBhcmF0b3IsIG5hbWVDaHVuaywgc3R5bGVBc3NpZ24sIHN0eWxlVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaXNGaXJzdCB8fCB0YXJnZXQucHVzaChhdHRyaWJ1dGVFbmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YWx1ZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBuYW1lLCBhdHRyaWJ1dGVFbXB0eVN0cmluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIFwiYm9vbGVhblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSxcbiAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEFkZGl0aW9uYWxGb3JtRmllbGQodmFsdWUsIGtleSkge1xuICAgICAgdGhpcy5wdXNoKHN0YXJ0SGlkZGVuSW5wdXRDaHVuayk7XG4gICAgICB2YWxpZGF0ZUFkZGl0aW9uYWxGb3JtRmllbGQodmFsdWUpO1xuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0aGlzLCBcIm5hbWVcIiwga2V5KTtcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGhpcywgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICB0aGlzLnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBZGRpdGlvbmFsRm9ybUZpZWxkKHZhbHVlKSB7XG4gICAgICBpZiAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHZhbHVlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkZpbGUvQmxvYiBmaWVsZHMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGluIHByb2dyZXNzaXZlIGZvcm1zLiBXaWxsIGZhbGxiYWNrIHRvIGNsaWVudCBoeWRyYXRpb24uXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VzdG9tRm9ybUZpZWxkcyhyZXN1bWFibGVTdGF0ZSwgZm9ybUFjdGlvbikge1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZvcm1BY3Rpb24uJCRGT1JNX0FDVElPTikge1xuICAgICAgICB2YXIgaWQgPSByZXN1bWFibGVTdGF0ZS5uZXh0Rm9ybUlEKys7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlID0gcmVzdW1hYmxlU3RhdGUuaWRQcmVmaXggKyBpZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgY3VzdG9tRmllbGRzID0gZm9ybUFjdGlvbi4kJEZPUk1fQUNUSU9OKHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgICAgICBpZiAoY3VzdG9tRmllbGRzKSB7XG4gICAgICAgICAgICB2YXIgZm9ybURhdGEgPSBjdXN0b21GaWVsZHMuZGF0YTtcbiAgICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEgJiYgZm9ybURhdGEuZm9yRWFjaCh2YWxpZGF0ZUFkZGl0aW9uYWxGb3JtRmllbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3VzdG9tRmllbGRzO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHggJiZcbiAgICAgICAgICAgIG51bGwgIT09IHggJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHgudGhlblxuICAgICAgICAgIClcbiAgICAgICAgICAgIHRocm93IHg7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRmFpbGVkIHRvIHNlcmlhbGl6ZSBhbiBhY3Rpb24gZm9yIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50OlxcbiVzXCIsXG4gICAgICAgICAgICB4XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKFxuICAgICAgdGFyZ2V0LFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtVGFyZ2V0LFxuICAgICAgbmFtZVxuICAgICkge1xuICAgICAgdmFyIGZvcm1EYXRhID0gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmb3JtQWN0aW9uKSB7XG4gICAgICAgIG51bGwgPT09IG5hbWUgfHxcbiAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk5hbWUgfHxcbiAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0Nhbm5vdCBzcGVjaWZ5IGEgXCJuYW1lXCIgcHJvcCBmb3IgYSBidXR0b24gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyBhIGZvcm1BY3Rpb24uIFJlYWN0IG5lZWRzIGl0IHRvIGVuY29kZSB3aGljaCBhY3Rpb24gc2hvdWxkIGJlIGludm9rZWQuIEl0IHdpbGwgZ2V0IG92ZXJyaWRkZW4uJ1xuICAgICAgICAgICkpO1xuICAgICAgICAobnVsbCA9PT0gZm9ybUVuY1R5cGUgJiYgbnVsbCA9PT0gZm9ybU1ldGhvZCkgfHxcbiAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCB8fFxuICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSBmb3JtRW5jVHlwZSBvciBmb3JtTWV0aG9kIGZvciBhIGJ1dHRvbiB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIGEgZm9ybUFjdGlvbi4gUmVhY3QgcHJvdmlkZXMgdGhvc2UgYXV0b21hdGljYWxseS4gVGhleSB3aWxsIGdldCBvdmVycmlkZGVuLlwiXG4gICAgICAgICAgKSk7XG4gICAgICAgIG51bGwgPT09IGZvcm1UYXJnZXQgfHxcbiAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCB8fFxuICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSBmb3JtVGFyZ2V0IGZvciBhIGJ1dHRvbiB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIGEgZm9ybUFjdGlvbi4gVGhlIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIHdpbmRvdy5cIlxuICAgICAgICAgICkpO1xuICAgICAgICB2YXIgY3VzdG9tRmllbGRzID0gZ2V0Q3VzdG9tRm9ybUZpZWxkcyhyZXN1bWFibGVTdGF0ZSwgZm9ybUFjdGlvbik7XG4gICAgICAgIG51bGwgIT09IGN1c3RvbUZpZWxkc1xuICAgICAgICAgID8gKChuYW1lID0gY3VzdG9tRmllbGRzLm5hbWUpLFxuICAgICAgICAgICAgKGZvcm1BY3Rpb24gPSBjdXN0b21GaWVsZHMuYWN0aW9uIHx8IFwiXCIpLFxuICAgICAgICAgICAgKGZvcm1FbmNUeXBlID0gY3VzdG9tRmllbGRzLmVuY1R5cGUpLFxuICAgICAgICAgICAgKGZvcm1NZXRob2QgPSBjdXN0b21GaWVsZHMubWV0aG9kKSxcbiAgICAgICAgICAgIChmb3JtVGFyZ2V0ID0gY3VzdG9tRmllbGRzLnRhcmdldCksXG4gICAgICAgICAgICAoZm9ybURhdGEgPSBjdXN0b21GaWVsZHMuZGF0YSkpXG4gICAgICAgICAgOiAodGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgXCJmb3JtQWN0aW9uXCIsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgYWN0aW9uSmF2YVNjcmlwdFVSTCxcbiAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGZvcm1UYXJnZXQgPSBmb3JtTWV0aG9kID0gZm9ybUVuY1R5cGUgPSBmb3JtQWN0aW9uID0gbmFtZSA9IG51bGwpLFxuICAgICAgICAgICAgaW5qZWN0Rm9ybVJlcGxheWluZ1J1bnRpbWUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSk7XG4gICAgICB9XG4gICAgICBudWxsICE9IG5hbWUgJiYgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgIG51bGwgIT0gZm9ybUFjdGlvbiAmJiBwdXNoQXR0cmlidXRlKHRhcmdldCwgXCJmb3JtQWN0aW9uXCIsIGZvcm1BY3Rpb24pO1xuICAgICAgbnVsbCAhPSBmb3JtRW5jVHlwZSAmJiBwdXNoQXR0cmlidXRlKHRhcmdldCwgXCJmb3JtRW5jVHlwZVwiLCBmb3JtRW5jVHlwZSk7XG4gICAgICBudWxsICE9IGZvcm1NZXRob2QgJiYgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIFwiZm9ybU1ldGhvZFwiLCBmb3JtTWV0aG9kKTtcbiAgICAgIG51bGwgIT0gZm9ybVRhcmdldCAmJiBwdXNoQXR0cmlidXRlKHRhcmdldCwgXCJmb3JtVGFyZ2V0XCIsIGZvcm1UYXJnZXQpO1xuICAgICAgcmV0dXJuIGZvcm1EYXRhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlIFwiY2xhc3NOYW1lXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwiY2xhc3NcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGFiSW5kZXhcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ0YWJpbmRleFwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkaXJcIjpcbiAgICAgICAgY2FzZSBcInJvbGVcIjpcbiAgICAgICAgY2FzZSBcInZpZXdCb3hcIjpcbiAgICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgIGNhc2UgXCJoZWlnaHRcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICBwdXNoU3R5bGVBdHRyaWJ1dGUodGFyZ2V0LCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzcmNcIjpcbiAgICAgICAgY2FzZSBcImhyZWZcIjpcbiAgICAgICAgICBpZiAoXCJcIiA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIFwic3JjXCIgPT09IG5hbWVcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ0FuIGVtcHR5IHN0cmluZyAoXCJcIikgd2FzIHBhc3NlZCB0byB0aGUgJXMgYXR0cmlidXRlLiBUaGlzIG1heSBjYXVzZSB0aGUgYnJvd3NlciB0byBkb3dubG9hZCB0aGUgd2hvbGUgcGFnZSBhZ2FpbiBvdmVyIHRoZSBuZXR3b3JrLiBUbyBmaXggdGhpcywgZWl0aGVyIGRvIG5vdCByZW5kZXIgdGhlIGVsZW1lbnQgYXQgYWxsIG9yIHBhc3MgbnVsbCB0byAlcyBpbnN0ZWFkIG9mIGFuIGVtcHR5IHN0cmluZy4nLFxuICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdBbiBlbXB0eSBzdHJpbmcgKFwiXCIpIHdhcyBwYXNzZWQgdG8gdGhlICVzIGF0dHJpYnV0ZS4gVG8gZml4IHRoaXMsIGVpdGhlciBkbyBub3QgcmVuZGVyIHRoZSBlbGVtZW50IGF0IGFsbCBvciBwYXNzIG51bGwgdG8gJXMgaW5zdGVhZCBvZiBhbiBlbXB0eSBzdHJpbmcuJyxcbiAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcImFjdGlvblwiOlxuICAgICAgICBjYXNlIFwiZm9ybUFjdGlvblwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgPT0gdmFsdWUgfHxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgICApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBuYW1lKTtcbiAgICAgICAgICB2YWx1ZSA9IHNhbml0aXplVVJMKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpLFxuICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdENoZWNrZWRcIjpcbiAgICAgICAgY2FzZSBcImlubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInJlZlwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYXV0b0ZvY3VzXCI6XG4gICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICBjYXNlIFwibXV0ZWRcIjpcbiAgICAgICAgICBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQsIG5hbWUudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtIcmVmXCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIG5hbWUpO1xuICAgICAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgIFwieGxpbms6aHJlZlwiLFxuICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpLFxuICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNvbnRlbnRFZGl0YWJsZVwiOlxuICAgICAgICBjYXNlIFwic3BlbGxDaGVja1wiOlxuICAgICAgICBjYXNlIFwiZHJhZ2dhYmxlXCI6XG4gICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICBjYXNlIFwiYXV0b1JldmVyc2VcIjpcbiAgICAgICAgY2FzZSBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIjpcbiAgICAgICAgY2FzZSBcImZvY3VzYWJsZVwiOlxuICAgICAgICBjYXNlIFwicHJlc2VydmVBbHBoYVwiOlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbmVydFwiOlxuICAgICAgICAgIFwiXCIgIT09IHZhbHVlIHx8XG4gICAgICAgICAgICBkaWRXYXJuRm9yTmV3Qm9vbGVhblByb3BzV2l0aEVtcHR5VmFsdWVbbmFtZV0gfHxcbiAgICAgICAgICAgICgoZGlkV2FybkZvck5ld0Jvb2xlYW5Qcm9wc1dpdGhFbXB0eVZhbHVlW25hbWVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiBlbXB0eSBzdHJpbmcgZm9yIGEgYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC4gVGhpcyB3aWxsIHRyZWF0IHRoZSBhdHRyaWJ1dGUgYXMgaWYgaXQgd2VyZSBmYWxzZS4gRWl0aGVyIHBhc3MgYGZhbHNlYCB0byBzaWxlbmNlIHRoaXMgd2FybmluZywgb3IgcGFzcyBgdHJ1ZWAgaWYgeW91IHVzZWQgYW4gZW1wdHkgc3RyaW5nIGluIGVhcmxpZXIgdmVyc2lvbnMgb2YgUmVhY3QgdG8gaW5kaWNhdGUgdGhpcyBhdHRyaWJ1dGUgaXMgdHJ1ZS5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIGNhc2UgXCJhbGxvd0Z1bGxTY3JlZW5cIjpcbiAgICAgICAgY2FzZSBcImFzeW5jXCI6XG4gICAgICAgIGNhc2UgXCJhdXRvUGxheVwiOlxuICAgICAgICBjYXNlIFwiY29udHJvbHNcIjpcbiAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgY2FzZSBcImRlZmVyXCI6XG4gICAgICAgIGNhc2UgXCJkaXNhYmxlZFwiOlxuICAgICAgICBjYXNlIFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIjpcbiAgICAgICAgY2FzZSBcImRpc2FibGVSZW1vdGVQbGF5YmFja1wiOlxuICAgICAgICBjYXNlIFwiZm9ybU5vVmFsaWRhdGVcIjpcbiAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICBjYXNlIFwibG9vcFwiOlxuICAgICAgICBjYXNlIFwibm9Nb2R1bGVcIjpcbiAgICAgICAgY2FzZSBcIm5vVmFsaWRhdGVcIjpcbiAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgY2FzZSBcInBsYXlzSW5saW5lXCI6XG4gICAgICAgIGNhc2UgXCJyZWFkT25seVwiOlxuICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgY2FzZSBcInJldmVyc2VkXCI6XG4gICAgICAgIGNhc2UgXCJzY29wZWRcIjpcbiAgICAgICAgY2FzZSBcInNlYW1sZXNzXCI6XG4gICAgICAgIGNhc2UgXCJpdGVtU2NvcGVcIjpcbiAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBuYW1lLCBhdHRyaWJ1dGVFbXB0eVN0cmluZyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjYXB0dXJlXCI6XG4gICAgICAgIGNhc2UgXCJkb3dubG9hZFwiOlxuICAgICAgICAgICEwID09PSB2YWx1ZVxuICAgICAgICAgICAgPyB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIG5hbWUsIGF0dHJpYnV0ZUVtcHR5U3RyaW5nKVxuICAgICAgICAgICAgOiAhMSAhPT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb2xzXCI6XG4gICAgICAgIGNhc2UgXCJyb3dzXCI6XG4gICAgICAgIGNhc2UgXCJzaXplXCI6XG4gICAgICAgIGNhc2UgXCJzcGFuXCI6XG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgIWlzTmFOKHZhbHVlKSAmJlxuICAgICAgICAgICAgMSA8PSB2YWx1ZSAmJlxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJvd1NwYW5cIjpcbiAgICAgICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgaXNOYU4odmFsdWUpIHx8XG4gICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtBY3R1YXRlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6YWN0dWF0ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua0FyY3JvbGVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bGluazphcmNyb2xlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rUm9sZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhsaW5rOnJvbGVcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtTaG93XCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6c2hvd1wiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua1RpdGxlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6dGl0bGVcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtUeXBlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6dHlwZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bWxCYXNlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieG1sOmJhc2VcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieG1sTGFuZ1wiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhtbDpsYW5nXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhtbFNwYWNlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieG1sOnNwYWNlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKDIgPCBuYW1lLmxlbmd0aCkgfHxcbiAgICAgICAgICAgIChcIm9cIiAhPT0gbmFtZVswXSAmJiBcIk9cIiAhPT0gbmFtZVswXSkgfHxcbiAgICAgICAgICAgIChcIm5cIiAhPT0gbmFtZVsxXSAmJiBcIk5cIiAhPT0gbmFtZVsxXSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgobmFtZSA9IGFsaWFzZXMuZ2V0KG5hbWUpIHx8IG5hbWUpLCBpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuICAgICAgICAgICAgICAgICAgaWYgKFwiZGF0YS1cIiAhPT0gcHJlZml4ICYmIFwiYXJpYS1cIiAhPT0gcHJlZml4KSByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChudWxsICE9IGlubmVySFRNTCkge1xuICAgICAgICBpZiAobnVsbCAhPSBjaGlsZHJlbilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGlubmVySFRNTCB8fCAhKFwiX19odG1sXCIgaW4gaW5uZXJIVE1MKSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgICApO1xuICAgICAgICBpbm5lckhUTUwgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgICBudWxsICE9PSBpbm5lckhUTUwgJiZcbiAgICAgICAgICB2b2lkIDAgIT09IGlubmVySFRNTCAmJlxuICAgICAgICAgIChjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihpbm5lckhUTUwpLCB0YXJnZXQucHVzaChcIlwiICsgaW5uZXJIVE1MKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgcHJvcE5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAgICAgKCh2YWx1ZSA9IGlzQXJyYXlJbXBsKHZhbHVlKSksXG4gICAgICAgIHByb3BzLm11bHRpcGxlICYmICF2YWx1ZVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgYG11bHRpcGxlYCBpcyB0cnVlLlwiLFxuICAgICAgICAgICAgICBwcm9wTmFtZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogIXByb3BzLm11bHRpcGxlICYmXG4gICAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgdmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS5cIixcbiAgICAgICAgICAgICAgcHJvcE5hbWVcbiAgICAgICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBudWxsICE9IGNoaWxkICYmXG4gICAgICAgICAgKChjb250ZW50ICs9IGNoaWxkKSxcbiAgICAgICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuIHx8XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGQgfHxcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjaGlsZCB8fFxuICAgICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIGNoaWxkIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkNhbm5vdCBpbmZlciB0aGUgb3B0aW9uIHZhbHVlIG9mIGNvbXBsZXggY2hpbGRyZW4uIFBhc3MgYSBgdmFsdWVgIHByb3Agb3IgdXNlIGEgcGxhaW4gc3RyaW5nIGFzIGNoaWxkcmVuIHRvIDxvcHRpb24+LlwiXG4gICAgICAgICAgICApKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmplY3RGb3JtUmVwbGF5aW5nUnVudGltZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpIHtcbiAgICAgIChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgJiAxNikgPT09IE5vdGhpbmdTZW50ICYmXG4gICAgICAgICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IDE2KSxcbiAgICAgICAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwQ2h1bmtzLnVuc2hpZnQoXG4gICAgICAgICAgcmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQsXG4gICAgICAgICAgZm9ybVJlcGxheWluZ1J1bnRpbWVTY3JpcHQsXG4gICAgICAgICAgZW5kSW5saW5lU2NyaXB0XG4gICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoTGlua0ltcGwodGFyZ2V0LCBwcm9wcykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyhcImxpbmtcIikpO1xuICAgICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcImxpbmsgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlU3R5bGVUZXh0Q29udGVudChzdHlsZVRleHQpIHtcbiAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKHN0eWxlVGV4dCk7XG4gICAgICByZXR1cm4gKFwiXCIgKyBzdHlsZVRleHQpLnJlcGxhY2Uoc3R5bGVSZWdleCwgc3R5bGVSZXBsYWNlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTZWxmQ2xvc2luZyh0YXJnZXQsIHByb3BzLCB0YWcpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gICAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIHRhZyArXG4gICAgICAgICAgICAgICAgICAgIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hUaXRsZUltcGwodGFyZ2V0LCBwcm9wcykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyhcInRpdGxlXCIpKTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG51bGwsXG4gICAgICAgIGlubmVySFRNTCA9IG51bGwsXG4gICAgICAgIHByb3BLZXk7XG4gICAgICBmb3IgKHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICBwcm9wcyA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgID8gMiA+IGNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAgID8gY2hpbGRyZW5bMF1cbiAgICAgICAgICA6IG51bGxcbiAgICAgICAgOiBjaGlsZHJlbjtcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHByb3BzICYmXG4gICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBwcm9wcyAmJlxuICAgICAgICBudWxsICE9PSBwcm9wcyAmJlxuICAgICAgICB2b2lkIDAgIT09IHByb3BzICYmXG4gICAgICAgIHRhcmdldC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKFwiXCIgKyBwcm9wcykpO1xuICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICAgICAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcoXCJ0aXRsZVwiKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFNjcmlwdEltcGwodGFyZ2V0LCBwcm9wcykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyhcInNjcmlwdFwiKSk7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBudWxsLFxuICAgICAgICBpbm5lckhUTUwgPSBudWxsLFxuICAgICAgICBwcm9wS2V5O1xuICAgICAgZm9yIChwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgbnVsbCAhPSBjaGlsZHJlbiAmJlxuICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgY2hpbGRyZW4gJiZcbiAgICAgICAgKChwcm9wcyA9XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNoaWxkcmVuXG4gICAgICAgICAgICA/IFwiYSBudW1iZXIgZm9yIGNoaWxkcmVuXCJcbiAgICAgICAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgICAgICAgICAgPyBcImFuIGFycmF5IGZvciBjaGlsZHJlblwiXG4gICAgICAgICAgICAgIDogXCJzb21ldGhpbmcgdW5leHBlY3RlZCBmb3IgY2hpbGRyZW5cIiksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBIHNjcmlwdCBlbGVtZW50IHdhcyByZW5kZXJlZCB3aXRoICVzLiBJZiBzY3JpcHQgZWxlbWVudCBoYXMgY2hpbGRyZW4gaXQgbXVzdCBiZSBhIHNpbmdsZSBzdHJpbmcuIENvbnNpZGVyIHVzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIG9yIHBhc3NpbmcgYSBwbGFpbiBzdHJpbmcgYXMgY2hpbGRyZW4uXCIsXG4gICAgICAgICAgcHJvcHNcbiAgICAgICAgKSk7XG4gICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4gJiZcbiAgICAgICAgdGFyZ2V0LnB1c2goZXNjYXBlRW50aXJlSW5saW5lU2NyaXB0Q29udGVudChjaGlsZHJlbikpO1xuICAgICAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcoXCJzY3JpcHRcIikpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdGFydFNpbmdsZXRvbkVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICAgICAgdmFyIGlubmVySFRNTCA9ICh0YWcgPSBudWxsKSxcbiAgICAgICAgcHJvcEtleTtcbiAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICB0YWcgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCB0YWcpO1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICAgICAgdmFyIGlubmVySFRNTCA9ICh0YWcgPSBudWxsKSxcbiAgICAgICAgcHJvcEtleTtcbiAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICB0YWcgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCB0YWcpO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0YWdcbiAgICAgICAgPyAodGFyZ2V0LnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIodGFnKSksIG51bGwpXG4gICAgICAgIDogdGFnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydENodW5rRm9yVGFnKHRhZykge1xuICAgICAgdmFyIHRhZ1N0YXJ0Q2h1bmsgPSB2YWxpZGF0ZWRUYWdDYWNoZS5nZXQodGFnKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHRhZ1N0YXJ0Q2h1bmspIHtcbiAgICAgICAgaWYgKCFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpKSB0aHJvdyBFcnJvcihcIkludmFsaWQgdGFnOiBcIiArIHRhZyk7XG4gICAgICAgIHRhZ1N0YXJ0Q2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8XCIgKyB0YWcpO1xuICAgICAgICB2YWxpZGF0ZWRUYWdDYWNoZS5zZXQodGFnLCB0YWdTdGFydENodW5rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWdTdGFydENodW5rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3RhcnRJbnN0YW5jZShcbiAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICBwcmVhbWJsZVN0YXRlLFxuICAgICAgaG9pc3RhYmxlU3RhdGUsXG4gICAgICBmb3JtYXRDb250ZXh0LFxuICAgICAgdGV4dEVtYmVkZGVkLFxuICAgICAgaXNGYWxsYmFja1xuICAgICkge1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpO1xuICAgICAgKFwiaW5wdXRcIiAhPT0gdHlwZSAmJiBcInRleHRhcmVhXCIgIT09IHR5cGUgJiYgXCJzZWxlY3RcIiAhPT0gdHlwZSkgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcyB8fFxuICAgICAgICBudWxsICE9PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICBkaWRXYXJuVmFsdWVOdWxsIHx8XG4gICAgICAgICgoZGlkV2FyblZhbHVlTnVsbCA9ICEwKSxcbiAgICAgICAgXCJzZWxlY3RcIiA9PT0gdHlwZSAmJiBwcm9wcy5tdWx0aXBsZVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuIENvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImB2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApKTtcbiAgICAgIGI6IGlmICgtMSA9PT0gdHlwZS5pbmRleE9mKFwiLVwiKSkgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgZWxzZVxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpcbiAgICAgICAgICBjYXNlIFwiY29sb3ItcHJvZmlsZVwiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2VcIjpcbiAgICAgICAgICBjYXNlIFwiZm9udC1mYWNlLXNyY1wiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2UtdXJpXCI6XG4gICAgICAgICAgY2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpcbiAgICAgICAgICBjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpcbiAgICAgICAgICBjYXNlIFwibWlzc2luZy1nbHlwaFwiOlxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgICAgfVxuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0IHx8XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5pcyB8fFxuICAgICAgICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIG51bGwpO1xuICAgICAgIXByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyAmJlxuICAgICAgICBwcm9wcy5jb250ZW50RWRpdGFibGUgJiZcbiAgICAgICAgbnVsbCAhPSBwcm9wcy5jaGlsZHJlbiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSBSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiB0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgcHJvYmFibHkgbm90IGludGVudGlvbmFsLlwiXG4gICAgICAgICk7XG4gICAgICBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgIT09IFNWR19NT0RFICYmXG4gICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSAhPT0gTUFUSE1MX01PREUgJiZcbiAgICAgICAgLTEgPT09IHR5cGUuaW5kZXhPZihcIi1cIikgJiZcbiAgICAgICAgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSB0eXBlICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCI8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsIG9yIGxvd2VyY2FzZSBmb3IgSFRNTCBlbGVtZW50cy5cIixcbiAgICAgICAgICB0eXBlXG4gICAgICAgICk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImRpdlwiOlxuICAgICAgICBjYXNlIFwic3BhblwiOlxuICAgICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcImFcIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleTtcbiAgICAgICAgICBmb3IgKHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgICAgICAgICAgICBcIlwiID09PSBwcm9wVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICA/IHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImhyZWZcIiwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICA6IHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIoY2hpbGRyZW4pKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBjaGlsZHJlbjtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwO1xuICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICBjYXNlIFwibGlcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJzZWxlY3RcIiwgcHJvcHMpO1xuICAgICAgICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICBjaGVja1NlbGVjdFByb3AocHJvcHMsIFwiZGVmYXVsdFZhbHVlXCIpO1xuICAgICAgICAgIHZvaWQgMCA9PT0gcHJvcHMudmFsdWUgfHxcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gcHJvcHMuZGVmYXVsdFZhbHVlIHx8XG4gICAgICAgICAgICBkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0IGVsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlID0gITApKTtcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwic2VsZWN0XCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDA7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQwIGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDApKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDAgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQwXTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQwKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkMCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMCwgY2hpbGRyZW4kanNjb21wJDApO1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbiRqc2NvbXAkMDtcbiAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgIHZhciBzZWxlY3RlZFZhbHVlID0gZm9ybWF0Q29udGV4dC5zZWxlY3RlZFZhbHVlO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJvcHRpb25cIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBzZWxlY3RlZCA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMTtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDEgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMSA9IHByb3BzW3Byb3BLZXkkanNjb21wJDFdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDEpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQxKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDEgPSBwcm9wVmFsdWUkanNjb21wJDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gcHJvcFZhbHVlJGpzY29tcCQxO1xuICAgICAgICAgICAgICAgICAgICBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiBzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uXCJcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIChkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9ICEwKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wVmFsdWUkanNjb21wJDE7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkMVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobnVsbCAhPSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG51bGwgPT09IGlubmVySFRNTCRqc2NvbXAkMSB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MIHx8XG4gICAgICAgICAgICAgICAgKChkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9ICEwKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJQYXNzIGEgYHZhbHVlYCBwcm9wIGlmIHlvdSBzZXQgZGFuZ2Vyb3VzbHlJbm5lckhUTUwgc28gUmVhY3Qga25vd3Mgd2hpY2ggdmFsdWUgc2hvdWxkIGJlIHNlbGVjdGVkLlwiXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHN0cmluZ1ZhbHVlID0gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKGNoaWxkcmVuJGpzY29tcCQxKSk7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoc2VsZWN0ZWRWYWx1ZSkpXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHNlbGVjdGVkVmFsdWVbaV0sIFwidmFsdWVcIiksXG4gICAgICAgICAgICAgICAgICBcIlwiICsgc2VsZWN0ZWRWYWx1ZVtpXSA9PT0gc3RyaW5nVmFsdWUpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihzZWxlY3RlZFZhbHVlLCBcInNlbGVjdC52YWx1ZVwiKSxcbiAgICAgICAgICAgICAgICBcIlwiICsgc2VsZWN0ZWRWYWx1ZSA9PT0gc3RyaW5nVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHNlbGVjdGVkTWFya2VyQXR0cmlidXRlKTtcbiAgICAgICAgICB9IGVsc2Ugc2VsZWN0ZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2goc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0JGpzY29tcCQwLCBpbm5lckhUTUwkanNjb21wJDEsIGNoaWxkcmVuJGpzY29tcCQxKTtcbiAgICAgICAgICByZXR1cm4gY2hpbGRyZW4kanNjb21wJDE7XG4gICAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJ0ZXh0YXJlYVwiLCBwcm9wcyk7XG4gICAgICAgICAgdm9pZCAwID09PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICAgICAgdm9pZCAwID09PSBwcm9wcy5kZWZhdWx0VmFsdWUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSB8fFxuICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSAhMCkpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgICAgICAgdmFyIHZhbHVlJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMiA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQyO1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMiBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQyKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQyID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkMl07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMilcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDIpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMiA9IHByb3BWYWx1ZSRqc2NvbXAkMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wVmFsdWUkanNjb21wJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDIsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQyXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgPT09IHZhbHVlJGpzY29tcCQwICYmXG4gICAgICAgICAgICBudWxsICE9PSBkZWZhdWx0VmFsdWUgJiZcbiAgICAgICAgICAgICh2YWx1ZSRqc2NvbXAkMCA9IGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgaWYgKG51bGwgIT0gY2hpbGRyZW4kanNjb21wJDIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyBjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKG51bGwgIT0gdmFsdWUkanNjb21wJDApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4kanNjb21wJDIpKSB7XG4gICAgICAgICAgICAgIGlmICgxIDwgY2hpbGRyZW4kanNjb21wJDIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLlwiKTtcbiAgICAgICAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oY2hpbGRyZW4kanNjb21wJDJbMF0pO1xuICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMCA9IFwiXCIgKyBjaGlsZHJlbiRqc2NvbXAkMlswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGNoaWxkcmVuJGpzY29tcCQyKTtcbiAgICAgICAgICAgIHZhbHVlJGpzY29tcCQwID0gXCJcIiArIGNoaWxkcmVuJGpzY29tcCQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIFwiXFxuXCIgPT09IHZhbHVlJGpzY29tcCQwWzBdICYmXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gICAgICAgICAgbnVsbCAhPT0gdmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlJGpzY29tcCQwLCBcInZhbHVlXCIpLFxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIoXCJcIiArIHZhbHVlJGpzY29tcCQwKSkpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKFwiaW5wdXRcIiwgcHJvcHMpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJpbnB1dFwiKSk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBudWxsLFxuICAgICAgICAgICAgZm9ybUFjdGlvbiA9IG51bGwsXG4gICAgICAgICAgICBmb3JtRW5jVHlwZSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtTWV0aG9kID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQgPSBudWxsLFxuICAgICAgICAgICAgdmFsdWUkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGNoZWNrZWQgPSBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMztcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDMgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMykpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMyA9IHByb3BzW3Byb3BLZXkkanNjb21wJDNdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDMpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQzKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImlucHV0IGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1BY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUFjdGlvbiA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybUVuY1R5cGVcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUVuY1R5cGUgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1NZXRob2RcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybVRhcmdldFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtVGFyZ2V0ID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQzLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkM1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsID09PSBmb3JtQWN0aW9uIHx8XG4gICAgICAgICAgICBcImltYWdlXCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIFwic3VibWl0XCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnQW4gaW5wdXQgY2FuIG9ubHkgc3BlY2lmeSBhIGZvcm1BY3Rpb24gYWxvbmcgd2l0aCB0eXBlPVwic3VibWl0XCIgb3IgdHlwZT1cImltYWdlXCIuJ1xuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgdmFyIGZvcm1EYXRhID0gcHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUoXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBudWxsID09PSBjaGVja2VkIHx8XG4gICAgICAgICAgICBudWxsID09PSBkZWZhdWx0Q2hlY2tlZCB8fFxuICAgICAgICAgICAgZGlkV2FybkRlZmF1bHRDaGVja2VkIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90IGJvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0IGVsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIixcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICBwcm9wcy50eXBlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9ICEwKSk7XG4gICAgICAgICAgbnVsbCA9PT0gdmFsdWUkanNjb21wJDEgfHxcbiAgICAgICAgICAgIG51bGwgPT09IGRlZmF1bHRWYWx1ZSRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiBJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCBib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCBlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzXCIsXG4gICAgICAgICAgICAgIFwiQSBjb21wb25lbnRcIixcbiAgICAgICAgICAgICAgcHJvcHMudHlwZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSAhMCkpO1xuICAgICAgICAgIG51bGwgIT09IGNoZWNrZWRcbiAgICAgICAgICAgID8gcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImNoZWNrZWRcIiwgY2hlY2tlZClcbiAgICAgICAgICAgIDogbnVsbCAhPT0gZGVmYXVsdENoZWNrZWQgJiZcbiAgICAgICAgICAgICAgcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImNoZWNrZWRcIiwgZGVmYXVsdENoZWNrZWQpO1xuICAgICAgICAgIG51bGwgIT09IHZhbHVlJGpzY29tcCQxXG4gICAgICAgICAgICA/IHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcInZhbHVlXCIsIHZhbHVlJGpzY29tcCQxKVxuICAgICAgICAgICAgOiBudWxsICE9PSBkZWZhdWx0VmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwidmFsdWVcIiwgZGVmYXVsdFZhbHVlJGpzY29tcCQwKTtcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEgJiZcbiAgICAgICAgICAgIGZvcm1EYXRhLmZvckVhY2gocHVzaEFkZGl0aW9uYWxGb3JtRmllbGQsIHRhcmdldCRqc2NvbXAkMCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwiYnV0dG9uXCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDMgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQyID0gbnVsbCxcbiAgICAgICAgICAgIG5hbWUkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBmb3JtTWV0aG9kJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNDtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDQgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkNCkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkNCA9IHByb3BzW3Byb3BLZXkkanNjb21wJDRdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDQpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ0KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDMgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMiA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICBuYW1lJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtQWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1FbmNUeXBlXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtTWV0aG9kXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1UYXJnZXRcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ0LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkNFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsID09PSBmb3JtQWN0aW9uJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBudWxsID09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIFwic3VibWl0XCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnQSBidXR0b24gY2FuIG9ubHkgc3BlY2lmeSBhIGZvcm1BY3Rpb24gYWxvbmcgd2l0aCB0eXBlPVwic3VibWl0XCIgb3Igbm8gdHlwZS4nXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB2YXIgZm9ybURhdGEkanNjb21wJDAgPSBwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZShcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQwLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGUkanNjb21wJDAsXG4gICAgICAgICAgICBmb3JtTWV0aG9kJGpzY29tcCQwLFxuICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgIG5hbWUkanNjb21wJDBcbiAgICAgICAgICApO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEkanNjb21wJDAgJiZcbiAgICAgICAgICAgIGZvcm1EYXRhJGpzY29tcCQwLmZvckVhY2gocHVzaEFkZGl0aW9uYWxGb3JtRmllbGQsIHRhcmdldCRqc2NvbXAkMCk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMiwgY2hpbGRyZW4kanNjb21wJDMpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDMpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQzKSk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxID0gY2hpbGRyZW4kanNjb21wJDM7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTtcbiAgICAgICAgY2FzZSBcImZvcm1cIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwiZm9ybVwiKSk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQ0ID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMyA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ1O1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkNSBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQ1KSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ1ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkNV07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkNSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkNCA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQzID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZW5jVHlwZVwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibWV0aG9kXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDEgPSBwcm9wVmFsdWUkanNjb21wJDU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInRhcmdldFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtVGFyZ2V0JGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDUsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQ1XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHZhciBmb3JtRGF0YSRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uTmFtZSA9IG51bGw7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZvcm1BY3Rpb24kanNjb21wJDEpIHtcbiAgICAgICAgICAgIChudWxsID09PSBmb3JtRW5jVHlwZSRqc2NvbXAkMSAmJiBudWxsID09PSBmb3JtTWV0aG9kJGpzY29tcCQxKSB8fFxuICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSBlbmNUeXBlIG9yIG1ldGhvZCBmb3IgYSBmb3JtIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgdGhlIGFjdGlvbi4gUmVhY3QgcHJvdmlkZXMgdGhvc2UgYXV0b21hdGljYWxseS4gVGhleSB3aWxsIGdldCBvdmVycmlkZGVuLlwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgbnVsbCA9PT0gZm9ybVRhcmdldCRqc2NvbXAkMSB8fFxuICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSB0YXJnZXQgZm9yIGEgZm9ybSB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIHRoZSBhY3Rpb24uIFRoZSBmdW5jdGlvbiB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSB3aW5kb3cuXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB2YXIgY3VzdG9tRmllbGRzID0gZ2V0Q3VzdG9tRm9ybUZpZWxkcyhcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBudWxsICE9PSBjdXN0b21GaWVsZHNcbiAgICAgICAgICAgICAgPyAoKGZvcm1BY3Rpb24kanNjb21wJDEgPSBjdXN0b21GaWVsZHMuYWN0aW9uIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgIChmb3JtRW5jVHlwZSRqc2NvbXAkMSA9IGN1c3RvbUZpZWxkcy5lbmNUeXBlKSxcbiAgICAgICAgICAgICAgICAoZm9ybU1ldGhvZCRqc2NvbXAkMSA9IGN1c3RvbUZpZWxkcy5tZXRob2QpLFxuICAgICAgICAgICAgICAgIChmb3JtVGFyZ2V0JGpzY29tcCQxID0gY3VzdG9tRmllbGRzLnRhcmdldCksXG4gICAgICAgICAgICAgICAgKGZvcm1EYXRhJGpzY29tcCQxID0gY3VzdG9tRmllbGRzLmRhdGEpLFxuICAgICAgICAgICAgICAgIChmb3JtQWN0aW9uTmFtZSA9IGN1c3RvbUZpZWxkcy5uYW1lKSlcbiAgICAgICAgICAgICAgOiAodGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgICBcImFjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgICAgYWN0aW9uSmF2YVNjcmlwdFVSTCxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGZvcm1UYXJnZXQkanNjb21wJDEgPVxuICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICAgICAgbnVsbCksXG4gICAgICAgICAgICAgICAgaW5qZWN0Rm9ybVJlcGxheWluZ1J1bnRpbWUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bGwgIT0gZm9ybUFjdGlvbiRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiYWN0aW9uXCIsIGZvcm1BY3Rpb24kanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybUVuY1R5cGUkanNjb21wJDEgJiZcbiAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImVuY1R5cGVcIiwgZm9ybUVuY1R5cGUkanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybU1ldGhvZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwibWV0aG9kXCIsIGZvcm1NZXRob2QkanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybVRhcmdldCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwidGFyZ2V0XCIsIGZvcm1UYXJnZXQkanNjb21wJDEpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIG51bGwgIT09IGZvcm1BY3Rpb25OYW1lICYmXG4gICAgICAgICAgICAodGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRIaWRkZW5JbnB1dENodW5rKSxcbiAgICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcIm5hbWVcIiwgZm9ybUFjdGlvbk5hbWUpLFxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKSxcbiAgICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEkanNjb21wJDEgJiZcbiAgICAgICAgICAgICAgZm9ybURhdGEkanNjb21wJDEuZm9yRWFjaChcbiAgICAgICAgICAgICAgICBwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCxcbiAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDBcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMywgY2hpbGRyZW4kanNjb21wJDQpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDQpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQ0KSk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyID0gY2hpbGRyZW4kanNjb21wJDQ7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMjtcbiAgICAgICAgY2FzZSBcIm1lbnVpdGVtXCI6XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcIm1lbnVpdGVtXCIpKTtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wS2V5JGpzY29tcCQ2IGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDYpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDYgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ2XTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ2KVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkNikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJtZW51aXRlbXMgY2Fubm90IGhhdmUgYGNoaWxkcmVuYCBub3IgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNixcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDZcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwib2JqZWN0XCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDUgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ0ID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDc7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQ3IGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDcpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDcgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ3XTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ3KVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkNykge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ1ID0gcHJvcFZhbHVlJGpzY29tcCQ3O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDQgPSBwcm9wVmFsdWUkanNjb21wJDc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihwcm9wVmFsdWUkanNjb21wJDcsIFwiZGF0YVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhbml0aXplZFZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHByb3BWYWx1ZSRqc2NvbXAkNyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIlwiID09PSBzYW5pdGl6ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnQW4gZW1wdHkgc3RyaW5nIChcIlwiKSB3YXMgcGFzc2VkIHRvIHRoZSAlcyBhdHRyaWJ1dGUuIFRvIGZpeCB0aGlzLCBlaXRoZXIgZG8gbm90IHJlbmRlciB0aGUgZWxlbWVudCBhdCBhbGwgb3IgcGFzcyBudWxsIHRvICVzIGluc3RlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ3LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkN1xuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcihzYW5pdGl6ZWRWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNyxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkNCwgY2hpbGRyZW4kanNjb21wJDUpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDUpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQ1KSk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQzID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQzID0gY2hpbGRyZW4kanNjb21wJDU7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMztcbiAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgdmFyIGluc2VydGlvbk1vZGUgPSBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUsXG4gICAgICAgICAgICBub3NjcmlwdFRhZ0luU2NvcGUgPSAhIShmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMSk7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIFwiY2hpbGRyZW5cIikpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkNiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBjaGlsZCA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4kanNjb21wJDYpXG4gICAgICAgICAgICAgICAgPyAyID4gY2hpbGRyZW4kanNjb21wJDYubGVuZ3RoXG4gICAgICAgICAgICAgICAgICA/IGNoaWxkcmVuJGpzY29tcCQ2WzBdXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgICA6IGNoaWxkcmVuJGpzY29tcCQ2O1xuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShjaGlsZHJlbiRqc2NvbXAkNikgJiYgMSA8IGNoaWxkcmVuJGpzY29tcCQ2Lmxlbmd0aFxuICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlJlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgYmlnaW50LCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCBhbiBBcnJheSB3aXRoIGxlbmd0aCAlcyBpbnN0ZWFkLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlIHdoaWNoIGlzIHdoeSBBcnJheXMgb2YgbGVuZ3RoIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3Qgc3VwcG9ydGVkLiBXaGVuIHVzaW5nIEpTWCBpdCBjYW4gYmUgY29tbW9uIHRvIGNvbWJpbmUgdGV4dCBub2RlcyBhbmQgdmFsdWUgbm9kZXMuIEZvciBleGFtcGxlOiA8dGl0bGU+aGVsbG8ge25hbWVPZlVzZXJ9PC90aXRsZT4uIFdoaWxlIG5vdCBpbW1lZGlhdGVseSBhcHBhcmVudCwgYGNoaWxkcmVuYCBpbiB0aGlzIGNhc2UgaXMgYW4gQXJyYXkgd2l0aCBsZW5ndGggMi4gSWYgeW91ciBgY2hpbGRyZW5gIHByb3AgaXMgdXNpbmcgdGhpcyBmb3JtIHRyeSByZXdyaXRpbmcgaXQgdXNpbmcgYSB0ZW1wbGF0ZSBzdHJpbmc6IDx0aXRsZT57YGhlbGxvICR7bmFtZU9mVXNlcn1gfTwvdGl0bGU+LlwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDYubGVuZ3RoXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkIHx8IFwic3ltYm9sXCIgPT09IHR5cGVvZiBjaGlsZFxuICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3QgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgJXMgaW5zdGVhZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkID8gXCJhIEZ1bmN0aW9uXCIgOiBcImEgU3libW9sXCJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGNoaWxkICYmXG4gICAgICAgICAgICAgICAgICBjaGlsZC50b1N0cmluZyA9PT0ge30udG9TdHJpbmcgJiZcbiAgICAgICAgICAgICAgICAgIChudWxsICE9IGNoaWxkLiQkdHlwZW9mXG4gICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIG9iamVjdCB0aGF0IGFwcGVhcnMgdG8gYmUgYSBSZWFjdCBlbGVtZW50IHdoaWNoIG5ldmVyIGltcGxlbWVudHMgYSBzdWl0YWJsZSBgdG9TdHJpbmdgIG1ldGhvZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUgd2hpY2ggaXMgd2h5IHJlbmRlcmluZyBSZWFjdCBlbGVtZW50cyBpcyBub3Qgc3VwcG9ydGVkLiBJZiB0aGUgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IGlzIGEgUmVhY3QgQ29tcG9uZW50IHRyeSBtb3ZpbmcgdGhlIDx0aXRsZT4gdGFnIGludG8gdGhhdCBjb21wb25lbnQuIElmIHRoZSBgY2hpbGRyZW5gIG9mIDx0aXRsZT4gaXMgc29tZSBIVE1MIG1hcmt1cCBjaGFuZ2UgaXQgdG8gYmUgVGV4dCBvbmx5IHRvIGJlIHZhbGlkIEhUTUwuXCJcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIG9iamVjdCB0aGF0IGRvZXMgbm90IGltcGxlbWVudCBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZS4gVXNpbmcgdGhlIGRlZmF1bHQgYHRvU3RyaW5nYCBtZXRob2QgYXZhaWxhYmxlIG9uIGV2ZXJ5IG9iamVjdCBpcyBhbG1vc3QgY2VydGFpbmx5IGFuIGVycm9yLiBDb25zaWRlciB3aGV0aGVyIHRoZSBgY2hpbGRyZW5gIG9mIHRoaXMgPHRpdGxlPiBpcyBhbiBvYmplY3QgaW4gZXJyb3IgYW5kIGNoYW5nZSBpdCB0byBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgaWYgc28uIE90aGVyd2lzZSBpbXBsZW1lbnQgYSBgdG9TdHJpbmdgIG1ldGhvZCB0aGF0IFJlYWN0IGNhbiB1c2UgdG8gcHJvZHVjZSBhIHZhbGlkIDx0aXRsZT4uXCJcbiAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDQgPSBwdXNoVGl0bGVJbXBsKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0ID0gbnVsbClcbiAgICAgICAgICAgICAgOiAocHVzaFRpdGxlSW1wbChyZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3MsIHByb3BzKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0ID0gdm9pZCAwKSk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNDtcbiAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICB2YXIgcmVsID0gcHJvcHMucmVsLFxuICAgICAgICAgICAgaHJlZiA9IHByb3BzLmhyZWYsXG4gICAgICAgICAgICBwcmVjZWRlbmNlID0gcHJvcHMucHJlY2VkZW5jZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8XG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHJlbCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGhyZWYgfHxcbiAgICAgICAgICAgIFwiXCIgPT09IGhyZWZcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIFwic3R5bGVzaGVldFwiID09PSByZWwgJiZcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgJiZcbiAgICAgICAgICAgICAgKChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB8fFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kIGV4cGVjdGVkIHRoZSBgaHJlZmAgcHJvcCB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgYnV0IGVjb3VudGVyZWQgJXMgaW5zdGVhZC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgZW5zdXJlIHRoZXJlIGlzIGEgbm9uLWVtcHR5IHN0cmluZyBgaHJlZmAgcHJvcCBhcyB3ZWxsLCBvdGhlcndpc2UgcmVtb3ZlIHRoZSBgcHJlY2VkZW5jZWAgcHJvcC4nLFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICA/IFwiYG51bGxgXCJcbiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDAgPT09IGhyZWZcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiYHVuZGVmaW5lZGBcIlxuICAgICAgICAgICAgICAgICAgICAgIDogXCJcIiA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImFuIGVtcHR5IHN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdzb21ldGhpbmcgd2l0aCB0eXBlIFwiJyArIHR5cGVvZiBocmVmICsgJ1wiJ1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgcHVzaExpbmtJbXBsKHRhcmdldCRqc2NvbXAkMCwgcHJvcHMpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChcInN0eWxlc2hlZXRcIiA9PT0gcHJvcHMucmVsKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJlY2VkZW5jZSB8fFxuICAgICAgICAgICAgICBudWxsICE9IHByb3BzLmRpc2FibGVkIHx8XG4gICAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fFxuICAgICAgICAgICAgICBwcm9wcy5vbkVycm9yXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcmVjZWRlbmNlKVxuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BzLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlYWN0IGVuY291bnRlcmVkIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4vPmAgd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIGFuZCBhIGBkaXNhYmxlZGAgcHJvcC4gVGhlIHByZXNlbmNlIG9mIHRoZSBgZGlzYWJsZWRgIHByb3AgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgYWN0aXZlIHN0YXRlIGZyb20geW91ciBmcm9tIHlvdXIgQ29tcG9uZW50IGNvZGUgYW5kIFJlYWN0IHdpbGwgbm90IGhvaXN0IG9yIGRlZHVwbGljYXRlIHRoaXMgc3R5bGVzaGVldC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgcmVtb3ZlIHRoZSBgZGlzYWJsZWRgIHByb3AsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLidcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm9wRGVzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbkxvYWQgJiYgcHJvcHMub25FcnJvclxuICAgICAgICAgICAgICAgICAgICAgID8gXCJgb25Mb2FkYCBhbmQgYG9uRXJyb3JgIHByb3BzXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IHByb3BzLm9uTG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImBvbkxvYWRgIHByb3BcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcImBvbkVycm9yYCBwcm9wXCI7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kICVzLiBUaGUgcHJlc2VuY2Ugb2YgbG9hZGluZyBhbmQgZXJyb3IgaGFuZGxlcnMgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgbG9hZGluZyBzdGF0ZSBmcm9tIHlvdXIgZnJvbSB5b3VyIENvbXBvbmVudCBjb2RlIGFuZCBSZWFjdCB3aWxsIG5vdCBob2lzdCBvciBkZWR1cGxpY2F0ZSB0aGlzIHN0eWxlc2hlZXQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHJlbW92ZSB0aGUgJXMsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BEZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlUXVldWUgPSByZW5kZXJTdGF0ZS5zdHlsZXMuZ2V0KHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgPSByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTO1xuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUgfHxcbiAgICAgICAgICAgICAgICAgICgoc3R5bGVRdWV1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSksXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaHJlZnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuc2V0KHByZWNlZGVuY2UsIHN0eWxlUXVldWUpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZTogUEVORElORyQxLFxuICAgICAgICAgICAgICAgICAgcHJvcHM6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJvcHMucHJlY2VkZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogbnVsbFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhyZXNvdXJjZS5wcm9wcywgcmVzb3VyY2VTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuZ2V0KGhyZWYpO1xuICAgICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlICYmIDAgPCBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gKHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPSAwKVxuICAgICAgICAgICAgICAgICAgICA6IChyZXNvdXJjZS5zdGF0ZSA9IFBSRUxPQURFRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUuc2hlZXRzLnNldChocmVmLCByZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaG9pc3RhYmxlU3RhdGUgJiYgaG9pc3RhYmxlU3RhdGUuc3R5bGVzaGVldHMuYWRkKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZXNvdXJjZSA9IHN0eWxlUXVldWUuc2hlZXRzLmdldChocmVmKTtcbiAgICAgICAgICAgICAgICBfcmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXNoZWV0cy5hZGQoX3Jlc291cmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3JcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6ICh0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2godGV4dFNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IGlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgOiBwdXNoTGlua0ltcGwocmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcykpKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1O1xuICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgdmFyIGFzeW5jUHJvcCA9IHByb3BzLmFzeW5jO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBwcm9wcy5zcmMgfHxcbiAgICAgICAgICAgICFwcm9wcy5zcmMgfHxcbiAgICAgICAgICAgICFhc3luY1Byb3AgfHxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFzeW5jUHJvcCB8fFxuICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIGFzeW5jUHJvcCB8fFxuICAgICAgICAgICAgcHJvcHMub25Mb2FkIHx8XG4gICAgICAgICAgICBwcm9wcy5vbkVycm9yIHx8XG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8XG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDYgPSBwdXNoU2NyaXB0SW1wbChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBwcm9wcy5zcmM7XG4gICAgICAgICAgICBpZiAoXCJtb2R1bGVcIiA9PT0gcHJvcHMudHlwZSkge1xuICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VzID0gcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzO1xuICAgICAgICAgICAgICB2YXIgcHJlbG9hZHMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5tb2R1bGVTY3JpcHRzO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIChyZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMpLFxuICAgICAgICAgICAgICAgIChwcmVsb2FkcyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLnNjcmlwdHMpO1xuICAgICAgICAgICAgdmFyIHJlc291cmNlU3RhdGUkanNjb21wJDAgPSByZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KVxuICAgICAgICAgICAgICA/IHJlc291cmNlc1trZXldXG4gICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUkanNjb21wJDAgIT09IEVYSVNUUykge1xuICAgICAgICAgICAgICByZXNvdXJjZXNba2V5XSA9IEVYSVNUUztcbiAgICAgICAgICAgICAgdmFyIHNjcmlwdFByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlJGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgICAgMiA9PT0gcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICgoc2NyaXB0UHJvcHMgPSBhc3NpZ24oe30sIHByb3BzKSksXG4gICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhzY3JpcHRQcm9wcywgcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMCkpO1xuICAgICAgICAgICAgICAgIHZhciBwcmVsb2FkUmVzb3VyY2UkanNjb21wJDAgPSBwcmVsb2Fkcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2UkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgIChwcmVsb2FkUmVzb3VyY2UkanNjb21wJDAubGVuZ3RoID0gMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHJlc291cmNlJGpzY29tcCQwID0gW107XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlJGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgcHVzaFNjcmlwdEltcGwocmVzb3VyY2UkanNjb21wJDAsIHNjcmlwdFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHRFbWJlZGRlZCAmJiB0YXJnZXQkanNjb21wJDAucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDY7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIHZhciBpbnNlcnRpb25Nb2RlJGpzY29tcCQwID0gZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLFxuICAgICAgICAgICAgbm9zY3JpcHRUYWdJblNjb3BlJGpzY29tcCQwID0gISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDEpO1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBcImNoaWxkcmVuXCIpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDcgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgY2hpbGQkanNjb21wJDAgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ3KVxuICAgICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ3Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyBjaGlsZHJlbiRqc2NvbXAkN1swXVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkNztcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgY2hpbGQkanNjb21wJDAgfHxcbiAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShjaGlsZCRqc2NvbXAkMCkpICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3QgY2hpbGRyZW4gb2YgPHN0eWxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIG9iamVjdCB3aXRoIGEgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kICVzIGluc3RlYWQuIEluIGJyb3dzZXJzIHN0eWxlIEVsZW1lbnRzIGNhbiBvbmx5IGhhdmUgYFRleHRgIE5vZGVzIGFzIGNoaWxkcmVuLlwiLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICA/IFwiYSBGdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICA6IFwic3ltYm9sXCIgPT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICA/IFwiYSBTeWJtb2xcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiYW4gQXJyYXlcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJlY2VkZW5jZSRqc2NvbXAkMCA9IHByb3BzLnByZWNlZGVuY2UsXG4gICAgICAgICAgICBocmVmJGpzY29tcCQwID0gcHJvcHMuaHJlZjtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpbnNlcnRpb25Nb2RlJGpzY29tcCQwID09PSBTVkdfTU9ERSB8fFxuICAgICAgICAgICAgbm9zY3JpcHRUYWdJblNjb3BlJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBudWxsICE9IHByb3BzLml0ZW1Qcm9wIHx8XG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJlY2VkZW5jZSRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGhyZWYkanNjb21wJDAgfHxcbiAgICAgICAgICAgIFwiXCIgPT09IGhyZWYkanNjb21wJDBcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJzdHlsZVwiKSk7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDggPSBudWxsLFxuICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDUgPSBudWxsLFxuICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ4O1xuICAgICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQ4IGluIHByb3BzKVxuICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkOCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ4ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkOF07XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ4KVxuICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ4ID0gcHJvcFZhbHVlJGpzY29tcCQ4O1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDUgPSBwcm9wVmFsdWUkanNjb21wJDg7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDhcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICAgIHZhciBjaGlsZCRqc2NvbXAkMSA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4kanNjb21wJDgpXG4gICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ4Lmxlbmd0aFxuICAgICAgICAgICAgICAgID8gY2hpbGRyZW4kanNjb21wJDhbMF1cbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkODtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNoaWxkJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjaGlsZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICB2b2lkIDAgIT09IGNoaWxkJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVzY2FwZVN0eWxlVGV4dENvbnRlbnQoY2hpbGQkanNjb21wJDEpKTtcbiAgICAgICAgICAgIHB1c2hJbm5lckhUTUwoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ1LFxuICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZENodW5rRm9yVGFnKFwic3R5bGVcIikpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNyA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhyZWYkanNjb21wJDAuaW5jbHVkZXMoXCIgXCIpICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1JlYWN0IGV4cGVjdGVkIHRoZSBgaHJlZmAgcHJvcCBmb3IgYSA8c3R5bGU+IHRhZyBvcHRpbmcgaW50byBob2lzdGluZyBzZW1hbnRpY3MgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHRvIG5vdCBoYXZlIGFueSBzcGFjZXMgYnV0IGVjb3VudGVyZWQgc3BhY2VzIGluc3RlYWQuIHVzaW5nIHNwYWNlcyBpbiB0aGlzIHByb3Agd2lsbCBjYXVzZSBoeWRyYXRpb24gb2YgdGhpcyBzdHlsZSB0byBmYWlsIG9uIHRoZSBjbGllbnQuIFRoZSBocmVmIGZvciB0aGUgPHN0eWxlPiB3aGVyZSB0aGlzIG9jdXJyZWQgaXMgXCIlc1wiLicsXG4gICAgICAgICAgICAgICAgaHJlZiRqc2NvbXAkMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIHN0eWxlUXVldWUkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5nZXQocHJlY2VkZW5jZSRqc2NvbXAkMCksXG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUkanNjb21wJDEgPVxuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYkanNjb21wJDApXG4gICAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWYkanNjb21wJDBdXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlJGpzY29tcCQxICE9PSBFWElTVFMpIHtcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNbaHJlZiRqc2NvbXAkMF0gPSBFWElTVFM7XG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUkanNjb21wJDEgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ1JlYWN0IGVuY291bnRlcmVkIGEgaG9pc3RhYmxlIHN0eWxlIHRhZyBmb3IgdGhlIHNhbWUgaHJlZiBhcyBhIHByZWxvYWQ6IFwiJXNcIi4gV2hlbiB1c2luZyBhIHN0eWxlIHRhZyB0byBpbmxpbmUgc3R5bGVzIHlvdSBzaG91bGQgbm90IGFsc28gcHJlbG9hZCBpdCBhcyBhIHN0eWxzaGVldC4nLFxuICAgICAgICAgICAgICAgICAgaHJlZiRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHN0eWxlUXVldWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICA/IHN0eWxlUXVldWUkanNjb21wJDAuaHJlZnMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZiRqc2NvbXAkMClcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6ICgoc3R5bGVRdWV1ZSRqc2NvbXAkMCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSRqc2NvbXAkMCksXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaHJlZnM6IFtlc2NhcGVUZXh0Rm9yQnJvd3NlcihocmVmJGpzY29tcCQwKV0sXG4gICAgICAgICAgICAgICAgICAgIHNoZWV0czogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5zZXQoXG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2UkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlUXVldWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gc3R5bGVRdWV1ZSRqc2NvbXAkMC5ydWxlcyxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkOSA9IG51bGwsXG4gICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ2ID0gbnVsbCxcbiAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ5O1xuICAgICAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDkgaW4gcHJvcHMpXG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDkpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ5ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkOV07XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDkpXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkOSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDkgPSBwcm9wVmFsdWUkanNjb21wJDk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNiA9IHByb3BWYWx1ZSRqc2NvbXAkOTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGNoaWxkJGpzY29tcCQyID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbiRqc2NvbXAkOSlcbiAgICAgICAgICAgICAgICA/IDIgPiBjaGlsZHJlbiRqc2NvbXAkOS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gY2hpbGRyZW4kanNjb21wJDlbMF1cbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICAgIDogY2hpbGRyZW4kanNjb21wJDk7XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNoaWxkJGpzY29tcCQyICYmXG4gICAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIGNoaWxkJGpzY29tcCQyICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGNoaWxkJGpzY29tcCQyICYmXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goZXNjYXBlU3R5bGVUZXh0Q29udGVudChjaGlsZCRqc2NvbXAkMikpO1xuICAgICAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MJGpzY29tcCQ2LCBjaGlsZHJlbiRqc2NvbXAkOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVF1ZXVlJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlLnN0eWxlcy5hZGQoc3R5bGVRdWV1ZSRqc2NvbXAkMCk7XG4gICAgICAgICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDcgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDc7XG4gICAgICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBTVkdfTU9ERSB8fFxuICAgICAgICAgICAgZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDEgfHxcbiAgICAgICAgICAgIG51bGwgIT0gcHJvcHMuaXRlbVByb3BcbiAgICAgICAgICApXG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ4ID0gcHVzaFNlbGZDbG9zaW5nKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcIm1ldGFcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2godGV4dFNlcGFyYXRvciksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDggPSBpc0ZhbGxiYWNrXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMuY2hhclNldFxuICAgICAgICAgICAgICAgICAgPyBwdXNoU2VsZkNsb3NpbmcocmVuZGVyU3RhdGUuY2hhcnNldENodW5rcywgcHJvcHMsIFwibWV0YVwiKVxuICAgICAgICAgICAgICAgICAgOiBcInZpZXdwb3J0XCIgPT09IHByb3BzLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyBwdXNoU2VsZkNsb3NpbmcocmVuZGVyU3RhdGUudmlld3BvcnRDaHVua3MsIHByb3BzLCBcIm1ldGFcIilcbiAgICAgICAgICAgICAgICAgICAgOiBwdXNoU2VsZkNsb3NpbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWV0YVwiXG4gICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkODtcbiAgICAgICAgY2FzZSBcImxpc3RpbmdcIjpcbiAgICAgICAgY2FzZSBcInByZVwiOlxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodHlwZSkpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMTAgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ3ID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDEwO1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMTAgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMTApKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDEwID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkMTBdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDEwKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkMTApIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMTAgPSBwcm9wVmFsdWUkanNjb21wJDEwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDcgPSBwcm9wVmFsdWUkanNjb21wJDEwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDEwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkMTBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgaWYgKG51bGwgIT0gaW5uZXJIVE1MJGpzY29tcCQ3KSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSBjaGlsZHJlbiRqc2NvbXAkMTApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIGlubmVySFRNTCRqc2NvbXAkNyB8fFxuICAgICAgICAgICAgICAhKFwiX19odG1sXCIgaW4gaW5uZXJIVE1MJGpzY29tcCQ3KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0LmRldi9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IGlubmVySFRNTCRqc2NvbXAkNy5fX2h0bWw7XG4gICAgICAgICAgICBudWxsICE9PSBodG1sICYmXG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gaHRtbCAmJlxuICAgICAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGh0bWwgJiYgMCA8IGh0bWwubGVuZ3RoICYmIFwiXFxuXCIgPT09IGh0bWxbMF1cbiAgICAgICAgICAgICAgICA/IHRhcmdldCRqc2NvbXAkMC5wdXNoKGxlYWRpbmdOZXdsaW5lLCBodG1sKVxuICAgICAgICAgICAgICAgIDogKGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGh0bWwpLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goXCJcIiArIGh0bWwpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbiRqc2NvbXAkMTAgJiZcbiAgICAgICAgICAgIFwiXFxuXCIgPT09IGNoaWxkcmVuJGpzY29tcCQxMFswXSAmJlxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2gobGVhZGluZ05ld2xpbmUpO1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbiRqc2NvbXAkMTA7XG4gICAgICAgIGNhc2UgXCJpbWdcIjpcbiAgICAgICAgICB2YXIgc3JjID0gcHJvcHMuc3JjLFxuICAgICAgICAgICAgc3JjU2V0ID0gcHJvcHMuc3JjU2V0O1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgIFwibGF6eVwiID09PSBwcm9wcy5sb2FkaW5nIHx8XG4gICAgICAgICAgICAgICghc3JjICYmICFzcmNTZXQpIHx8XG4gICAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygc3JjICYmIG51bGwgIT0gc3JjKSB8fFxuICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHNyY1NldCAmJiBudWxsICE9IHNyY1NldClcbiAgICAgICAgICAgICkgJiZcbiAgICAgICAgICAgIFwibG93XCIgIT09IHByb3BzLmZldGNoUHJpb3JpdHkgJiZcbiAgICAgICAgICAgICExID09PSAhIShmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMykgJiZcbiAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygc3JjIHx8XG4gICAgICAgICAgICAgIFwiOlwiICE9PSBzcmNbNF0gfHxcbiAgICAgICAgICAgICAgKFwiZFwiICE9PSBzcmNbMF0gJiYgXCJEXCIgIT09IHNyY1swXSkgfHxcbiAgICAgICAgICAgICAgKFwiYVwiICE9PSBzcmNbMV0gJiYgXCJBXCIgIT09IHNyY1sxXSkgfHxcbiAgICAgICAgICAgICAgKFwidFwiICE9PSBzcmNbMl0gJiYgXCJUXCIgIT09IHNyY1syXSkgfHxcbiAgICAgICAgICAgICAgKFwiYVwiICE9PSBzcmNbM10gJiYgXCJBXCIgIT09IHNyY1szXSkpICYmXG4gICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHNyY1NldCB8fFxuICAgICAgICAgICAgICBcIjpcIiAhPT0gc3JjU2V0WzRdIHx8XG4gICAgICAgICAgICAgIChcImRcIiAhPT0gc3JjU2V0WzBdICYmIFwiRFwiICE9PSBzcmNTZXRbMF0pIHx8XG4gICAgICAgICAgICAgIChcImFcIiAhPT0gc3JjU2V0WzFdICYmIFwiQVwiICE9PSBzcmNTZXRbMV0pIHx8XG4gICAgICAgICAgICAgIChcInRcIiAhPT0gc3JjU2V0WzJdICYmIFwiVFwiICE9PSBzcmNTZXRbMl0pIHx8XG4gICAgICAgICAgICAgIChcImFcIiAhPT0gc3JjU2V0WzNdICYmIFwiQVwiICE9PSBzcmNTZXRbM10pKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHNpemVzID0gXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLnNpemVzID8gcHJvcHMuc2l6ZXMgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIGtleSRqc2NvbXAkMCA9IHNyY1NldCA/IHNyY1NldCArIFwiXFxuXCIgKyAoc2l6ZXMgfHwgXCJcIikgOiBzcmMsXG4gICAgICAgICAgICAgIHByb21vdGFibGVQcmVsb2FkcyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLmltYWdlcyxcbiAgICAgICAgICAgICAgcmVzb3VyY2UkanNjb21wJDEgPSBwcm9tb3RhYmxlUHJlbG9hZHMuZ2V0KGtleSRqc2NvbXAkMCk7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2UkanNjb21wJDEpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwiaGlnaFwiID09PSBwcm9wcy5mZXRjaFByaW9yaXR5IHx8XG4gICAgICAgICAgICAgICAgMTAgPiByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5zaXplXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBwcm9tb3RhYmxlUHJlbG9hZHMuZGVsZXRlKGtleSRqc2NvbXAkMCksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5hZGQocmVzb3VyY2UkanNjb21wJDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgIXJlc3VtYWJsZVN0YXRlLmltYWdlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSRqc2NvbXAkMClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlc1trZXkkanNjb21wJDBdID0gUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICAgICAgdmFyIGlucHV0ID0gcHJvcHMuY3Jvc3NPcmlnaW47XG4gICAgICAgICAgICAgIHZhciBjcm9zc09yaWdpbiA9XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlucHV0XG4gICAgICAgICAgICAgICAgICA/IFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IGlucHV0XG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGhlYWRlcjtcbiAgICAgICAgICAgICAgaGVhZGVycyAmJlxuICAgICAgICAgICAgICAwIDwgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAmJlxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJvcHMuc3JjU2V0ICYmXG4gICAgICAgICAgICAgIChcImhpZ2hcIiA9PT0gcHJvcHMuZmV0Y2hQcmlvcml0eSB8fFxuICAgICAgICAgICAgICAgIDUwMCA+IGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMubGVuZ3RoKSAmJlxuICAgICAgICAgICAgICAoKGhlYWRlciA9IGdldFByZWxvYWRBc0hlYWRlcihzcmMsIFwiaW1hZ2VcIiwge1xuICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0OiBwcm9wcy5zcmNTZXQsXG4gICAgICAgICAgICAgICAgaW1hZ2VTaXplczogcHJvcHMuc2l6ZXMsXG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICAgICAgICAgIG5vbmNlOiBwcm9wcy5ub25jZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBwcm9wcy50eXBlLFxuICAgICAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgICAgICAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHByb3BzLnJlZmVyZXJQb2xpY3lcbiAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAwIDw9IChoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGggKyAyKSlcbiAgICAgICAgICAgICAgICA/ICgocmVuZGVyU3RhdGUucmVzZXRzLmltYWdlW2tleSRqc2NvbXAkMF0gPSBQUkVMT0FEX05PX0NSRURTKSxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgKGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgIChoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICs9IGhlYWRlcikpXG4gICAgICAgICAgICAgICAgOiAoKHJlc291cmNlJGpzY29tcCQxID0gW10pLFxuICAgICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKHJlc291cmNlJGpzY29tcCQxLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgICAgICAgICAgICAgIGFzOiBcImltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IHNyY1NldCA/IHZvaWQgMCA6IHNyYyxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQ6IHNyY1NldCxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTaXplczogc2l6ZXMsXG4gICAgICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyaXR5OiBwcm9wcy5pbnRlZ3JpdHksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHByb3BzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgICAgICAgICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICBcImhpZ2hcIiA9PT0gcHJvcHMuZmV0Y2hQcmlvcml0eSB8fFxuICAgICAgICAgICAgICAgICAgMTAgPiByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5zaXplXG4gICAgICAgICAgICAgICAgICAgID8gcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc291cmNlJGpzY29tcCQxKVxuICAgICAgICAgICAgICAgICAgICA6IChyZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKHJlc291cmNlJGpzY29tcCQxKSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9tb3RhYmxlUHJlbG9hZHMuc2V0KGtleSRqc2NvbXAkMCwgcmVzb3VyY2UkanNjb21wJDEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0JGpzY29tcCQwLCBwcm9wcywgXCJpbWdcIik7XG4gICAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICAgIGNhc2UgXCJhcmVhXCI6XG4gICAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICBjYXNlIFwiY29sXCI6XG4gICAgICAgIGNhc2UgXCJlbWJlZFwiOlxuICAgICAgICBjYXNlIFwiaHJcIjpcbiAgICAgICAgY2FzZSBcImtleWdlblwiOlxuICAgICAgICBjYXNlIFwicGFyYW1cIjpcbiAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICBjYXNlIFwidHJhY2tcIjpcbiAgICAgICAgY2FzZSBcIndiclwiOlxuICAgICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0JGpzY29tcCQwLCBwcm9wcywgdHlwZSk7XG4gICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uLXhtbFwiOlxuICAgICAgICBjYXNlIFwiY29sb3ItcHJvZmlsZVwiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2Utc3JjXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2UtdXJpXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2UtbmFtZVwiOlxuICAgICAgICBjYXNlIFwibWlzc2luZy1nbHlwaFwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgICAgIGlmIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPCBIVE1MX01PREUpIHtcbiAgICAgICAgICAgIHZhciBwcmVhbWJsZSA9IHByZWFtYmxlU3RhdGUgfHwgcmVuZGVyU3RhdGUucHJlYW1ibGU7XG4gICAgICAgICAgICBpZiAocHJlYW1ibGUuaGVhZENodW5rcylcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgYDxoZWFkPmAgdGFnIG1heSBvbmx5IGJlIHJlbmRlcmVkIG9uY2UuXCIpO1xuICAgICAgICAgICAgcHJlYW1ibGUuaGVhZENodW5rcyA9IFtdO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOSA9IHB1c2hTdGFydFNpbmdsZXRvbkVsZW1lbnQoXG4gICAgICAgICAgICAgIHByZWFtYmxlLmhlYWRDaHVua3MsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImhlYWRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOSA9IHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImhlYWRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ5O1xuICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgIGlmIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPCBIVE1MX01PREUpIHtcbiAgICAgICAgICAgIHZhciBwcmVhbWJsZSRqc2NvbXAkMCA9IHByZWFtYmxlU3RhdGUgfHwgcmVuZGVyU3RhdGUucHJlYW1ibGU7XG4gICAgICAgICAgICBpZiAocHJlYW1ibGUkanNjb21wJDAuYm9keUNodW5rcylcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgYDxib2R5PmAgdGFnIG1heSBvbmx5IGJlIHJlbmRlcmVkIG9uY2UuXCIpO1xuICAgICAgICAgICAgcHJlYW1ibGUkanNjb21wJDAuYm9keUNodW5rcyA9IFtdO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTAgPSBwdXNoU3RhcnRTaW5nbGV0b25FbGVtZW50KFxuICAgICAgICAgICAgICBwcmVhbWJsZSRqc2NvbXAkMC5ib2R5Q2h1bmtzLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJib2R5XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDEwID0gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIFwiYm9keVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDEwO1xuICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgIGlmIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFKSB7XG4gICAgICAgICAgICB2YXIgcHJlYW1ibGUkanNjb21wJDEgPSBwcmVhbWJsZVN0YXRlIHx8IHJlbmRlclN0YXRlLnByZWFtYmxlO1xuICAgICAgICAgICAgaWYgKHByZWFtYmxlJGpzY29tcCQxLmh0bWxDaHVua3MpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIGA8aHRtbD5gIHRhZyBtYXkgb25seSBiZSByZW5kZXJlZCBvbmNlLlwiKTtcbiAgICAgICAgICAgIHByZWFtYmxlJGpzY29tcCQxLmh0bWxDaHVua3MgPSBbZG9jdHlwZUNodW5rXTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDExID0gcHVzaFN0YXJ0U2luZ2xldG9uRWxlbWVudChcbiAgICAgICAgICAgICAgcHJlYW1ibGUkanNjb21wJDEuaHRtbENodW5rcyxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIFwiaHRtbFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMSA9IHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImh0bWxcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoLTEgIT09IHR5cGUuaW5kZXhPZihcIi1cIikpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodHlwZSkpO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQxMSA9IG51bGwsXG4gICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkOCA9IG51bGwsXG4gICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDExO1xuICAgICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQxMSBpbiBwcm9wcylcbiAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDExKSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDExID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkMTFdO1xuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMTEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcEtleSRqc2NvbXAkMTE7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDExKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQxMSA9IHByb3BWYWx1ZSRqc2NvbXAkMTE7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkOCA9IHByb3BWYWx1ZSRqc2NvbXAkMTE7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIHByb3BWYWx1ZSRqc2NvbXAkMTEpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlZlwiOlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2xhc3NOYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IFwiY2xhc3NcIjtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0F0dHJpYnV0ZU5hbWVTYWZlKHByb3BLZXkkanNjb21wJDExKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcHJvcFZhbHVlJGpzY29tcCQxMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHByb3BWYWx1ZSRqc2NvbXAkMTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICExICE9PSBwcm9wVmFsdWUkanNjb21wJDExXG4gICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgPT09IHByb3BWYWx1ZSRqc2NvbXAkMTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkMTEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHByb3BWYWx1ZSRqc2NvbXAkMTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihwcm9wVmFsdWUkanNjb21wJDExKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgICAgcHVzaElubmVySFRNTChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDgsXG4gICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQxMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbiRqc2NvbXAkMTE7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHRhcmdldCRqc2NvbXAkMCwgcHJvcHMsIHR5cGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmRDaHVua0ZvclRhZyh0YWcpIHtcbiAgICAgIHZhciBjaHVuayA9IGVuZFRhZ0NhY2hlLmdldCh0YWcpO1xuICAgICAgdm9pZCAwID09PSBjaHVuayAmJlxuICAgICAgICAoKGNodW5rID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPC9cIiArIHRhZyArIFwiPlwiKSksXG4gICAgICAgIGVuZFRhZ0NhY2hlLnNldCh0YWcsIGNodW5rKSk7XG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvaXN0UHJlYW1ibGVTdGF0ZShyZW5kZXJTdGF0ZSwgcHJlYW1ibGVTdGF0ZSkge1xuICAgICAgcmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZS5wcmVhbWJsZTtcbiAgICAgIG51bGwgPT09IHJlbmRlclN0YXRlLmh0bWxDaHVua3MgJiZcbiAgICAgICAgcHJlYW1ibGVTdGF0ZS5odG1sQ2h1bmtzICYmXG4gICAgICAgICgocmVuZGVyU3RhdGUuaHRtbENodW5rcyA9IHByZWFtYmxlU3RhdGUuaHRtbENodW5rcyksXG4gICAgICAgIChwcmVhbWJsZVN0YXRlLmNvbnRyaWJ1dGlvbiB8PSAxKSk7XG4gICAgICBudWxsID09PSByZW5kZXJTdGF0ZS5oZWFkQ2h1bmtzICYmXG4gICAgICAgIHByZWFtYmxlU3RhdGUuaGVhZENodW5rcyAmJlxuICAgICAgICAoKHJlbmRlclN0YXRlLmhlYWRDaHVua3MgPSBwcmVhbWJsZVN0YXRlLmhlYWRDaHVua3MpLFxuICAgICAgICAocHJlYW1ibGVTdGF0ZS5jb250cmlidXRpb24gfD0gNCkpO1xuICAgICAgbnVsbCA9PT0gcmVuZGVyU3RhdGUuYm9keUNodW5rcyAmJlxuICAgICAgICBwcmVhbWJsZVN0YXRlLmJvZHlDaHVua3MgJiZcbiAgICAgICAgKChyZW5kZXJTdGF0ZS5ib2R5Q2h1bmtzID0gcHJlYW1ibGVTdGF0ZS5ib2R5Q2h1bmtzKSxcbiAgICAgICAgKHByZWFtYmxlU3RhdGUuY29udHJpYnV0aW9uIHw9IDIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gICAgICByZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlLmJvb3RzdHJhcENodW5rcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVuZGVyU3RhdGUubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZVtpXSk7XG4gICAgICByZXR1cm4gaSA8IHJlbmRlclN0YXRlLmxlbmd0aFxuICAgICAgICA/ICgoaSA9IHJlbmRlclN0YXRlW2ldKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUubGVuZ3RoID0gMCksXG4gICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgaSkpXG4gICAgICAgIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUsIGlkKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MSk7XG4gICAgICBpZiAobnVsbCA9PT0gaWQpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQW4gSUQgbXVzdCBoYXZlIGJlZW4gYXNzaWduZWQgYmVmb3JlIHdlIGNhbiBjb21wbGV0ZSB0aGUgYm91bmRhcnkuXCJcbiAgICAgICAgKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLmJvdW5kYXJ5UHJlZml4KTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGlkLnRvU3RyaW5nKDE2KSk7XG4gICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVByZWFtYmxlQ29udHJpYnV0aW9uKGRlc3RpbmF0aW9uLCBwcmVhbWJsZVN0YXRlKSB7XG4gICAgICBwcmVhbWJsZVN0YXRlID0gcHJlYW1ibGVTdGF0ZS5jb250cmlidXRpb247XG4gICAgICBwcmVhbWJsZVN0YXRlICE9PSBOb0NvbnRyaWJ1dGlvbiAmJlxuICAgICAgICAod3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYm91bmRhcnlQcmVhbWJsZUNvbnRyaWJ1dGlvbkNodW5rU3RhcnQpLFxuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBcIlwiICsgcHJlYW1ibGVTdGF0ZSksXG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGJvdW5kYXJ5UHJlYW1ibGVDb250cmlidXRpb25DaHVua0VuZCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVN0YXJ0U2VnbWVudChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUsIGZvcm1hdENvbnRleHQsIGlkKSB7XG4gICAgICBzd2l0Y2ggKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSkge1xuICAgICAgICBjYXNlIFJPT1RfSFRNTF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfSFRNTF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfSEVBRF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50SFRNTCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRIVE1MMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFNWR19NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRTVkcpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBpZC50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50U1ZHMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIE1BVEhNTF9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRNYXRoTUwpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBpZC50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50TWF0aE1MMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGUpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBpZC50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGUyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9CT0RZX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlQm9keSksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZUJvZHkyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9ST1dfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVSb3cpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBpZC50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVSb3cyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSFRNTF9DT0xHUk9VUF9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRDb2xHcm91cCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRDb2xHcm91cDIpXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gaW5zZXJ0aW9uIG1vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUVuZFNlZ21lbnQoZGVzdGluYXRpb24sIGZvcm1hdENvbnRleHQpIHtcbiAgICAgIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgICAgIGNhc2UgUk9PVF9IVE1MX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9IVE1MX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9IRUFEX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50SFRNTCk7XG4gICAgICAgIGNhc2UgU1ZHX01PREU6XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRTVkcpO1xuICAgICAgICBjYXNlIE1BVEhNTF9NT0RFOlxuICAgICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50TWF0aE1MKTtcbiAgICAgICAgY2FzZSBIVE1MX1RBQkxFX01PREU6XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRUYWJsZSk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9CT0RZX01PREU6XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRUYWJsZUJvZHkpO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfUk9XX01PREU6XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRUYWJsZVJvdyk7XG4gICAgICAgIGNhc2UgSFRNTF9DT0xHUk9VUF9NT0RFOlxuICAgICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50Q29sR3JvdXApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biBpbnNlcnRpb24gbW9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGlucHV0KS5yZXBsYWNlKFxuICAgICAgICByZWdleEZvckpTU3RyaW5nc0luSW5zdHJ1Y3Rpb25TY3JpcHRzLFxuICAgICAgICBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2NcIjtcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI4XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MjAyOFwiO1xuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3RcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbnB1dCkucmVwbGFjZShcbiAgICAgICAgcmVnZXhGb3JKU1N0cmluZ3NJblNjcmlwdHMsXG4gICAgICAgIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNhc2UgXCImXCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MDAyNlwiO1xuICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDNlXCI7XG4gICAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2NcIjtcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI4XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MjAyOFwiO1xuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN0eWxlVGFnc0xhdGVGb3JCb3VuZGFyeShzdHlsZVF1ZXVlKSB7XG4gICAgICB2YXIgcnVsZXMgPSBzdHlsZVF1ZXVlLnJ1bGVzLFxuICAgICAgICBocmVmcyA9IHN0eWxlUXVldWUuaHJlZnM7XG4gICAgICAwIDwgcnVsZXMubGVuZ3RoICYmXG4gICAgICAgIDAgPT09IGhyZWZzLmxlbmd0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3QgZXhwZWN0ZWQgdG8gaGF2ZSBhdCBsZWFzdCBvbmUgaHJlZiBmb3IgYW4gYSBob2lzdGFibGUgc3R5bGUgYnV0IGZvdW5kIG5vbmUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGlmIChocmVmcy5sZW5ndGgpIHtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVF1ZXVlLnByZWNlZGVuY2UpO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHdyaXRlQ2h1bmsodGhpcywgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMik7XG4gICAgICAgICAgaSA8IGhyZWZzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaSsrXG4gICAgICAgIClcbiAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIGhyZWZzW2ldKSwgd3JpdGVDaHVuayh0aGlzLCBzcGFjZVNlcGFyYXRvcik7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgaHJlZnNbaV0pO1xuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHdyaXRlQ2h1bmsodGhpcywgcnVsZXNbaV0pO1xuICAgICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gd3JpdGVDaHVua0FuZFJldHVybihcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGxhdGVTdHlsZVRhZ1RlbXBsYXRlQ2xvc2VcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gITA7XG4gICAgICAgIHJ1bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGhyZWZzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1N0eWxlc1RvSG9pc3Qoc3R5bGVzaGVldCkge1xuICAgICAgcmV0dXJuIHN0eWxlc2hlZXQuc3RhdGUgIT09IFBSRUFNQkxFXG4gICAgICAgID8gKGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9ICEwKVxuICAgICAgICA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUhvaXN0YWJsZXNGb3JCb3VuZGFyeShcbiAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgaG9pc3RhYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZVxuICAgICkge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gITE7XG4gICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gITA7XG4gICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXMuZm9yRWFjaChmbHVzaFN0eWxlVGFnc0xhdGVGb3JCb3VuZGFyeSwgZGVzdGluYXRpb24pO1xuICAgICAgaG9pc3RhYmxlU3RhdGUuc3R5bGVzaGVldHMuZm9yRWFjaChoYXNTdHlsZXNUb0hvaXN0KTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCAmJlxuICAgICAgICAocmVuZGVyU3RhdGUuc3R5bGVzVG9Ib2lzdCA9ICEwKTtcbiAgICAgIHJldHVybiBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFJlc291cmNlKHJlc291cmNlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc291cmNlLmxlbmd0aDsgaSsrKSB3cml0ZUNodW5rKHRoaXMsIHJlc291cmNlW2ldKTtcbiAgICAgIHJlc291cmNlLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3R5bGVJblByZWFtYmxlKHN0eWxlc2hlZXQpIHtcbiAgICAgIHB1c2hMaW5rSW1wbChzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZSwgc3R5bGVzaGVldC5wcm9wcyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLmxlbmd0aDsgaSsrKVxuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlW2ldKTtcbiAgICAgIHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICBzdHlsZXNoZWV0LnN0YXRlID0gUFJFQU1CTEU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3R5bGVzSW5QcmVhbWJsZShzdHlsZVF1ZXVlKSB7XG4gICAgICB2YXIgaGFzU3R5bGVzaGVldHMgPSAwIDwgc3R5bGVRdWV1ZS5zaGVldHMuc2l6ZTtcbiAgICAgIHN0eWxlUXVldWUuc2hlZXRzLmZvckVhY2goZmx1c2hTdHlsZUluUHJlYW1ibGUsIHRoaXMpO1xuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuY2xlYXIoKTtcbiAgICAgIHZhciBydWxlcyA9IHN0eWxlUXVldWUucnVsZXMsXG4gICAgICAgIGhyZWZzID0gc3R5bGVRdWV1ZS5ocmVmcztcbiAgICAgIGlmICghaGFzU3R5bGVzaGVldHMgfHwgaHJlZnMubGVuZ3RoKSB7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVF1ZXVlLnByZWNlZGVuY2UpO1xuICAgICAgICBzdHlsZVF1ZXVlID0gMDtcbiAgICAgICAgaWYgKGhyZWZzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMik7XG4gICAgICAgICAgICBzdHlsZVF1ZXVlIDwgaHJlZnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHN0eWxlUXVldWUrK1xuICAgICAgICAgIClcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsodGhpcywgaHJlZnNbc3R5bGVRdWV1ZV0pLFxuICAgICAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHNwYWNlU2VwYXJhdG9yKTtcbiAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIGhyZWZzW3N0eWxlUXVldWVdKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG4gICAgICAgIGZvciAoc3R5bGVRdWV1ZSA9IDA7IHN0eWxlUXVldWUgPCBydWxlcy5sZW5ndGg7IHN0eWxlUXVldWUrKylcbiAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHJ1bGVzW3N0eWxlUXVldWVdKTtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVRhZ1Jlc291cmNlQ2xvc2UpO1xuICAgICAgICBydWxlcy5sZW5ndGggPSAwO1xuICAgICAgICBocmVmcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkTGF0ZVN0eWxlKHN0eWxlc2hlZXQpIHtcbiAgICAgIGlmIChzdHlsZXNoZWV0LnN0YXRlID09PSBQRU5ESU5HJDEpIHtcbiAgICAgICAgc3R5bGVzaGVldC5zdGF0ZSA9IFBSRUxPQURFRDtcbiAgICAgICAgdmFyIHByb3BzID0gc3R5bGVzaGVldC5wcm9wcztcbiAgICAgICAgcHVzaExpbmtJbXBsKHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLCB7XG4gICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICBhczogXCJzdHlsZVwiLFxuICAgICAgICAgIGhyZWY6IHN0eWxlc2hlZXQucHJvcHMuaHJlZixcbiAgICAgICAgICBjcm9zc09yaWdpbjogcHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgZmV0Y2hQcmlvcml0eTogcHJvcHMuZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICAgICAgICBtZWRpYTogcHJvcHMubWVkaWEsXG4gICAgICAgICAgaHJlZkxhbmc6IHByb3BzLmhyZWZMYW5nLFxuICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBzdHlsZXNoZWV0ID0gMDtcbiAgICAgICAgICBzdHlsZXNoZWV0IDwgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoO1xuICAgICAgICAgIHN0eWxlc2hlZXQrK1xuICAgICAgICApXG4gICAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZVtzdHlsZXNoZWV0XSk7XG4gICAgICAgIHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWxvYWRMYXRlU3R5bGVzKHN0eWxlUXVldWUpIHtcbiAgICAgIHN0eWxlUXVldWUuc2hlZXRzLmZvckVhY2gocHJlbG9hZExhdGVTdHlsZSwgdGhpcyk7XG4gICAgICBzdHlsZVF1ZXVlLnNoZWV0cy5jbGVhcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkpTKGRlc3RpbmF0aW9uLCBob2lzdGFibGVTdGF0ZSkge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlGaXJzdE9wZW5CcmFja2V0KTtcbiAgICAgIHZhciBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5Rmlyc3RPcGVuQnJhY2tldDtcbiAgICAgIGhvaXN0YWJsZVN0YXRlLnN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgICAgIGlmIChyZXNvdXJjZS5zdGF0ZSAhPT0gUFJFQU1CTEUpXG4gICAgICAgICAgaWYgKHJlc291cmNlLnN0YXRlID09PSBMQVRFKVxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspLFxuICAgICAgICAgICAgICAocmVzb3VyY2UgPSByZXNvdXJjZS5wcm9wcy5ocmVmKSxcbiAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihyZXNvdXJjZSwgXCJocmVmXCIpLFxuICAgICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgIGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKFwiXCIgKyByZXNvdXJjZSlcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpLFxuICAgICAgICAgICAgICAobmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayk7XG4gICAgICAgICAgICB2YXIgcHJlY2VkZW5jZSA9IHJlc291cmNlLnByb3BzW1wiZGF0YS1wcmVjZWRlbmNlXCJdLFxuICAgICAgICAgICAgICBwcm9wcyA9IHJlc291cmNlLnByb3BzLFxuICAgICAgICAgICAgICBjb2VyY2VkSHJlZiA9IHNhbml0aXplVVJMKFwiXCIgKyByZXNvdXJjZS5wcm9wcy5ocmVmKTtcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICBlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhjb2VyY2VkSHJlZilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHByZWNlZGVuY2UsIFwicHJlY2VkZW5jZVwiKTtcbiAgICAgICAgICAgIHByZWNlZGVuY2UgPSBcIlwiICsgcHJlY2VkZW5jZTtcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICBlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhwcmVjZWRlbmNlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSAmJlxuICAgICAgICAgICAgICAgICgocHJlY2VkZW5jZSA9IHByb3BzW3Byb3BLZXldKSwgbnVsbCAhPSBwcmVjZWRlbmNlKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcInJlbFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcInByZWNlZGVuY2VcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhLXByZWNlZGVuY2VcIjpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImxpbmsgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVTdHlsZVJlc291cmNlQXR0cmlidXRlSW5KUyhcbiAgICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICAgICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgICAgICAgICAgcmVzb3VyY2Uuc3RhdGUgPSBMQVRFO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkpTKGRlc3RpbmF0aW9uLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlIFwiaW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJjbGFzc05hbWVcIjpcbiAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gXCJjbGFzc1wiO1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIG5hbWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgICBpZiAoITEgPT09IHZhbHVlKSByZXR1cm47XG4gICAgICAgICAgbmFtZSA9IFwiXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzcmNcIjpcbiAgICAgICAgY2FzZSBcImhyZWZcIjpcbiAgICAgICAgICB2YWx1ZSA9IHNhbml0aXplVVJMKHZhbHVlKTtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBuYW1lID0gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICgyIDwgbmFtZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgKFwib1wiID09PSBuYW1lWzBdIHx8IFwiT1wiID09PSBuYW1lWzBdKSAmJlxuICAgICAgICAgICAgICAoXCJuXCIgPT09IG5hbWVbMV0gfHwgXCJOXCIgPT09IG5hbWVbMV0pKSB8fFxuICAgICAgICAgICAgIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgbmFtZSA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICBlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhhdHRyaWJ1dGVOYW1lKVxuICAgICAgKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKG5hbWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlSG9pc3RhYmxlU3RhdGUoKSB7XG4gICAgICByZXR1cm4geyBzdHlsZXM6IG5ldyBTZXQoKSwgc3R5bGVzaGVldHM6IG5ldyBTZXQoKSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkQm9vdHN0cmFwU2NyaXB0T3JNb2R1bGUoXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgaHJlZixcbiAgICAgIHByb3BzXG4gICAgKSB7XG4gICAgICAocmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpIHx8XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSkgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnSW50ZXJuYWwgUmVhY3QgRXJyb3I6IFJlYWN0IGV4cGVjdGVkIGJvb3RzdHJhcCBzY3JpcHQgb3IgbW9kdWxlIHdpdGggc3JjIFwiJXNcIiB0byBub3QgaGF2ZSBiZWVuIHByZWxvYWRlZCBhbHJlYWR5LiBwbGVhc2UgZmlsZSBhbiBpc3N1ZScsXG4gICAgICAgICAgaHJlZlxuICAgICAgICApO1xuICAgICAgcmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTO1xuICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTO1xuICAgICAgcmVzdW1hYmxlU3RhdGUgPSBbXTtcbiAgICAgIHB1c2hMaW5rSW1wbChyZXN1bWFibGVTdGF0ZSwgcHJvcHMpO1xuICAgICAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwU2NyaXB0cy5hZGQocmVzdW1hYmxlU3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZG9wdFByZWxvYWRDcmVkZW50aWFscyh0YXJnZXQsIHByZWxvYWRTdGF0ZSkge1xuICAgICAgbnVsbCA9PSB0YXJnZXQuY3Jvc3NPcmlnaW4gJiYgKHRhcmdldC5jcm9zc09yaWdpbiA9IHByZWxvYWRTdGF0ZVswXSk7XG4gICAgICBudWxsID09IHRhcmdldC5pbnRlZ3JpdHkgJiYgKHRhcmdldC5pbnRlZ3JpdHkgPSBwcmVsb2FkU3RhdGVbMV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQcmVsb2FkQXNIZWFkZXIoaHJlZiwgYXMsIHBhcmFtcykge1xuICAgICAgaHJlZiA9IGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmKTtcbiAgICAgIGFzID0gZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KGFzLCBcImFzXCIpO1xuICAgICAgYXMgPSBcIjxcIiArIGhyZWYgKyAnPjsgcmVsPXByZWxvYWQ7IGFzPVwiJyArIGFzICsgJ1wiJztcbiAgICAgIGZvciAodmFyIHBhcmFtTmFtZSBpbiBwYXJhbXMpXG4gICAgICAgIGhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBwYXJhbU5hbWUpICYmXG4gICAgICAgICAgKChocmVmID0gcGFyYW1zW3BhcmFtTmFtZV0pLFxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmXG4gICAgICAgICAgICAoYXMgKz1cbiAgICAgICAgICAgICAgXCI7IFwiICtcbiAgICAgICAgICAgICAgcGFyYW1OYW1lLnRvTG93ZXJDYXNlKCkgK1xuICAgICAgICAgICAgICAnPVwiJyArXG4gICAgICAgICAgICAgIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dChcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZVxuICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgJ1wiJykpO1xuICAgICAgcmV0dXJuIGFzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZklucHV0KSB7XG4gICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKGhyZWZJbnB1dCwgXCJocmVmXCIpO1xuICAgICAgcmV0dXJuIChcIlwiICsgaHJlZklucHV0KS5yZXBsYWNlKFxuICAgICAgICByZWdleEZvckhyZWZJbkxpbmtIZWFkZXJVUkxDb250ZXh0LFxuICAgICAgICBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHRSZXBsYWNlclxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0UmVwbGFjZXIobWF0Y2gpIHtcbiAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICByZXR1cm4gXCIlM0NcIjtcbiAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICByZXR1cm4gXCIlM0VcIjtcbiAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgIHJldHVybiBcIiUwQVwiO1xuICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTBEXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcImVzY2FwZUxpbmtIcmVmRm9ySGVhZGVyQ29udGV4dFJlcGxhY2VyIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdFwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KHZhbHVlLCBuYW1lKSB7XG4gICAgICB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkgJiZcbiAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQgYCVzYCBvcHRpb24gaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0eXBlTmFtZSh2YWx1ZSlcbiAgICAgICAgKSxcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSk7XG4gICAgICByZXR1cm4gKFwiXCIgKyB2YWx1ZSkucmVwbGFjZShcbiAgICAgICAgcmVnZXhGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQsXG4gICAgICAgIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlcihtYXRjaCkge1xuICAgICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgcmV0dXJuIFwiJTIyXCI7XG4gICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTI3XCI7XG4gICAgICAgIGNhc2UgXCI7XCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTNCXCI7XG4gICAgICAgIGNhc2UgXCIsXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTJDXCI7XG4gICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICByZXR1cm4gXCIlMEFcIjtcbiAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgIHJldHVybiBcIiUwRFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlciBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3RcIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvaXN0U3R5bGVRdWV1ZURlcGVuZGVuY3koc3R5bGVRdWV1ZSkge1xuICAgICAgdGhpcy5zdHlsZXMuYWRkKHN0eWxlUXVldWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5KHN0eWxlc2hlZXQpIHtcbiAgICAgIHRoaXMuc3R5bGVzaGVldHMuYWRkKHN0eWxlc2hlZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgbmV4dCkge1xuICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcbiAgICAgICAgcHJldi5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBwcmV2LnBhcmVudFZhbHVlO1xuICAgICAgICBwcmV2ID0gcHJldi5wYXJlbnQ7XG4gICAgICAgIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG4gICAgICAgIGlmIChudWxsID09PSBwcmV2KSB7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHBhcmVudE5leHQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJUaGUgc3RhY2tzIG11c3QgcmVhY2ggdGhlIHJvb3QgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcGFyZW50TmV4dClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIHBhcmVudE5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQuY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wQWxsUHJldmlvdXMocHJldikge1xuICAgICAgcHJldi5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBwcmV2LnBhcmVudFZhbHVlO1xuICAgICAgcHJldiA9IHByZXYucGFyZW50O1xuICAgICAgbnVsbCAhPT0gcHJldiAmJiBwb3BBbGxQcmV2aW91cyhwcmV2KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEFsbE5leHQobmV4dCkge1xuICAgICAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcbiAgICAgIG51bGwgIT09IHBhcmVudE5leHQgJiYgcHVzaEFsbE5leHQocGFyZW50TmV4dCk7XG4gICAgICBuZXh0LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHQudmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFByZXZpb3VzVG9Db21tb25MZXZlbChwcmV2LCBuZXh0KSB7XG4gICAgICBwcmV2LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByZXYucGFyZW50VmFsdWU7XG4gICAgICBwcmV2ID0gcHJldi5wYXJlbnQ7XG4gICAgICBpZiAobnVsbCA9PT0gcHJldilcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUaGUgZGVwdGggbXVzdCBlcXVhbCBhdCBsZWFzdCBhdCB6ZXJvIGJlZm9yZSByZWFjaGluZyB0aGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgcHJldi5kZXB0aCA9PT0gbmV4dC5kZXB0aFxuICAgICAgICA/IHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpXG4gICAgICAgIDogcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBuZXh0KSB7XG4gICAgICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuICAgICAgaWYgKG51bGwgPT09IHBhcmVudE5leHQpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHByZXYuZGVwdGggPT09IHBhcmVudE5leHQuZGVwdGhcbiAgICAgICAgPyBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBwYXJlbnROZXh0KVxuICAgICAgICA6IHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIHBhcmVudE5leHQpO1xuICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0LnZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzd2l0Y2hDb250ZXh0KG5ld1NuYXBzaG90KSB7XG4gICAgICB2YXIgcHJldiA9IGN1cnJlbnRBY3RpdmVTbmFwc2hvdDtcbiAgICAgIHByZXYgIT09IG5ld1NuYXBzaG90ICYmXG4gICAgICAgIChudWxsID09PSBwcmV2XG4gICAgICAgICAgPyBwdXNoQWxsTmV4dChuZXdTbmFwc2hvdClcbiAgICAgICAgICA6IG51bGwgPT09IG5ld1NuYXBzaG90XG4gICAgICAgICAgICA/IHBvcEFsbFByZXZpb3VzKHByZXYpXG4gICAgICAgICAgICA6IHByZXYuZGVwdGggPT09IG5ld1NuYXBzaG90LmRlcHRoXG4gICAgICAgICAgICAgID8gcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgbmV3U25hcHNob3QpXG4gICAgICAgICAgICAgIDogcHJldi5kZXB0aCA+IG5ld1NuYXBzaG90LmRlcHRoXG4gICAgICAgICAgICAgICAgPyBwb3BQcmV2aW91c1RvQ29tbW9uTGV2ZWwocHJldiwgbmV3U25hcHNob3QpXG4gICAgICAgICAgICAgICAgOiBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBuZXdTbmFwc2hvdCksXG4gICAgICAgIChjdXJyZW50QWN0aXZlU25hcHNob3QgPSBuZXdTbmFwc2hvdCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgIGlmIChudWxsICE9PSBjYWxsYmFjayAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgICB2YXIga2V5ID0gU3RyaW5nKGNhbGxiYWNrKTtcbiAgICAgICAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmhhcyhrZXkpIHx8XG4gICAgICAgICAgKGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgICAgIHB1YmxpY0luc3RhbmNlID1cbiAgICAgICAgKChwdWJsaWNJbnN0YW5jZSA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yKSAmJlxuICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShwdWJsaWNJbnN0YW5jZSkpIHx8XG4gICAgICAgIFwiUmVhY3RDbGFzc1wiO1xuICAgICAgdmFyIHdhcm5pbmdLZXkgPSBwdWJsaWNJbnN0YW5jZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcbiAgICAgIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0gfHxcbiAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuIFRoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb3V0c2lkZSBjb21wb25lbnRXaWxsTW91bnQoKSBvbiB0aGUgc2VydmVyLiBUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LlwiLFxuICAgICAgICAgIGNhbGxlck5hbWUsXG4gICAgICAgICAgcHVibGljSW5zdGFuY2VcbiAgICAgICAgKSxcbiAgICAgICAgKGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0gPSAhMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVHJlZUNvbnRleHQoYmFzZUNvbnRleHQsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KSB7XG4gICAgICB2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQgPSBiYXNlQ29udGV4dC5pZDtcbiAgICAgIGJhc2VDb250ZXh0ID0gYmFzZUNvbnRleHQub3ZlcmZsb3c7XG4gICAgICB2YXIgYmFzZUxlbmd0aCA9IDMyIC0gY2x6MzIoYmFzZUlkV2l0aExlYWRpbmdCaXQpIC0gMTtcbiAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ICY9IH4oMSA8PCBiYXNlTGVuZ3RoKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICB2YXIgbGVuZ3RoID0gMzIgLSBjbHozMih0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGg7XG4gICAgICBpZiAoMzAgPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIG51bWJlck9mT3ZlcmZsb3dCaXRzID0gYmFzZUxlbmd0aCAtIChiYXNlTGVuZ3RoICUgNSk7XG4gICAgICAgIGxlbmd0aCA9IChcbiAgICAgICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmXG4gICAgICAgICAgKCgxIDw8IG51bWJlck9mT3ZlcmZsb3dCaXRzKSAtIDEpXG4gICAgICAgICkudG9TdHJpbmcoMzIpO1xuICAgICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCA+Pj0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgICAgIGJhc2VMZW5ndGggLT0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6XG4gICAgICAgICAgICAoMSA8PCAoMzIgLSBjbHozMih0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGgpKSB8XG4gICAgICAgICAgICAoaW5kZXggPDwgYmFzZUxlbmd0aCkgfFxuICAgICAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQsXG4gICAgICAgICAgb3ZlcmZsb3c6IGxlbmd0aCArIGJhc2VDb250ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogKDEgPDwgbGVuZ3RoKSB8IChpbmRleCA8PCBiYXNlTGVuZ3RoKSB8IGJhc2VJZFdpdGhMZWFkaW5nQml0LFxuICAgICAgICBvdmVyZmxvdzogYmFzZUNvbnRleHRcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsejMyRmFsbGJhY2soeCkge1xuICAgICAgeCA+Pj49IDA7XG4gICAgICByZXR1cm4gMCA9PT0geCA/IDMyIDogKDMxIC0gKChsb2coeCkgLyBMTjIpIHwgMCkpIHwgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCQyKCkge31cbiAgICBmdW5jdGlvbiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpIHtcbiAgICAgIGluZGV4ID0gdGhlbmFibGVTdGF0ZVtpbmRleF07XG4gICAgICB2b2lkIDAgPT09IGluZGV4XG4gICAgICAgID8gdGhlbmFibGVTdGF0ZS5wdXNoKHRoZW5hYmxlKVxuICAgICAgICA6IGluZGV4ICE9PSB0aGVuYWJsZSAmJlxuICAgICAgICAgICh0aGVuYWJsZS50aGVuKG5vb3AkMiwgbm9vcCQyKSwgKHRoZW5hYmxlID0gaW5kZXgpKTtcbiAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgIHRocm93IHRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdGhlbmFibGUuc3RhdHVzXG4gICAgICAgICAgICA/IHRoZW5hYmxlLnRoZW4obm9vcCQyLCBub29wJDIpXG4gICAgICAgICAgICA6ICgodGhlbmFibGVTdGF0ZSA9IHRoZW5hYmxlKSxcbiAgICAgICAgICAgICAgKHRoZW5hYmxlU3RhdGUuc3RhdHVzID0gXCJwZW5kaW5nXCIpLFxuICAgICAgICAgICAgICB0aGVuYWJsZVN0YXRlLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGZ1bGZpbGxlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUucmVhc29uID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgIHRocm93IFN1c3BlbnNlRXhjZXB0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpIHtcbiAgICAgIGlmIChudWxsID09PSBzdXNwZW5kZWRUaGVuYWJsZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCBhIHN1c3BlbmRlZCB0aGVuYWJsZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciB0aGVuYWJsZSA9IHN1c3BlbmRlZFRoZW5hYmxlO1xuICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgICByZXR1cm4gKHggPT09IHkgJiYgKDAgIT09IHggfHwgMSAvIHggPT09IDEgLyB5KSkgfHwgKHggIT09IHggJiYgeSAhPT0geSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKSB7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIlxuICAgICAgICApO1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuIFlvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3J1bGVzLW9mLWhvb2tzXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhvb2soKSB7XG4gICAgICBpZiAoMCA8IG51bWJlck9mUmVSZW5kZXJzKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlJlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlclwiKTtcbiAgICAgIHJldHVybiB7IG1lbW9pemVkU3RhdGU6IG51bGwsIHF1ZXVlOiBudWxsLCBuZXh0OiBudWxsIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICA/IG51bGwgPT09IGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICAgICAgPyAoKGlzUmVSZW5kZXIgPSAhMSksXG4gICAgICAgICAgICAoZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVIb29rKCkpKVxuICAgICAgICAgIDogKChpc1JlUmVuZGVyID0gITApLCAod29ya0luUHJvZ3Jlc3NIb29rID0gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2spKVxuICAgICAgICA6IG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9vay5uZXh0XG4gICAgICAgICAgPyAoKGlzUmVSZW5kZXIgPSAhMSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBjcmVhdGVIb29rKCkpKVxuICAgICAgICAgIDogKChpc1JlUmVuZGVyID0gITApLCAod29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQpKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGVuYWJsZVN0YXRlO1xuICAgICAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0SG9va3NTdGF0ZSgpIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aCA9XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3QgPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID1cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID1cbiAgICAgICAgICBudWxsO1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExO1xuICAgICAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAgICAgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCkge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiBJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFjdGlvbiA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgcmVkdWNlciAhPT0gYmFzaWNTdGF0ZVJlZHVjZXIgJiYgKGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCIpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAoaXNSZVJlbmRlcikge1xuICAgICAgICBpbml0ID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlO1xuICAgICAgICBpbml0aWFsQXJnID0gaW5pdC5kaXNwYXRjaDtcbiAgICAgICAgaWYgKG51bGwgIT09IHJlbmRlclBoYXNlVXBkYXRlcykge1xuICAgICAgICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChpbml0KTtcbiAgICAgICAgICBpZiAodm9pZCAwICE9PSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgICAgICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuZGVsZXRlKGluaXQpO1xuICAgICAgICAgICAgaW5pdCA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZS5hY3Rpb247XG4gICAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICEwO1xuICAgICAgICAgICAgICBpbml0ID0gcmVkdWNlcihpbml0LCBhY3Rpb24pO1xuICAgICAgICAgICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMTtcbiAgICAgICAgICAgICAgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dDtcbiAgICAgICAgICAgIH0gd2hpbGUgKG51bGwgIT09IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBpbml0O1xuICAgICAgICAgICAgcmV0dXJuIFtpbml0LCBpbml0aWFsQXJnXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSwgaW5pdGlhbEFyZ107XG4gICAgICB9XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMDtcbiAgICAgIHJlZHVjZXIgPVxuICAgICAgICByZWR1Y2VyID09PSBiYXNpY1N0YXRlUmVkdWNlclxuICAgICAgICAgID8gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5pdGlhbEFyZ1xuICAgICAgICAgICAgPyBpbml0aWFsQXJnKClcbiAgICAgICAgICAgIDogaW5pdGlhbEFyZ1xuICAgICAgICAgIDogdm9pZCAwICE9PSBpbml0XG4gICAgICAgICAgICA/IGluaXQoaW5pdGlhbEFyZylcbiAgICAgICAgICAgIDogaW5pdGlhbEFyZztcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSByZWR1Y2VyO1xuICAgICAgcmVkdWNlciA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZSA9IHsgbGFzdDogbnVsbCwgZGlzcGF0Y2g6IG51bGwgfTtcbiAgICAgIHJlZHVjZXIgPSByZWR1Y2VyLmRpc3BhdGNoID0gZGlzcGF0Y2hBY3Rpb24uYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50LFxuICAgICAgICByZWR1Y2VyXG4gICAgICApO1xuICAgICAgcmV0dXJuIFt3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSwgcmVkdWNlcl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBkZXBzID0gdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHM7XG4gICAgICBpZiAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3NIb29rKSB7XG4gICAgICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IHByZXZTdGF0ZSAmJiBudWxsICE9PSBkZXBzKSB7XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHByZXZTdGF0ZVsxXTtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IG5vdCBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci4gRXZlbiB0aG91Z2ggdGhlIGZpbmFsIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCBpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy5cIixcbiAgICAgICAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZGVwcy5sZW5ndGggIT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSBvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcblByZXZpb3VzOiAlc1xcbkluY29taW5nOiAlc1wiLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYsXG4gICAgICAgICAgICAgICAgICBcIltcIiArIGRlcHMuam9pbihcIiwgXCIpICsgXCJdXCIsXG4gICAgICAgICAgICAgICAgICBcIltcIiArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5qb2luKFwiLCBcIikgKyBcIl1cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIGkgPCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQubGVuZ3RoICYmIGkgPCBkZXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGlmICghb2JqZWN0SXMoZGVwc1tpXSwgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0W2ldKSkge1xuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICEwO1xuICAgICAgbmV4dENyZWF0ZSA9IG5leHRDcmVhdGUoKTtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dENyZWF0ZSwgZGVwc107XG4gICAgICByZXR1cm4gbmV4dENyZWF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oY29tcG9uZW50SWRlbnRpdHksIHF1ZXVlLCBhY3Rpb24pIHtcbiAgICAgIGlmICgyNSA8PSBudW1iZXJPZlJlUmVuZGVycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcC5cIlxuICAgICAgICApO1xuICAgICAgaWYgKGNvbXBvbmVudElkZW50aXR5ID09PSBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMCksXG4gICAgICAgICAgKGNvbXBvbmVudElkZW50aXR5ID0geyBhY3Rpb246IGFjdGlvbiwgbmV4dDogbnVsbCB9KSxcbiAgICAgICAgICBudWxsID09PSByZW5kZXJQaGFzZVVwZGF0ZXMgJiYgKHJlbmRlclBoYXNlVXBkYXRlcyA9IG5ldyBNYXAoKSksXG4gICAgICAgICAgKGFjdGlvbiA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpKSxcbiAgICAgICAgICB2b2lkIDAgPT09IGFjdGlvbilcbiAgICAgICAgKVxuICAgICAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5zZXQocXVldWUsIGNvbXBvbmVudElkZW50aXR5KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yIChxdWV1ZSA9IGFjdGlvbjsgbnVsbCAhPT0gcXVldWUubmV4dDsgKSBxdWV1ZSA9IHF1ZXVlLm5leHQ7XG4gICAgICAgICAgcXVldWUubmV4dCA9IGNvbXBvbmVudElkZW50aXR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuc3VwcG9ydGVkU3RhcnRUcmFuc2l0aW9uKCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJzdGFydFRyYW5zaXRpb24gY2Fubm90IGJlIGNhbGxlZCBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy5cIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuc3VwcG9ydGVkU2V0T3B0aW1pc3RpY1N0YXRlKCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIG9wdGltaXN0aWMgc3RhdGUgd2hpbGUgcmVuZGVyaW5nLlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUG9zdGJhY2tBY3Rpb25TdGF0ZUtleShcbiAgICAgIHBlcm1hbGluayxcbiAgICAgIGNvbXBvbmVudEtleVBhdGgsXG4gICAgICBob29rSW5kZXhcbiAgICApIHtcbiAgICAgIGlmICh2b2lkIDAgIT09IHBlcm1hbGluaykgcmV0dXJuIFwicFwiICsgcGVybWFsaW5rO1xuICAgICAgcGVybWFsaW5rID0gSlNPTi5zdHJpbmdpZnkoW2NvbXBvbmVudEtleVBhdGgsIG51bGwsIGhvb2tJbmRleF0pO1xuICAgICAgY29tcG9uZW50S2V5UGF0aCA9IGNyeXB0by5jcmVhdGVIYXNoKFwibWQ1XCIpO1xuICAgICAgY29tcG9uZW50S2V5UGF0aC51cGRhdGUocGVybWFsaW5rKTtcbiAgICAgIHJldHVybiBcImtcIiArIGNvbXBvbmVudEtleVBhdGguZGlnZXN0KFwiaGV4XCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB2YXIgYWN0aW9uU3RhdGVIb29rSW5kZXggPSBhY3Rpb25TdGF0ZUNvdW50ZXIrKyxcbiAgICAgICAgcmVxdWVzdCA9IGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3Q7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uLiQkRk9STV9BQ1RJT04pIHtcbiAgICAgICAgdmFyIG5leHRQb3N0YmFja1N0YXRlS2V5ID0gbnVsbCxcbiAgICAgICAgICBjb21wb25lbnRLZXlQYXRoID0gY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aDtcbiAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QuZm9ybVN0YXRlO1xuICAgICAgICB2YXIgaXNTaWduYXR1cmVFcXVhbCA9IGFjdGlvbi4kJElTX1NJR05BVFVSRV9FUVVBTDtcbiAgICAgICAgaWYgKG51bGwgIT09IHJlcXVlc3QgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaXNTaWduYXR1cmVFcXVhbCkge1xuICAgICAgICAgIHZhciBwb3N0YmFja0tleSA9IHJlcXVlc3RbMV07XG4gICAgICAgICAgaXNTaWduYXR1cmVFcXVhbC5jYWxsKGFjdGlvbiwgcmVxdWVzdFsyXSwgcmVxdWVzdFszXSkgJiZcbiAgICAgICAgICAgICgobmV4dFBvc3RiYWNrU3RhdGVLZXkgPSBjcmVhdGVQb3N0YmFja0FjdGlvblN0YXRlS2V5KFxuICAgICAgICAgICAgICBwZXJtYWxpbmssXG4gICAgICAgICAgICAgIGNvbXBvbmVudEtleVBhdGgsXG4gICAgICAgICAgICAgIGFjdGlvblN0YXRlSG9va0luZGV4XG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHBvc3RiYWNrS2V5ID09PSBuZXh0UG9zdGJhY2tTdGF0ZUtleSAmJlxuICAgICAgICAgICAgICAoKGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCA9IGFjdGlvblN0YXRlSG9va0luZGV4KSxcbiAgICAgICAgICAgICAgKGluaXRpYWxTdGF0ZSA9IHJlcXVlc3RbMF0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvdW5kQWN0aW9uID0gYWN0aW9uLmJpbmQobnVsbCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgYWN0aW9uID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICBib3VuZEFjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYm91bmRBY3Rpb24uJCRGT1JNX0FDVElPTiAmJlxuICAgICAgICAgIChhY3Rpb24uJCRGT1JNX0FDVElPTiA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IGJvdW5kQWN0aW9uLiQkRk9STV9BQ1RJT04ocHJlZml4KTtcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gcGVybWFsaW5rICYmXG4gICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHBlcm1hbGluaywgXCJ0YXJnZXRcIiksXG4gICAgICAgICAgICAgIChwZXJtYWxpbmsgKz0gXCJcIiksXG4gICAgICAgICAgICAgIChwcmVmaXguYWN0aW9uID0gcGVybWFsaW5rKSk7XG4gICAgICAgICAgICB2YXIgZm9ybURhdGEgPSBwcmVmaXguZGF0YTtcbiAgICAgICAgICAgIGZvcm1EYXRhICYmXG4gICAgICAgICAgICAgIChudWxsID09PSBuZXh0UG9zdGJhY2tTdGF0ZUtleSAmJlxuICAgICAgICAgICAgICAgIChuZXh0UG9zdGJhY2tTdGF0ZUtleSA9IGNyZWF0ZVBvc3RiYWNrQWN0aW9uU3RhdGVLZXkoXG4gICAgICAgICAgICAgICAgICBwZXJtYWxpbmssXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRLZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVIb29rSW5kZXhcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiJEFDVElPTl9LRVlcIiwgbmV4dFBvc3RiYWNrU3RhdGVLZXkpKTtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbaW5pdGlhbFN0YXRlLCBhY3Rpb24sICExXTtcbiAgICAgIH1cbiAgICAgIHZhciBfYm91bmRBY3Rpb24gPSBhY3Rpb24uYmluZChudWxsLCBpbml0aWFsU3RhdGUpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgaW5pdGlhbFN0YXRlLFxuICAgICAgICBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgIF9ib3VuZEFjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgfSxcbiAgICAgICAgITFcbiAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGVuYWJsZUluZGV4Q291bnRlcjtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyICs9IDE7XG4gICAgICBudWxsID09PSB0aGVuYWJsZVN0YXRlICYmICh0aGVuYWJsZVN0YXRlID0gW10pO1xuICAgICAgcmV0dXJuIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuc3VwcG9ydGVkUmVmcmVzaCgpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQ2FjaGUgY2Fubm90IGJlIHJlZnJlc2hlZCBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy5cIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AkMSgpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuICAgIGZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGlzYWJsZWREZXB0aCsrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gICAgICBkaXNhYmxlZERlcHRoLS07XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB7IGNvbmZpZ3VyYWJsZTogITAsIGVudW1lcmFibGU6ICEwLCB3cml0YWJsZTogITAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkxvZyB9KSxcbiAgICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2SW5mbyB9KSxcbiAgICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2V2FybiB9KSxcbiAgICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkVycm9yIH0pLFxuICAgICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXAgfSksXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZCB9KSxcbiAgICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwRW5kIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgMCA+IGRpc2FibGVkRGVwdGggJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlU3RhY2tUcmFjZShlcnJvciwgc3RydWN0dXJlZFN0YWNrVHJhY2UpIHtcbiAgICAgIGVycm9yID0gKGVycm9yLm5hbWUgfHwgXCJFcnJvclwiKSArIFwiOiBcIiArIChlcnJvci5tZXNzYWdlIHx8IFwiXCIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJ1Y3R1cmVkU3RhY2tUcmFjZS5sZW5ndGg7IGkrKylcbiAgICAgICAgZXJyb3IgKz0gXCJcXG4gICAgYXQgXCIgKyBzdHJ1Y3R1cmVkU3RhY2tUcmFjZVtpXS50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSB7XG4gICAgICBpZiAodm9pZCAwID09PSBwcmVmaXgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgcHJlZml4ID0gKG1hdGNoICYmIG1hdGNoWzFdKSB8fCBcIlwiO1xuICAgICAgICAgIHN1ZmZpeCA9XG4gICAgICAgICAgICAtMSA8IHguc3RhY2suaW5kZXhPZihcIlxcbiAgICBhdFwiKVxuICAgICAgICAgICAgICA/IFwiICg8YW5vbnltb3VzPilcIlxuICAgICAgICAgICAgICA6IC0xIDwgeC5zdGFjay5pbmRleE9mKFwiQFwiKVxuICAgICAgICAgICAgICAgID8gXCJAdW5rbm93bjowOjBcIlxuICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXFxuXCIgKyBwcmVmaXggKyBuYW1lICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgICAgIGlmICghZm4gfHwgcmVlbnRyeSkgcmV0dXJuIFwiXCI7XG4gICAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG4gICAgICBpZiAodm9pZCAwICE9PSBmcmFtZSkgcmV0dXJuIGZyYW1lO1xuICAgICAgcmVlbnRyeSA9ICEwO1xuICAgICAgZnJhbWUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdE93bmVyU3RhY2soZXJyb3IpIHtcbiAgICAgIHZhciBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBlcnJvciA9IGVycm9yLnN0YWNrO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2UHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBlcnJvci5zdGFydHNXaXRoKFwiRXJyb3I6IHJlYWN0LXN0YWNrLXRvcC1mcmFtZVxcblwiKSAmJlxuICAgICAgICAoZXJyb3IgPSBlcnJvci5zbGljZSgyOSkpO1xuICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlID0gZXJyb3IuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgIC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgJiZcbiAgICAgICAgKGVycm9yID0gZXJyb3Iuc2xpY2UocHJldlByZXBhcmVTdGFja1RyYWNlICsgMSkpO1xuICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlID0gZXJyb3IuaW5kZXhPZihcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiKTtcbiAgICAgIC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgJiZcbiAgICAgICAgKHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IGVycm9yLmxhc3RJbmRleE9mKFxuICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlXG4gICAgICAgICkpO1xuICAgICAgaWYgKC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UpXG4gICAgICAgIGVycm9yID0gZXJyb3Iuc2xpY2UoMCwgcHJldlByZXBhcmVTdGFja1RyYWNlKTtcbiAgICAgIGVsc2UgcmV0dXJuIFwiXCI7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQ29tcG9uZW50U3RhY2tCeVR5cGUodHlwZSkge1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnRcbiAgICAgICAgICA/IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgITApXG4gICAgICAgICAgOiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsICExKTtcbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyLCAhMSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLnR5cGUsICExKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZSxcbiAgICAgICAgICAgICAgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgICBsYXp5Q29tcG9uZW50ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHR5cGUgPSBsYXp5Q29tcG9uZW50KHBheWxvYWQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJMYXp5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50U3RhY2tCeVR5cGUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlLm5hbWUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChwYXlsb2FkID0gdHlwZS5lbnYpLFxuICAgICAgICAgICAgZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgICAgIHR5cGUubmFtZSArIChwYXlsb2FkID8gXCIgW1wiICsgcGF5bG9hZCArIFwiXVwiIDogXCJcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5lbnZpcm9ubWVudE5hbWVcbiAgICAgICkge1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gZXJyb3IuZW52aXJvbm1lbnROYW1lO1xuICAgICAgICBlcnJvciA9IFtlcnJvcl0uc2xpY2UoMCk7XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvclswXVxuICAgICAgICAgID8gZXJyb3Iuc3BsaWNlKFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICBcIlxcdTAwMWJbMG1cXHUwMDFiWzdtJWMlc1xcdTAwMWJbMG0lYyBcIiArIGVycm9yWzBdLFxuICAgICAgICAgICAgICBcImJhY2tncm91bmQ6ICNlNmU2ZTY7YmFja2dyb3VuZDogbGlnaHQtZGFyayhyZ2JhKDAsMCwwLDAuMSksIHJnYmEoMjU1LDI1NSwyNTUsMC4yNSkpO2NvbG9yOiAjMDAwMDAwO2NvbG9yOiBsaWdodC1kYXJrKCMwMDAwMDAsICNmZmZmZmYpO2JvcmRlci1yYWRpdXM6IDJweFwiLFxuICAgICAgICAgICAgICBcIiBcIiArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCArIFwiIFwiLFxuICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBlcnJvci5zcGxpY2UoXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIFwiXFx1MDAxYlswbVxcdTAwMWJbN20lYyVzXFx1MDAxYlswbSVjIFwiLFxuICAgICAgICAgICAgICBcImJhY2tncm91bmQ6ICNlNmU2ZTY7YmFja2dyb3VuZDogbGlnaHQtZGFyayhyZ2JhKDAsMCwwLDAuMSksIHJnYmEoMjU1LDI1NSwyNTUsMC4yNSkpO2NvbG9yOiAjMDAwMDAwO2NvbG9yOiBsaWdodC1kYXJrKCMwMDAwMDAsICNmZmZmZmYpO2JvcmRlci1yYWRpdXM6IDJweFwiLFxuICAgICAgICAgICAgICBcIiBcIiArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCArIFwiIFwiLFxuICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICApO1xuICAgICAgICBlcnJvci51bnNoaWZ0KGNvbnNvbGUpO1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBiaW5kLmFwcGx5KGNvbnNvbGUuZXJyb3IsIGVycm9yKTtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KCk7XG4gICAgICB9IGVsc2UgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gICAgZnVuY3Rpb24gUmVxdWVzdEluc3RhbmNlKFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgICBvbkVycm9yLFxuICAgICAgb25BbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgIG9uRmF0YWxFcnJvcixcbiAgICAgIG9uUG9zdHBvbmUsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIHZhciBhYm9ydFNldCA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgdGhpcy5mbHVzaFNjaGVkdWxlZCA9ICExO1xuICAgICAgdGhpcy5yZXN1bWFibGVTdGF0ZSA9IHJlc3VtYWJsZVN0YXRlO1xuICAgICAgdGhpcy5yZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlO1xuICAgICAgdGhpcy5yb290Rm9ybWF0Q29udGV4dCA9IHJvb3RGb3JtYXRDb250ZXh0O1xuICAgICAgdGhpcy5wcm9ncmVzc2l2ZUNodW5rU2l6ZSA9XG4gICAgICAgIHZvaWQgMCA9PT0gcHJvZ3Jlc3NpdmVDaHVua1NpemUgPyAxMjgwMCA6IHByb2dyZXNzaXZlQ2h1bmtTaXplO1xuICAgICAgdGhpcy5zdGF0dXMgPSAxMDtcbiAgICAgIHRoaXMuZmF0YWxFcnJvciA9IG51bGw7XG4gICAgICB0aGlzLnBlbmRpbmdSb290VGFza3MgPSB0aGlzLmFsbFBlbmRpbmdUYXNrcyA9IHRoaXMubmV4dFNlZ21lbnRJZCA9IDA7XG4gICAgICB0aGlzLmNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMgPSB0aGlzLmNvbXBsZXRlZFJvb3RTZWdtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuYWJvcnRhYmxlVGFza3MgPSBhYm9ydFNldDtcbiAgICAgIHRoaXMucGluZ2VkVGFza3MgPSBbXTtcbiAgICAgIHRoaXMuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzID0gW107XG4gICAgICB0aGlzLmNvbXBsZXRlZEJvdW5kYXJpZXMgPSBbXTtcbiAgICAgIHRoaXMucGFydGlhbEJvdW5kYXJpZXMgPSBbXTtcbiAgICAgIHRoaXMudHJhY2tlZFBvc3Rwb25lcyA9IG51bGw7XG4gICAgICB0aGlzLm9uRXJyb3IgPSB2b2lkIDAgPT09IG9uRXJyb3IgPyBkZWZhdWx0RXJyb3JIYW5kbGVyIDogb25FcnJvcjtcbiAgICAgIHRoaXMub25Qb3N0cG9uZSA9IHZvaWQgMCA9PT0gb25Qb3N0cG9uZSA/IG5vb3AgOiBvblBvc3Rwb25lO1xuICAgICAgdGhpcy5vbkFsbFJlYWR5ID0gdm9pZCAwID09PSBvbkFsbFJlYWR5ID8gbm9vcCA6IG9uQWxsUmVhZHk7XG4gICAgICB0aGlzLm9uU2hlbGxSZWFkeSA9IHZvaWQgMCA9PT0gb25TaGVsbFJlYWR5ID8gbm9vcCA6IG9uU2hlbGxSZWFkeTtcbiAgICAgIHRoaXMub25TaGVsbEVycm9yID0gdm9pZCAwID09PSBvblNoZWxsRXJyb3IgPyBub29wIDogb25TaGVsbEVycm9yO1xuICAgICAgdGhpcy5vbkZhdGFsRXJyb3IgPSB2b2lkIDAgPT09IG9uRmF0YWxFcnJvciA/IG5vb3AgOiBvbkZhdGFsRXJyb3I7XG4gICAgICB0aGlzLmZvcm1TdGF0ZSA9IHZvaWQgMCA9PT0gZm9ybVN0YXRlID8gbnVsbCA6IGZvcm1TdGF0ZTtcbiAgICAgIHRoaXMuZGlkV2FybkZvcktleSA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3QoXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgIHByb2dyZXNzaXZlQ2h1bmtTaXplLFxuICAgICAgb25FcnJvcixcbiAgICAgIG9uQWxsUmVhZHksXG4gICAgICBvblNoZWxsUmVhZHksXG4gICAgICBvblNoZWxsRXJyb3IsXG4gICAgICBvbkZhdGFsRXJyb3IsXG4gICAgICBvblBvc3Rwb25lLFxuICAgICAgZm9ybVN0YXRlXG4gICAgKSB7XG4gICAgICByZXN1bWFibGVTdGF0ZSA9IG5ldyBSZXF1ZXN0SW5zdGFuY2UoXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICAgIHByb2dyZXNzaXZlQ2h1bmtTaXplLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBvbkFsbFJlYWR5LFxuICAgICAgICBvblNoZWxsUmVhZHksXG4gICAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgICBvblBvc3Rwb25lLFxuICAgICAgICBmb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICByZW5kZXJTdGF0ZSA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgMCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICAgICExLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgICAgIHJlbmRlclN0YXRlLnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgIGNoaWxkcmVuID0gY3JlYXRlUmVuZGVyVGFzayhcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAtMSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmFib3J0YWJsZVRhc2tzLFxuICAgICAgICBudWxsLFxuICAgICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZW1wdHlUcmVlQ29udGV4dCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgITEsXG4gICAgICAgIGVtcHR5Q29udGV4dE9iamVjdCxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICAgIHB1c2hDb21wb25lbnRTdGFjayhjaGlsZHJlbik7XG4gICAgICByZXN1bWFibGVTdGF0ZS5waW5nZWRUYXNrcy5wdXNoKGNoaWxkcmVuKTtcbiAgICAgIHJldHVybiByZXN1bWFibGVTdGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUHJlcmVuZGVyUmVxdWVzdChcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgICBvbkVycm9yLFxuICAgICAgb25BbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgIG9uRmF0YWxFcnJvcixcbiAgICAgIG9uUG9zdHBvbmVcbiAgICApIHtcbiAgICAgIGNoaWxkcmVuID0gY3JlYXRlUmVxdWVzdChcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICAgIHByb2dyZXNzaXZlQ2h1bmtTaXplLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBvbkFsbFJlYWR5LFxuICAgICAgICBvblNoZWxsUmVhZHksXG4gICAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgICBvblBvc3Rwb25lLFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgICBjaGlsZHJlbi50cmFja2VkUG9zdHBvbmVzID0ge1xuICAgICAgICB3b3JraW5nTWFwOiBuZXcgTWFwKCksXG4gICAgICAgIHJvb3ROb2RlczogW10sXG4gICAgICAgIHJvb3RTbG90czogbnVsbFxuICAgICAgfTtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVJlcXVlc3QoKSB7XG4gICAgICBpZiAoY3VycmVudFJlcXVlc3QpIHJldHVybiBjdXJyZW50UmVxdWVzdDtcbiAgICAgIHZhciBzdG9yZSA9IHJlcXVlc3RTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgICByZXR1cm4gc3RvcmUgPyBzdG9yZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spIHtcbiAgICAgIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaCh0YXNrKTtcbiAgICAgIDEgPT09IHJlcXVlc3QucGluZ2VkVGFza3MubGVuZ3RoICYmXG4gICAgICAgICgocmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9IG51bGwgIT09IHJlcXVlc3QuZGVzdGluYXRpb24pLFxuICAgICAgICBudWxsICE9PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgfHwgMTAgPT09IHJlcXVlc3Quc3RhdHVzXG4gICAgICAgICAgPyBzY2hlZHVsZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwZXJmb3JtV29yayhyZXF1ZXN0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgOiBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGVyZm9ybVdvcmsocmVxdWVzdCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgICByZXF1ZXN0LFxuICAgICAgZmFsbGJhY2tBYm9ydGFibGVUYXNrcyxcbiAgICAgIGNvbnRlbnRQcmVhbWJsZSxcbiAgICAgIGZhbGxiYWNrUHJlYW1ibGVcbiAgICApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogUEVORElORyxcbiAgICAgICAgcm9vdFNlZ21lbnRJRDogLTEsXG4gICAgICAgIHBhcmVudEZsdXNoZWQ6ICExLFxuICAgICAgICBwZW5kaW5nVGFza3M6IDAsXG4gICAgICAgIGNvbXBsZXRlZFNlZ21lbnRzOiBbXSxcbiAgICAgICAgYnl0ZVNpemU6IDAsXG4gICAgICAgIGZhbGxiYWNrQWJvcnRhYmxlVGFza3M6IGZhbGxiYWNrQWJvcnRhYmxlVGFza3MsXG4gICAgICAgIGVycm9yRGlnZXN0OiBudWxsLFxuICAgICAgICBjb250ZW50U3RhdGU6IGNyZWF0ZUhvaXN0YWJsZVN0YXRlKCksXG4gICAgICAgIGZhbGxiYWNrU3RhdGU6IGNyZWF0ZUhvaXN0YWJsZVN0YXRlKCksXG4gICAgICAgIGNvbnRlbnRQcmVhbWJsZTogY29udGVudFByZWFtYmxlLFxuICAgICAgICBmYWxsYmFja1ByZWFtYmxlOiBmYWxsYmFja1ByZWFtYmxlLFxuICAgICAgICB0cmFja2VkQ29udGVudEtleVBhdGg6IG51bGwsXG4gICAgICAgIHRyYWNrZWRGYWxsYmFja05vZGU6IG51bGwsXG4gICAgICAgIGVycm9yTWVzc2FnZTogbnVsbCxcbiAgICAgICAgZXJyb3JTdGFjazogbnVsbCxcbiAgICAgICAgZXJyb3JDb21wb25lbnRTdGFjazogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyVGFzayhcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0aGVuYWJsZVN0YXRlLFxuICAgICAgbm9kZSxcbiAgICAgIGNoaWxkSW5kZXgsXG4gICAgICBibG9ja2VkQm91bmRhcnksXG4gICAgICBibG9ja2VkU2VnbWVudCxcbiAgICAgIGJsb2NrZWRQcmVhbWJsZSxcbiAgICAgIGhvaXN0YWJsZVN0YXRlLFxuICAgICAgYWJvcnRTZXQsXG4gICAgICBrZXlQYXRoLFxuICAgICAgZm9ybWF0Q29udGV4dCxcbiAgICAgIGNvbnRleHQsXG4gICAgICB0cmVlQ29udGV4dCxcbiAgICAgIGNvbXBvbmVudFN0YWNrLFxuICAgICAgaXNGYWxsYmFjayxcbiAgICAgIGxlZ2FjeUNvbnRleHQsXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzKys7XG4gICAgICBudWxsID09PSBibG9ja2VkQm91bmRhcnlcbiAgICAgICAgPyByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MrK1xuICAgICAgICA6IGJsb2NrZWRCb3VuZGFyeS5wZW5kaW5nVGFza3MrKztcbiAgICAgIHZhciB0YXNrID0ge1xuICAgICAgICByZXBsYXk6IG51bGwsXG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIGNoaWxkSW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIHBpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcGluZ1Rhc2socmVxdWVzdCwgdGFzayk7XG4gICAgICAgIH0sXG4gICAgICAgIGJsb2NrZWRCb3VuZGFyeTogYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICBibG9ja2VkU2VnbWVudDogYmxvY2tlZFNlZ21lbnQsXG4gICAgICAgIGJsb2NrZWRQcmVhbWJsZTogYmxvY2tlZFByZWFtYmxlLFxuICAgICAgICBob2lzdGFibGVTdGF0ZTogaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgIGFib3J0U2V0OiBhYm9ydFNldCxcbiAgICAgICAga2V5UGF0aDoga2V5UGF0aCxcbiAgICAgICAgZm9ybWF0Q29udGV4dDogZm9ybWF0Q29udGV4dCxcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgdHJlZUNvbnRleHQ6IHRyZWVDb250ZXh0LFxuICAgICAgICBjb21wb25lbnRTdGFjazogY29tcG9uZW50U3RhY2ssXG4gICAgICAgIHRoZW5hYmxlU3RhdGU6IHRoZW5hYmxlU3RhdGUsXG4gICAgICAgIGlzRmFsbGJhY2s6IGlzRmFsbGJhY2tcbiAgICAgIH07XG4gICAgICB0YXNrLmRlYnVnVGFzayA9IGRlYnVnVGFzaztcbiAgICAgIGFib3J0U2V0LmFkZCh0YXNrKTtcbiAgICAgIHJldHVybiB0YXNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXBsYXlUYXNrKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRoZW5hYmxlU3RhdGUsXG4gICAgICByZXBsYXksXG4gICAgICBub2RlLFxuICAgICAgY2hpbGRJbmRleCxcbiAgICAgIGJsb2NrZWRCb3VuZGFyeSxcbiAgICAgIGhvaXN0YWJsZVN0YXRlLFxuICAgICAgYWJvcnRTZXQsXG4gICAgICBrZXlQYXRoLFxuICAgICAgZm9ybWF0Q29udGV4dCxcbiAgICAgIGNvbnRleHQsXG4gICAgICB0cmVlQ29udGV4dCxcbiAgICAgIGNvbXBvbmVudFN0YWNrLFxuICAgICAgaXNGYWxsYmFjayxcbiAgICAgIGxlZ2FjeUNvbnRleHQsXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzKys7XG4gICAgICBudWxsID09PSBibG9ja2VkQm91bmRhcnlcbiAgICAgICAgPyByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MrK1xuICAgICAgICA6IGJsb2NrZWRCb3VuZGFyeS5wZW5kaW5nVGFza3MrKztcbiAgICAgIHJlcGxheS5wZW5kaW5nVGFza3MrKztcbiAgICAgIHZhciB0YXNrID0ge1xuICAgICAgICByZXBsYXk6IHJlcGxheSxcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgY2hpbGRJbmRleDogY2hpbGRJbmRleCxcbiAgICAgICAgcGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgYmxvY2tlZEJvdW5kYXJ5OiBibG9ja2VkQm91bmRhcnksXG4gICAgICAgIGJsb2NrZWRTZWdtZW50OiBudWxsLFxuICAgICAgICBibG9ja2VkUHJlYW1ibGU6IG51bGwsXG4gICAgICAgIGhvaXN0YWJsZVN0YXRlOiBob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgYWJvcnRTZXQ6IGFib3J0U2V0LFxuICAgICAgICBrZXlQYXRoOiBrZXlQYXRoLFxuICAgICAgICBmb3JtYXRDb250ZXh0OiBmb3JtYXRDb250ZXh0LFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICB0cmVlQ29udGV4dDogdHJlZUNvbnRleHQsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBjb21wb25lbnRTdGFjayxcbiAgICAgICAgdGhlbmFibGVTdGF0ZTogdGhlbmFibGVTdGF0ZSxcbiAgICAgICAgaXNGYWxsYmFjazogaXNGYWxsYmFja1xuICAgICAgfTtcbiAgICAgIHRhc2suZGVidWdUYXNrID0gZGVidWdUYXNrO1xuICAgICAgYWJvcnRTZXQuYWRkKHRhc2spO1xuICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGluZGV4LFxuICAgICAgYm91bmRhcnksXG4gICAgICBwYXJlbnRGb3JtYXRDb250ZXh0LFxuICAgICAgbGFzdFB1c2hlZFRleHQsXG4gICAgICB0ZXh0RW1iZWRkZWRcbiAgICApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogUEVORElORyxcbiAgICAgICAgcGFyZW50Rmx1c2hlZDogITEsXG4gICAgICAgIGlkOiAtMSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjaHVua3M6IFtdLFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIHByZWFtYmxlQ2hpbGRyZW46IFtdLFxuICAgICAgICBwYXJlbnRGb3JtYXRDb250ZXh0OiBwYXJlbnRGb3JtYXRDb250ZXh0LFxuICAgICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICAgIGxhc3RQdXNoZWRUZXh0OiBsYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgdGV4dEVtYmVkZGVkOiB0ZXh0RW1iZWRkZWRcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRTdGFja0luREVWKCkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRUYXNrSW5ERVYgfHwgbnVsbCA9PT0gY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjaylcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB2YXIgY29tcG9uZW50U3RhY2sgPSBjdXJyZW50VGFza0luREVWLmNvbXBvbmVudFN0YWNrO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBcIlwiO1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNvbXBvbmVudFN0YWNrLnR5cGUpXG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShjb21wb25lbnRTdGFjay50eXBlKTtcbiAgICAgICAgZWxzZSBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29tcG9uZW50U3RhY2sudHlwZSkge1xuICAgICAgICAgIGlmICghY29tcG9uZW50U3RhY2sub3duZXIpIHtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBpbmZvLFxuICAgICAgICAgICAgICBmbiA9IGNvbXBvbmVudFN0YWNrLnR5cGUsXG4gICAgICAgICAgICAgIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiBcIlwiO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IG5hbWVcbiAgICAgICAgICAgICAgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKVxuICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICBpbmZvID0gSlNDb21waWxlcl90ZW1wX2NvbnN0ICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgY29tcG9uZW50U3RhY2sub3duZXIgfHxcbiAgICAgICAgICAgIChpbmZvICs9IGRlc2NyaWJlQ29tcG9uZW50U3RhY2tCeVR5cGUoY29tcG9uZW50U3RhY2sudHlwZSkpO1xuICAgICAgICBmb3IgKDsgY29tcG9uZW50U3RhY2s7IClcbiAgICAgICAgICAoSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9IGNvbXBvbmVudFN0YWNrLmRlYnVnU3RhY2tcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gZm9ybWF0T3duZXJTdGFjayhcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrLmRlYnVnU3RhY2tcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6ICgoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29tcG9uZW50U3RhY2spLFxuICAgICAgICAgICAgICAgIG51bGwgIT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LnN0YWNrICYmXG4gICAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wX2NvbnN0ID1cbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGFja1xuICAgICAgICAgICAgICAgICAgICAgID8gKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGFjayA9IGZvcm1hdE93bmVyU3RhY2soXG4gICAgICAgICAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICA6IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGFjaykpLFxuICAgICAgICAgICAgKGNvbXBvbmVudFN0YWNrID0gY29tcG9uZW50U3RhY2sub3duZXIpICYmXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdCAmJlxuICAgICAgICAgICAgICAoaW5mbyArPSBcIlxcblwiICsgSlNDb21waWxlcl90ZW1wX2NvbnN0KTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IGluZm87XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFNlcnZlckNvbXBvbmVudFN0YWNrKHRhc2ssIGRlYnVnSW5mbykge1xuICAgICAgaWYgKG51bGwgIT0gZGVidWdJbmZvKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlYnVnSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjb21wb25lbnRJbmZvID0gZGVidWdJbmZvW2ldO1xuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjb21wb25lbnRJbmZvLm5hbWUgJiZcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gY29tcG9uZW50SW5mby5kZWJ1Z1N0YWNrICYmXG4gICAgICAgICAgICAoKHRhc2suY29tcG9uZW50U3RhY2sgPSB7XG4gICAgICAgICAgICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgICAgICAgdHlwZTogY29tcG9uZW50SW5mbyxcbiAgICAgICAgICAgICAgb3duZXI6IGNvbXBvbmVudEluZm8ub3duZXIsXG4gICAgICAgICAgICAgIHN0YWNrOiBjb21wb25lbnRJbmZvLmRlYnVnU3RhY2tcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKHRhc2suZGVidWdUYXNrID0gY29tcG9uZW50SW5mby5kZWJ1Z1Rhc2spKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQ29tcG9uZW50U3RhY2sodGFzaykge1xuICAgICAgdmFyIG5vZGUgPSB0YXNrLm5vZGU7XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiYgbnVsbCAhPT0gbm9kZSlcbiAgICAgICAgc3dpdGNoIChub2RlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgICB2YXIgdHlwZSA9IG5vZGUudHlwZSxcbiAgICAgICAgICAgICAgb3duZXIgPSBub2RlLl9vd25lcixcbiAgICAgICAgICAgICAgc3RhY2sgPSBub2RlLl9kZWJ1Z1N0YWNrO1xuICAgICAgICAgICAgcHVzaFNlcnZlckNvbXBvbmVudFN0YWNrKHRhc2ssIG5vZGUuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICB0YXNrLmRlYnVnVGFzayA9IG5vZGUuX2RlYnVnVGFzaztcbiAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSB7XG4gICAgICAgICAgICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgb3duZXI6IG93bmVyLFxuICAgICAgICAgICAgICBzdGFjazogc3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHB1c2hTZXJ2ZXJDb21wb25lbnRTdGFjayh0YXNrLCBub2RlLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUudGhlbiAmJlxuICAgICAgICAgICAgICBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgbm9kZS5fZGVidWdJbmZvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUaHJvd25JbmZvKG5vZGUkanNjb21wJDApIHtcbiAgICAgIHZhciBlcnJvckluZm8gPSB7fTtcbiAgICAgIG5vZGUkanNjb21wJDAgJiZcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9ySW5mbywgXCJjb21wb25lbnRTdGFja1wiLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBpbmZvID0gXCJcIixcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZSRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAoaW5mbyArPSBkZXNjcmliZUNvbXBvbmVudFN0YWNrQnlUeXBlKG5vZGUudHlwZSkpLFxuICAgICAgICAgICAgICAgICAgKG5vZGUgPSBub2RlLnBhcmVudCk7XG4gICAgICAgICAgICAgIHdoaWxlIChub2RlKTtcbiAgICAgICAgICAgICAgdmFyIHN0YWNrID0gaW5mbztcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgc3RhY2sgPSBcIlxcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6IFwiICsgeC5tZXNzYWdlICsgXCJcXG5cIiArIHguc3RhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JJbmZvLCBcImNvbXBvbmVudFN0YWNrXCIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHN0YWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVycm9ySW5mbztcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgZGlnZXN0LFxuICAgICAgZXJyb3IsXG4gICAgICB0aHJvd25JbmZvLFxuICAgICAgd2FzQWJvcnRlZFxuICAgICkge1xuICAgICAgYm91bmRhcnkuZXJyb3JEaWdlc3QgPSBkaWdlc3Q7XG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgID8gKChkaWdlc3QgPSBTdHJpbmcoZXJyb3IubWVzc2FnZSkpLCAoZXJyb3IgPSBTdHJpbmcoZXJyb3Iuc3RhY2spKSlcbiAgICAgICAgOiAoKGRpZ2VzdCA9XG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiYgbnVsbCAhPT0gZXJyb3JcbiAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShlcnJvcilcbiAgICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IpKSxcbiAgICAgICAgICAoZXJyb3IgPSBudWxsKSk7XG4gICAgICB3YXNBYm9ydGVkID0gd2FzQWJvcnRlZFxuICAgICAgICA/IFwiU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZyBiZWNhdXNlIHRoZSBzZXJ2ZXIgcmVuZGVyaW5nIGFib3J0ZWQgZHVlIHRvOlxcblxcblwiXG4gICAgICAgIDogXCJTd2l0Y2hlZCB0byBjbGllbnQgcmVuZGVyaW5nIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJpbmcgZXJyb3JlZDpcXG5cXG5cIjtcbiAgICAgIGJvdW5kYXJ5LmVycm9yTWVzc2FnZSA9IHdhc0Fib3J0ZWQgKyBkaWdlc3Q7XG4gICAgICBib3VuZGFyeS5lcnJvclN0YWNrID0gbnVsbCAhPT0gZXJyb3IgPyB3YXNBYm9ydGVkICsgZXJyb3IgOiBudWxsO1xuICAgICAgYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjayA9IHRocm93bkluZm8uY29tcG9uZW50U3RhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIGVycm9ySW5mbywgZGVidWdUYXNrKSB7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5vbkVycm9yO1xuICAgICAgZXJyb3IgPSBkZWJ1Z1Rhc2tcbiAgICAgICAgPyBkZWJ1Z1Rhc2sucnVuKHJlcXVlc3QuYmluZChudWxsLCBlcnJvciwgZXJyb3JJbmZvKSlcbiAgICAgICAgOiByZXF1ZXN0KGVycm9yLCBlcnJvckluZm8pO1xuICAgICAgaWYgKG51bGwgIT0gZXJyb3IgJiYgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGVycm9yKVxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdvbkVycm9yIHJldHVybmVkIHNvbWV0aGluZyB3aXRoIGEgdHlwZSBvdGhlciB0aGFuIFwic3RyaW5nXCIuIG9uRXJyb3Igc2hvdWxkIHJldHVybiBhIHN0cmluZyBhbmQgbWF5IHJldHVybiBudWxsIG9yIHVuZGVmaW5lZCBidXQgbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGVsc2UuIEl0IHJlY2VpdmVkIHNvbWV0aGluZyBvZiB0eXBlIFwiJXNcIiBpbnN0ZWFkJyxcbiAgICAgICAgICB0eXBlb2YgZXJyb3JcbiAgICAgICAgKTtcbiAgICAgIGVsc2UgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8sIGRlYnVnVGFzaykge1xuICAgICAgZXJyb3JJbmZvID0gcmVxdWVzdC5vblNoZWxsRXJyb3I7XG4gICAgICB2YXIgb25GYXRhbEVycm9yID0gcmVxdWVzdC5vbkZhdGFsRXJyb3I7XG4gICAgICBkZWJ1Z1Rhc2tcbiAgICAgICAgPyAoZGVidWdUYXNrLnJ1bihlcnJvckluZm8uYmluZChudWxsLCBlcnJvcikpLFxuICAgICAgICAgIGRlYnVnVGFzay5ydW4ob25GYXRhbEVycm9yLmJpbmQobnVsbCwgZXJyb3IpKSlcbiAgICAgICAgOiAoZXJyb3JJbmZvKGVycm9yKSwgb25GYXRhbEVycm9yKGVycm9yKSk7XG4gICAgICBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uXG4gICAgICAgID8gKChyZXF1ZXN0LnN0YXR1cyA9IENMT1NFRCksIHJlcXVlc3QuZGVzdGluYXRpb24uZGVzdHJveShlcnJvcikpXG4gICAgICAgIDogKChyZXF1ZXN0LnN0YXR1cyA9IDEzKSwgKHJlcXVlc3QuZmF0YWxFcnJvciA9IGVycm9yKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0YXNrLFxuICAgICAga2V5UGF0aCxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHByb3BzLFxuICAgICAgc2Vjb25kQXJnXG4gICAgKSB7XG4gICAgICB2YXIgcHJldlRoZW5hYmxlU3RhdGUgPSB0YXNrLnRoZW5hYmxlU3RhdGU7XG4gICAgICB0YXNrLnRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0ge307XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID0gdGFzaztcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMTtcbiAgICAgIGFjdGlvblN0YXRlQ291bnRlciA9IGxvY2FsSWRDb3VudGVyID0gMDtcbiAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCA9IC0xO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICAgICAgdGhlbmFibGVTdGF0ZSA9IHByZXZUaGVuYWJsZVN0YXRlO1xuICAgICAgZm9yIChcbiAgICAgICAgcmVxdWVzdCA9IGNhbGxDb21wb25lbnRJbkRFVihDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpO1xuICAgICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICApXG4gICAgICAgIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITEpLFxuICAgICAgICAgIChhY3Rpb25TdGF0ZUNvdW50ZXIgPSBsb2NhbElkQ291bnRlciA9IDApLFxuICAgICAgICAgIChhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXggPSAtMSksXG4gICAgICAgICAgKHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMCksXG4gICAgICAgICAgKG51bWJlck9mUmVSZW5kZXJzICs9IDEpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsKSxcbiAgICAgICAgICAocmVxdWVzdCA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKSk7XG4gICAgICByZXNldEhvb2tzU3RhdGUoKTtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2hGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0YXNrLFxuICAgICAga2V5UGF0aCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgaGFzSWQsXG4gICAgICBhY3Rpb25TdGF0ZUNvdW50LFxuICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4XG4gICAgKSB7XG4gICAgICB2YXIgZGlkRW1pdEFjdGlvblN0YXRlTWFya2VycyA9ICExO1xuICAgICAgaWYgKDAgIT09IGFjdGlvblN0YXRlQ291bnQgJiYgbnVsbCAhPT0gcmVxdWVzdC5mb3JtU3RhdGUpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgICBpZiAobnVsbCAhPT0gc2VnbWVudCkge1xuICAgICAgICAgIGRpZEVtaXRBY3Rpb25TdGF0ZU1hcmtlcnMgPSAhMDtcbiAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudC5jaHVua3M7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3Rpb25TdGF0ZUNvdW50OyBpKyspXG4gICAgICAgICAgICBpID09PSBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXhcbiAgICAgICAgICAgICAgPyBzZWdtZW50LnB1c2goZm9ybVN0YXRlTWFya2VySXNNYXRjaGluZylcbiAgICAgICAgICAgICAgOiBzZWdtZW50LnB1c2goZm9ybVN0YXRlTWFya2VySXNOb3RNYXRjaGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGlvblN0YXRlQ291bnQgPSB0YXNrLmtleVBhdGg7XG4gICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgaGFzSWRcbiAgICAgICAgPyAoKGtleVBhdGggPSB0YXNrLnRyZWVDb250ZXh0KSxcbiAgICAgICAgICAodGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChrZXlQYXRoLCAxLCAwKSksXG4gICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpLFxuICAgICAgICAgICh0YXNrLnRyZWVDb250ZXh0ID0ga2V5UGF0aCkpXG4gICAgICAgIDogZGlkRW1pdEFjdGlvblN0YXRlTWFya2Vyc1xuICAgICAgICAgID8gcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpXG4gICAgICAgICAgOiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4sIC0xKTtcbiAgICAgIHRhc2sua2V5UGF0aCA9IGFjdGlvblN0YXRlQ291bnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZSwgcHJvcHMsIHJlZikge1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIG5ld1Byb3BzID0gcHJvcHM7XG4gICAgICAgICAgaWYgKFwicmVmXCIgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIG5ld1Byb3BzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcylcbiAgICAgICAgICAgICAgXCJyZWZcIiAhPT0gcHJvcE5hbWUgJiYgKG5ld1Byb3BzW3Byb3BOYW1lXSA9IHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICAgICAgICBpZiAoZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgICBuZXdQcm9wcyA9PT0gcHJvcHMgJiYgKG5ld1Byb3BzID0gYXNzaWduKHt9LCBuZXdQcm9wcywgcHJvcHMpKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9wcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpXG4gICAgICAgICAgICAgIHZvaWQgMCA9PT0gbmV3UHJvcHNbX3Byb3BOYW1lXSAmJlxuICAgICAgICAgICAgICAgIChuZXdQcm9wc1tfcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW19wcm9wTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzb2x2ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgICAgICAgIHZhciBjb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICAgICAgY29udGV4dFR5cGUgPSB0eXBlLmNvbnRleHRUeXBlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwiY29udGV4dFR5cGVcIiBpbiB0eXBlICYmXG4gICAgICAgICAgICBudWxsICE9PSBjb250ZXh0VHlwZSAmJlxuICAgICAgICAgICAgKHZvaWQgMCA9PT0gY29udGV4dFR5cGUgfHxcbiAgICAgICAgICAgICAgY29udGV4dFR5cGUuJCR0eXBlb2YgIT09IFJFQUNUX0NPTlRFWFRfVFlQRSkgJiZcbiAgICAgICAgICAgICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKHR5cGUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKHR5cGUpO1xuICAgICAgICAgICAgdmFyIGFkZGVuZHVtID1cbiAgICAgICAgICAgICAgdm9pZCAwID09PSBjb250ZXh0VHlwZVxuICAgICAgICAgICAgICAgID8gXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgdHlwbyBvciBieSBtaXhpbmcgdXAgbmFtZWQgYW5kIGRlZmF1bHQgaW1wb3J0cy4gVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gdHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLlwiXG4gICAgICAgICAgICAgICAgOiBcIm9iamVjdFwiICE9PSB0eXBlb2YgY29udGV4dFR5cGVcbiAgICAgICAgICAgICAgICAgID8gXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgXCIgKyB0eXBlb2YgY29udGV4dFR5cGUgKyBcIi5cIlxuICAgICAgICAgICAgICAgICAgOiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRVxuICAgICAgICAgICAgICAgICAgICA/IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuQ29uc3VtZXIgaW5zdGVhZD9cIlxuICAgICAgICAgICAgICAgICAgICA6IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHtcIiArXG4gICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgXCJ9LlwiO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuIGNvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICBhZGRlbmR1bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICBudWxsICE9PSBjb250ZXh0VHlwZSAmJlxuICAgICAgICAgICAgKGNvbnRleHQgPSBjb250ZXh0VHlwZS5fY3VycmVudFZhbHVlKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgdHlwZShyZXNvbHZlZFByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgICAgKG51bGwgPT09IGluc3RhbmNlLnN0YXRlIHx8IHZvaWQgMCA9PT0gaW5zdGFuY2Uuc3RhdGUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSB8fFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcImAlc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuIFRoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS5cIixcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IGluc3RhbmNlLnN0YXRlID8gXCJudWxsXCIgOiBcInVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIHx8XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGZvdW5kV2lsbE1vdW50TmFtZSA9IG51bGwsXG4gICAgICAgICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsLFxuICAgICAgICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gbnVsbDtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICAgID8gKGZvdW5kV2lsbE1vdW50TmFtZSA9IFwiY29tcG9uZW50V2lsbE1vdW50XCIpXG4gICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAgIChmb3VuZFdpbGxNb3VudE5hbWUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRcIik7XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICAhMCAhPT1cbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICAgID8gKGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIilcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAoZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9XG4gICAgICAgICAgICAgICAgICBcIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIpO1xuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgICA/IChmb3VuZFdpbGxVcGRhdGVOYW1lID0gXCJjb21wb25lbnRXaWxsVXBkYXRlXCIpXG4gICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAoZm91bmRXaWxsVXBkYXRlTmFtZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVcIik7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbE1vdW50TmFtZSB8fFxuICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIHx8XG4gICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPVxuICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCIsXG4gICAgICAgICAgICAgICAgbmV3QXBpTmFtZSA9XG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1xuICAgICAgICAgICAgICAgICAgICA/IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKClcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKVwiO1xuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkgfHxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoXG4gICAgICAgICAgICAgICAgICBfY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcblRoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbmh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzXCIsXG4gICAgICAgICAgICAgICAgICBfY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgIG5ld0FwaU5hbWUsXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxNb3VudE5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxNb3VudE5hbWVcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWVcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsVXBkYXRlTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgaW5zdGFuY2UucmVuZGVyIHx8XG4gICAgICAgICAgICAodHlwZS5wcm90b3R5cGUgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVuZGVyXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSAlcyBpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj9cIixcbiAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSAlcyBpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuXCIsXG4gICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fFxuICAgICAgICAgICAgaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8XG4gICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSB8fFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiBEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD9cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICAgICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpbnN0YW5jZS5jb250ZXh0VHlwZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHR5cGUuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAgICFkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcy5oYXModHlwZSkgJiZcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcy5hZGQodHlwZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjaGlsZENvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIHR5cGUuY29udGV4dFR5cGVzICYmXG4gICAgICAgICAgICAhZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEuaGFzKHR5cGUpICYmXG4gICAgICAgICAgICAoZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEuYWRkKHR5cGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIHN0YXRpYyBjb250ZXh0VHlwZSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHR5cGUucHJvdG90eXBlICYmXG4gICAgICAgICAgICB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJlxuICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiBzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuIFBsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJBIHB1cmUgY29tcG9uZW50XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/XCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuIElmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCB1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciBydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpP1wiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/XCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSByZXNvbHZlZFByb3BzO1xuICAgICAgICAgIHZvaWQgMCAhPT0gaW5zdGFuY2UucHJvcHMgJiZcbiAgICAgICAgICAgIGhhc011dGF0ZWRQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyB1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpbnN0YW5jZS5kZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLlwiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXModHlwZSkgfHxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKHR5cGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBzaG91bGQgYmUgdXNlZCB3aXRoIGNvbXBvbmVudERpZFVwZGF0ZSgpLiBUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgICAgICBzdGF0ZSAmJlxuICAgICAgICAgICAgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBzdGF0ZSB8fCBpc0FycmF5SW1wbChzdGF0ZSkpICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsXCIsIG5hbWUpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAmJlxuICAgICAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHR5cGUuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byB1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHZvaWQgMCAhPT0gaW5zdGFuY2Uuc3RhdGUgPyBpbnN0YW5jZS5zdGF0ZSA6IG51bGw7XG4gICAgICAgICAgaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IHJlc29sdmVkUHJvcHM7XG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSB7IHF1ZXVlOiBbXSwgcmVwbGFjZTogITEgfTtcbiAgICAgICAgICBpbnN0YW5jZS5fcmVhY3RJbnRlcm5hbHMgPSBpbnRlcm5hbEluc3RhbmNlO1xuICAgICAgICAgIHZhciBjb250ZXh0VHlwZSRqc2NvbXAkMCA9IHR5cGUuY29udGV4dFR5cGU7XG4gICAgICAgICAgaW5zdGFuY2UuY29udGV4dCA9XG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY29udGV4dFR5cGUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHRUeXBlJGpzY29tcCQwXG4gICAgICAgICAgICAgID8gY29udGV4dFR5cGUkanNjb21wJDAuX2N1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgICA6IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IHJlc29sdmVkUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDBcbiAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQwXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSBiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDBcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKSB7XG4gICAgICAgICAgICB2YXIgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICAgICAgICByZXNvbHZlZFByb3BzLFxuICAgICAgICAgICAgICBpbml0aWFsU3RhdGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBwYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUkanNjb21wJDEgPVxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUkanNjb21wJDEpIHx8XG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSRqc2NvbXAkMSksXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuXCIsXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQxXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID1cbiAgICAgICAgICAgICAgbnVsbCA9PT0gcGFydGlhbFN0YXRlIHx8IHZvaWQgMCA9PT0gcGFydGlhbFN0YXRlXG4gICAgICAgICAgICAgICAgPyBpbml0aWFsU3RhdGVcbiAgICAgICAgICAgICAgICA6IGFzc2lnbih7fSwgaW5pdGlhbFN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAmJlxuICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgfHxcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUkanNjb21wJDIgPVxuICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiVW5rbm93blwiO1xuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnRbY29tcG9uZW50TmFtZSRqc2NvbXAkMl0gfHxcbiAgICAgICAgICAgICAgICAgIChjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgIFwiY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBjb2RlIGZyb20gY29tcG9uZW50V2lsbE1vdW50IHRvIGNvbXBvbmVudERpZE1vdW50IChwcmVmZXJyZWQgaW4gbW9zdCBjYXNlcykgb3IgdGhlIGNvbnN0cnVjdG9yLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQyXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnRbY29tcG9uZW50TmFtZSRqc2NvbXAkMl0gPVxuICAgICAgICAgICAgICAgICAgICAhMCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgICAgICBvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUgJiZcbiAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSAmJlxuICAgICAgICAgICAgICAwIDwgaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZS5sZW5ndGhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgb2xkUXVldWUgPSBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlLFxuICAgICAgICAgICAgICAgIG9sZFJlcGxhY2UgPSBpbnRlcm5hbEluc3RhbmNlLnJlcGxhY2U7XG4gICAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2UucXVldWUgPSBudWxsO1xuICAgICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlLnJlcGxhY2UgPSAhMTtcbiAgICAgICAgICAgICAgaWYgKG9sZFJlcGxhY2UgJiYgMSA9PT0gb2xkUXVldWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gb2xkUXVldWVbMF07XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gb2xkUmVwbGFjZSA/IG9sZFF1ZXVlWzBdIDogaW5zdGFuY2Uuc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGRvbnRNdXRhdGUgPSAhMCxcbiAgICAgICAgICAgICAgICAgICAgaSA9IG9sZFJlcGxhY2UgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgIGkgPCBvbGRRdWV1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBpKytcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gb2xkUXVldWVbaV0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxTdGF0ZSRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGFydGlhbFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJ0aWFsLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGFydGlhbDtcbiAgICAgICAgICAgICAgICAgIG51bGwgIT0gcGFydGlhbFN0YXRlJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICAgIChkb250TXV0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgPyAoKGRvbnRNdXRhdGUgPSAhMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAobmV4dFN0YXRlID0gYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsU3RhdGUkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgICAgICAgICAgIDogYXNzaWduKG5leHRTdGF0ZSwgcGFydGlhbFN0YXRlJGpzY29tcCQwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBjYWxsUmVuZGVySW5ERVYoaW5zdGFuY2UpO1xuICAgICAgICAgIGlmICgxMiA9PT0gcmVxdWVzdC5zdGF0dXMpIHRocm93IG51bGw7XG4gICAgICAgICAgaW5zdGFuY2UucHJvcHMgIT09IHJlc29sdmVkUHJvcHMgJiZcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJJdCBsb29rcyBsaWtlICVzIGlzIHJlYXNzaWduaW5nIGl0cyBvd24gYHRoaXMucHJvcHNgIHdoaWxlIHJlbmRlcmluZy4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBjYW4gbGVhZCB0byBjb25mdXNpbmcgYnVncy5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJhIGNvbXBvbmVudFwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9ICEwKSk7XG4gICAgICAgICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG5leHRDaGlsZHJlbiwgLTEpO1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZW5kZXIpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lJGpzY29tcCQzID1cbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiVW5rbm93blwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZSRqc2NvbXAkM10gfHxcbiAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMyxcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQzXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lJGpzY29tcCQzXSA9ICEwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKDEyID09PSByZXF1ZXN0LnN0YXR1cykgdGhyb3cgbnVsbDtcbiAgICAgICAgICB2YXIgaGFzSWQgPSAwICE9PSBsb2NhbElkQ291bnRlcixcbiAgICAgICAgICAgIGFjdGlvblN0YXRlQ291bnQgPSBhY3Rpb25TdGF0ZUNvdW50ZXIsXG4gICAgICAgICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXgkanNjb21wJDAgPSBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXg7XG4gICAgICAgICAgaWYgKHR5cGUuY29udGV4dFR5cGVzKSB7XG4gICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUkanNjb21wJDAgPVxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXNbX2NvbXBvbmVudE5hbWUkanNjb21wJDBdIHx8XG4gICAgICAgICAgICAgICgoZGlkV2FybkFib3V0Q29udGV4dFR5cGVzW19jb21wb25lbnROYW1lJGpzY29tcCQwXSA9ICEwKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggUmVhY3QudXNlQ29udGV4dCgpIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgICAgIF9jb21wb25lbnROYW1lJGpzY29tcCQwXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0eXBlICYmXG4gICAgICAgICAgICB0eXBlLmNoaWxkQ29udGV4dFR5cGVzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LlxcbiAgJXMuY2hpbGRDb250ZXh0VHlwZXMgPSAuLi5cIixcbiAgICAgICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZTIgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0gfHxcbiAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuXCIsXG4gICAgICAgICAgICAgICAgX2NvbXBvbmVudE5hbWUyXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0gPVxuICAgICAgICAgICAgICAgICEwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlLmNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICBudWxsICE9PSB0eXBlLmNvbnRleHRUeXBlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUzID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiVW5rbm93blwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gfHxcbiAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBjb250ZXh0VHlwZS5cIixcbiAgICAgICAgICAgICAgICBfY29tcG9uZW50TmFtZTNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdID1cbiAgICAgICAgICAgICAgICAhMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5pc2hGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgaGFzSWQsXG4gICAgICAgICAgICBhY3Rpb25TdGF0ZUNvdW50LFxuICAgICAgICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4JGpzY29tcCQwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgICBpZiAobnVsbCA9PT0gc2VnbWVudCkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgcHJldkNvbnRleHQgPSB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICBwcmV2S2V5UGF0aCRqc2NvbXAkMCA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBnZXRDaGlsZEZvcm1hdENvbnRleHQocHJldkNvbnRleHQsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2Q29udGV4dDtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCRqc2NvbXAkMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2NoaWxkcmVuID0gcHVzaFN0YXJ0SW5zdGFuY2UoXG4gICAgICAgICAgICBzZWdtZW50LmNodW5rcyxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgdGFzay5ibG9ja2VkUHJlYW1ibGUsXG4gICAgICAgICAgICB0YXNrLmhvaXN0YWJsZVN0YXRlLFxuICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAgIHRhc2suaXNGYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgICAgIHZhciBfcHJldkNvbnRleHQgPSB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICBfcHJldktleVBhdGgyID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHRhc2suZm9ybWF0Q29udGV4dCA9IGdldENoaWxkRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgICAgX3ByZXZDb250ZXh0LFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgKSkuaW5zZXJ0aW9uTW9kZSA9PT0gSFRNTF9IRUFEX01PREVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBwcmVhbWJsZVNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAhMSxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZWdtZW50LnByZWFtYmxlQ2hpbGRyZW4ucHVzaChwcmVhbWJsZVNlZ21lbnQpO1xuICAgICAgICAgICAgdmFyIHByZWFtYmxlVGFzayA9IGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIF9jaGlsZHJlbixcbiAgICAgICAgICAgICAgLTEsXG4gICAgICAgICAgICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICAgICAgICBwcmVhbWJsZVNlZ21lbnQsXG4gICAgICAgICAgICAgIHRhc2suYmxvY2tlZFByZWFtYmxlLFxuICAgICAgICAgICAgICB0YXNrLmhvaXN0YWJsZVN0YXRlLFxuICAgICAgICAgICAgICByZXF1ZXN0LmFib3J0YWJsZVRhc2tzLFxuICAgICAgICAgICAgICB0YXNrLmtleVBhdGgsXG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0LFxuICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0LFxuICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICB0YXNrLmlzRmFsbGJhY2ssXG4gICAgICAgICAgICAgIGVtcHR5Q29udGV4dE9iamVjdCxcbiAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwdXNoQ29tcG9uZW50U3RhY2socHJlYW1ibGVUYXNrKTtcbiAgICAgICAgICAgIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChwcmVhbWJsZVRhc2spO1xuICAgICAgICAgIH0gZWxzZSByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIF9jaGlsZHJlbiwgLTEpO1xuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IF9wcmV2Q29udGV4dDtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgyO1xuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBzZWdtZW50LmNodW5rcyxcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYXJlYVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImhyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJpbWdcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJrZXlnZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInBhcmFtXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInRyYWNrXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJ3YnJcIjpcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgIGlmIChfcHJldkNvbnRleHQuaW5zZXJ0aW9uTW9kZSA8PSBIVE1MX0hUTUxfTU9ERSkge1xuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaGFzQm9keSA9ICEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgICAgICAgICAgaWYgKF9wcmV2Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSkge1xuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaGFzSHRtbCA9ICEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJoZWFkXCI6XG4gICAgICAgICAgICAgICAgaWYgKF9wcmV2Q29udGV4dC5pbnNlcnRpb25Nb2RlIDw9IEhUTUxfSFRNTF9NT0RFKSBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcodHlwZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gITE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoJGpzY29tcCQxID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBwcm9wcy5jaGlsZHJlbiwgLTEpO1xuICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTpcbiAgICAgICAgICAgIGlmIChcImhpZGRlblwiICE9PSBwcm9wcy5tb2RlKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkMiA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgdmFyIF9wcmV2S2V5UGF0aDMgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgzO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfVklFV19UUkFOU0lUSU9OX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgc2NvcGUgY29tcG9uZW50cy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICBhOiBpZiAobnVsbCAhPT0gdGFzay5yZXBsYXkpIHtcbiAgICAgICAgICAgICAgdmFyIF9wcmV2S2V5UGF0aCA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgdmFyIF9jb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBfY29udGVudCwgLTEpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IF9wcmV2S2V5UGF0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoJGpzY29tcCQzID0gdGFzay5rZXlQYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudEJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgcGFyZW50UHJlYW1ibGUgPSB0YXNrLmJsb2NrZWRQcmVhbWJsZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRIb2lzdGFibGVTdGF0ZSA9IHRhc2suaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgcGFyZW50U2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQsXG4gICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBwcm9wcy5mYWxsYmFjayxcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgdmFyIG5ld0JvdW5kYXJ5ID1cbiAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8IEhUTUxfTU9ERVxuICAgICAgICAgICAgICAgICAgPyBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCxcbiAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVQcmVhbWJsZVN0YXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUHJlYW1ibGVTdGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIG51bGwgIT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAmJlxuICAgICAgICAgICAgICAgIChuZXdCb3VuZGFyeS50cmFja2VkQ29udGVudEtleVBhdGggPSBrZXlQYXRoKTtcbiAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcGFyZW50U2VnbWVudC5jaHVua3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAhMSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50LmNoaWxkcmVuLnB1c2goYm91bmRhcnlTZWdtZW50KTtcbiAgICAgICAgICAgICAgcGFyZW50U2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgICAgICAgICB2YXIgY29udGVudFJvb3RTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAgICExLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmFsbGJhY2tLZXlQYXRoID0gW1xuICAgICAgICAgICAgICAgICAgICBrZXlQYXRoWzBdLFxuICAgICAgICAgICAgICAgICAgICBcIlN1c3BlbnNlIEZhbGxiYWNrXCIsXG4gICAgICAgICAgICAgICAgICAgIGtleVBhdGhbMl1cbiAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICBmYWxsYmFja1JlcGxheU5vZGUgPSBbXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrS2V5UGF0aFsxXSxcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tLZXlQYXRoWzJdLFxuICAgICAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMud29ya2luZ01hcC5zZXQoXG4gICAgICAgICAgICAgICAgICBmYWxsYmFja0tleVBhdGgsXG4gICAgICAgICAgICAgICAgICBmYWxsYmFja1JlcGxheU5vZGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LnRyYWNrZWRGYWxsYmFja05vZGUgPSBmYWxsYmFja1JlcGxheU5vZGU7XG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkU2VnbWVudCA9IGJvdW5kYXJ5U2VnbWVudDtcbiAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRQcmVhbWJsZSA9IG5ld0JvdW5kYXJ5LmZhbGxiYWNrUHJlYW1ibGU7XG4gICAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gZmFsbGJhY2tLZXlQYXRoO1xuICAgICAgICAgICAgICAgIGJvdW5kYXJ5U2VnbWVudC5zdGF0dXMgPSA2O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGZhbGxiYWNrLCAtMSksXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5U2VnbWVudC5sYXN0UHVzaGVkVGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5U2VnbWVudC50ZXh0RW1iZWRkZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVNlZ21lbnQuY2h1bmtzLnB1c2godGV4dFNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAgICAgIChib3VuZGFyeVNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAgICAgICAoKGJvdW5kYXJ5U2VnbWVudC5zdGF0dXMgPSAxMiA9PT0gcmVxdWVzdC5zdGF0dXMgPyAzIDogNCksXG4gICAgICAgICAgICAgICAgICAgIHRocm93blZhbHVlKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZFNlZ21lbnQgPSBwYXJlbnRTZWdtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZFByZWFtYmxlID0gcGFyZW50UHJlYW1ibGUpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3VzcGVuZGVkUHJpbWFyeVRhc2sgPSBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgLTEsXG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudCxcbiAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LmNvbnRlbnRQcmVhbWJsZSxcbiAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LmNvbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIHRhc2suYWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgdGFzay5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgICAgICB0YXNrLmlzRmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcHVzaENvbXBvbmVudFN0YWNrKHN1c3BlbmRlZFByaW1hcnlUYXNrKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkUHJpbWFyeVRhc2spO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gbmV3Qm91bmRhcnk7XG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkUHJlYW1ibGUgPSBuZXdCb3VuZGFyeS5jb250ZW50UHJlYW1ibGU7XG4gICAgICAgICAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSA9IG5ld0JvdW5kYXJ5LmNvbnRlbnRTdGF0ZTtcbiAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRTZWdtZW50ID0gY29udGVudFJvb3RTZWdtZW50O1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IDY7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY29udGVudCwgLTEpLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQubGFzdFB1c2hlZFRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQudGV4dEVtYmVkZGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LmNodW5rcy5wdXNoKHRleHRTZXBhcmF0b3IpLFxuICAgICAgICAgICAgICAgICAgICAoY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRCksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChuZXdCb3VuZGFyeSwgY29udGVudFJvb3RTZWdtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gbmV3Qm91bmRhcnkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkuc3RhdHVzID09PSBQRU5ESU5HKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LnN0YXR1cyA9IENPTVBMRVRFRDtcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkUHJlYW1ibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUkMikge1xuICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEO1xuICAgICAgICAgICAgICAgICAgaWYgKDEyID09PSByZXF1ZXN0LnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gMztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gcmVxdWVzdC5mYXRhbEVycm9yO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIChjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gNCksIChlcnJvciA9IHRocm93blZhbHVlJDIpO1xuICAgICAgICAgICAgICAgICAgdmFyIHRocm93bkluZm8gPSBnZXRUaHJvd25JbmZvKHRhc2suY29tcG9uZW50U3RhY2spO1xuICAgICAgICAgICAgICAgICAgdmFyIGVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHRocm93bkluZm8sXG4gICAgICAgICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgdGhyb3duSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB1bnRyYWNrQm91bmRhcnkocmVxdWVzdCwgbmV3Qm91bmRhcnkpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAodGFzay5ibG9ja2VkQm91bmRhcnkgPSBwYXJlbnRCb3VuZGFyeSksXG4gICAgICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRQcmVhbWJsZSA9IHBhcmVudFByZWFtYmxlKSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2suaG9pc3RhYmxlU3RhdGUgPSBwYXJlbnRIb2lzdGFibGVTdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRTZWdtZW50ID0gcGFyZW50U2VnbWVudCksXG4gICAgICAgICAgICAgICAgICAgICh0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCRqc2NvbXAkMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdXNwZW5kZWRGYWxsYmFja1Rhc2sgPSBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBmYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgIC0xLFxuICAgICAgICAgICAgICAgICAgcGFyZW50Qm91bmRhcnksXG4gICAgICAgICAgICAgICAgICBib3VuZGFyeVNlZ21lbnQsXG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5mYWxsYmFja1ByZWFtYmxlLFxuICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkuZmFsbGJhY2tTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICBba2V5UGF0aFswXSwgXCJTdXNwZW5zZSBGYWxsYmFja1wiLCBrZXlQYXRoWzJdXSxcbiAgICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICAgICAgITAsXG4gICAgICAgICAgICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcHVzaENvbXBvbmVudFN0YWNrKHN1c3BlbmRlZEZhbGxiYWNrVGFzayk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKHN1c3BlbmRlZEZhbGxiYWNrVGFzayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiYgbnVsbCAhPT0gdHlwZSlcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgaWYgKFwicmVmXCIgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHNXaXRob3V0UmVmID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzKVxuICAgICAgICAgICAgICAgICAgXCJyZWZcIiAhPT0ga2V5ICYmIChwcm9wc1dpdGhvdXRSZWZba2V5XSA9IHByb3BzW2tleV0pO1xuICAgICAgICAgICAgICB9IGVsc2UgcHJvcHNXaXRob3V0UmVmID0gcHJvcHM7XG4gICAgICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMCA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICB0eXBlLnJlbmRlcixcbiAgICAgICAgICAgICAgICBwcm9wc1dpdGhvdXRSZWYsXG4gICAgICAgICAgICAgICAgcmVmXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgIDAgIT09IGxvY2FsSWRDb3VudGVyLFxuICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlQ291bnRlcixcbiAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXhcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZS50eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSRqc2NvbXAkMCA9IHByb3BzLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQxID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICAgIHZhciBwcmV2U25hcHNob3QgPSB0YXNrLmNvbnRleHQ7XG4gICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkNCA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHR5cGUuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFZhbHVlID0gdmFsdWUkanNjb21wJDA7XG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZS5fY3VycmVudFJlbmRlcmVyICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gdHlwZS5fY3VycmVudFJlbmRlcmVyICYmXG4gICAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlIHNhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0eXBlLl9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgICAgICAgICAgICB2YXIgcHJldk5vZGUgPSBjdXJyZW50QWN0aXZlU25hcHNob3QsXG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudDogcHJldk5vZGUsXG4gICAgICAgICAgICAgICAgICBkZXB0aDogbnVsbCA9PT0gcHJldk5vZGUgPyAwIDogcHJldk5vZGUuZGVwdGggKyAxLFxuICAgICAgICAgICAgICAgICAgY29udGV4dDogdHlwZSxcbiAgICAgICAgICAgICAgICAgIHBhcmVudFZhbHVlOiBwcmV2VmFsdWUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBuZXdOb2RlO1xuICAgICAgICAgICAgICB0YXNrLmNvbnRleHQgPSBuZXdOb2RlO1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4kanNjb21wJDEsIC0xKTtcbiAgICAgICAgICAgICAgdmFyIHByZXZTbmFwc2hvdCRqc2NvbXAkMCA9IGN1cnJlbnRBY3RpdmVTbmFwc2hvdDtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHByZXZTbmFwc2hvdCRqc2NvbXAkMClcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVHJpZWQgdG8gcG9wIGEgQ29udGV4dCBhdCB0aGUgcm9vdCBvZiB0aGUgYXBwLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHJldlNuYXBzaG90JGpzY29tcCQwLmNvbnRleHQgIT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUaGUgcGFyZW50IGNvbnRleHQgaXMgbm90IHRoZSBleHBlY3RlZCBjb250ZXh0LiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHJldlNuYXBzaG90JGpzY29tcCQwLmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgcHJldlNuYXBzaG90JGpzY29tcCQwLnBhcmVudFZhbHVlO1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuX2N1cnJlbnRSZW5kZXJlciAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IHR5cGUuX2N1cnJlbnRSZW5kZXJlciAmJlxuICAgICAgICAgICAgICAgIHR5cGUuX2N1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkRldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSBzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcbiAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IChjdXJyZW50QWN0aXZlU25hcHNob3QgPVxuICAgICAgICAgICAgICAgIHByZXZTbmFwc2hvdCRqc2NvbXAkMC5wYXJlbnQpO1xuICAgICAgICAgICAgICB0YXNrLmNvbnRleHQgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDA7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQ0O1xuICAgICAgICAgICAgICBwcmV2U25hcHNob3QgIT09IHRhc2suY29udGV4dCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlBvcHBpbmcgdGhlIGNvbnRleHQgcHJvdmlkZXIgZGlkIG5vdCByZXR1cm4gYmFjayB0byB0aGUgb3JpZ2luYWwgc25hcHNob3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICAgIHZhciBjb250ZXh0JGpzY29tcCQwID0gdHlwZS5fY29udGV4dCxcbiAgICAgICAgICAgICAgICByZW5kZXIgPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcmVuZGVyICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkIHRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgdGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlIGlzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSByZW5kZXIoY29udGV4dCRqc2NvbXAkMC5fY3VycmVudFZhbHVlKSxcbiAgICAgICAgICAgICAgICBwcmV2S2V5UGF0aCRqc2NvbXAkNSA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG5ld0NoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQ1O1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IGNhbGxMYXp5SW5pdEluREVWKHR5cGUpO1xuICAgICAgICAgICAgICBpZiAoMTIgPT09IHJlcXVlc3Quc3RhdHVzKSB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIENvbXBvbmVudCwgcHJvcHMsIHJlZik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIHZhciBpbmZvID0gXCJcIjtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHZvaWQgMCA9PT0gdHlwZSB8fFxuICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgMCA9PT0gT2JqZWN0LmtleXModHlwZSkubGVuZ3RoKVxuICAgICAgICApXG4gICAgICAgICAgaW5mbyArPVxuICAgICAgICAgICAgXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogXCIgK1xuICAgICAgICAgICAgKChudWxsID09IHR5cGUgPyB0eXBlIDogdHlwZW9mIHR5cGUpICsgXCIuXCIgKyBpbmZvKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXN1bWVOb2RlKHJlcXVlc3QsIHRhc2ssIHNlZ21lbnRJZCwgbm9kZSwgY2hpbGRJbmRleCkge1xuICAgICAgdmFyIHByZXZSZXBsYXkgPSB0YXNrLnJlcGxheSxcbiAgICAgICAgYmxvY2tlZEJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgIHJlc3VtZWRTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICExLFxuICAgICAgICAgICExXG4gICAgICAgICk7XG4gICAgICByZXN1bWVkU2VnbWVudC5pZCA9IHNlZ21lbnRJZDtcbiAgICAgIHJlc3VtZWRTZWdtZW50LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgIHRyeSB7XG4gICAgICAgICh0YXNrLnJlcGxheSA9IG51bGwpLFxuICAgICAgICAgICh0YXNrLmJsb2NrZWRTZWdtZW50ID0gcmVzdW1lZFNlZ21lbnQpLFxuICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCksXG4gICAgICAgICAgKHJlc3VtZWRTZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRCksXG4gICAgICAgICAgbnVsbCA9PT0gYmxvY2tlZEJvdW5kYXJ5XG4gICAgICAgICAgICA/IChyZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID0gcmVzdW1lZFNlZ21lbnQpXG4gICAgICAgICAgICA6IChxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYmxvY2tlZEJvdW5kYXJ5LCByZXN1bWVkU2VnbWVudCksXG4gICAgICAgICAgICAgIGJsb2NrZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcy5wdXNoKGJsb2NrZWRCb3VuZGFyeSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKHRhc2sucmVwbGF5ID0gcHJldlJlcGxheSksICh0YXNrLmJsb2NrZWRTZWdtZW50ID0gbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxheUVsZW1lbnQoXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGFzayxcbiAgICAgIGtleVBhdGgsXG4gICAgICBuYW1lLFxuICAgICAga2V5T3JJbmRleCxcbiAgICAgIGNoaWxkSW5kZXgsXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICByZWYsXG4gICAgICByZXBsYXlcbiAgICApIHtcbiAgICAgIGNoaWxkSW5kZXggPSByZXBsYXkubm9kZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkSW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjaGlsZEluZGV4W2ldO1xuICAgICAgICBpZiAoa2V5T3JJbmRleCA9PT0gbm9kZVsxXSkge1xuICAgICAgICAgIGlmICg0ID09PSBub2RlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IG5hbWUgJiYgbmFtZSAhPT0gbm9kZVswXSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJFeHBlY3RlZCB0aGUgcmVzdW1lIHRvIHJlbmRlciA8XCIgK1xuICAgICAgICAgICAgICAgICAgbm9kZVswXSArXG4gICAgICAgICAgICAgICAgICBcIj4gaW4gdGhpcyBzbG90IGJ1dCBpbnN0ZWFkIGl0IHJlbmRlcmVkIDxcIiArXG4gICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgIFwiPi4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gbm9kZVsyXTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlWzNdO1xuICAgICAgICAgICAgbmFtZSA9IHRhc2subm9kZTtcbiAgICAgICAgICAgIHRhc2sucmVwbGF5ID0geyBub2RlczogY2hpbGROb2Rlcywgc2xvdHM6IG5vZGUsIHBlbmRpbmdUYXNrczogMSB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDEgPT09IHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgIDAgPCB0YXNrLnJlcGxheS5ub2Rlcy5sZW5ndGhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDb3VsZG4ndCBmaW5kIGFsbCByZXN1bWFibGUgc2xvdHMgYnkga2V5L2luZGV4IGR1cmluZyByZXBsYXlpbmcuIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IHggJiZcbiAgICAgICAgICAgICAgICAoeCA9PT0gU3VzcGVuc2VFeGNlcHRpb24gfHwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeC50aGVuKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgKHRhc2subm9kZSA9PT0gbmFtZSAmJiAodGFzay5yZXBsYXkgPSByZXBsYXkpLCB4KTtcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgIHR5cGUgPSBnZXRUaHJvd25JbmZvKHRhc2suY29tcG9uZW50U3RhY2spO1xuICAgICAgICAgICAgICBwcm9wcyA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgICAgICAgICAgICAga2V5UGF0aCA9IHg7XG4gICAgICAgICAgICAgIHJlZiA9IG5vZGU7XG4gICAgICAgICAgICAgIG5vZGUgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHByb3BzLCBrZXlQYXRoLCB0eXBlLCB0YXNrLmRlYnVnVGFzayk7XG4gICAgICAgICAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMoXG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLFxuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFzay5yZXBsYXkgPSByZXBsYXk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSBSRUFDVF9TVVNQRU5TRV9UWVBFKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSByZXN1bWUgdG8gcmVuZGVyIDxTdXNwZW5zZT4gaW4gdGhpcyBzbG90IGJ1dCBpbnN0ZWFkIGl0IHJlbmRlcmVkIDxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiVW5rbm93blwiKSArXG4gICAgICAgICAgICAgICAgICBcIj4uIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgIHJlcGxheSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgdHlwZSA9IG5vZGVbNV07XG4gICAgICAgICAgICAgIHJlZiA9IG5vZGVbMl07XG4gICAgICAgICAgICAgIG5hbWUgPSBub2RlWzNdO1xuICAgICAgICAgICAgICBrZXlPckluZGV4ID0gbnVsbCA9PT0gbm9kZVs0XSA/IFtdIDogbm9kZVs0XVsyXTtcbiAgICAgICAgICAgICAgbm9kZSA9IG51bGwgPT09IG5vZGVbNF0gPyBudWxsIDogbm9kZVs0XVszXTtcbiAgICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzUmVwbGF5U2V0ID0gdGFzay5yZXBsYXksXG4gICAgICAgICAgICAgICAgcGFyZW50Qm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICBwYXJlbnRIb2lzdGFibGVTdGF0ZSA9IHRhc2suaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgY29udGVudCA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrID0gcHJvcHMuZmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgcHJvcHMgPVxuICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFXG4gICAgICAgICAgICAgICAgICA/IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0LFxuICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVByZWFtYmxlU3RhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVQcmVhbWJsZVN0YXRlKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHJvcHMucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgICAgICAgICBwcm9wcy5yb290U2VnbWVudElEID0gdHlwZTtcbiAgICAgICAgICAgICAgdGFzay5ibG9ja2VkQm91bmRhcnkgPSBwcm9wcztcbiAgICAgICAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSA9IHByb3BzLmNvbnRlbnRTdGF0ZTtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkgPSB7IG5vZGVzOiByZWYsIHNsb3RzOiBuYW1lLCBwZW5kaW5nVGFza3M6IDEgfTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNvbnRlbnQsIC0xKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAxID09PSB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgIDAgPCB0YXNrLnJlcGxheS5ub2Rlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJDb3VsZG4ndCBmaW5kIGFsbCByZXN1bWFibGUgc2xvdHMgYnkga2V5L2luZGV4IGR1cmluZyByZXBsYXlpbmcuIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBwcm9wcy5wZW5kaW5nVGFza3MgJiYgcHJvcHMuc3RhdHVzID09PSBQRU5ESU5HKSB7XG4gICAgICAgICAgICAgICAgICBwcm9wcy5zdGF0dXMgPSBDT01QTEVURUQ7XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXMucHVzaChwcm9wcyk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAocHJvcHMuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEKSxcbiAgICAgICAgICAgICAgICAgIChjaGlsZE5vZGVzID0gZ2V0VGhyb3duSW5mbyh0YXNrLmNvbXBvbmVudFN0YWNrKSksXG4gICAgICAgICAgICAgICAgICAocmVwbGF5ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgIGVuY29kZUVycm9yRm9yQm91bmRhcnkocHJvcHMsIHJlcGxheSwgZXJyb3IsIGNoaWxkTm9kZXMsICExKSxcbiAgICAgICAgICAgICAgICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tLFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChwcm9wcyk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcGFyZW50Qm91bmRhcnkpLFxuICAgICAgICAgICAgICAgICAgKHRhc2suaG9pc3RhYmxlU3RhdGUgPSBwYXJlbnRIb2lzdGFibGVTdGF0ZSksXG4gICAgICAgICAgICAgICAgICAodGFzay5yZXBsYXkgPSBwcmV2aW91c1JlcGxheVNldCksXG4gICAgICAgICAgICAgICAgICAodGFzay5rZXlQYXRoID0gcHJldktleVBhdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHByb3BzID0gY3JlYXRlUmVwbGF5VGFzayhcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgeyBub2Rlczoga2V5T3JJbmRleCwgc2xvdHM6IG5vZGUsIHBlbmRpbmdUYXNrczogMCB9LFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIC0xLFxuICAgICAgICAgICAgICAgIHBhcmVudEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIHByb3BzLmZhbGxiYWNrU3RhdGUsXG4gICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCxcbiAgICAgICAgICAgICAgICBba2V5UGF0aFswXSwgXCJTdXNwZW5zZSBGYWxsYmFja1wiLCBrZXlQYXRoWzJdXSxcbiAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICAgICAgdGFzay5jb250ZXh0LFxuICAgICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgICAgICAgICAhMCxcbiAgICAgICAgICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHVzaENvbXBvbmVudFN0YWNrKHByb3BzKTtcbiAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGRJbmRleC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpIHtcbiAgICAgIG51bGwgIT09IHRhc2sucmVwbGF5ICYmIFwibnVtYmVyXCIgPT09IHR5cGVvZiB0YXNrLnJlcGxheS5zbG90c1xuICAgICAgICA/IHJlc3VtZU5vZGUocmVxdWVzdCwgdGFzaywgdGFzay5yZXBsYXkuc2xvdHMsIG5vZGUsIGNoaWxkSW5kZXgpXG4gICAgICAgIDogKCh0YXNrLm5vZGUgPSBub2RlKSxcbiAgICAgICAgICAodGFzay5jaGlsZEluZGV4ID0gY2hpbGRJbmRleCksXG4gICAgICAgICAgKG5vZGUgPSB0YXNrLmNvbXBvbmVudFN0YWNrKSxcbiAgICAgICAgICAoY2hpbGRJbmRleCA9IHRhc2suZGVidWdUYXNrKSxcbiAgICAgICAgICBwdXNoQ29tcG9uZW50U3RhY2sodGFzayksXG4gICAgICAgICAgcmV0cnlOb2RlKHJlcXVlc3QsIHRhc2spLFxuICAgICAgICAgICh0YXNrLmNvbXBvbmVudFN0YWNrID0gbm9kZSksXG4gICAgICAgICAgKHRhc2suZGVidWdUYXNrID0gY2hpbGRJbmRleCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXRyeU5vZGUocmVxdWVzdCwgdGFzaykge1xuICAgICAgdmFyIG5vZGUgPSB0YXNrLm5vZGUsXG4gICAgICAgIGNoaWxkSW5kZXggPSB0YXNrLmNoaWxkSW5kZXg7XG4gICAgICBpZiAobnVsbCAhPT0gbm9kZSkge1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5vZGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICB2YXIgdHlwZSA9IG5vZGUudHlwZSxcbiAgICAgICAgICAgICAgICBrZXkgPSBub2RlLmtleTtcbiAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucHJvcHM7XG4gICAgICAgICAgICAgIHZhciByZWZQcm9wID0gbm9kZS5yZWY7XG4gICAgICAgICAgICAgIHJlZlByb3AgPSB2b2lkIDAgIT09IHJlZlByb3AgPyByZWZQcm9wIDogbnVsbDtcbiAgICAgICAgICAgICAgdmFyIGRlYnVnVGFzayA9IHRhc2suZGVidWdUYXNrLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgICAgICAgIGtleSA9IG51bGwgPT0ga2V5ID8gKC0xID09PSBjaGlsZEluZGV4ID8gMCA6IGNoaWxkSW5kZXgpIDoga2V5O1xuICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IFt0YXNrLmtleVBhdGgsIG5hbWUsIGtleV07XG4gICAgICAgICAgICAgIG51bGwgIT09IHRhc2sucmVwbGF5XG4gICAgICAgICAgICAgICAgPyBkZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICAgID8gZGVidWdUYXNrLnJ1bihcbiAgICAgICAgICAgICAgICAgICAgICByZXBsYXlFbGVtZW50LmJpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnJlcGxheVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiByZXBsYXlFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgIHJlZlByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgdGFzay5yZXBsYXlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogZGVidWdUYXNrXG4gICAgICAgICAgICAgICAgICA/IGRlYnVnVGFzay5ydW4oXG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudC5iaW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmUHJvcFxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUsIG5vZGUsIHJlZlByb3ApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlBvcnRhbHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXIgcmVuZGVyZXIuIFJlbmRlciB0aGVtIGNvbmRpdGlvbmFsbHkgc28gdGhhdCB0aGV5IG9ubHkgYXBwZWFyIG9uIHRoZSBjbGllbnQgcmVuZGVyLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgbm9kZSA9IGNhbGxMYXp5SW5pdEluREVWKG5vZGUpO1xuICAgICAgICAgICAgICBpZiAoMTIgPT09IHJlcXVlc3Quc3RhdHVzKSB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5vZGUpKSB7XG4gICAgICAgICAgICByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudWxsID09PSBub2RlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/IChrZXkgPSBudWxsKVxuICAgICAgICAgICAgOiAoKHR5cGUgPVxuICAgICAgICAgICAgICAgIChNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbm9kZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgICAgICAgICAgIG5vZGVbXCJAQGl0ZXJhdG9yXCJdKSxcbiAgICAgICAgICAgICAgKGtleSA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUgPyB0eXBlIDogbnVsbCkpO1xuICAgICAgICAgIGlmIChrZXkgJiYgKHR5cGUgPSBrZXkuY2FsbChub2RlKSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAtMSAhPT0gY2hpbGRJbmRleCB8fFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHRhc2suY29tcG9uZW50U3RhY2sgfHxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB0YXNrLmNvbXBvbmVudFN0YWNrLnR5cGUgfHxcbiAgICAgICAgICAgICAgICBcIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dXCIgIT09XG4gICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFzay5jb21wb25lbnRTdGFjay50eXBlKSB8fFxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JdXCIgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0eXBlKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyB8fFxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJVc2luZyBJdGVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkIHVuZXhwZWN0ZWQgcmVzdWx0cyBiZWNhdXNlIGVudW1lcmF0aW5nIGEgZ2VuZXJhdG9yIG11dGF0ZXMgaXQuIFlvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSBgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIFlvdSBjYW4gYWxzbyB1c2UgYW4gSXRlcmFibGUgdGhhdCBjYW4gaXRlcmF0ZSBtdWx0aXBsZSB0aW1lcyBvdmVyIHRoZSBzYW1lIGl0ZW1zLlwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSAhMCk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgbm9kZS5lbnRyaWVzICE9PSBrZXkgfHxcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzIHx8XG4gICAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dE1hcHMgPSAhMCkpO1xuICAgICAgICAgICAgbm9kZSA9IHR5cGUubmV4dCgpO1xuICAgICAgICAgICAgaWYgKCFub2RlLmRvbmUpIHtcbiAgICAgICAgICAgICAga2V5ID0gW107XG4gICAgICAgICAgICAgIGRvIGtleS5wdXNoKG5vZGUudmFsdWUpLCAobm9kZSA9IHR5cGUubmV4dCgpKTtcbiAgICAgICAgICAgICAgd2hpbGUgKCFub2RlLmRvbmUpO1xuICAgICAgICAgICAgICByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIGtleSwgY2hpbGRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBub2RlLnRoZW4pXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAodGFzay50aGVuYWJsZVN0YXRlID0gbnVsbCksXG4gICAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgdW53cmFwVGhlbmFibGUobm9kZSksXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICBub2RlLl9jdXJyZW50VmFsdWUsXG4gICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVxdWVzdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChub2RlKTtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArXG4gICAgICAgICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgPyBcIm9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMobm9kZSkuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgICAgICA6IHJlcXVlc3QpICtcbiAgICAgICAgICAgICAgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgPyAoKHRhc2sgPSB0YXNrLmJsb2NrZWRTZWdtZW50KSxcbiAgICAgICAgICAgIG51bGwgIT09IHRhc2sgJiZcbiAgICAgICAgICAgICAgKHRhc2subGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgIHRhc2suY2h1bmtzLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICB0YXNrLmxhc3RQdXNoZWRUZXh0XG4gICAgICAgICAgICAgICkpKVxuICAgICAgICAgIDogXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5vZGUgfHwgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5vZGVcbiAgICAgICAgICAgID8gKCh0YXNrID0gdGFzay5ibG9ja2VkU2VnbWVudCksXG4gICAgICAgICAgICAgIG51bGwgIT09IHRhc2sgJiZcbiAgICAgICAgICAgICAgICAodGFzay5sYXN0UHVzaGVkVGV4dCA9IHB1c2hUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICB0YXNrLmNodW5rcyxcbiAgICAgICAgICAgICAgICAgIFwiXCIgKyBub2RlLFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIHRhc2subGFzdFB1c2hlZFRleHRcbiAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgICAgICAgICAoKHJlcXVlc3QgPSBub2RlLmRpc3BsYXlOYW1lIHx8IG5vZGUubmFtZSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgeW91IHJldHVybiAlcyBpbnN0ZWFkIG9mIDwlcyAvPiBmcm9tIHJlbmRlci4gT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXCIsXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlN5bWJvbHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLlxcbiAgJXNcIixcbiAgICAgICAgICAgICAgICAgIFN0cmluZyhub2RlKVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCBjaGlsZEluZGV4KSB7XG4gICAgICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGgsXG4gICAgICAgIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrO1xuICAgICAgdmFyIHByZXZpb3VzRGVidWdUYXNrID0gdGFzay5kZWJ1Z1Rhc2s7XG4gICAgICBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgdGFzay5ub2RlLl9kZWJ1Z0luZm8pO1xuICAgICAgaWYgKFxuICAgICAgICAtMSAhPT0gY2hpbGRJbmRleCAmJlxuICAgICAgICAoKHRhc2sua2V5UGF0aCA9IFt0YXNrLmtleVBhdGgsIFwiRnJhZ21lbnRcIiwgY2hpbGRJbmRleF0pLFxuICAgICAgICBudWxsICE9PSB0YXNrLnJlcGxheSlcbiAgICAgICkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciByZXBsYXkgPSB0YXNrLnJlcGxheSwgcmVwbGF5Tm9kZXMgPSByZXBsYXkubm9kZXMsIGogPSAwO1xuICAgICAgICAgIGogPCByZXBsYXlOb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgaisrXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBub2RlID0gcmVwbGF5Tm9kZXNbal07XG4gICAgICAgICAgaWYgKG5vZGVbMV0gPT09IGNoaWxkSW5kZXgpIHtcbiAgICAgICAgICAgIGNoaWxkSW5kZXggPSBub2RlWzJdO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVbM107XG4gICAgICAgICAgICB0YXNrLnJlcGxheSA9IHsgbm9kZXM6IGNoaWxkSW5kZXgsIHNsb3RzOiBub2RlLCBwZW5kaW5nVGFza3M6IDEgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDEgPT09IHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgIDAgPCB0YXNrLnJlcGxheS5ub2Rlcy5sZW5ndGhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDb3VsZG4ndCBmaW5kIGFsbCByZXN1bWFibGUgc2xvdHMgYnkga2V5L2luZGV4IGR1cmluZyByZXBsYXlpbmcuIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IHggJiZcbiAgICAgICAgICAgICAgICAoeCA9PT0gU3VzcGVuc2VFeGNlcHRpb24gfHwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeC50aGVuKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgeDtcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgIHZhciB0aHJvd25JbmZvID0gZ2V0VGhyb3duSW5mbyh0YXNrLmNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0geCxcbiAgICAgICAgICAgICAgICByZXN1bWVTbG90cyA9IG5vZGU7XG4gICAgICAgICAgICAgIG5vZGUgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgdGhyb3duSW5mbyxcbiAgICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleCxcbiAgICAgICAgICAgICAgICByZXN1bWVTbG90cyxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIHRocm93bkluZm8sXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2sucmVwbGF5ID0gcmVwbGF5O1xuICAgICAgICAgICAgcmVwbGF5Tm9kZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBwcmV2aW91c0RlYnVnVGFzaztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVwbGF5ID0gdGFzay50cmVlQ29udGV4dDtcbiAgICAgIHJlcGxheU5vZGVzID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSB0YXNrLnJlcGxheSAmJlxuICAgICAgICAoKGogPSB0YXNrLnJlcGxheS5zbG90cyksIG51bGwgIT09IGogJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGopXG4gICAgICApIHtcbiAgICAgICAgZm9yIChjaGlsZEluZGV4ID0gMDsgY2hpbGRJbmRleCA8IHJlcGxheU5vZGVzOyBjaGlsZEluZGV4KyspXG4gICAgICAgICAgKG5vZGUgPSBjaGlsZHJlbltjaGlsZEluZGV4XSksXG4gICAgICAgICAgICAodGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChcbiAgICAgICAgICAgICAgcmVwbGF5LFxuICAgICAgICAgICAgICByZXBsYXlOb2RlcyxcbiAgICAgICAgICAgICAgY2hpbGRJbmRleFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAoZXJyb3IgPSBqW2NoaWxkSW5kZXhdKSxcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBlcnJvclxuICAgICAgICAgICAgICA/IChyZXN1bWVOb2RlKHJlcXVlc3QsIHRhc2ssIGVycm9yLCBub2RlLCBjaGlsZEluZGV4KSxcbiAgICAgICAgICAgICAgICBkZWxldGUgaltjaGlsZEluZGV4XSlcbiAgICAgICAgICAgICAgOiByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcmVwbGF5O1xuICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDA7IGogPCByZXBsYXlOb2RlczsgaisrKSB7XG4gICAgICAgIGNoaWxkSW5kZXggPSBjaGlsZHJlbltqXTtcbiAgICAgICAgcmVzdW1lU2xvdHMgPSByZXF1ZXN0O1xuICAgICAgICBub2RlID0gdGFzaztcbiAgICAgICAgZXJyb3IgPSBjaGlsZEluZGV4O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiZcbiAgICAgICAgICAoZXJyb3IuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSB8fFxuICAgICAgICAgICAgZXJyb3IuJCR0eXBlb2YgPT09IFJFQUNUX1BPUlRBTF9UWVBFKSAmJlxuICAgICAgICAgIGVycm9yLl9zdG9yZSAmJlxuICAgICAgICAgICgoIWVycm9yLl9zdG9yZS52YWxpZGF0ZWQgJiYgbnVsbCA9PSBlcnJvci5rZXkpIHx8XG4gICAgICAgICAgICAyID09PSBlcnJvci5fc3RvcmUudmFsaWRhdGVkKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGVycm9yLl9zdG9yZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBlcnJvci5fc3RvcmUudmFsaWRhdGVkID0gMTtcbiAgICAgICAgICB0aHJvd25JbmZvID0gcmVzdW1lU2xvdHMuZGlkV2FybkZvcktleTtcbiAgICAgICAgICBudWxsID09IHRocm93bkluZm8gJiZcbiAgICAgICAgICAgICh0aHJvd25JbmZvID0gcmVzdW1lU2xvdHMuZGlkV2FybkZvcktleSA9IG5ldyBXZWFrU2V0KCkpO1xuICAgICAgICAgIHJlc3VtZVNsb3RzID0gbm9kZS5jb21wb25lbnRTdGFjaztcbiAgICAgICAgICBpZiAobnVsbCAhPT0gcmVzdW1lU2xvdHMgJiYgIXRocm93bkluZm8uaGFzKHJlc3VtZVNsb3RzKSkge1xuICAgICAgICAgICAgdGhyb3duSW5mby5hZGQocmVzdW1lU2xvdHMpO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZXJyb3IudHlwZSk7XG4gICAgICAgICAgICB0aHJvd25JbmZvID0gZXJyb3IuX293bmVyO1xuICAgICAgICAgICAgdmFyIHBhcmVudE93bmVyID0gcmVzdW1lU2xvdHMub3duZXI7XG4gICAgICAgICAgICByZXN1bWVTbG90cyA9IFwiXCI7XG4gICAgICAgICAgICBpZiAocGFyZW50T3duZXIgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHBhcmVudE93bmVyLnR5cGUpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50T3duZXIudHlwZSk7XG4gICAgICAgICAgICAgIG5hbWUgJiZcbiAgICAgICAgICAgICAgICAocmVzdW1lU2xvdHMgPVxuICAgICAgICAgICAgICAgICAgXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBuYW1lICsgXCJgLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VtZVNsb3RzIHx8XG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAgICAgKHJlc3VtZVNsb3RzID1cbiAgICAgICAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgK1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSArXG4gICAgICAgICAgICAgICAgICBcIj4uXCIpKTtcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgbnVsbCAhPSB0aHJvd25JbmZvICYmXG4gICAgICAgICAgICAgIHBhcmVudE93bmVyICE9PSB0aHJvd25JbmZvICYmXG4gICAgICAgICAgICAgICgocGFyZW50T3duZXIgPSBudWxsKSxcbiAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHRocm93bkluZm8udHlwZVxuICAgICAgICAgICAgICAgID8gKHBhcmVudE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRocm93bkluZm8udHlwZSkpXG4gICAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgdGhyb3duSW5mby5uYW1lICYmXG4gICAgICAgICAgICAgICAgICAocGFyZW50T3duZXIgPSB0aHJvd25JbmZvLm5hbWUpLFxuICAgICAgICAgICAgICBwYXJlbnRPd25lciAmJlxuICAgICAgICAgICAgICAgIChjb21wb25lbnROYW1lID1cbiAgICAgICAgICAgICAgICAgIFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgcGFyZW50T3duZXIgKyBcIi5cIikpO1xuICAgICAgICAgICAgdGhyb3duSW5mbyA9IG5vZGUuY29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICBub2RlLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgICAgICAgICBwYXJlbnQ6IG5vZGUuY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgIHR5cGU6IGVycm9yLnR5cGUsXG4gICAgICAgICAgICAgIG93bmVyOiBlcnJvci5fb3duZXIsXG4gICAgICAgICAgICAgIHN0YWNrOiBlcnJvci5fZGVidWdTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICAgICAgcmVzdW1lU2xvdHMsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBub2RlLmNvbXBvbmVudFN0YWNrID0gdGhyb3duSW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChyZXBsYXksIHJlcGxheU5vZGVzLCBqKTtcbiAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZEluZGV4LCBqKTtcbiAgICAgIH1cbiAgICAgIHRhc2sudHJlZUNvbnRleHQgPSByZXBsYXk7XG4gICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBwcmV2aW91c0RlYnVnVGFzaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdW50cmFja0JvdW5kYXJ5KHJlcXVlc3QsIGJvdW5kYXJ5KSB7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzO1xuICAgICAgbnVsbCAhPT0gcmVxdWVzdCAmJlxuICAgICAgICAoKGJvdW5kYXJ5ID0gYm91bmRhcnkudHJhY2tlZENvbnRlbnRLZXlQYXRoKSxcbiAgICAgICAgbnVsbCAhPT0gYm91bmRhcnkgJiZcbiAgICAgICAgICAoKGJvdW5kYXJ5ID0gcmVxdWVzdC53b3JraW5nTWFwLmdldChib3VuZGFyeSkpLFxuICAgICAgICAgIHZvaWQgMCAhPT0gYm91bmRhcnkgJiZcbiAgICAgICAgICAgICgoYm91bmRhcnkubGVuZ3RoID0gNCksIChib3VuZGFyeVsyXSA9IFtdKSwgKGJvdW5kYXJ5WzNdID0gbnVsbCkpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhyZXF1ZXN0LCB0YXNrLCB0aGVuYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVwbGF5VGFzayhcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgdGhlbmFibGVTdGF0ZSxcbiAgICAgICAgdGFzay5yZXBsYXksXG4gICAgICAgIHRhc2subm9kZSxcbiAgICAgICAgdGFzay5jaGlsZEluZGV4LFxuICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgdGFzay5hYm9ydFNldCxcbiAgICAgICAgdGFzay5rZXlQYXRoLFxuICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgdGFzay5pc0ZhbGxiYWNrLFxuICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2socmVxdWVzdCwgdGFzaywgdGhlbmFibGVTdGF0ZSkge1xuICAgICAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50LFxuICAgICAgICBuZXdTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBzZWdtZW50LmNodW5rcy5sZW5ndGgsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAhMFxuICAgICAgICApO1xuICAgICAgc2VnbWVudC5jaGlsZHJlbi5wdXNoKG5ld1NlZ21lbnQpO1xuICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIHRoZW5hYmxlU3RhdGUsXG4gICAgICAgIHRhc2subm9kZSxcbiAgICAgICAgdGFzay5jaGlsZEluZGV4LFxuICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgbmV3U2VnbWVudCxcbiAgICAgICAgdGFzay5ibG9ja2VkUHJlYW1ibGUsXG4gICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgIHRhc2suYWJvcnRTZXQsXG4gICAgICAgIHRhc2sua2V5UGF0aCxcbiAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgIHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgIHRhc2suaXNGYWxsYmFjayxcbiAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gICAgICB2YXIgcHJldmlvdXNGb3JtYXRDb250ZXh0ID0gdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICBwcmV2aW91c0NvbnRleHQgPSB0YXNrLmNvbnRleHQsXG4gICAgICAgIHByZXZpb3VzS2V5UGF0aCA9IHRhc2sua2V5UGF0aCxcbiAgICAgICAgcHJldmlvdXNUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICBwcmV2aW91c0RlYnVnVGFzayA9IHRhc2suZGVidWdUYXNrLFxuICAgICAgICBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgIGlmIChudWxsID09PSBzZWdtZW50KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHJlc2V0SG9va3NTdGF0ZSgpLFxuICAgICAgICAgICAgKG5vZGUgPVxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICA/IGdldFN1c3BlbmRlZFRoZW5hYmxlKClcbiAgICAgICAgICAgICAgICA6IHRocm93blZhbHVlKSxcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmIG51bGwgIT09IG5vZGUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygbm9kZS50aGVuKSB7XG4gICAgICAgICAgICAgIGNoaWxkSW5kZXggPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSBzcGF3bk5ld1N1c3BlbmRlZFJlcGxheVRhc2soXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgKS5waW5nO1xuICAgICAgICAgICAgICBub2RlLnRoZW4ocmVxdWVzdCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBwcmV2aW91c0RlYnVnVGFzaztcbiAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiID09PSBub2RlLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgbm9kZSA9IHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhyZXF1ZXN0LCB0YXNrLCBub2RlKTtcbiAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgIGNodW5rTGVuZ3RoID0gc2VnbWVudC5jaHVua3MubGVuZ3RoO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlJDMpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocmVzZXRIb29rc1N0YXRlKCksXG4gICAgICAgICAgICAoc2VnbWVudC5jaGlsZHJlbi5sZW5ndGggPSBjaGlsZHJlbkxlbmd0aCksXG4gICAgICAgICAgICAoc2VnbWVudC5jaHVua3MubGVuZ3RoID0gY2h1bmtMZW5ndGgpLFxuICAgICAgICAgICAgKG5vZGUgPVxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSQzID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgID8gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKVxuICAgICAgICAgICAgICAgIDogdGhyb3duVmFsdWUkMyksXG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJiBudWxsICE9PSBub2RlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUudGhlbikge1xuICAgICAgICAgICAgICBjaGlsZEluZGV4ID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICAgICAgICByZXF1ZXN0ID0gc3Bhd25OZXdTdXNwZW5kZWRSZW5kZXJUYXNrKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICAgICkucGluZztcbiAgICAgICAgICAgICAgbm9kZS50aGVuKHJlcXVlc3QsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwiTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIiA9PT0gbm9kZS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgIG5vZGUgPSBzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2socmVxdWVzdCwgdGFzaywgbm9kZSk7XG4gICAgICAgICAgICAgIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZpb3VzVHJlZUNvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFzayA9IHByZXZpb3VzRGVidWdUYXNrO1xuICAgICAgICAgICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0O1xuICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgdGhyb3cgbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWJvcnRUYXNrU29mdCh0YXNrKSB7XG4gICAgICB2YXIgYm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgICAgIHRhc2sgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgbnVsbCAhPT0gdGFzayAmJiAoKHRhc2suc3RhdHVzID0gMyksIGZpbmlzaGVkVGFzayh0aGlzLCBib3VuZGFyeSwgdGFzaykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgcmVxdWVzdCRqc2NvbXAkMCxcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgbm9kZXMsXG4gICAgICBzbG90cyxcbiAgICAgIGVycm9yJGpzY29tcCQwLFxuICAgICAgZXJyb3JEaWdlc3QkanNjb21wJDAsXG4gICAgICBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICBhYm9ydGVkXG4gICAgKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmICg0ID09PSBub2RlLmxlbmd0aClcbiAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgbm9kZVsyXSxcbiAgICAgICAgICAgIG5vZGVbM10sXG4gICAgICAgICAgICBlcnJvciRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9yRGlnZXN0JGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQwLFxuICAgICAgICAgICAgYWJvcnRlZFxuICAgICAgICAgICk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciByZXF1ZXN0ID0gcmVxdWVzdCRqc2NvbXAkMDtcbiAgICAgICAgICBub2RlID0gbm9kZVs1XTtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBlcnJvciRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9yRGlnZXN0ID0gZXJyb3JEaWdlc3QkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvckluZm8gPSBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICAgICAgICB3YXNBYm9ydGVkID0gYWJvcnRlZCxcbiAgICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bWVkQm91bmRhcnkucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeS5yb290U2VnbWVudElEID0gbm9kZTtcbiAgICAgICAgICByZXN1bWVkQm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEO1xuICAgICAgICAgIGVuY29kZUVycm9yRm9yQm91bmRhcnkoXG4gICAgICAgICAgICByZXN1bWVkQm91bmRhcnksXG4gICAgICAgICAgICBlcnJvckRpZ2VzdCxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgZXJyb3JJbmZvLFxuICAgICAgICAgICAgd2FzQWJvcnRlZFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2gocmVzdW1lZEJvdW5kYXJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZXMubGVuZ3RoID0gMDtcbiAgICAgIGlmIChudWxsICE9PSBzbG90cykge1xuICAgICAgICBpZiAobnVsbCA9PT0gYm91bmRhcnkpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIldlIHNob3VsZCBub3QgaGF2ZSBhbnkgcmVzdW1hYmxlIG5vZGVzIGluIHRoZSBzaGVsbC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEICYmXG4gICAgICAgICAgKChib3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQpLFxuICAgICAgICAgIGVuY29kZUVycm9yRm9yQm91bmRhcnkoXG4gICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgIGVycm9yRGlnZXN0JGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3IkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICAgICAgICBhYm9ydGVkXG4gICAgICAgICAgKSxcbiAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwLmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2Ygc2xvdHMpXG4gICAgICAgICAgZm9yICh2YXIgaW5kZXggaW4gc2xvdHMpIGRlbGV0ZSBzbG90c1tpbmRleF07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFib3J0VGFzayh0YXNrLCByZXF1ZXN0LCBlcnJvcikge1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgaWYgKG51bGwgIT09IHNlZ21lbnQpIHtcbiAgICAgICAgaWYgKDYgPT09IHNlZ21lbnQuc3RhdHVzKSByZXR1cm47XG4gICAgICAgIHNlZ21lbnQuc3RhdHVzID0gMztcbiAgICAgIH1cbiAgICAgIHNlZ21lbnQgPSBnZXRUaHJvd25JbmZvKHRhc2suY29tcG9uZW50U3RhY2spO1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KSB7XG4gICAgICAgIGlmICgxMyAhPT0gcmVxdWVzdC5zdGF0dXMgJiYgcmVxdWVzdC5zdGF0dXMgIT09IENMT1NFRCkge1xuICAgICAgICAgIGJvdW5kYXJ5ID0gdGFzay5yZXBsYXk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KSB7XG4gICAgICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBzZWdtZW50LCBudWxsKTtcbiAgICAgICAgICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IsIHNlZ21lbnQsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib3VuZGFyeS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAwID09PSBib3VuZGFyeS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgIDAgPCBib3VuZGFyeS5ub2Rlcy5sZW5ndGggJiZcbiAgICAgICAgICAgICgodGFzayA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIHNlZ21lbnQsIG51bGwpKSxcbiAgICAgICAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGJvdW5kYXJ5Lm5vZGVzLFxuICAgICAgICAgICAgICBib3VuZGFyeS5zbG90cyxcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICAgICEwXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MtLTtcbiAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiYgY29tcGxldGVTaGVsbChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIGJvdW5kYXJ5LnBlbmRpbmdUYXNrcy0tLFxuICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEICYmXG4gICAgICAgICAgICAoKGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRCksXG4gICAgICAgICAgICAodGFzayA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIHNlZ21lbnQsIG51bGwpKSxcbiAgICAgICAgICAgIChib3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQpLFxuICAgICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShib3VuZGFyeSwgdGFzaywgZXJyb3IsIHNlZ21lbnQsICEwKSxcbiAgICAgICAgICAgIHVudHJhY2tCb3VuZGFyeShyZXF1ZXN0LCBib3VuZGFyeSksXG4gICAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpKSxcbiAgICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmZvckVhY2goZnVuY3Rpb24gKGZhbGxiYWNrVGFzaykge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0VGFzayhmYWxsYmFja1Rhc2ssIHJlcXVlc3QsIGVycm9yKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tO1xuICAgICAgMCA9PT0gcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgJiYgY29tcGxldGVBbGwocmVxdWVzdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QsIHNoZWxsQ29tcGxldGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgb25IZWFkZXJzID0gcmVuZGVyU3RhdGUub25IZWFkZXJzO1xuICAgICAgICBpZiAob25IZWFkZXJzKSB7XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5oZWFkZXJzID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBsaW5rSGVhZGVyID0gaGVhZGVycy5wcmVjb25uZWN0cztcbiAgICAgICAgICAgIGhlYWRlcnMuZm9udFByZWxvYWRzICYmXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICYmIChsaW5rSGVhZGVyICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICs9IGhlYWRlcnMuZm9udFByZWxvYWRzKSk7XG4gICAgICAgICAgICBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICYmXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICYmIChsaW5rSGVhZGVyICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICs9IGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMpKTtcbiAgICAgICAgICAgIGlmICghc2hlbGxDb21wbGV0ZSkge1xuICAgICAgICAgICAgICB2YXIgcXVldWVJdGVyID0gcmVuZGVyU3RhdGUuc3R5bGVzLnZhbHVlcygpLFxuICAgICAgICAgICAgICAgIHF1ZXVlU3RlcCA9IHF1ZXVlSXRlci5uZXh0KCk7XG4gICAgICAgICAgICAgIGI6IGZvciAoXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIDAgPCBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ICYmICFxdWV1ZVN0ZXAuZG9uZTtcbiAgICAgICAgICAgICAgICBxdWV1ZVN0ZXAgPSBxdWV1ZUl0ZXIubmV4dCgpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgdmFyIHNoZWV0SXRlciA9IHF1ZXVlU3RlcC52YWx1ZS5zaGVldHMudmFsdWVzKCksXG4gICAgICAgICAgICAgICAgICAgIHNoZWV0U3RlcCA9IHNoZWV0SXRlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAwIDwgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAmJiAhc2hlZXRTdGVwLmRvbmU7XG4gICAgICAgICAgICAgICAgICBzaGVldFN0ZXAgPSBzaGVldEl0ZXIubmV4dCgpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc2hlZXQgPSBzaGVldFN0ZXAudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzID0gc2hlZXQucHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHByb3BzLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzJGpzY29tcCQwID0gc2hlZXQucHJvcHM7XG4gICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gZ2V0UHJlbG9hZEFzSGVhZGVyKFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyRqc2NvbXAkMC5ocmVmLFxuICAgICAgICAgICAgICAgICAgICBcInN0eWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogcHJvcHMkanNjb21wJDAuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgaW50ZWdyaXR5OiBwcm9wcyRqc2NvbXAkMC5pbnRlZ3JpdHksXG4gICAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHByb3BzJGpzY29tcCQwLm5vbmNlLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHByb3BzJGpzY29tcCQwLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogcHJvcHMkanNjb21wJDAuZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICByZWZlcnJlclBvbGljeTogcHJvcHMkanNjb21wJDAucmVmZXJyZXJQb2xpY3ksXG4gICAgICAgICAgICAgICAgICAgICAgbWVkaWE6IHByb3BzJGpzY29tcCQwLm1lZGlhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAoMCA8PSAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpXG4gICAgICAgICAgICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZXNldHMuc3R5bGVba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFMpLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmtIZWFkZXIgJiYgKGxpbmtIZWFkZXIgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAobGlua0hlYWRlciArPSBoZWFkZXIpLFxuICAgICAgICAgICAgICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZXNldHMuc3R5bGVba2V5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMuY3Jvc3NPcmlnaW4gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcHJvcHMuY3Jvc3NPcmlnaW4sIHByb3BzLmludGVncml0eV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBQUkVMT0FEX05PX0NSRURTKTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rSGVhZGVyID8gb25IZWFkZXJzKHsgTGluazogbGlua0hlYWRlciB9KSA6IG9uSGVhZGVycyh7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCB7fSwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlU2hlbGwocmVxdWVzdCkge1xuICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QsICEwKTtcbiAgICAgIG51bGwgPT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAmJiBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCk7XG4gICAgICByZXF1ZXN0Lm9uU2hlbGxFcnJvciA9IG5vb3A7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5vblNoZWxsUmVhZHk7XG4gICAgICByZXF1ZXN0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlQWxsKHJlcXVlc3QpIHtcbiAgICAgIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXNcbiAgICAgICAgICA/ICEwXG4gICAgICAgICAgOiBudWxsID09PSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50IHx8XG4gICAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQuc3RhdHVzICE9PSBQT1NUUE9ORURcbiAgICAgICk7XG4gICAgICBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCk7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5vbkFsbFJlYWR5O1xuICAgICAgcmVxdWVzdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gc2VnbWVudC5jaHVua3MubGVuZ3RoICYmXG4gICAgICAgIDEgPT09IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIG51bGwgPT09IHNlZ21lbnQuY2hpbGRyZW5bMF0uYm91bmRhcnkgJiZcbiAgICAgICAgLTEgPT09IHNlZ21lbnQuY2hpbGRyZW5bMF0uaWRcbiAgICAgICkge1xuICAgICAgICB2YXIgY2hpbGRTZWdtZW50ID0gc2VnbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgY2hpbGRTZWdtZW50LmlkID0gc2VnbWVudC5pZDtcbiAgICAgICAgY2hpbGRTZWdtZW50LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgICAgY2hpbGRTZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEICYmXG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBjaGlsZFNlZ21lbnQpO1xuICAgICAgfSBlbHNlIGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaGVkVGFzayhyZXF1ZXN0LCBib3VuZGFyeSwgc2VnbWVudCkge1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KSB7XG4gICAgICAgIGlmIChudWxsICE9PSBzZWdtZW50ICYmIHNlZ21lbnQucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlcmUgY2FuIG9ubHkgYmUgb25lIHJvb3Qgc2VnbWVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID0gc2VnbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MtLTtcbiAgICAgICAgMCA9PT0gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzICYmIGNvbXBsZXRlU2hlbGwocmVxdWVzdCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS0sXG4gICAgICAgICAgYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQgJiZcbiAgICAgICAgICAgICgwID09PSBib3VuZGFyeS5wZW5kaW5nVGFza3NcbiAgICAgICAgICAgICAgPyAoYm91bmRhcnkuc3RhdHVzID09PSBQRU5ESU5HICYmIChib3VuZGFyeS5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IHNlZ21lbnQgJiZcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnQucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgICAgc2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCAmJlxuICAgICAgICAgICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KSxcbiAgICAgICAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSksXG4gICAgICAgICAgICAgICAgYm91bmRhcnkuc3RhdHVzID09PSBDT01QTEVURUQgJiZcbiAgICAgICAgICAgICAgICAgIChib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgIGFib3J0VGFza1NvZnQsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCksXG4gICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGJvdW5kYXJ5LmNvbnRlbnRQcmVhbWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCkpKVxuICAgICAgICAgICAgICA6IG51bGwgIT09IHNlZ21lbnQgJiZcbiAgICAgICAgICAgICAgICBzZWdtZW50LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgICBzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEICYmXG4gICAgICAgICAgICAgICAgKHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgc2VnbWVudCksXG4gICAgICAgICAgICAgICAgMSA9PT0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpKSk7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tO1xuICAgICAgMCA9PT0gcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgJiYgY29tcGxldGVBbGwocmVxdWVzdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrKHJlcXVlc3QkanNjb21wJDIpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmVxdWVzdCRqc2NvbXAkMi5zdGF0dXMgIT09IENMT1NFRCAmJlxuICAgICAgICAxMyAhPT0gcmVxdWVzdCRqc2NvbXAkMi5zdGF0dXNcbiAgICAgICkge1xuICAgICAgICB2YXIgcHJldkNvbnRleHQgPSBjdXJyZW50QWN0aXZlU25hcHNob3QsXG4gICAgICAgICAgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSG9va3NEaXNwYXRjaGVyO1xuICAgICAgICB2YXIgcHJldkFzeW5jRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyO1xuICAgICAgICB2YXIgcHJldlJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdDtcbiAgICAgICAgY3VycmVudFJlcXVlc3QgPSByZXF1ZXN0JGpzY29tcCQyO1xuICAgICAgICB2YXIgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRTdGFja0luREVWO1xuICAgICAgICB2YXIgcHJldlJlc3VtYWJsZVN0YXRlID0gY3VycmVudFJlc3VtYWJsZVN0YXRlO1xuICAgICAgICBjdXJyZW50UmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0JGpzY29tcCQyLnJlc3VtYWJsZVN0YXRlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBwaW5nZWRUYXNrcyA9IHJlcXVlc3QkanNjb21wJDIucGluZ2VkVGFza3MsXG4gICAgICAgICAgICBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwaW5nZWRUYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSByZXF1ZXN0JGpzY29tcCQyLFxuICAgICAgICAgICAgICB0YXNrID0gcGluZ2VkVGFza3NbaV0sXG4gICAgICAgICAgICAgIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IHNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZUYXNrSW5ERVYgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSB0YXNrO1xuICAgICAgICAgICAgICBpZiAoMCAhPT0gcmVxdWVzdC5yZXBsYXkucGVuZGluZ1Rhc2tzKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChyZXF1ZXN0LmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHByZXZUYXNrSW5ERVYgPSBjdXJyZW50VGFza0luREVWO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgcmVxdWVzdC5yZXBsYXkuc2xvdHNcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bWVOb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGxheS5zbG90cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2hpbGRJbmRleFxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiByZXRyeU5vZGUocmVxdWVzdCRqc2NvbXAkMCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIDEgPT09IHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAwIDwgcmVxdWVzdC5yZXBsYXkubm9kZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LmFib3J0U2V0LmRlbGV0ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkVGFzayhyZXF1ZXN0JGpzY29tcCQwLCByZXF1ZXN0LmJsb2NrZWRCb3VuZGFyeSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgdmFyIHggPVxuICAgICAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICA/IGdldFN1c3BlbmRlZFRoZW5hYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICA6IHRocm93blZhbHVlO1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSB4ICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHgudGhlblxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaW5nID0gcmVxdWVzdC5waW5nO1xuICAgICAgICAgICAgICAgICAgICB4LnRoZW4ocGluZywgcGluZyk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QudGhlbmFibGVTdGF0ZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmFib3J0U2V0LmRlbGV0ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9ySW5mbyA9IGdldFRocm93bkluZm8ocmVxdWVzdC5jb21wb25lbnRTdGFjayksXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMSA9IHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkgPSByZXF1ZXN0LmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvciRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAxMiA9PT0gcmVxdWVzdCRqc2NvbXAkMC5zdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXF1ZXN0JGpzY29tcCQwLmZhdGFsRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiB4LFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCA9IGVycm9ySW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICByZXBsYXlOb2RlcyA9IHJlcXVlc3QucmVwbGF5Lm5vZGVzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VtZVNsb3RzID0gcmVxdWVzdC5yZXBsYXkuc2xvdHM7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgICAgcmVwbGF5Tm9kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdW1lU2xvdHMsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAucGVuZGluZ1Jvb3RUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0JGpzY29tcCQwLnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVNoZWxsKHJlcXVlc3QkanNjb21wJDApO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwLmFsbFBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0JGpzY29tcCQwLmFsbFBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlQWxsKHJlcXVlc3QkanNjb21wJDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFza0luREVWID0gcHJldlRhc2tJbkRFVjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICgocmVxdWVzdCRqc2NvbXAkMCA9IHByZXZUYXNrSW5ERVYgPSB2b2lkIDApLFxuICAgICAgICAgICAgICAoZXJyb3JEaWdlc3QgPSB0YXNrKSxcbiAgICAgICAgICAgICAgKHJlcXVlc3QkanNjb21wJDEgPSBzZWdtZW50KSxcbiAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5zdGF0dXMgPT09IFBFTkRJTkcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5zdGF0dXMgPSA2O1xuICAgICAgICAgICAgICBzd2l0Y2hDb250ZXh0KGVycm9yRGlnZXN0LmNvbnRleHQpO1xuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICAgICAgICAgICAgY3VycmVudFRhc2tJbkRFViA9IGVycm9yRGlnZXN0O1xuICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5MZW5ndGggPSByZXF1ZXN0JGpzY29tcCQxLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjaHVua0xlbmd0aCA9IHJlcXVlc3QkanNjb21wJDEuY2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXRyeU5vZGUocmVxdWVzdCwgZXJyb3JEaWdlc3QpLFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5sYXN0UHVzaGVkVGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLnRleHRFbWJlZGRlZCAmJlxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLmNodW5rcy5wdXNoKHRleHRTZXBhcmF0b3IpLFxuICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QuYWJvcnRTZXQuZGVsZXRlKGVycm9yRGlnZXN0KSxcbiAgICAgICAgICAgICAgICAgIChyZXF1ZXN0JGpzY29tcCQxLnN0YXR1cyA9IENPTVBMRVRFRCksXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFRhc2soXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXNldEhvb2tzU3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLmNoaWxkcmVuLmxlbmd0aCA9IGNoaWxkcmVuTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuY2h1bmtzLmxlbmd0aCA9IGNodW5rTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciB4JGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICAgIHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgICAgICA/IGdldFN1c3BlbmRlZFRoZW5hYmxlKClcbiAgICAgICAgICAgICAgICAgICAgOiAxMiA9PT0gcmVxdWVzdC5zdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICA/IHJlcXVlc3QuZmF0YWxFcnJvclxuICAgICAgICAgICAgICAgICAgICAgIDogdGhyb3duVmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHgkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHgkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHgkanNjb21wJDAudGhlblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5zdGF0dXMgPSBQRU5ESU5HO1xuICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QudGhlbmFibGVTdGF0ZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgIHZhciBwaW5nJGpzY29tcCQwID0gZXJyb3JEaWdlc3QucGluZztcbiAgICAgICAgICAgICAgICAgIHgkanNjb21wJDAudGhlbihwaW5nJGpzY29tcCQwLCBwaW5nJGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGVycm9ySW5mbyRqc2NvbXAkMSA9IGdldFRocm93bkluZm8oXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmNvbXBvbmVudFN0YWNrXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QuYWJvcnRTZXQuZGVsZXRlKGVycm9yRGlnZXN0KTtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuc3RhdHVzID0gNDtcbiAgICAgICAgICAgICAgICAgIHZhciBib3VuZGFyeSRqc2NvbXAkMCA9IGVycm9yRGlnZXN0LmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgZGVidWdUYXNrID0gZXJyb3JEaWdlc3QuZGVidWdUYXNrO1xuICAgICAgICAgICAgICAgICAgcHJldlRhc2tJbkRFViA9IGxvZ1JlY292ZXJhYmxlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIHgkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICAgICAgZGVidWdUYXNrXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gYm91bmRhcnkkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgPyBmYXRhbEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogKGJvdW5kYXJ5JGpzY29tcCQwLnBlbmRpbmdUYXNrcy0tLFxuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5JGpzY29tcCQwLnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoKGJvdW5kYXJ5JGpzY29tcCQwLnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRCksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlRhc2tJbkRFVixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVudHJhY2tCb3VuZGFyeShyZXF1ZXN0LCBib3VuZGFyeSRqc2NvbXAkMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSRqc2NvbXAkMC5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAgPT09IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gYm91bmRhcnkkanNjb21wJDAuY29udGVudFByZWFtYmxlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXBhcmVQcmVhbWJsZShyZXF1ZXN0KSkpO1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICAgIDAgPT09IHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzICYmIGNvbXBsZXRlQWxsKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFza0luREVWID0gcmVxdWVzdCRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwaW5nZWRUYXNrcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgbnVsbCAhPT0gcmVxdWVzdCRqc2NvbXAkMi5kZXN0aW5hdGlvbiAmJlxuICAgICAgICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMoXG4gICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDIsXG4gICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDIuZGVzdGluYXRpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgKHBpbmdlZFRhc2tzID0ge30pLFxuICAgICAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0JGpzY29tcCQyLCBlcnJvciwgcGluZ2VkVGFza3MsIG51bGwpLFxuICAgICAgICAgICAgZmF0YWxFcnJvcihyZXF1ZXN0JGpzY29tcCQyLCBlcnJvciwgcGluZ2VkVGFza3MsIG51bGwpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIChjdXJyZW50UmVzdW1hYmxlU3RhdGUgPSBwcmV2UmVzdW1hYmxlU3RhdGUpLFxuICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlciksXG4gICAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXIpLFxuICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2tJbXBsKSxcbiAgICAgICAgICAgIHByZXZEaXNwYXRjaGVyID09PSBIb29rc0Rpc3BhdGNoZXIgJiYgc3dpdGNoQ29udGV4dChwcmV2Q29udGV4dCksXG4gICAgICAgICAgICAoY3VycmVudFJlcXVlc3QgPSBwcmV2UmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGFyZVByZWFtYmxlRnJvbVN1YnRyZWUoXG4gICAgICByZXF1ZXN0LFxuICAgICAgc2VnbWVudCxcbiAgICAgIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHNcbiAgICApIHtcbiAgICAgIHNlZ21lbnQucHJlYW1ibGVDaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgY29sbGVjdGVkUHJlYW1ibGVTZWdtZW50cy5wdXNoKHNlZ21lbnQucHJlYW1ibGVDaGlsZHJlbik7XG4gICAgICBmb3IgKHZhciBwZW5kaW5nUHJlYW1ibGVzID0gITEsIGkgPSAwOyBpIDwgc2VnbWVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgcGVuZGluZ1ByZWFtYmxlcyA9XG4gICAgICAgICAgcHJlcGFyZVByZWFtYmxlRnJvbVNlZ21lbnQoXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgc2VnbWVudC5jaGlsZHJlbltpXSxcbiAgICAgICAgICAgIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHNcbiAgICAgICAgICApIHx8IHBlbmRpbmdQcmVhbWJsZXM7XG4gICAgICByZXR1cm4gcGVuZGluZ1ByZWFtYmxlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGFyZVByZWFtYmxlRnJvbVNlZ21lbnQoXG4gICAgICByZXF1ZXN0LFxuICAgICAgc2VnbWVudCxcbiAgICAgIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHNcbiAgICApIHtcbiAgICAgIHZhciBib3VuZGFyeSA9IHNlZ21lbnQuYm91bmRhcnk7XG4gICAgICBpZiAobnVsbCA9PT0gYm91bmRhcnkpXG4gICAgICAgIHJldHVybiBwcmVwYXJlUHJlYW1ibGVGcm9tU3VidHJlZShcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgY29sbGVjdGVkUHJlYW1ibGVTZWdtZW50c1xuICAgICAgICApO1xuICAgICAgdmFyIHByZWFtYmxlID0gYm91bmRhcnkuY29udGVudFByZWFtYmxlLFxuICAgICAgICBmYWxsYmFja1ByZWFtYmxlID0gYm91bmRhcnkuZmFsbGJhY2tQcmVhbWJsZTtcbiAgICAgIGlmIChudWxsID09PSBwcmVhbWJsZSB8fCBudWxsID09PSBmYWxsYmFja1ByZWFtYmxlKSByZXR1cm4gITE7XG4gICAgICBzd2l0Y2ggKGJvdW5kYXJ5LnN0YXR1cykge1xuICAgICAgICBjYXNlIENPTVBMRVRFRDpcbiAgICAgICAgICBob2lzdFByZWFtYmxlU3RhdGUocmVxdWVzdC5yZW5kZXJTdGF0ZSwgcHJlYW1ibGUpO1xuICAgICAgICAgIHNlZ21lbnQgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50c1swXTtcbiAgICAgICAgICBpZiAoIXNlZ21lbnQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJBIHByZXZpb3VzbHkgdW52aXNpdGVkIGJvdW5kYXJ5IG11c3QgaGF2ZSBleGFjdGx5IG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHByZXBhcmVQcmVhbWJsZUZyb21TdWJ0cmVlKFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBQT1NUUE9ORUQ6XG4gICAgICAgICAgaWYgKG51bGwgIT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcykgcmV0dXJuICEwO1xuICAgICAgICBjYXNlIENMSUVOVF9SRU5ERVJFRDpcbiAgICAgICAgICBpZiAoc2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRClcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGhvaXN0UHJlYW1ibGVTdGF0ZShyZXF1ZXN0LnJlbmRlclN0YXRlLCBmYWxsYmFja1ByZWFtYmxlKSxcbiAgICAgICAgICAgICAgcHJlcGFyZVByZWFtYmxlRnJvbVN1YnRyZWUoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgICAgICAgIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVQcmVhbWJsZShyZXF1ZXN0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgJiZcbiAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC5jb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHMgPSBbXSxcbiAgICAgICAgICBoYXNQZW5kaW5nUHJlYW1ibGVzID0gcHJlcGFyZVByZWFtYmxlRnJvbVNlZ21lbnQoXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCxcbiAgICAgICAgICAgIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHNcbiAgICAgICAgICApLFxuICAgICAgICAgIHByZWFtYmxlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZS5wcmVhbWJsZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICExID09PSBoYXNQZW5kaW5nUHJlYW1ibGVzIHx8XG4gICAgICAgICAgKHByZWFtYmxlLmhlYWRDaHVua3MgJiYgcHJlYW1ibGUuYm9keUNodW5rcylcbiAgICAgICAgKVxuICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cyA9IGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHM7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpIHtcbiAgICAgIHNlZ21lbnQucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgc3dpdGNoIChzZWdtZW50LnN0YXR1cykge1xuICAgICAgICBjYXNlIFBFTkRJTkc6XG4gICAgICAgICAgc2VnbWVudC5pZCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrO1xuICAgICAgICBjYXNlIFBPU1RQT05FRDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGhvaXN0YWJsZVN0YXRlID0gc2VnbWVudC5pZCksXG4gICAgICAgICAgICAoc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExKSxcbiAgICAgICAgICAgIChzZWdtZW50LnRleHRFbWJlZGRlZCA9ICExKSxcbiAgICAgICAgICAgIChyZXF1ZXN0ID0gcmVxdWVzdC5yZW5kZXJTdGF0ZSksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBwbGFjZWhvbGRlcjEpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVxdWVzdC5wbGFjZWhvbGRlclByZWZpeCksXG4gICAgICAgICAgICAocmVxdWVzdCA9IGhvaXN0YWJsZVN0YXRlLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXF1ZXN0KSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHBsYWNlaG9sZGVyMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIENPTVBMRVRFRDpcbiAgICAgICAgICBzZWdtZW50LnN0YXR1cyA9IEZMVVNIRUQ7XG4gICAgICAgICAgdmFyIHIgPSAhMCxcbiAgICAgICAgICAgIGNodW5rcyA9IHNlZ21lbnQuY2h1bmtzLFxuICAgICAgICAgICAgY2h1bmtJZHggPSAwO1xuICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50LmNoaWxkcmVuO1xuICAgICAgICAgIGZvciAodmFyIGNoaWxkSWR4ID0gMDsgY2hpbGRJZHggPCBzZWdtZW50Lmxlbmd0aDsgY2hpbGRJZHgrKykge1xuICAgICAgICAgICAgZm9yIChyID0gc2VnbWVudFtjaGlsZElkeF07IGNodW5rSWR4IDwgci5pbmRleDsgY2h1bmtJZHgrKylcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmtzW2NodW5rSWR4XSk7XG4gICAgICAgICAgICByID0gZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCByLCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoOyBjaHVua0lkeCA8IGNodW5rcy5sZW5ndGggLSAxOyBjaHVua0lkeCsrKVxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmtzW2NodW5rSWR4XSk7XG4gICAgICAgICAgY2h1bmtJZHggPCBjaHVua3MubGVuZ3RoICYmXG4gICAgICAgICAgICAociA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNodW5rc1tjaHVua0lkeF0pKTtcbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQWJvcnRlZCwgZXJyb3JlZCBvciBhbHJlYWR5IGZsdXNoZWQgYm91bmRhcmllcyBzaG91bGQgbm90IGJlIGZsdXNoZWQgYWdhaW4uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKSB7XG4gICAgICB2YXIgYm91bmRhcnkgPSBzZWdtZW50LmJvdW5kYXJ5O1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KVxuICAgICAgICByZXR1cm4gZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICBpZiAoYm91bmRhcnkuc3RhdHVzID09PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAgICAgdmFyIGVycm9yRGlnZXN0ID0gYm91bmRhcnkuZXJyb3JEaWdlc3QsXG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gYm91bmRhcnkuZXJyb3JNZXNzYWdlLFxuICAgICAgICAgIGVycm9yU3RhY2sgPSBib3VuZGFyeS5lcnJvclN0YWNrLFxuICAgICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2sgPSBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrO1xuICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMSk7XG4gICAgICAgIGVycm9yRGlnZXN0ICYmXG4gICAgICAgICAgKHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUEpLFxuICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yRGlnZXN0KSksXG4gICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsXG4gICAgICAgICAgKSk7XG4gICAgICAgIGVycm9yTWVzc2FnZSAmJlxuICAgICAgICAgICh3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFCKSxcbiAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvck1lc3NhZ2UpKSxcbiAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWxcbiAgICAgICAgICApKTtcbiAgICAgICAgZXJyb3JTdGFjayAmJlxuICAgICAgICAgICh3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFDKSxcbiAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvclN0YWNrKSksXG4gICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsXG4gICAgICAgICAgKSk7XG4gICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2sgJiZcbiAgICAgICAgICAod3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxRCksXG4gICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JDb21wb25lbnRTdGFjaykpLFxuICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbFxuICAgICAgICAgICkpO1xuICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIpO1xuICAgICAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgICAgKHJlcXVlc3QgPSBib3VuZGFyeS5mYWxsYmFja1ByZWFtYmxlKSAmJlxuICAgICAgICAgIHdyaXRlUHJlYW1ibGVDb250cmlidXRpb24oZGVzdGluYXRpb24sIHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU3VzcGVuc2VCb3VuZGFyeSk7XG4gICAgICB9XG4gICAgICBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDT01QTEVURUQpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYm91bmRhcnkuc3RhdHVzID09PSBQRU5ESU5HICYmXG4gICAgICAgICAgICAoYm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrKSxcbiAgICAgICAgICAwIDwgYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpLFxuICAgICAgICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnJvb3RTZWdtZW50SURcbiAgICAgICAgICApLFxuICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICAoKGJvdW5kYXJ5ID0gYm91bmRhcnkuZmFsbGJhY2tTdGF0ZSksXG4gICAgICAgICAgICBib3VuZGFyeS5zdHlsZXMuZm9yRWFjaChob2lzdFN0eWxlUXVldWVEZXBlbmRlbmN5LCBob2lzdGFibGVTdGF0ZSksXG4gICAgICAgICAgICBib3VuZGFyeS5zdHlsZXNoZWV0cy5mb3JFYWNoKFxuICAgICAgICAgICAgICBob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5LFxuICAgICAgICAgICAgICBob2lzdGFibGVTdGF0ZVxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSksXG4gICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU3VzcGVuc2VCb3VuZGFyeSlcbiAgICAgICAgKTtcbiAgICAgIGlmIChib3VuZGFyeS5ieXRlU2l6ZSA+IHJlcXVlc3QucHJvZ3Jlc3NpdmVDaHVua1NpemUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKyksXG4gICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpLFxuICAgICAgICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnJvb3RTZWdtZW50SURcbiAgICAgICAgICApLFxuICAgICAgICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpLFxuICAgICAgICAgIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFN1c3BlbnNlQm91bmRhcnkpXG4gICAgICAgICk7XG4gICAgICBob2lzdGFibGVTdGF0ZSAmJlxuICAgICAgICAoKHNlZ21lbnQgPSBib3VuZGFyeS5jb250ZW50U3RhdGUpLFxuICAgICAgICBzZWdtZW50LnN0eWxlcy5mb3JFYWNoKGhvaXN0U3R5bGVRdWV1ZURlcGVuZGVuY3ksIGhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgc2VnbWVudC5zdHlsZXNoZWV0cy5mb3JFYWNoKGhvaXN0U3R5bGVzaGVldERlcGVuZGVuY3ksIGhvaXN0YWJsZVN0YXRlKSk7XG4gICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkpO1xuICAgICAgc2VnbWVudCA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuICAgICAgaWYgKDEgIT09IHNlZ21lbnQubGVuZ3RoKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkEgcHJldmlvdXNseSB1bnZpc2l0ZWQgYm91bmRhcnkgbXVzdCBoYXZlIGV4YWN0bHkgb25lIHJvb3Qgc2VnbWVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50WzBdLCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICAocmVxdWVzdCA9IGJvdW5kYXJ5LmNvbnRlbnRQcmVhbWJsZSkgJiZcbiAgICAgICAgd3JpdGVQcmVhbWJsZUNvbnRyaWJ1dGlvbihkZXN0aW5hdGlvbiwgcmVxdWVzdCk7XG4gICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU3VzcGVuc2VCb3VuZGFyeSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU2VnbWVudENvbnRhaW5lcihcbiAgICAgIHJlcXVlc3QsXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIHNlZ21lbnQsXG4gICAgICBob2lzdGFibGVTdGF0ZVxuICAgICkge1xuICAgICAgd3JpdGVTdGFydFNlZ21lbnQoXG4gICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICBzZWdtZW50LnBhcmVudEZvcm1hdENvbnRleHQsXG4gICAgICAgIHNlZ21lbnQuaWRcbiAgICAgICk7XG4gICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgIHJldHVybiB3cml0ZUVuZFNlZ21lbnQoZGVzdGluYXRpb24sIHNlZ21lbnQucGFyZW50Rm9ybWF0Q29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoQ29tcGxldGVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5KSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cywgaSA9IDA7XG4gICAgICAgIGkgPCBjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGkrK1xuICAgICAgKVxuICAgICAgICBmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICBjb21wbGV0ZWRTZWdtZW50c1tpXVxuICAgICAgICApO1xuICAgICAgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoID0gMDtcbiAgICAgIHdyaXRlSG9pc3RhYmxlc0ZvckJvdW5kYXJ5KFxuICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgYm91bmRhcnkuY29udGVudFN0YXRlLFxuICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlXG4gICAgICApO1xuICAgICAgY29tcGxldGVkU2VnbWVudHMgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlO1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICBpID0gYm91bmRhcnkucm9vdFNlZ21lbnRJRDtcbiAgICAgIGJvdW5kYXJ5ID0gYm91bmRhcnkuY29udGVudFN0YXRlO1xuICAgICAgdmFyIHJlcXVpcmVzU3R5bGVJbnNlcnRpb24gPSByZXF1ZXN0LnN0eWxlc1RvSG9pc3Q7XG4gICAgICByZXF1ZXN0LnN0eWxlc1RvSG9pc3QgPSAhMTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlcXVlc3Quc3RhcnRJbmxpbmVTY3JpcHQpO1xuICAgICAgcmVxdWlyZXNTdHlsZUluc2VydGlvblxuICAgICAgICA/IChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSA9PT1cbiAgICAgICAgICBOb3RoaW5nU2VudFxuICAgICAgICAgID8gKChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgPVxuICAgICAgICAgICAgICBjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgfFxuICAgICAgICAgICAgICBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbiB8XG4gICAgICAgICAgICAgIFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24pLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbEJvdGgpKVxuICAgICAgICAgIDogKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyAmIFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uKSA9PT1cbiAgICAgICAgICAgICAgTm90aGluZ1NlbnRcbiAgICAgICAgICAgID8gKChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgfD0gU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24pLFxuICAgICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsXG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgICA6IHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MVBhcnRpYWwpXG4gICAgICAgIDogKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyAmIFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24pID09PVxuICAgICAgICAgICAgTm90aGluZ1NlbnRcbiAgICAgICAgICA/ICgoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24pLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsKSlcbiAgICAgICAgICA6IHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCk7XG4gICAgICBjb21wbGV0ZWRTZWdtZW50cyA9IGkudG9TdHJpbmcoMTYpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVxdWVzdC5ib3VuZGFyeVByZWZpeCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZWRTZWdtZW50cyk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0Mik7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnNlZ21lbnRQcmVmaXgpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVkU2VnbWVudHMpO1xuICAgICAgcmVxdWlyZXNTdHlsZUluc2VydGlvblxuICAgICAgICA/ICh3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EpLFxuICAgICAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luSlMoZGVzdGluYXRpb24sIGJvdW5kYXJ5KSlcbiAgICAgICAgOiB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2IpO1xuICAgICAgYm91bmRhcnkgPSB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kKTtcbiAgICAgIHJldHVybiB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVxdWVzdCkgJiYgYm91bmRhcnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgc2VnbWVudFxuICAgICkge1xuICAgICAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBGTFVTSEVEKSByZXR1cm4gITA7XG4gICAgICB2YXIgaG9pc3RhYmxlU3RhdGUgPSBib3VuZGFyeS5jb250ZW50U3RhdGUsXG4gICAgICAgIHNlZ21lbnRJRCA9IHNlZ21lbnQuaWQ7XG4gICAgICBpZiAoLTEgPT09IHNlZ21lbnRJRCkge1xuICAgICAgICBpZiAoLTEgPT09IChzZWdtZW50LmlkID0gYm91bmRhcnkucm9vdFNlZ21lbnRJRCkpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkEgcm9vdCBzZWdtZW50IElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJ5IG5vdy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBmbHVzaFNlZ21lbnRDb250YWluZXIoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgIGhvaXN0YWJsZVN0YXRlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VnbWVudElEID09PSBib3VuZGFyeS5yb290U2VnbWVudElEKVxuICAgICAgICByZXR1cm4gZmx1c2hTZWdtZW50Q29udGFpbmVyKFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICBob2lzdGFibGVTdGF0ZVxuICAgICAgICApO1xuICAgICAgZmx1c2hTZWdtZW50Q29udGFpbmVyKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICBib3VuZGFyeSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlcXVlc3Quc3RhcnRJbmxpbmVTY3JpcHQpO1xuICAgICAgKGJvdW5kYXJ5Lmluc3RydWN0aW9ucyAmIFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbikgPT09IE5vdGhpbmdTZW50XG4gICAgICAgID8gKChib3VuZGFyeS5pbnN0cnVjdGlvbnMgfD0gU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uKSxcbiAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxRnVsbCkpXG4gICAgICAgIDogd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVxdWVzdC5zZWdtZW50UHJlZml4KTtcbiAgICAgIHNlZ21lbnRJRCA9IHNlZ21lbnRJRC50b1N0cmluZygxNik7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzZWdtZW50SUQpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0Mik7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnBsYWNlaG9sZGVyUHJlZml4KTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHNlZ21lbnRJRCk7XG4gICAgICBkZXN0aW5hdGlvbiA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdEVuZCk7XG4gICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKSB7XG4gICAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KDIwNDgpO1xuICAgICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgICAgIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkkMSA9ICEwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCEoMCA8IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcykpIHtcbiAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudDtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY29tcGxldGVkUm9vdFNlZ21lbnQpIHtcbiAgICAgICAgICAgIGlmIChjb21wbGV0ZWRSb290U2VnbWVudC5zdGF0dXMgPT09IFBPU1RQT05FRCkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMgPSByZXF1ZXN0LmNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHM7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cykgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgcHJlYW1ibGUgPSByZW5kZXJTdGF0ZS5wcmVhbWJsZSxcbiAgICAgICAgICAgICAgaHRtbENodW5rcyA9IHByZWFtYmxlLmh0bWxDaHVua3MsXG4gICAgICAgICAgICAgIGhlYWRDaHVua3MgPSBwcmVhbWJsZS5oZWFkQ2h1bmtzLFxuICAgICAgICAgICAgICBpJGpzY29tcCQwO1xuICAgICAgICAgICAgaWYgKGh0bWxDaHVua3MpIHtcbiAgICAgICAgICAgICAgZm9yIChpJGpzY29tcCQwID0gMDsgaSRqc2NvbXAkMCA8IGh0bWxDaHVua3MubGVuZ3RoOyBpJGpzY29tcCQwKyspXG4gICAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaHRtbENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICAgIGlmIChoZWFkQ2h1bmtzKVxuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICAgICAgICAgIGkkanNjb21wJDAgPCBoZWFkQ2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGkkanNjb21wJDArK1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGhlYWRDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRDaHVua0ZvclRhZyhcImhlYWRcIikpLFxuICAgICAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRDaHVua3MpXG4gICAgICAgICAgICAgIGZvciAoaSRqc2NvbXAkMCA9IDA7IGkkanNjb21wJDAgPCBoZWFkQ2h1bmtzLmxlbmd0aDsgaSRqc2NvbXAkMCsrKVxuICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGhlYWRDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgdmFyIGNoYXJzZXRDaHVua3MgPSByZW5kZXJTdGF0ZS5jaGFyc2V0Q2h1bmtzO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPCBjaGFyc2V0Q2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCsrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNoYXJzZXRDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgY2hhcnNldENodW5rcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5jbGVhcigpO1xuICAgICAgICAgICAgdmFyIHZpZXdwb3J0Q2h1bmtzID0gcmVuZGVyU3RhdGUudmlld3BvcnRDaHVua3M7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IHZpZXdwb3J0Q2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCsrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHZpZXdwb3J0Q2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgIHZpZXdwb3J0Q2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5mb3JFYWNoKGZsdXNoU3R5bGVzSW5QcmVhbWJsZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgdmFyIGltcG9ydE1hcENodW5rcyA9IHJlbmRlclN0YXRlLmltcG9ydE1hcENodW5rcztcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgaW1wb3J0TWFwQ2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCsrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGltcG9ydE1hcENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICBpbXBvcnRNYXBDaHVua3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmJvb3RzdHJhcFNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2NyaXB0cy5jbGVhcigpO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgICB2YXIgaG9pc3RhYmxlQ2h1bmtzID0gcmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPCBob2lzdGFibGVDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaG9pc3RhYmxlQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlID0gaG9pc3RhYmxlQ2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlIDwgY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlKytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgc2VnbWVudHMgPSBjb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzW3JlbmRlclN0YXRlXTtcbiAgICAgICAgICAgICAgZm9yIChwcmVhbWJsZSA9IDA7IHByZWFtYmxlIDwgc2VnbWVudHMubGVuZ3RoOyBwcmVhbWJsZSsrKVxuICAgICAgICAgICAgICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudHNbcHJlYW1ibGVdLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmVhbWJsZSRqc2NvbXAkMCA9IHJlcXVlc3QucmVuZGVyU3RhdGUucHJlYW1ibGUsXG4gICAgICAgICAgICAgIGhlYWRDaHVua3MkanNjb21wJDAgPSBwcmVhbWJsZSRqc2NvbXAkMC5oZWFkQ2h1bmtzO1xuICAgICAgICAgICAgKHByZWFtYmxlJGpzY29tcCQwLmh0bWxDaHVua3MgfHwgaGVhZENodW5rcyRqc2NvbXAkMCkgJiZcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kQ2h1bmtGb3JUYWcoXCJoZWFkXCIpKTtcbiAgICAgICAgICAgIHZhciBib2R5Q2h1bmtzID0gcHJlYW1ibGUkanNjb21wJDAuYm9keUNodW5rcztcbiAgICAgICAgICAgIGlmIChib2R5Q2h1bmtzKVxuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMgPSAwO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMgPCBib2R5Q2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGJvZHlDaHVua3NbY29tcGxldGVkUHJlYW1ibGVTZWdtZW50c10pO1xuICAgICAgICAgICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBjb21wbGV0ZWRSb290U2VnbWVudCwgbnVsbCk7XG4gICAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHdyaXRlQm9vdHN0cmFwKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlbmRlclN0YXRlJGpzY29tcCQwID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCA9IDA7XG4gICAgICAgICAgdmFyIHZpZXdwb3J0Q2h1bmtzJGpzY29tcCQwID0gcmVuZGVyU3RhdGUkanNjb21wJDAudmlld3BvcnRDaHVua3M7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gMDtcbiAgICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50IDwgdmlld3BvcnRDaHVua3MkanNjb21wJDAubGVuZ3RoO1xuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQrK1xuICAgICAgICAgIClcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICB2aWV3cG9ydENodW5rcyRqc2NvbXAkMFtjb21wbGV0ZWRSb290U2VnbWVudF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdmlld3BvcnRDaHVua3MkanNjb21wJDAubGVuZ3RoID0gMDtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wcmVjb25uZWN0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wcmVjb25uZWN0cy5jbGVhcigpO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLmZvbnRQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5mb250UHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5oaWdoSW1hZ2VQcmVsb2Fkcy5mb3JFYWNoKFxuICAgICAgICAgICAgZmx1c2hSZXNvdXJjZSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5oaWdoSW1hZ2VQcmVsb2Fkcy5jbGVhcigpO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnN0eWxlcy5mb3JFYWNoKHByZWxvYWRMYXRlU3R5bGVzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuc2NyaXB0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5zY3JpcHRzLmNsZWFyKCk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuYnVsa1ByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLmJ1bGtQcmVsb2Fkcy5jbGVhcigpO1xuICAgICAgICAgIHZhciBob2lzdGFibGVDaHVua3MkanNjb21wJDAgPSByZW5kZXJTdGF0ZSRqc2NvbXAkMC5ob2lzdGFibGVDaHVua3M7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gMDtcbiAgICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50IDwgaG9pc3RhYmxlQ2h1bmtzJGpzY29tcCQwLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50KytcbiAgICAgICAgICApXG4gICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgaG9pc3RhYmxlQ2h1bmtzJGpzY29tcCQwW2NvbXBsZXRlZFJvb3RTZWdtZW50XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBob2lzdGFibGVDaHVua3MkanNjb21wJDAubGVuZ3RoID0gMDtcbiAgICAgICAgICB2YXIgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXM7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvdW5kYXJ5ID0gY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzW2ldO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxID0gcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgaWQgPSBib3VuZGFyeS5yb290U2VnbWVudElELFxuICAgICAgICAgICAgICBlcnJvckRpZ2VzdCA9IGJvdW5kYXJ5LmVycm9yRGlnZXN0LFxuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBib3VuZGFyeS5lcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgIGVycm9yU3RhY2sgPSBib3VuZGFyeS5lcnJvclN0YWNrLFxuICAgICAgICAgICAgICBlcnJvckNvbXBvbmVudFN0YWNrID0gYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMS5zdGFydElubGluZVNjcmlwdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgJiBTZW50Q2xpZW50UmVuZGVyRnVuY3Rpb24pID09PVxuICAgICAgICAgICAgTm90aGluZ1NlbnRcbiAgICAgICAgICAgICAgPyAoKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyB8PSBTZW50Q2xpZW50UmVuZGVyRnVuY3Rpb24pLFxuICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsocmVuZGVyU3RhdGUkanNjb21wJDAsIGNsaWVudFJlbmRlclNjcmlwdDFGdWxsKSlcbiAgICAgICAgICAgICAgOiB3cml0ZUNodW5rKHJlbmRlclN0YXRlJGpzY29tcCQwLCBjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCk7XG4gICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEuYm91bmRhcnlQcmVmaXhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3cml0ZUNodW5rKHJlbmRlclN0YXRlJGpzY29tcCQwLCBpZC50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgd3JpdGVDaHVuayhyZW5kZXJTdGF0ZSRqc2NvbXAkMCwgY2xpZW50UmVuZGVyU2NyaXB0MUEpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBlcnJvckRpZ2VzdCB8fFxuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgfHxcbiAgICAgICAgICAgICAgZXJyb3JTdGFjayB8fFxuICAgICAgICAgICAgICBlcnJvckNvbXBvbmVudFN0YWNrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICBlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoZXJyb3JEaWdlc3QgfHwgXCJcIilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZSB8fCBlcnJvclN0YWNrIHx8IGVycm9yQ29tcG9uZW50U3RhY2spXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICBlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoZXJyb3JNZXNzYWdlIHx8IFwiXCIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChlcnJvclN0YWNrIHx8IGVycm9yQ29tcG9uZW50U3RhY2spXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICBlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoZXJyb3JTdGFjayB8fCBcIlwiKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnJvckNvbXBvbmVudFN0YWNrICYmXG4gICAgICAgICAgICAgICh3cml0ZUNodW5rKFxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGVycm9yQ29tcG9uZW50U3RhY2spXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLFxuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJTY3JpcHRFbmRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIUpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgdmFyIGNvbXBsZXRlZEJvdW5kYXJpZXMgPSByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXM7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBsZXRlZEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICFmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgY29tcGxldGVkQm91bmRhcmllc1tpXVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgY29tcGxldGVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjb21wbGV0ZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pO1xuICAgICAgICAgIGN1cnJlbnRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMjA0OCk7XG4gICAgICAgICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgICAgICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5JDEgPSAhMDtcbiAgICAgICAgICB2YXIgcGFydGlhbEJvdW5kYXJpZXMgPSByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0aWFsQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICBib3VuZGFyeSA9IGRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgICB2YXIgYm91bmRhcnkkanNjb21wJDAgPSBwYXJ0aWFsQm91bmRhcmllc1tpXSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5JGpzY29tcCQwLmNvbXBsZXRlZFNlZ21lbnRzO1xuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IDA7XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0IDwgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCsrXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAhZmx1c2hQYXJ0aWFsbHlDb21wbGV0ZWRTZWdtZW50KFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHNbSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0Kys7XG4gICAgICAgICAgICAgICAgICBjb21wbGV0ZWRTZWdtZW50cy5zcGxpY2UoMCwgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSAhMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb21wbGV0ZWRTZWdtZW50cy5zcGxpY2UoMCwgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KTtcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gd3JpdGVIb2lzdGFibGVzRm9yQm91bmRhcnkoXG4gICAgICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAuY29udGVudFN0YXRlLFxuICAgICAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5yZW5kZXJTdGF0ZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDApIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgcGFydGlhbEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnRpYWxCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICB2YXIgbGFyZ2VCb3VuZGFyaWVzID0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsYXJnZUJvdW5kYXJpZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICFmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBsYXJnZUJvdW5kYXJpZXNbaV0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgbGFyZ2VCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGxhcmdlQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIDAgPT09IHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzICYmXG4gICAgICAgIDAgPT09IHJlcXVlc3QucGluZ2VkVGFza3MubGVuZ3RoICYmXG4gICAgICAgIDAgPT09IHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLmxlbmd0aCAmJlxuICAgICAgICAwID09PSByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXMubGVuZ3RoXG4gICAgICAgICAgPyAoKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSAhMSksXG4gICAgICAgICAgICAoaSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUpLFxuICAgICAgICAgICAgaS5oYXNCb2R5ICYmIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVuZENodW5rRm9yVGFnKFwiYm9keVwiKSksXG4gICAgICAgICAgICBpLmhhc0h0bWwgJiYgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kQ2h1bmtGb3JUYWcoXCJodG1sXCIpKSxcbiAgICAgICAgICAgIGNvbXBsZXRlV3JpdGluZyhkZXN0aW5hdGlvbiksXG4gICAgICAgICAgICBmbHVzaEJ1ZmZlcmVkKGRlc3RpbmF0aW9uKSxcbiAgICAgICAgICAgIDAgIT09IHJlcXVlc3QuYWJvcnRhYmxlVGFza3Muc2l6ZSAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhlcmUgd2FzIHN0aWxsIGFib3J0YWJsZSB0YXNrIGF0IHRoZSByb290IHdoZW4gd2UgY2xvc2VkLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAocmVxdWVzdC5zdGF0dXMgPSBDTE9TRUQpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24uZW5kKCksXG4gICAgICAgICAgICAocmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGwpKVxuICAgICAgICAgIDogKGNvbXBsZXRlV3JpdGluZyhkZXN0aW5hdGlvbiksIGZsdXNoQnVmZmVyZWQoZGVzdGluYXRpb24pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRXb3JrKHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uO1xuICAgICAgc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWVzdFN0b3JhZ2UucnVuKHJlcXVlc3QsIHBlcmZvcm1Xb3JrLCByZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgMTAgPT09IHJlcXVlc3Quc3RhdHVzICYmIChyZXF1ZXN0LnN0YXR1cyA9IDExKTtcbiAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmXG4gICAgICAgICAgcmVxdWVzdFN0b3JhZ2UucnVuKFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIGVucXVldWVFYXJseVByZWxvYWRzQWZ0ZXJJbml0aWFsV29yayxcbiAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVFYXJseVByZWxvYWRzQWZ0ZXJJbml0aWFsV29yayhyZXF1ZXN0KSB7XG4gICAgICBzYWZlbHlFbWl0RWFybHlQcmVsb2FkcyhyZXF1ZXN0LCAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlRmx1c2gocmVxdWVzdCkge1xuICAgICAgITEgPT09IHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgJiZcbiAgICAgICAgMCA9PT0gcmVxdWVzdC5waW5nZWRUYXNrcy5sZW5ndGggJiZcbiAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvbiAmJlxuICAgICAgICAoKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSAhMCksXG4gICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gcmVxdWVzdC5kZXN0aW5hdGlvbjtcbiAgICAgICAgICBkZXN0aW5hdGlvblxuICAgICAgICAgICAgPyBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbilcbiAgICAgICAgICAgIDogKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSAhMSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRGbG93aW5nKHJlcXVlc3QsIGRlc3RpbmF0aW9uKSB7XG4gICAgICBpZiAoMTMgPT09IHJlcXVlc3Quc3RhdHVzKVxuICAgICAgICAocmVxdWVzdC5zdGF0dXMgPSBDTE9TRUQpLCBkZXN0aW5hdGlvbi5kZXN0cm95KHJlcXVlc3QuZmF0YWxFcnJvcik7XG4gICAgICBlbHNlIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gQ0xPU0VEICYmIG51bGwgPT09IHJlcXVlc3QuZGVzdGluYXRpb24pIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAoZGVzdGluYXRpb24gPSB7fSksXG4gICAgICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBkZXN0aW5hdGlvbiwgbnVsbCksXG4gICAgICAgICAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yLCBkZXN0aW5hdGlvbiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWJvcnQocmVxdWVzdCwgcmVhc29uKSB7XG4gICAgICBpZiAoMTEgPT09IHJlcXVlc3Quc3RhdHVzIHx8IDEwID09PSByZXF1ZXN0LnN0YXR1cykgcmVxdWVzdC5zdGF0dXMgPSAxMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBhYm9ydGFibGVUYXNrcyA9IHJlcXVlc3QuYWJvcnRhYmxlVGFza3M7XG4gICAgICAgIGlmICgwIDwgYWJvcnRhYmxlVGFza3Muc2l6ZSkge1xuICAgICAgICAgIHZhciBlcnJvciA9XG4gICAgICAgICAgICB2b2lkIDAgPT09IHJlYXNvblxuICAgICAgICAgICAgICA/IEVycm9yKFwiVGhlIHJlbmRlciB3YXMgYWJvcnRlZCBieSB0aGUgc2VydmVyIHdpdGhvdXQgYSByZWFzb24uXCIpXG4gICAgICAgICAgICAgIDogXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJlYXNvbiAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVhc29uICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWFzb24udGhlblxuICAgICAgICAgICAgICAgID8gRXJyb3IoXCJUaGUgcmVuZGVyIHdhcyBhYm9ydGVkIGJ5IHRoZSBzZXJ2ZXIgd2l0aCBhIHByb21pc2UuXCIpXG4gICAgICAgICAgICAgICAgOiByZWFzb247XG4gICAgICAgICAgcmVxdWVzdC5mYXRhbEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgYWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAodGFzaykge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0VGFzayh0YXNrLCByZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uICYmXG4gICAgICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgcmVxdWVzdC5kZXN0aW5hdGlvbik7XG4gICAgICB9IGNhdGNoIChlcnJvciQ0KSB7XG4gICAgICAgIChyZWFzb24gPSB7fSksXG4gICAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciQ0LCByZWFzb24sIG51bGwpLFxuICAgICAgICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IkNCwgcmVhc29uLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZW5zdXJlQ29ycmVjdElzb21vcnBoaWNSZWFjdFZlcnNpb24oKSB7XG4gICAgICB2YXIgaXNvbW9ycGhpY1JlYWN0UGFja2FnZVZlcnNpb24gPSBSZWFjdC52ZXJzaW9uO1xuICAgICAgaWYgKFwiMTkuMS4wLWNhbmFyeS0wMjllOGJkNi0yMDI1MDMwNlwiICE9PSBpc29tb3JwaGljUmVhY3RQYWNrYWdlVmVyc2lvbilcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgJ0luY29tcGF0aWJsZSBSZWFjdCB2ZXJzaW9uczogVGhlIFwicmVhY3RcIiBhbmQgXCJyZWFjdC1kb21cIiBwYWNrYWdlcyBtdXN0IGhhdmUgdGhlIGV4YWN0IHNhbWUgdmVyc2lvbi4gSW5zdGVhZCBnb3Q6XFxuICAtIHJlYWN0OiAgICAgICcgK1xuICAgICAgICAgICAgKGlzb21vcnBoaWNSZWFjdFBhY2thZ2VWZXJzaW9uICtcbiAgICAgICAgICAgICAgXCJcXG4gIC0gcmVhY3QtZG9tOiAgMTkuMS4wLWNhbmFyeS0wMjllOGJkNi0yMDI1MDMwNlxcbkxlYXJuIG1vcmU6IGh0dHBzOi8vcmVhY3QuZGV2L3dhcm5pbmdzL3ZlcnNpb24tbWlzbWF0Y2hcIilcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRHJhaW5IYW5kbGVyKGRlc3RpbmF0aW9uLCByZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3RhcnRGbG93aW5nKHJlcXVlc3QsIGRlc3RpbmF0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbmNlbEhhbmRsZXIocmVxdWVzdCwgcmVhc29uKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgYWJvcnQocmVxdWVzdCwgRXJyb3IocmVhc29uKSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0SW1wbChjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gY3JlYXRlUmVzdW1hYmxlU3RhdGUoXG4gICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggOiB2b2lkIDAsXG4gICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLnVuc3RhYmxlX2V4dGVybmFsUnVudGltZVNyYyA6IHZvaWQgMCxcbiAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0Q29udGVudCA6IHZvaWQgMCxcbiAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0cyA6IHZvaWQgMCxcbiAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwTW9kdWxlcyA6IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0KFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgIGNyZWF0ZVJlbmRlclN0YXRlKFxuICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm5vbmNlIDogdm9pZCAwLFxuICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLnVuc3RhYmxlX2V4dGVybmFsUnVudGltZVNyYyA6IHZvaWQgMCxcbiAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5pbXBvcnRNYXAgOiB2b2lkIDAsXG4gICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMub25IZWFkZXJzIDogdm9pZCAwLFxuICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm1heEhlYWRlcnNMZW5ndGggOiB2b2lkIDBcbiAgICAgICAgKSxcbiAgICAgICAgY3JlYXRlUm9vdEZvcm1hdENvbnRleHQob3B0aW9ucyA/IG9wdGlvbnMubmFtZXNwYWNlVVJJIDogdm9pZCAwKSxcbiAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMucHJvZ3Jlc3NpdmVDaHVua1NpemUgOiB2b2lkIDAsXG4gICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm9uRXJyb3IgOiB2b2lkIDAsXG4gICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm9uQWxsUmVhZHkgOiB2b2lkIDAsXG4gICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm9uU2hlbGxSZWFkeSA6IHZvaWQgMCxcbiAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMub25TaGVsbEVycm9yIDogdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm9uUG9zdHBvbmUgOiB2b2lkIDAsXG4gICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmZvcm1TdGF0ZSA6IHZvaWQgMFxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmFrZVdyaXRhYmxlKHJlYWRhYmxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRhYmxlLnB1c2goY2h1bmspO1xuICAgICAgICB9LFxuICAgICAgICBlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZWFkYWJsZS5wdXNoKG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZWFkYWJsZS5kZXN0cm95KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKSxcbiAgICAgIGNyeXB0byA9IHJlcXVpcmUoXCJjcnlwdG9cIiksXG4gICAgICBhc3luY19ob29rcyA9IHJlcXVpcmUoXCJhc3luY19ob29rc1wiKSxcbiAgICAgIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJlYWN0RE9NID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb21cIiksXG4gICAgICBzdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLFxuICAgICAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSxcbiAgICAgIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfU0NPUEVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKSxcbiAgICAgIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSxcbiAgICAgIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sZWdhY3lfaGlkZGVuXCIpLFxuICAgICAgUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpLFxuICAgICAgUkVBQ1RfVklFV19UUkFOU0lUSU9OX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qudmlld190cmFuc2l0aW9uXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAganN4UHJvcHNQYXJlbnRzID0gbmV3IFdlYWtNYXAoKSxcbiAgICAgIGpzeENoaWxkcmVuUGFyZW50cyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBDTElFTlRfUkVGRVJFTkNFX1RBRyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgc2NoZWR1bGVNaWNyb3Rhc2sgPSBxdWV1ZU1pY3JvdGFzayxcbiAgICAgIGN1cnJlbnRWaWV3ID0gbnVsbCxcbiAgICAgIHdyaXR0ZW5CeXRlcyA9IDAsXG4gICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5JDEgPSAhMCxcbiAgICAgIHRleHRFbmNvZGVyID0gbmV3IHV0aWwuVGV4dEVuY29kZXIoKSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IFJlZ0V4cChcbiAgICAgICAgXCJeWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9LFxuICAgICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge30sXG4gICAgICB1bml0bGVzc051bWJlcnMgPSBuZXcgU2V0KFxuICAgICAgICBcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IGFzcGVjdFJhdGlvIGJvcmRlckltYWdlT3V0c2V0IGJvcmRlckltYWdlU2xpY2UgYm9yZGVySW1hZ2VXaWR0aCBib3hGbGV4IGJveEZsZXhHcm91cCBib3hPcmRpbmFsR3JvdXAgY29sdW1uQ291bnQgY29sdW1ucyBmbGV4IGZsZXhHcm93IGZsZXhQb3NpdGl2ZSBmbGV4U2hyaW5rIGZsZXhOZWdhdGl2ZSBmbGV4T3JkZXIgZ3JpZEFyZWEgZ3JpZFJvdyBncmlkUm93RW5kIGdyaWRSb3dTcGFuIGdyaWRSb3dTdGFydCBncmlkQ29sdW1uIGdyaWRDb2x1bW5FbmQgZ3JpZENvbHVtblNwYW4gZ3JpZENvbHVtblN0YXJ0IGZvbnRXZWlnaHQgbGluZUNsYW1wIGxpbmVIZWlnaHQgb3BhY2l0eSBvcmRlciBvcnBoYW5zIHNjYWxlIHRhYlNpemUgd2lkb3dzIHpJbmRleCB6b29tIGZpbGxPcGFjaXR5IGZsb29kT3BhY2l0eSBzdG9wT3BhY2l0eSBzdHJva2VEYXNoYXJyYXkgc3Ryb2tlRGFzaG9mZnNldCBzdHJva2VNaXRlcmxpbWl0IHN0cm9rZU9wYWNpdHkgc3Ryb2tlV2lkdGggTW96QW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgTW96Qm94RmxleCBNb3pCb3hGbGV4R3JvdXAgTW96TGluZUNsYW1wIG1zQW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgbXNGbGV4IG1zWm9vbSBtc0ZsZXhHcm93IG1zRmxleE5lZ2F0aXZlIG1zRmxleE9yZGVyIG1zRmxleFBvc2l0aXZlIG1zRmxleFNocmluayBtc0dyaWRDb2x1bW4gbXNHcmlkQ29sdW1uU3BhbiBtc0dyaWRSb3cgbXNHcmlkUm93U3BhbiBXZWJraXRBbmltYXRpb25JdGVyYXRpb25Db3VudCBXZWJraXRCb3hGbGV4IFdlYktpdEJveEZsZXhHcm91cCBXZWJraXRCb3hPcmRpbmFsR3JvdXAgV2Via2l0Q29sdW1uQ291bnQgV2Via2l0Q29sdW1ucyBXZWJraXRGbGV4IFdlYmtpdEZsZXhHcm93IFdlYmtpdEZsZXhQb3NpdGl2ZSBXZWJraXRGbGV4U2hyaW5rIFdlYmtpdExpbmVDbGFtcFwiLnNwbGl0KFxuICAgICAgICAgIFwiIFwiXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBhbGlhc2VzID0gbmV3IE1hcChbXG4gICAgICAgIFtcImFjY2VwdENoYXJzZXRcIiwgXCJhY2NlcHQtY2hhcnNldFwiXSxcbiAgICAgICAgW1wiaHRtbEZvclwiLCBcImZvclwiXSxcbiAgICAgICAgW1wiaHR0cEVxdWl2XCIsIFwiaHR0cC1lcXVpdlwiXSxcbiAgICAgICAgW1wiY3Jvc3NPcmlnaW5cIiwgXCJjcm9zc29yaWdpblwiXSxcbiAgICAgICAgW1wiYWNjZW50SGVpZ2h0XCIsIFwiYWNjZW50LWhlaWdodFwiXSxcbiAgICAgICAgW1wiYWxpZ25tZW50QmFzZWxpbmVcIiwgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIl0sXG4gICAgICAgIFtcImFyYWJpY0Zvcm1cIiwgXCJhcmFiaWMtZm9ybVwiXSxcbiAgICAgICAgW1wiYmFzZWxpbmVTaGlmdFwiLCBcImJhc2VsaW5lLXNoaWZ0XCJdLFxuICAgICAgICBbXCJjYXBIZWlnaHRcIiwgXCJjYXAtaGVpZ2h0XCJdLFxuICAgICAgICBbXCJjbGlwUGF0aFwiLCBcImNsaXAtcGF0aFwiXSxcbiAgICAgICAgW1wiY2xpcFJ1bGVcIiwgXCJjbGlwLXJ1bGVcIl0sXG4gICAgICAgIFtcImNvbG9ySW50ZXJwb2xhdGlvblwiLCBcImNvbG9yLWludGVycG9sYXRpb25cIl0sXG4gICAgICAgIFtcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIl0sXG4gICAgICAgIFtcImNvbG9yUHJvZmlsZVwiLCBcImNvbG9yLXByb2ZpbGVcIl0sXG4gICAgICAgIFtcImNvbG9yUmVuZGVyaW5nXCIsIFwiY29sb3ItcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJkb21pbmFudEJhc2VsaW5lXCIsIFwiZG9taW5hbnQtYmFzZWxpbmVcIl0sXG4gICAgICAgIFtcImVuYWJsZUJhY2tncm91bmRcIiwgXCJlbmFibGUtYmFja2dyb3VuZFwiXSxcbiAgICAgICAgW1wiZmlsbE9wYWNpdHlcIiwgXCJmaWxsLW9wYWNpdHlcIl0sXG4gICAgICAgIFtcImZpbGxSdWxlXCIsIFwiZmlsbC1ydWxlXCJdLFxuICAgICAgICBbXCJmbG9vZENvbG9yXCIsIFwiZmxvb2QtY29sb3JcIl0sXG4gICAgICAgIFtcImZsb29kT3BhY2l0eVwiLCBcImZsb29kLW9wYWNpdHlcIl0sXG4gICAgICAgIFtcImZvbnRGYW1pbHlcIiwgXCJmb250LWZhbWlseVwiXSxcbiAgICAgICAgW1wiZm9udFNpemVcIiwgXCJmb250LXNpemVcIl0sXG4gICAgICAgIFtcImZvbnRTaXplQWRqdXN0XCIsIFwiZm9udC1zaXplLWFkanVzdFwiXSxcbiAgICAgICAgW1wiZm9udFN0cmV0Y2hcIiwgXCJmb250LXN0cmV0Y2hcIl0sXG4gICAgICAgIFtcImZvbnRTdHlsZVwiLCBcImZvbnQtc3R5bGVcIl0sXG4gICAgICAgIFtcImZvbnRWYXJpYW50XCIsIFwiZm9udC12YXJpYW50XCJdLFxuICAgICAgICBbXCJmb250V2VpZ2h0XCIsIFwiZm9udC13ZWlnaHRcIl0sXG4gICAgICAgIFtcImdseXBoTmFtZVwiLCBcImdseXBoLW5hbWVcIl0sXG4gICAgICAgIFtcImdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiXSxcbiAgICAgICAgW1wiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIl0sXG4gICAgICAgIFtcImhvcml6QWR2WFwiLCBcImhvcml6LWFkdi14XCJdLFxuICAgICAgICBbXCJob3Jpek9yaWdpblhcIiwgXCJob3Jpei1vcmlnaW4teFwiXSxcbiAgICAgICAgW1wiaW1hZ2VSZW5kZXJpbmdcIiwgXCJpbWFnZS1yZW5kZXJpbmdcIl0sXG4gICAgICAgIFtcImxldHRlclNwYWNpbmdcIiwgXCJsZXR0ZXItc3BhY2luZ1wiXSxcbiAgICAgICAgW1wibGlnaHRpbmdDb2xvclwiLCBcImxpZ2h0aW5nLWNvbG9yXCJdLFxuICAgICAgICBbXCJtYXJrZXJFbmRcIiwgXCJtYXJrZXItZW5kXCJdLFxuICAgICAgICBbXCJtYXJrZXJNaWRcIiwgXCJtYXJrZXItbWlkXCJdLFxuICAgICAgICBbXCJtYXJrZXJTdGFydFwiLCBcIm1hcmtlci1zdGFydFwiXSxcbiAgICAgICAgW1wib3ZlcmxpbmVQb3NpdGlvblwiLCBcIm92ZXJsaW5lLXBvc2l0aW9uXCJdLFxuICAgICAgICBbXCJvdmVybGluZVRoaWNrbmVzc1wiLCBcIm92ZXJsaW5lLXRoaWNrbmVzc1wiXSxcbiAgICAgICAgW1wicGFpbnRPcmRlclwiLCBcInBhaW50LW9yZGVyXCJdLFxuICAgICAgICBbXCJwYW5vc2UtMVwiLCBcInBhbm9zZS0xXCJdLFxuICAgICAgICBbXCJwb2ludGVyRXZlbnRzXCIsIFwicG9pbnRlci1ldmVudHNcIl0sXG4gICAgICAgIFtcInJlbmRlcmluZ0ludGVudFwiLCBcInJlbmRlcmluZy1pbnRlbnRcIl0sXG4gICAgICAgIFtcInNoYXBlUmVuZGVyaW5nXCIsIFwic2hhcGUtcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJzdG9wQ29sb3JcIiwgXCJzdG9wLWNvbG9yXCJdLFxuICAgICAgICBbXCJzdG9wT3BhY2l0eVwiLCBcInN0b3Atb3BhY2l0eVwiXSxcbiAgICAgICAgW1wic3RyaWtldGhyb3VnaFBvc2l0aW9uXCIsIFwic3RyaWtldGhyb3VnaC1wb3NpdGlvblwiXSxcbiAgICAgICAgW1wic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLCBcInN0cmlrZXRocm91Z2gtdGhpY2tuZXNzXCJdLFxuICAgICAgICBbXCJzdHJva2VEYXNoYXJyYXlcIiwgXCJzdHJva2UtZGFzaGFycmF5XCJdLFxuICAgICAgICBbXCJzdHJva2VEYXNob2Zmc2V0XCIsIFwic3Ryb2tlLWRhc2hvZmZzZXRcIl0sXG4gICAgICAgIFtcInN0cm9rZUxpbmVjYXBcIiwgXCJzdHJva2UtbGluZWNhcFwiXSxcbiAgICAgICAgW1wic3Ryb2tlTGluZWpvaW5cIiwgXCJzdHJva2UtbGluZWpvaW5cIl0sXG4gICAgICAgIFtcInN0cm9rZU1pdGVybGltaXRcIiwgXCJzdHJva2UtbWl0ZXJsaW1pdFwiXSxcbiAgICAgICAgW1wic3Ryb2tlT3BhY2l0eVwiLCBcInN0cm9rZS1vcGFjaXR5XCJdLFxuICAgICAgICBbXCJzdHJva2VXaWR0aFwiLCBcInN0cm9rZS13aWR0aFwiXSxcbiAgICAgICAgW1widGV4dEFuY2hvclwiLCBcInRleHQtYW5jaG9yXCJdLFxuICAgICAgICBbXCJ0ZXh0RGVjb3JhdGlvblwiLCBcInRleHQtZGVjb3JhdGlvblwiXSxcbiAgICAgICAgW1widGV4dFJlbmRlcmluZ1wiLCBcInRleHQtcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJ0cmFuc2Zvcm1PcmlnaW5cIiwgXCJ0cmFuc2Zvcm0tb3JpZ2luXCJdLFxuICAgICAgICBbXCJ1bmRlcmxpbmVQb3NpdGlvblwiLCBcInVuZGVybGluZS1wb3NpdGlvblwiXSxcbiAgICAgICAgW1widW5kZXJsaW5lVGhpY2tuZXNzXCIsIFwidW5kZXJsaW5lLXRoaWNrbmVzc1wiXSxcbiAgICAgICAgW1widW5pY29kZUJpZGlcIiwgXCJ1bmljb2RlLWJpZGlcIl0sXG4gICAgICAgIFtcInVuaWNvZGVSYW5nZVwiLCBcInVuaWNvZGUtcmFuZ2VcIl0sXG4gICAgICAgIFtcInVuaXRzUGVyRW1cIiwgXCJ1bml0cy1wZXItZW1cIl0sXG4gICAgICAgIFtcInZBbHBoYWJldGljXCIsIFwidi1hbHBoYWJldGljXCJdLFxuICAgICAgICBbXCJ2SGFuZ2luZ1wiLCBcInYtaGFuZ2luZ1wiXSxcbiAgICAgICAgW1widklkZW9ncmFwaGljXCIsIFwidi1pZGVvZ3JhcGhpY1wiXSxcbiAgICAgICAgW1widk1hdGhlbWF0aWNhbFwiLCBcInYtbWF0aGVtYXRpY2FsXCJdLFxuICAgICAgICBbXCJ2ZWN0b3JFZmZlY3RcIiwgXCJ2ZWN0b3ItZWZmZWN0XCJdLFxuICAgICAgICBbXCJ2ZXJ0QWR2WVwiLCBcInZlcnQtYWR2LXlcIl0sXG4gICAgICAgIFtcInZlcnRPcmlnaW5YXCIsIFwidmVydC1vcmlnaW4teFwiXSxcbiAgICAgICAgW1widmVydE9yaWdpbllcIiwgXCJ2ZXJ0LW9yaWdpbi15XCJdLFxuICAgICAgICBbXCJ3b3JkU3BhY2luZ1wiLCBcIndvcmQtc3BhY2luZ1wiXSxcbiAgICAgICAgW1wid3JpdGluZ01vZGVcIiwgXCJ3cml0aW5nLW1vZGVcIl0sXG4gICAgICAgIFtcInhtbG5zWGxpbmtcIiwgXCJ4bWxuczp4bGlua1wiXSxcbiAgICAgICAgW1wieEhlaWdodFwiLCBcIngtaGVpZ2h0XCJdXG4gICAgICBdKSxcbiAgICAgIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICAgICAgIGJ1dHRvbjogITAsXG4gICAgICAgIGNoZWNrYm94OiAhMCxcbiAgICAgICAgaW1hZ2U6ICEwLFxuICAgICAgICBoaWRkZW46ICEwLFxuICAgICAgICByYWRpbzogITAsXG4gICAgICAgIHJlc2V0OiAhMCxcbiAgICAgICAgc3VibWl0OiAhMFxuICAgICAgfSxcbiAgICAgIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAgICAgICBcImFyaWEtY3VycmVudFwiOiAwLFxuICAgICAgICBcImFyaWEtZGVzY3JpcHRpb25cIjogMCxcbiAgICAgICAgXCJhcmlhLWRldGFpbHNcIjogMCxcbiAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1oaWRkZW5cIjogMCxcbiAgICAgICAgXCJhcmlhLWludmFsaWRcIjogMCxcbiAgICAgICAgXCJhcmlhLWtleXNob3J0Y3V0c1wiOiAwLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogMCxcbiAgICAgICAgXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiOiAwLFxuICAgICAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1jaGVja2VkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiAwLFxuICAgICAgICBcImFyaWEtaGFzcG9wdXBcIjogMCxcbiAgICAgICAgXCJhcmlhLWxldmVsXCI6IDAsXG4gICAgICAgIFwiYXJpYS1tb2RhbFwiOiAwLFxuICAgICAgICBcImFyaWEtbXVsdGlsaW5lXCI6IDAsXG4gICAgICAgIFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIjogMCxcbiAgICAgICAgXCJhcmlhLW9yaWVudGF0aW9uXCI6IDAsXG4gICAgICAgIFwiYXJpYS1wbGFjZWhvbGRlclwiOiAwLFxuICAgICAgICBcImFyaWEtcHJlc3NlZFwiOiAwLFxuICAgICAgICBcImFyaWEtcmVhZG9ubHlcIjogMCxcbiAgICAgICAgXCJhcmlhLXJlcXVpcmVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1zZWxlY3RlZFwiOiAwLFxuICAgICAgICBcImFyaWEtc29ydFwiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWVtYXhcIjogMCxcbiAgICAgICAgXCJhcmlhLXZhbHVlbWluXCI6IDAsXG4gICAgICAgIFwiYXJpYS12YWx1ZW5vd1wiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWV0ZXh0XCI6IDAsXG4gICAgICAgIFwiYXJpYS1hdG9taWNcIjogMCxcbiAgICAgICAgXCJhcmlhLWJ1c3lcIjogMCxcbiAgICAgICAgXCJhcmlhLWxpdmVcIjogMCxcbiAgICAgICAgXCJhcmlhLXJlbGV2YW50XCI6IDAsXG4gICAgICAgIFwiYXJpYS1kcm9wZWZmZWN0XCI6IDAsXG4gICAgICAgIFwiYXJpYS1ncmFiYmVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IDAsXG4gICAgICAgIFwiYXJpYS1jb2xjb3VudFwiOiAwLFxuICAgICAgICBcImFyaWEtY29saW5kZXhcIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbHNwYW5cIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IDAsXG4gICAgICAgIFwiYXJpYS1kZXNjcmliZWRieVwiOiAwLFxuICAgICAgICBcImFyaWEtZXJyb3JtZXNzYWdlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1mbG93dG9cIjogMCxcbiAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogMCxcbiAgICAgICAgXCJhcmlhLW93bnNcIjogMCxcbiAgICAgICAgXCJhcmlhLXBvc2luc2V0XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb3djb3VudFwiOiAwLFxuICAgICAgICBcImFyaWEtcm93aW5kZXhcIjogMCxcbiAgICAgICAgXCJhcmlhLXJvd3NwYW5cIjogMCxcbiAgICAgICAgXCJhcmlhLXNldHNpemVcIjogMFxuICAgICAgfSxcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9LFxuICAgICAgckFSSUEkMSA9IFJlZ0V4cChcbiAgICAgICAgXCJeKGFyaWEpLVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIHJBUklBQ2FtZWwkMSA9IFJlZ0V4cChcbiAgICAgICAgXCJeKGFyaWEpW0EtWl1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICBkaWRXYXJuVmFsdWVOdWxsID0gITEsXG4gICAgICBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gICAgICAgIGFjY2VwdDogXCJhY2NlcHRcIixcbiAgICAgICAgYWNjZXB0Y2hhcnNldDogXCJhY2NlcHRDaGFyc2V0XCIsXG4gICAgICAgIFwiYWNjZXB0LWNoYXJzZXRcIjogXCJhY2NlcHRDaGFyc2V0XCIsXG4gICAgICAgIGFjY2Vzc2tleTogXCJhY2Nlc3NLZXlcIixcbiAgICAgICAgYWN0aW9uOiBcImFjdGlvblwiLFxuICAgICAgICBhbGxvd2Z1bGxzY3JlZW46IFwiYWxsb3dGdWxsU2NyZWVuXCIsXG4gICAgICAgIGFsdDogXCJhbHRcIixcbiAgICAgICAgYXM6IFwiYXNcIixcbiAgICAgICAgYXN5bmM6IFwiYXN5bmNcIixcbiAgICAgICAgYXV0b2NhcGl0YWxpemU6IFwiYXV0b0NhcGl0YWxpemVcIixcbiAgICAgICAgYXV0b2NvbXBsZXRlOiBcImF1dG9Db21wbGV0ZVwiLFxuICAgICAgICBhdXRvY29ycmVjdDogXCJhdXRvQ29ycmVjdFwiLFxuICAgICAgICBhdXRvZm9jdXM6IFwiYXV0b0ZvY3VzXCIsXG4gICAgICAgIGF1dG9wbGF5OiBcImF1dG9QbGF5XCIsXG4gICAgICAgIGF1dG9zYXZlOiBcImF1dG9TYXZlXCIsXG4gICAgICAgIGNhcHR1cmU6IFwiY2FwdHVyZVwiLFxuICAgICAgICBjZWxscGFkZGluZzogXCJjZWxsUGFkZGluZ1wiLFxuICAgICAgICBjZWxsc3BhY2luZzogXCJjZWxsU3BhY2luZ1wiLFxuICAgICAgICBjaGFsbGVuZ2U6IFwiY2hhbGxlbmdlXCIsXG4gICAgICAgIGNoYXJzZXQ6IFwiY2hhclNldFwiLFxuICAgICAgICBjaGVja2VkOiBcImNoZWNrZWRcIixcbiAgICAgICAgY2hpbGRyZW46IFwiY2hpbGRyZW5cIixcbiAgICAgICAgY2l0ZTogXCJjaXRlXCIsXG4gICAgICAgIGNsYXNzOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICBjbGFzc2lkOiBcImNsYXNzSURcIixcbiAgICAgICAgY2xhc3NuYW1lOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICBjb2xzOiBcImNvbHNcIixcbiAgICAgICAgY29sc3BhbjogXCJjb2xTcGFuXCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiY29udGVudFwiLFxuICAgICAgICBjb250ZW50ZWRpdGFibGU6IFwiY29udGVudEVkaXRhYmxlXCIsXG4gICAgICAgIGNvbnRleHRtZW51OiBcImNvbnRleHRNZW51XCIsXG4gICAgICAgIGNvbnRyb2xzOiBcImNvbnRyb2xzXCIsXG4gICAgICAgIGNvbnRyb2xzbGlzdDogXCJjb250cm9sc0xpc3RcIixcbiAgICAgICAgY29vcmRzOiBcImNvb3Jkc1wiLFxuICAgICAgICBjcm9zc29yaWdpbjogXCJjcm9zc09yaWdpblwiLFxuICAgICAgICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiLFxuICAgICAgICBkYXRhOiBcImRhdGFcIixcbiAgICAgICAgZGF0ZXRpbWU6IFwiZGF0ZVRpbWVcIixcbiAgICAgICAgZGVmYXVsdDogXCJkZWZhdWx0XCIsXG4gICAgICAgIGRlZmF1bHRjaGVja2VkOiBcImRlZmF1bHRDaGVja2VkXCIsXG4gICAgICAgIGRlZmF1bHR2YWx1ZTogXCJkZWZhdWx0VmFsdWVcIixcbiAgICAgICAgZGVmZXI6IFwiZGVmZXJcIixcbiAgICAgICAgZGlyOiBcImRpclwiLFxuICAgICAgICBkaXNhYmxlZDogXCJkaXNhYmxlZFwiLFxuICAgICAgICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiLFxuICAgICAgICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6IFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCIsXG4gICAgICAgIGRvd25sb2FkOiBcImRvd25sb2FkXCIsXG4gICAgICAgIGRyYWdnYWJsZTogXCJkcmFnZ2FibGVcIixcbiAgICAgICAgZW5jdHlwZTogXCJlbmNUeXBlXCIsXG4gICAgICAgIGVudGVya2V5aGludDogXCJlbnRlcktleUhpbnRcIixcbiAgICAgICAgZmV0Y2hwcmlvcml0eTogXCJmZXRjaFByaW9yaXR5XCIsXG4gICAgICAgIGZvcjogXCJodG1sRm9yXCIsXG4gICAgICAgIGZvcm06IFwiZm9ybVwiLFxuICAgICAgICBmb3JtbWV0aG9kOiBcImZvcm1NZXRob2RcIixcbiAgICAgICAgZm9ybWFjdGlvbjogXCJmb3JtQWN0aW9uXCIsXG4gICAgICAgIGZvcm1lbmN0eXBlOiBcImZvcm1FbmNUeXBlXCIsXG4gICAgICAgIGZvcm1ub3ZhbGlkYXRlOiBcImZvcm1Ob1ZhbGlkYXRlXCIsXG4gICAgICAgIGZvcm10YXJnZXQ6IFwiZm9ybVRhcmdldFwiLFxuICAgICAgICBmcmFtZWJvcmRlcjogXCJmcmFtZUJvcmRlclwiLFxuICAgICAgICBoZWFkZXJzOiBcImhlYWRlcnNcIixcbiAgICAgICAgaGVpZ2h0OiBcImhlaWdodFwiLFxuICAgICAgICBoaWRkZW46IFwiaGlkZGVuXCIsXG4gICAgICAgIGhpZ2g6IFwiaGlnaFwiLFxuICAgICAgICBocmVmOiBcImhyZWZcIixcbiAgICAgICAgaHJlZmxhbmc6IFwiaHJlZkxhbmdcIixcbiAgICAgICAgaHRtbGZvcjogXCJodG1sRm9yXCIsXG4gICAgICAgIGh0dHBlcXVpdjogXCJodHRwRXF1aXZcIixcbiAgICAgICAgXCJodHRwLWVxdWl2XCI6IFwiaHR0cEVxdWl2XCIsXG4gICAgICAgIGljb246IFwiaWNvblwiLFxuICAgICAgICBpZDogXCJpZFwiLFxuICAgICAgICBpbWFnZXNpemVzOiBcImltYWdlU2l6ZXNcIixcbiAgICAgICAgaW1hZ2VzcmNzZXQ6IFwiaW1hZ2VTcmNTZXRcIixcbiAgICAgICAgaW5lcnQ6IFwiaW5lcnRcIixcbiAgICAgICAgaW5uZXJodG1sOiBcImlubmVySFRNTFwiLFxuICAgICAgICBpbnB1dG1vZGU6IFwiaW5wdXRNb2RlXCIsXG4gICAgICAgIGludGVncml0eTogXCJpbnRlZ3JpdHlcIixcbiAgICAgICAgaXM6IFwiaXNcIixcbiAgICAgICAgaXRlbWlkOiBcIml0ZW1JRFwiLFxuICAgICAgICBpdGVtcHJvcDogXCJpdGVtUHJvcFwiLFxuICAgICAgICBpdGVtcmVmOiBcIml0ZW1SZWZcIixcbiAgICAgICAgaXRlbXNjb3BlOiBcIml0ZW1TY29wZVwiLFxuICAgICAgICBpdGVtdHlwZTogXCJpdGVtVHlwZVwiLFxuICAgICAgICBrZXlwYXJhbXM6IFwia2V5UGFyYW1zXCIsXG4gICAgICAgIGtleXR5cGU6IFwia2V5VHlwZVwiLFxuICAgICAgICBraW5kOiBcImtpbmRcIixcbiAgICAgICAgbGFiZWw6IFwibGFiZWxcIixcbiAgICAgICAgbGFuZzogXCJsYW5nXCIsXG4gICAgICAgIGxpc3Q6IFwibGlzdFwiLFxuICAgICAgICBsb29wOiBcImxvb3BcIixcbiAgICAgICAgbG93OiBcImxvd1wiLFxuICAgICAgICBtYW5pZmVzdDogXCJtYW5pZmVzdFwiLFxuICAgICAgICBtYXJnaW53aWR0aDogXCJtYXJnaW5XaWR0aFwiLFxuICAgICAgICBtYXJnaW5oZWlnaHQ6IFwibWFyZ2luSGVpZ2h0XCIsXG4gICAgICAgIG1heDogXCJtYXhcIixcbiAgICAgICAgbWF4bGVuZ3RoOiBcIm1heExlbmd0aFwiLFxuICAgICAgICBtZWRpYTogXCJtZWRpYVwiLFxuICAgICAgICBtZWRpYWdyb3VwOiBcIm1lZGlhR3JvdXBcIixcbiAgICAgICAgbWV0aG9kOiBcIm1ldGhvZFwiLFxuICAgICAgICBtaW46IFwibWluXCIsXG4gICAgICAgIG1pbmxlbmd0aDogXCJtaW5MZW5ndGhcIixcbiAgICAgICAgbXVsdGlwbGU6IFwibXVsdGlwbGVcIixcbiAgICAgICAgbXV0ZWQ6IFwibXV0ZWRcIixcbiAgICAgICAgbmFtZTogXCJuYW1lXCIsXG4gICAgICAgIG5vbW9kdWxlOiBcIm5vTW9kdWxlXCIsXG4gICAgICAgIG5vbmNlOiBcIm5vbmNlXCIsXG4gICAgICAgIG5vdmFsaWRhdGU6IFwibm9WYWxpZGF0ZVwiLFxuICAgICAgICBvcGVuOiBcIm9wZW5cIixcbiAgICAgICAgb3B0aW11bTogXCJvcHRpbXVtXCIsXG4gICAgICAgIHBhdHRlcm46IFwicGF0dGVyblwiLFxuICAgICAgICBwbGFjZWhvbGRlcjogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICBwbGF5c2lubGluZTogXCJwbGF5c0lubGluZVwiLFxuICAgICAgICBwb3N0ZXI6IFwicG9zdGVyXCIsXG4gICAgICAgIHByZWxvYWQ6IFwicHJlbG9hZFwiLFxuICAgICAgICBwcm9maWxlOiBcInByb2ZpbGVcIixcbiAgICAgICAgcmFkaW9ncm91cDogXCJyYWRpb0dyb3VwXCIsXG4gICAgICAgIHJlYWRvbmx5OiBcInJlYWRPbmx5XCIsXG4gICAgICAgIHJlZmVycmVycG9saWN5OiBcInJlZmVycmVyUG9saWN5XCIsXG4gICAgICAgIHJlbDogXCJyZWxcIixcbiAgICAgICAgcmVxdWlyZWQ6IFwicmVxdWlyZWRcIixcbiAgICAgICAgcmV2ZXJzZWQ6IFwicmV2ZXJzZWRcIixcbiAgICAgICAgcm9sZTogXCJyb2xlXCIsXG4gICAgICAgIHJvd3M6IFwicm93c1wiLFxuICAgICAgICByb3dzcGFuOiBcInJvd1NwYW5cIixcbiAgICAgICAgc2FuZGJveDogXCJzYW5kYm94XCIsXG4gICAgICAgIHNjb3BlOiBcInNjb3BlXCIsXG4gICAgICAgIHNjb3BlZDogXCJzY29wZWRcIixcbiAgICAgICAgc2Nyb2xsaW5nOiBcInNjcm9sbGluZ1wiLFxuICAgICAgICBzZWFtbGVzczogXCJzZWFtbGVzc1wiLFxuICAgICAgICBzZWxlY3RlZDogXCJzZWxlY3RlZFwiLFxuICAgICAgICBzaGFwZTogXCJzaGFwZVwiLFxuICAgICAgICBzaXplOiBcInNpemVcIixcbiAgICAgICAgc2l6ZXM6IFwic2l6ZXNcIixcbiAgICAgICAgc3BhbjogXCJzcGFuXCIsXG4gICAgICAgIHNwZWxsY2hlY2s6IFwic3BlbGxDaGVja1wiLFxuICAgICAgICBzcmM6IFwic3JjXCIsXG4gICAgICAgIHNyY2RvYzogXCJzcmNEb2NcIixcbiAgICAgICAgc3JjbGFuZzogXCJzcmNMYW5nXCIsXG4gICAgICAgIHNyY3NldDogXCJzcmNTZXRcIixcbiAgICAgICAgc3RhcnQ6IFwic3RhcnRcIixcbiAgICAgICAgc3RlcDogXCJzdGVwXCIsXG4gICAgICAgIHN0eWxlOiBcInN0eWxlXCIsXG4gICAgICAgIHN1bW1hcnk6IFwic3VtbWFyeVwiLFxuICAgICAgICB0YWJpbmRleDogXCJ0YWJJbmRleFwiLFxuICAgICAgICB0YXJnZXQ6IFwidGFyZ2V0XCIsXG4gICAgICAgIHRpdGxlOiBcInRpdGxlXCIsXG4gICAgICAgIHR5cGU6IFwidHlwZVwiLFxuICAgICAgICB1c2VtYXA6IFwidXNlTWFwXCIsXG4gICAgICAgIHZhbHVlOiBcInZhbHVlXCIsXG4gICAgICAgIHdpZHRoOiBcIndpZHRoXCIsXG4gICAgICAgIHdtb2RlOiBcIndtb2RlXCIsXG4gICAgICAgIHdyYXA6IFwid3JhcFwiLFxuICAgICAgICBhYm91dDogXCJhYm91dFwiLFxuICAgICAgICBhY2NlbnRoZWlnaHQ6IFwiYWNjZW50SGVpZ2h0XCIsXG4gICAgICAgIFwiYWNjZW50LWhlaWdodFwiOiBcImFjY2VudEhlaWdodFwiLFxuICAgICAgICBhY2N1bXVsYXRlOiBcImFjY3VtdWxhdGVcIixcbiAgICAgICAgYWRkaXRpdmU6IFwiYWRkaXRpdmVcIixcbiAgICAgICAgYWxpZ25tZW50YmFzZWxpbmU6IFwiYWxpZ25tZW50QmFzZWxpbmVcIixcbiAgICAgICAgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIjogXCJhbGlnbm1lbnRCYXNlbGluZVwiLFxuICAgICAgICBhbGxvd3Jlb3JkZXI6IFwiYWxsb3dSZW9yZGVyXCIsXG4gICAgICAgIGFscGhhYmV0aWM6IFwiYWxwaGFiZXRpY1wiLFxuICAgICAgICBhbXBsaXR1ZGU6IFwiYW1wbGl0dWRlXCIsXG4gICAgICAgIGFyYWJpY2Zvcm06IFwiYXJhYmljRm9ybVwiLFxuICAgICAgICBcImFyYWJpYy1mb3JtXCI6IFwiYXJhYmljRm9ybVwiLFxuICAgICAgICBhc2NlbnQ6IFwiYXNjZW50XCIsXG4gICAgICAgIGF0dHJpYnV0ZW5hbWU6IFwiYXR0cmlidXRlTmFtZVwiLFxuICAgICAgICBhdHRyaWJ1dGV0eXBlOiBcImF0dHJpYnV0ZVR5cGVcIixcbiAgICAgICAgYXV0b3JldmVyc2U6IFwiYXV0b1JldmVyc2VcIixcbiAgICAgICAgYXppbXV0aDogXCJhemltdXRoXCIsXG4gICAgICAgIGJhc2VmcmVxdWVuY3k6IFwiYmFzZUZyZXF1ZW5jeVwiLFxuICAgICAgICBiYXNlbGluZXNoaWZ0OiBcImJhc2VsaW5lU2hpZnRcIixcbiAgICAgICAgXCJiYXNlbGluZS1zaGlmdFwiOiBcImJhc2VsaW5lU2hpZnRcIixcbiAgICAgICAgYmFzZXByb2ZpbGU6IFwiYmFzZVByb2ZpbGVcIixcbiAgICAgICAgYmJveDogXCJiYm94XCIsXG4gICAgICAgIGJlZ2luOiBcImJlZ2luXCIsXG4gICAgICAgIGJpYXM6IFwiYmlhc1wiLFxuICAgICAgICBieTogXCJieVwiLFxuICAgICAgICBjYWxjbW9kZTogXCJjYWxjTW9kZVwiLFxuICAgICAgICBjYXBoZWlnaHQ6IFwiY2FwSGVpZ2h0XCIsXG4gICAgICAgIFwiY2FwLWhlaWdodFwiOiBcImNhcEhlaWdodFwiLFxuICAgICAgICBjbGlwOiBcImNsaXBcIixcbiAgICAgICAgY2xpcHBhdGg6IFwiY2xpcFBhdGhcIixcbiAgICAgICAgXCJjbGlwLXBhdGhcIjogXCJjbGlwUGF0aFwiLFxuICAgICAgICBjbGlwcGF0aHVuaXRzOiBcImNsaXBQYXRoVW5pdHNcIixcbiAgICAgICAgY2xpcHJ1bGU6IFwiY2xpcFJ1bGVcIixcbiAgICAgICAgXCJjbGlwLXJ1bGVcIjogXCJjbGlwUnVsZVwiLFxuICAgICAgICBjb2xvcjogXCJjb2xvclwiLFxuICAgICAgICBjb2xvcmludGVycG9sYXRpb246IFwiY29sb3JJbnRlcnBvbGF0aW9uXCIsXG4gICAgICAgIFwiY29sb3ItaW50ZXJwb2xhdGlvblwiOiBcImNvbG9ySW50ZXJwb2xhdGlvblwiLFxuICAgICAgICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiBcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIixcbiAgICAgICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIjogXCJjb2xvckludGVycG9sYXRpb25GaWx0ZXJzXCIsXG4gICAgICAgIGNvbG9ycHJvZmlsZTogXCJjb2xvclByb2ZpbGVcIixcbiAgICAgICAgXCJjb2xvci1wcm9maWxlXCI6IFwiY29sb3JQcm9maWxlXCIsXG4gICAgICAgIGNvbG9ycmVuZGVyaW5nOiBcImNvbG9yUmVuZGVyaW5nXCIsXG4gICAgICAgIFwiY29sb3ItcmVuZGVyaW5nXCI6IFwiY29sb3JSZW5kZXJpbmdcIixcbiAgICAgICAgY29udGVudHNjcmlwdHR5cGU6IFwiY29udGVudFNjcmlwdFR5cGVcIixcbiAgICAgICAgY29udGVudHN0eWxldHlwZTogXCJjb250ZW50U3R5bGVUeXBlXCIsXG4gICAgICAgIGN1cnNvcjogXCJjdXJzb3JcIixcbiAgICAgICAgY3g6IFwiY3hcIixcbiAgICAgICAgY3k6IFwiY3lcIixcbiAgICAgICAgZDogXCJkXCIsXG4gICAgICAgIGRhdGF0eXBlOiBcImRhdGF0eXBlXCIsXG4gICAgICAgIGRlY2VsZXJhdGU6IFwiZGVjZWxlcmF0ZVwiLFxuICAgICAgICBkZXNjZW50OiBcImRlc2NlbnRcIixcbiAgICAgICAgZGlmZnVzZWNvbnN0YW50OiBcImRpZmZ1c2VDb25zdGFudFwiLFxuICAgICAgICBkaXJlY3Rpb246IFwiZGlyZWN0aW9uXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiZGlzcGxheVwiLFxuICAgICAgICBkaXZpc29yOiBcImRpdmlzb3JcIixcbiAgICAgICAgZG9taW5hbnRiYXNlbGluZTogXCJkb21pbmFudEJhc2VsaW5lXCIsXG4gICAgICAgIFwiZG9taW5hbnQtYmFzZWxpbmVcIjogXCJkb21pbmFudEJhc2VsaW5lXCIsXG4gICAgICAgIGR1cjogXCJkdXJcIixcbiAgICAgICAgZHg6IFwiZHhcIixcbiAgICAgICAgZHk6IFwiZHlcIixcbiAgICAgICAgZWRnZW1vZGU6IFwiZWRnZU1vZGVcIixcbiAgICAgICAgZWxldmF0aW9uOiBcImVsZXZhdGlvblwiLFxuICAgICAgICBlbmFibGViYWNrZ3JvdW5kOiBcImVuYWJsZUJhY2tncm91bmRcIixcbiAgICAgICAgXCJlbmFibGUtYmFja2dyb3VuZFwiOiBcImVuYWJsZUJhY2tncm91bmRcIixcbiAgICAgICAgZW5kOiBcImVuZFwiLFxuICAgICAgICBleHBvbmVudDogXCJleHBvbmVudFwiLFxuICAgICAgICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcbiAgICAgICAgZmlsbDogXCJmaWxsXCIsXG4gICAgICAgIGZpbGxvcGFjaXR5OiBcImZpbGxPcGFjaXR5XCIsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IFwiZmlsbE9wYWNpdHlcIixcbiAgICAgICAgZmlsbHJ1bGU6IFwiZmlsbFJ1bGVcIixcbiAgICAgICAgXCJmaWxsLXJ1bGVcIjogXCJmaWxsUnVsZVwiLFxuICAgICAgICBmaWx0ZXI6IFwiZmlsdGVyXCIsXG4gICAgICAgIGZpbHRlcnJlczogXCJmaWx0ZXJSZXNcIixcbiAgICAgICAgZmlsdGVydW5pdHM6IFwiZmlsdGVyVW5pdHNcIixcbiAgICAgICAgZmxvb2RvcGFjaXR5OiBcImZsb29kT3BhY2l0eVwiLFxuICAgICAgICBcImZsb29kLW9wYWNpdHlcIjogXCJmbG9vZE9wYWNpdHlcIixcbiAgICAgICAgZmxvb2Rjb2xvcjogXCJmbG9vZENvbG9yXCIsXG4gICAgICAgIFwiZmxvb2QtY29sb3JcIjogXCJmbG9vZENvbG9yXCIsXG4gICAgICAgIGZvY3VzYWJsZTogXCJmb2N1c2FibGVcIixcbiAgICAgICAgZm9udGZhbWlseTogXCJmb250RmFtaWx5XCIsXG4gICAgICAgIFwiZm9udC1mYW1pbHlcIjogXCJmb250RmFtaWx5XCIsXG4gICAgICAgIGZvbnRzaXplOiBcImZvbnRTaXplXCIsXG4gICAgICAgIFwiZm9udC1zaXplXCI6IFwiZm9udFNpemVcIixcbiAgICAgICAgZm9udHNpemVhZGp1c3Q6IFwiZm9udFNpemVBZGp1c3RcIixcbiAgICAgICAgXCJmb250LXNpemUtYWRqdXN0XCI6IFwiZm9udFNpemVBZGp1c3RcIixcbiAgICAgICAgZm9udHN0cmV0Y2g6IFwiZm9udFN0cmV0Y2hcIixcbiAgICAgICAgXCJmb250LXN0cmV0Y2hcIjogXCJmb250U3RyZXRjaFwiLFxuICAgICAgICBmb250c3R5bGU6IFwiZm9udFN0eWxlXCIsXG4gICAgICAgIFwiZm9udC1zdHlsZVwiOiBcImZvbnRTdHlsZVwiLFxuICAgICAgICBmb250dmFyaWFudDogXCJmb250VmFyaWFudFwiLFxuICAgICAgICBcImZvbnQtdmFyaWFudFwiOiBcImZvbnRWYXJpYW50XCIsXG4gICAgICAgIGZvbnR3ZWlnaHQ6IFwiZm9udFdlaWdodFwiLFxuICAgICAgICBcImZvbnQtd2VpZ2h0XCI6IFwiZm9udFdlaWdodFwiLFxuICAgICAgICBmb3JtYXQ6IFwiZm9ybWF0XCIsXG4gICAgICAgIGZyb206IFwiZnJvbVwiLFxuICAgICAgICBmeDogXCJmeFwiLFxuICAgICAgICBmeTogXCJmeVwiLFxuICAgICAgICBnMTogXCJnMVwiLFxuICAgICAgICBnMjogXCJnMlwiLFxuICAgICAgICBnbHlwaG5hbWU6IFwiZ2x5cGhOYW1lXCIsXG4gICAgICAgIFwiZ2x5cGgtbmFtZVwiOiBcImdseXBoTmFtZVwiLFxuICAgICAgICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLFxuICAgICAgICBcImdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWxcIjogXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLFxuICAgICAgICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6IFwiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsXCIsXG4gICAgICAgIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIjogXCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWxcIixcbiAgICAgICAgZ2x5cGhyZWY6IFwiZ2x5cGhSZWZcIixcbiAgICAgICAgZ3JhZGllbnR0cmFuc2Zvcm06IFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcbiAgICAgICAgZ3JhZGllbnR1bml0czogXCJncmFkaWVudFVuaXRzXCIsXG4gICAgICAgIGhhbmdpbmc6IFwiaGFuZ2luZ1wiLFxuICAgICAgICBob3JpemFkdng6IFwiaG9yaXpBZHZYXCIsXG4gICAgICAgIFwiaG9yaXotYWR2LXhcIjogXCJob3JpekFkdlhcIixcbiAgICAgICAgaG9yaXpvcmlnaW54OiBcImhvcml6T3JpZ2luWFwiLFxuICAgICAgICBcImhvcml6LW9yaWdpbi14XCI6IFwiaG9yaXpPcmlnaW5YXCIsXG4gICAgICAgIGlkZW9ncmFwaGljOiBcImlkZW9ncmFwaGljXCIsXG4gICAgICAgIGltYWdlcmVuZGVyaW5nOiBcImltYWdlUmVuZGVyaW5nXCIsXG4gICAgICAgIFwiaW1hZ2UtcmVuZGVyaW5nXCI6IFwiaW1hZ2VSZW5kZXJpbmdcIixcbiAgICAgICAgaW4yOiBcImluMlwiLFxuICAgICAgICBpbjogXCJpblwiLFxuICAgICAgICBpbmxpc3Q6IFwiaW5saXN0XCIsXG4gICAgICAgIGludGVyY2VwdDogXCJpbnRlcmNlcHRcIixcbiAgICAgICAgazE6IFwiazFcIixcbiAgICAgICAgazI6IFwiazJcIixcbiAgICAgICAgazM6IFwiazNcIixcbiAgICAgICAgazQ6IFwiazRcIixcbiAgICAgICAgazogXCJrXCIsXG4gICAgICAgIGtlcm5lbG1hdHJpeDogXCJrZXJuZWxNYXRyaXhcIixcbiAgICAgICAga2VybmVsdW5pdGxlbmd0aDogXCJrZXJuZWxVbml0TGVuZ3RoXCIsXG4gICAgICAgIGtlcm5pbmc6IFwia2VybmluZ1wiLFxuICAgICAgICBrZXlwb2ludHM6IFwia2V5UG9pbnRzXCIsXG4gICAgICAgIGtleXNwbGluZXM6IFwia2V5U3BsaW5lc1wiLFxuICAgICAgICBrZXl0aW1lczogXCJrZXlUaW1lc1wiLFxuICAgICAgICBsZW5ndGhhZGp1c3Q6IFwibGVuZ3RoQWRqdXN0XCIsXG4gICAgICAgIGxldHRlcnNwYWNpbmc6IFwibGV0dGVyU3BhY2luZ1wiLFxuICAgICAgICBcImxldHRlci1zcGFjaW5nXCI6IFwibGV0dGVyU3BhY2luZ1wiLFxuICAgICAgICBsaWdodGluZ2NvbG9yOiBcImxpZ2h0aW5nQ29sb3JcIixcbiAgICAgICAgXCJsaWdodGluZy1jb2xvclwiOiBcImxpZ2h0aW5nQ29sb3JcIixcbiAgICAgICAgbGltaXRpbmdjb25lYW5nbGU6IFwibGltaXRpbmdDb25lQW5nbGVcIixcbiAgICAgICAgbG9jYWw6IFwibG9jYWxcIixcbiAgICAgICAgbWFya2VyZW5kOiBcIm1hcmtlckVuZFwiLFxuICAgICAgICBcIm1hcmtlci1lbmRcIjogXCJtYXJrZXJFbmRcIixcbiAgICAgICAgbWFya2VyaGVpZ2h0OiBcIm1hcmtlckhlaWdodFwiLFxuICAgICAgICBtYXJrZXJtaWQ6IFwibWFya2VyTWlkXCIsXG4gICAgICAgIFwibWFya2VyLW1pZFwiOiBcIm1hcmtlck1pZFwiLFxuICAgICAgICBtYXJrZXJzdGFydDogXCJtYXJrZXJTdGFydFwiLFxuICAgICAgICBcIm1hcmtlci1zdGFydFwiOiBcIm1hcmtlclN0YXJ0XCIsXG4gICAgICAgIG1hcmtlcnVuaXRzOiBcIm1hcmtlclVuaXRzXCIsXG4gICAgICAgIG1hcmtlcndpZHRoOiBcIm1hcmtlcldpZHRoXCIsXG4gICAgICAgIG1hc2s6IFwibWFza1wiLFxuICAgICAgICBtYXNrY29udGVudHVuaXRzOiBcIm1hc2tDb250ZW50VW5pdHNcIixcbiAgICAgICAgbWFza3VuaXRzOiBcIm1hc2tVbml0c1wiLFxuICAgICAgICBtYXRoZW1hdGljYWw6IFwibWF0aGVtYXRpY2FsXCIsXG4gICAgICAgIG1vZGU6IFwibW9kZVwiLFxuICAgICAgICBudW1vY3RhdmVzOiBcIm51bU9jdGF2ZXNcIixcbiAgICAgICAgb2Zmc2V0OiBcIm9mZnNldFwiLFxuICAgICAgICBvcGFjaXR5OiBcIm9wYWNpdHlcIixcbiAgICAgICAgb3BlcmF0b3I6IFwib3BlcmF0b3JcIixcbiAgICAgICAgb3JkZXI6IFwib3JkZXJcIixcbiAgICAgICAgb3JpZW50OiBcIm9yaWVudFwiLFxuICAgICAgICBvcmllbnRhdGlvbjogXCJvcmllbnRhdGlvblwiLFxuICAgICAgICBvcmlnaW46IFwib3JpZ2luXCIsXG4gICAgICAgIG92ZXJmbG93OiBcIm92ZXJmbG93XCIsXG4gICAgICAgIG92ZXJsaW5lcG9zaXRpb246IFwib3ZlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICBcIm92ZXJsaW5lLXBvc2l0aW9uXCI6IFwib3ZlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICBvdmVybGluZXRoaWNrbmVzczogXCJvdmVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICBcIm92ZXJsaW5lLXRoaWNrbmVzc1wiOiBcIm92ZXJsaW5lVGhpY2tuZXNzXCIsXG4gICAgICAgIHBhaW50b3JkZXI6IFwicGFpbnRPcmRlclwiLFxuICAgICAgICBcInBhaW50LW9yZGVyXCI6IFwicGFpbnRPcmRlclwiLFxuICAgICAgICBwYW5vc2UxOiBcInBhbm9zZTFcIixcbiAgICAgICAgXCJwYW5vc2UtMVwiOiBcInBhbm9zZTFcIixcbiAgICAgICAgcGF0aGxlbmd0aDogXCJwYXRoTGVuZ3RoXCIsXG4gICAgICAgIHBhdHRlcm5jb250ZW50dW5pdHM6IFwicGF0dGVybkNvbnRlbnRVbml0c1wiLFxuICAgICAgICBwYXR0ZXJudHJhbnNmb3JtOiBcInBhdHRlcm5UcmFuc2Zvcm1cIixcbiAgICAgICAgcGF0dGVybnVuaXRzOiBcInBhdHRlcm5Vbml0c1wiLFxuICAgICAgICBwb2ludGVyZXZlbnRzOiBcInBvaW50ZXJFdmVudHNcIixcbiAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiBcInBvaW50ZXJFdmVudHNcIixcbiAgICAgICAgcG9pbnRzOiBcInBvaW50c1wiLFxuICAgICAgICBwb2ludHNhdHg6IFwicG9pbnRzQXRYXCIsXG4gICAgICAgIHBvaW50c2F0eTogXCJwb2ludHNBdFlcIixcbiAgICAgICAgcG9pbnRzYXR6OiBcInBvaW50c0F0WlwiLFxuICAgICAgICBwb3BvdmVyOiBcInBvcG92ZXJcIixcbiAgICAgICAgcG9wb3ZlcnRhcmdldDogXCJwb3BvdmVyVGFyZ2V0XCIsXG4gICAgICAgIHBvcG92ZXJ0YXJnZXRhY3Rpb246IFwicG9wb3ZlclRhcmdldEFjdGlvblwiLFxuICAgICAgICBwcmVmaXg6IFwicHJlZml4XCIsXG4gICAgICAgIHByZXNlcnZlYWxwaGE6IFwicHJlc2VydmVBbHBoYVwiLFxuICAgICAgICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiBcInByZXNlcnZlQXNwZWN0UmF0aW9cIixcbiAgICAgICAgcHJpbWl0aXZldW5pdHM6IFwicHJpbWl0aXZlVW5pdHNcIixcbiAgICAgICAgcHJvcGVydHk6IFwicHJvcGVydHlcIixcbiAgICAgICAgcjogXCJyXCIsXG4gICAgICAgIHJhZGl1czogXCJyYWRpdXNcIixcbiAgICAgICAgcmVmeDogXCJyZWZYXCIsXG4gICAgICAgIHJlZnk6IFwicmVmWVwiLFxuICAgICAgICByZW5kZXJpbmdpbnRlbnQ6IFwicmVuZGVyaW5nSW50ZW50XCIsXG4gICAgICAgIFwicmVuZGVyaW5nLWludGVudFwiOiBcInJlbmRlcmluZ0ludGVudFwiLFxuICAgICAgICByZXBlYXRjb3VudDogXCJyZXBlYXRDb3VudFwiLFxuICAgICAgICByZXBlYXRkdXI6IFwicmVwZWF0RHVyXCIsXG4gICAgICAgIHJlcXVpcmVkZXh0ZW5zaW9uczogXCJyZXF1aXJlZEV4dGVuc2lvbnNcIixcbiAgICAgICAgcmVxdWlyZWRmZWF0dXJlczogXCJyZXF1aXJlZEZlYXR1cmVzXCIsXG4gICAgICAgIHJlc291cmNlOiBcInJlc291cmNlXCIsXG4gICAgICAgIHJlc3RhcnQ6IFwicmVzdGFydFwiLFxuICAgICAgICByZXN1bHQ6IFwicmVzdWx0XCIsXG4gICAgICAgIHJlc3VsdHM6IFwicmVzdWx0c1wiLFxuICAgICAgICByb3RhdGU6IFwicm90YXRlXCIsXG4gICAgICAgIHJ4OiBcInJ4XCIsXG4gICAgICAgIHJ5OiBcInJ5XCIsXG4gICAgICAgIHNjYWxlOiBcInNjYWxlXCIsXG4gICAgICAgIHNlY3VyaXR5OiBcInNlY3VyaXR5XCIsXG4gICAgICAgIHNlZWQ6IFwic2VlZFwiLFxuICAgICAgICBzaGFwZXJlbmRlcmluZzogXCJzaGFwZVJlbmRlcmluZ1wiLFxuICAgICAgICBcInNoYXBlLXJlbmRlcmluZ1wiOiBcInNoYXBlUmVuZGVyaW5nXCIsXG4gICAgICAgIHNsb3BlOiBcInNsb3BlXCIsXG4gICAgICAgIHNwYWNpbmc6IFwic3BhY2luZ1wiLFxuICAgICAgICBzcGVjdWxhcmNvbnN0YW50OiBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgICAgICAgc3BlY3VsYXJleHBvbmVudDogXCJzcGVjdWxhckV4cG9uZW50XCIsXG4gICAgICAgIHNwZWVkOiBcInNwZWVkXCIsXG4gICAgICAgIHNwcmVhZG1ldGhvZDogXCJzcHJlYWRNZXRob2RcIixcbiAgICAgICAgc3RhcnRvZmZzZXQ6IFwic3RhcnRPZmZzZXRcIixcbiAgICAgICAgc3RkZGV2aWF0aW9uOiBcInN0ZERldmlhdGlvblwiLFxuICAgICAgICBzdGVtaDogXCJzdGVtaFwiLFxuICAgICAgICBzdGVtdjogXCJzdGVtdlwiLFxuICAgICAgICBzdGl0Y2h0aWxlczogXCJzdGl0Y2hUaWxlc1wiLFxuICAgICAgICBzdG9wY29sb3I6IFwic3RvcENvbG9yXCIsXG4gICAgICAgIFwic3RvcC1jb2xvclwiOiBcInN0b3BDb2xvclwiLFxuICAgICAgICBzdG9wb3BhY2l0eTogXCJzdG9wT3BhY2l0eVwiLFxuICAgICAgICBcInN0b3Atb3BhY2l0eVwiOiBcInN0b3BPcGFjaXR5XCIsXG4gICAgICAgIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogXCJzdHJpa2V0aHJvdWdoUG9zaXRpb25cIixcbiAgICAgICAgXCJzdHJpa2V0aHJvdWdoLXBvc2l0aW9uXCI6IFwic3RyaWtldGhyb3VnaFBvc2l0aW9uXCIsXG4gICAgICAgIHN0cmlrZXRocm91Z2h0aGlja25lc3M6IFwic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLFxuICAgICAgICBcInN0cmlrZXRocm91Z2gtdGhpY2tuZXNzXCI6IFwic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLFxuICAgICAgICBzdHJpbmc6IFwic3RyaW5nXCIsXG4gICAgICAgIHN0cm9rZTogXCJzdHJva2VcIixcbiAgICAgICAgc3Ryb2tlZGFzaGFycmF5OiBcInN0cm9rZURhc2hhcnJheVwiLFxuICAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIjogXCJzdHJva2VEYXNoYXJyYXlcIixcbiAgICAgICAgc3Ryb2tlZGFzaG9mZnNldDogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgICAgIFwic3Ryb2tlLWRhc2hvZmZzZXRcIjogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgICAgIHN0cm9rZWxpbmVjYXA6IFwic3Ryb2tlTGluZWNhcFwiLFxuICAgICAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwic3Ryb2tlTGluZWNhcFwiLFxuICAgICAgICBzdHJva2VsaW5lam9pbjogXCJzdHJva2VMaW5lam9pblwiLFxuICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInN0cm9rZUxpbmVqb2luXCIsXG4gICAgICAgIHN0cm9rZW1pdGVybGltaXQ6IFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICAgICAgICBcInN0cm9rZS1taXRlcmxpbWl0XCI6IFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICAgICAgICBzdHJva2V3aWR0aDogXCJzdHJva2VXaWR0aFwiLFxuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBcInN0cm9rZVdpZHRoXCIsXG4gICAgICAgIHN0cm9rZW9wYWNpdHk6IFwic3Ryb2tlT3BhY2l0eVwiLFxuICAgICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IFwic3Ryb2tlT3BhY2l0eVwiLFxuICAgICAgICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6IFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIsXG4gICAgICAgIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIixcbiAgICAgICAgc3VyZmFjZXNjYWxlOiBcInN1cmZhY2VTY2FsZVwiLFxuICAgICAgICBzeXN0ZW1sYW5ndWFnZTogXCJzeXN0ZW1MYW5ndWFnZVwiLFxuICAgICAgICB0YWJsZXZhbHVlczogXCJ0YWJsZVZhbHVlc1wiLFxuICAgICAgICB0YXJnZXR4OiBcInRhcmdldFhcIixcbiAgICAgICAgdGFyZ2V0eTogXCJ0YXJnZXRZXCIsXG4gICAgICAgIHRleHRhbmNob3I6IFwidGV4dEFuY2hvclwiLFxuICAgICAgICBcInRleHQtYW5jaG9yXCI6IFwidGV4dEFuY2hvclwiLFxuICAgICAgICB0ZXh0ZGVjb3JhdGlvbjogXCJ0ZXh0RGVjb3JhdGlvblwiLFxuICAgICAgICBcInRleHQtZGVjb3JhdGlvblwiOiBcInRleHREZWNvcmF0aW9uXCIsXG4gICAgICAgIHRleHRsZW5ndGg6IFwidGV4dExlbmd0aFwiLFxuICAgICAgICB0ZXh0cmVuZGVyaW5nOiBcInRleHRSZW5kZXJpbmdcIixcbiAgICAgICAgXCJ0ZXh0LXJlbmRlcmluZ1wiOiBcInRleHRSZW5kZXJpbmdcIixcbiAgICAgICAgdG86IFwidG9cIixcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zZm9ybVwiLFxuICAgICAgICB0cmFuc2Zvcm1vcmlnaW46IFwidHJhbnNmb3JtT3JpZ2luXCIsXG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBcInRyYW5zZm9ybU9yaWdpblwiLFxuICAgICAgICB0eXBlb2Y6IFwidHlwZW9mXCIsXG4gICAgICAgIHUxOiBcInUxXCIsXG4gICAgICAgIHUyOiBcInUyXCIsXG4gICAgICAgIHVuZGVybGluZXBvc2l0aW9uOiBcInVuZGVybGluZVBvc2l0aW9uXCIsXG4gICAgICAgIFwidW5kZXJsaW5lLXBvc2l0aW9uXCI6IFwidW5kZXJsaW5lUG9zaXRpb25cIixcbiAgICAgICAgdW5kZXJsaW5ldGhpY2tuZXNzOiBcInVuZGVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICBcInVuZGVybGluZS10aGlja25lc3NcIjogXCJ1bmRlcmxpbmVUaGlja25lc3NcIixcbiAgICAgICAgdW5pY29kZTogXCJ1bmljb2RlXCIsXG4gICAgICAgIHVuaWNvZGViaWRpOiBcInVuaWNvZGVCaWRpXCIsXG4gICAgICAgIFwidW5pY29kZS1iaWRpXCI6IFwidW5pY29kZUJpZGlcIixcbiAgICAgICAgdW5pY29kZXJhbmdlOiBcInVuaWNvZGVSYW5nZVwiLFxuICAgICAgICBcInVuaWNvZGUtcmFuZ2VcIjogXCJ1bmljb2RlUmFuZ2VcIixcbiAgICAgICAgdW5pdHNwZXJlbTogXCJ1bml0c1BlckVtXCIsXG4gICAgICAgIFwidW5pdHMtcGVyLWVtXCI6IFwidW5pdHNQZXJFbVwiLFxuICAgICAgICB1bnNlbGVjdGFibGU6IFwidW5zZWxlY3RhYmxlXCIsXG4gICAgICAgIHZhbHBoYWJldGljOiBcInZBbHBoYWJldGljXCIsXG4gICAgICAgIFwidi1hbHBoYWJldGljXCI6IFwidkFscGhhYmV0aWNcIixcbiAgICAgICAgdmFsdWVzOiBcInZhbHVlc1wiLFxuICAgICAgICB2ZWN0b3JlZmZlY3Q6IFwidmVjdG9yRWZmZWN0XCIsXG4gICAgICAgIFwidmVjdG9yLWVmZmVjdFwiOiBcInZlY3RvckVmZmVjdFwiLFxuICAgICAgICB2ZXJzaW9uOiBcInZlcnNpb25cIixcbiAgICAgICAgdmVydGFkdnk6IFwidmVydEFkdllcIixcbiAgICAgICAgXCJ2ZXJ0LWFkdi15XCI6IFwidmVydEFkdllcIixcbiAgICAgICAgdmVydG9yaWdpbng6IFwidmVydE9yaWdpblhcIixcbiAgICAgICAgXCJ2ZXJ0LW9yaWdpbi14XCI6IFwidmVydE9yaWdpblhcIixcbiAgICAgICAgdmVydG9yaWdpbnk6IFwidmVydE9yaWdpbllcIixcbiAgICAgICAgXCJ2ZXJ0LW9yaWdpbi15XCI6IFwidmVydE9yaWdpbllcIixcbiAgICAgICAgdmhhbmdpbmc6IFwidkhhbmdpbmdcIixcbiAgICAgICAgXCJ2LWhhbmdpbmdcIjogXCJ2SGFuZ2luZ1wiLFxuICAgICAgICB2aWRlb2dyYXBoaWM6IFwidklkZW9ncmFwaGljXCIsXG4gICAgICAgIFwidi1pZGVvZ3JhcGhpY1wiOiBcInZJZGVvZ3JhcGhpY1wiLFxuICAgICAgICB2aWV3Ym94OiBcInZpZXdCb3hcIixcbiAgICAgICAgdmlld3RhcmdldDogXCJ2aWV3VGFyZ2V0XCIsXG4gICAgICAgIHZpc2liaWxpdHk6IFwidmlzaWJpbGl0eVwiLFxuICAgICAgICB2bWF0aGVtYXRpY2FsOiBcInZNYXRoZW1hdGljYWxcIixcbiAgICAgICAgXCJ2LW1hdGhlbWF0aWNhbFwiOiBcInZNYXRoZW1hdGljYWxcIixcbiAgICAgICAgdm9jYWI6IFwidm9jYWJcIixcbiAgICAgICAgd2lkdGhzOiBcIndpZHRoc1wiLFxuICAgICAgICB3b3Jkc3BhY2luZzogXCJ3b3JkU3BhY2luZ1wiLFxuICAgICAgICBcIndvcmQtc3BhY2luZ1wiOiBcIndvcmRTcGFjaW5nXCIsXG4gICAgICAgIHdyaXRpbmdtb2RlOiBcIndyaXRpbmdNb2RlXCIsXG4gICAgICAgIFwid3JpdGluZy1tb2RlXCI6IFwid3JpdGluZ01vZGVcIixcbiAgICAgICAgeDE6IFwieDFcIixcbiAgICAgICAgeDI6IFwieDJcIixcbiAgICAgICAgeDogXCJ4XCIsXG4gICAgICAgIHhjaGFubmVsc2VsZWN0b3I6IFwieENoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICB4aGVpZ2h0OiBcInhIZWlnaHRcIixcbiAgICAgICAgXCJ4LWhlaWdodFwiOiBcInhIZWlnaHRcIixcbiAgICAgICAgeGxpbmthY3R1YXRlOiBcInhsaW5rQWN0dWF0ZVwiLFxuICAgICAgICBcInhsaW5rOmFjdHVhdGVcIjogXCJ4bGlua0FjdHVhdGVcIixcbiAgICAgICAgeGxpbmthcmNyb2xlOiBcInhsaW5rQXJjcm9sZVwiLFxuICAgICAgICBcInhsaW5rOmFyY3JvbGVcIjogXCJ4bGlua0FyY3JvbGVcIixcbiAgICAgICAgeGxpbmtocmVmOiBcInhsaW5rSHJlZlwiLFxuICAgICAgICBcInhsaW5rOmhyZWZcIjogXCJ4bGlua0hyZWZcIixcbiAgICAgICAgeGxpbmtyb2xlOiBcInhsaW5rUm9sZVwiLFxuICAgICAgICBcInhsaW5rOnJvbGVcIjogXCJ4bGlua1JvbGVcIixcbiAgICAgICAgeGxpbmtzaG93OiBcInhsaW5rU2hvd1wiLFxuICAgICAgICBcInhsaW5rOnNob3dcIjogXCJ4bGlua1Nob3dcIixcbiAgICAgICAgeGxpbmt0aXRsZTogXCJ4bGlua1RpdGxlXCIsXG4gICAgICAgIFwieGxpbms6dGl0bGVcIjogXCJ4bGlua1RpdGxlXCIsXG4gICAgICAgIHhsaW5rdHlwZTogXCJ4bGlua1R5cGVcIixcbiAgICAgICAgXCJ4bGluazp0eXBlXCI6IFwieGxpbmtUeXBlXCIsXG4gICAgICAgIHhtbGJhc2U6IFwieG1sQmFzZVwiLFxuICAgICAgICBcInhtbDpiYXNlXCI6IFwieG1sQmFzZVwiLFxuICAgICAgICB4bWxsYW5nOiBcInhtbExhbmdcIixcbiAgICAgICAgXCJ4bWw6bGFuZ1wiOiBcInhtbExhbmdcIixcbiAgICAgICAgeG1sbnM6IFwieG1sbnNcIixcbiAgICAgICAgXCJ4bWw6c3BhY2VcIjogXCJ4bWxTcGFjZVwiLFxuICAgICAgICB4bWxuc3hsaW5rOiBcInhtbG5zWGxpbmtcIixcbiAgICAgICAgXCJ4bWxuczp4bGlua1wiOiBcInhtbG5zWGxpbmtcIixcbiAgICAgICAgeG1sc3BhY2U6IFwieG1sU3BhY2VcIixcbiAgICAgICAgeTE6IFwieTFcIixcbiAgICAgICAgeTI6IFwieTJcIixcbiAgICAgICAgeTogXCJ5XCIsXG4gICAgICAgIHljaGFubmVsc2VsZWN0b3I6IFwieUNoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICB6OiBcInpcIixcbiAgICAgICAgem9vbWFuZHBhbjogXCJ6b29tQW5kUGFuXCJcbiAgICAgIH0sXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzID0ge30sXG4gICAgICBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vLFxuICAgICAgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS8sXG4gICAgICByQVJJQSA9IFJlZ0V4cChcbiAgICAgICAgXCJeKGFyaWEpLVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIHJBUklBQ2FtZWwgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKVtBLVpdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vLFxuICAgICAgbXNQYXR0ZXJuJDEgPSAvXi1tcy0vLFxuICAgICAgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2csXG4gICAgICBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLyxcbiAgICAgIHdhcm5lZFN0eWxlTmFtZXMgPSB7fSxcbiAgICAgIHdhcm5lZFN0eWxlVmFsdWVzID0ge30sXG4gICAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9ICExLFxuICAgICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9ICExLFxuICAgICAgbWF0Y2hIdG1sUmVnRXhwID0gL1tcIicmPD5dLyxcbiAgICAgIHVwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nLFxuICAgICAgbXNQYXR0ZXJuID0gL15tcy0vLFxuICAgICAgaXNKYXZhU2NyaXB0UHJvdG9jb2wgPVxuICAgICAgICAvXltcXHUwMDAwLVxcdTAwMUYgXSpqW1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnZbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qc1tcXHJcXG5cXHRdKmNbXFxyXFxuXFx0XSpyW1xcclxcblxcdF0qaVtcXHJcXG5cXHRdKnBbXFxyXFxuXFx0XSp0W1xcclxcblxcdF0qOi9pLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBSZWFjdERPTVNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0RE9NLl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIE5vdFBlbmRpbmcgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcGVuZGluZzogITEsXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIG1ldGhvZDogbnVsbCxcbiAgICAgICAgYWN0aW9uOiBudWxsXG4gICAgICB9KSxcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLmQ7XG4gICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZCA9IHtcbiAgICAgIGY6IHByZXZpb3VzRGlzcGF0Y2hlci5mLFxuICAgICAgcjogcHJldmlvdXNEaXNwYXRjaGVyLnIsXG4gICAgICBEOiBmdW5jdGlvbiAoaHJlZikge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikge1xuICAgICAgICAgICAgaWYgKCFyZXN1bWFibGVTdGF0ZS5kbnNSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpIHtcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuZG5zUmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTO1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICAgICAgICAgIHZhciBoZWFkZXIsIEpTQ29tcGlsZXJfdGVtcDtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgJiYgMCA8IHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgICgoaGVhZGVyID1cbiAgICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZikgK1xuICAgICAgICAgICAgICAgICAgICBcIj47IHJlbD1kbnMtcHJlZmV0Y2hcIiksXG4gICAgICAgICAgICAgICAgICAwIDw9IChyZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXBcbiAgICAgICAgICAgICAgICA/ICgocmVuZGVyU3RhdGUucmVzZXRzLmRuc1tocmVmXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyAmJlxuICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyArPSBoZWFkZXIpKVxuICAgICAgICAgICAgICAgIDogKChoZWFkZXIgPSBbXSksXG4gICAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwoaGVhZGVyLCB7IGhyZWY6IGhyZWYsIHJlbDogXCJkbnMtcHJlZmV0Y2hcIiB9KSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmFkZChoZWFkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuRChocmVmKTtcbiAgICAgIH0sXG4gICAgICBDOiBmdW5jdGlvbiAoaHJlZiwgY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWYpIHtcbiAgICAgICAgICAgIHZhciBidWNrZXQgPVxuICAgICAgICAgICAgICBcInVzZS1jcmVkZW50aWFsc1wiID09PSBjcm9zc09yaWdpblxuICAgICAgICAgICAgICAgID8gXCJjcmVkZW50aWFsc1wiXG4gICAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgID8gXCJhbm9ueW1vdXNcIlxuICAgICAgICAgICAgICAgICAgOiBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgIGlmICghcmVzdW1hYmxlU3RhdGUuY29ubmVjdFJlc291cmNlc1tidWNrZXRdLmhhc093blByb3BlcnR5KGhyZWYpKSB7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmNvbm5lY3RSZXNvdXJjZXNbYnVja2V0XVtocmVmXSA9IEVYSVNUUztcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgICAgICB2YXIgaGVhZGVyLCBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlICYmIDAgPCByZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSlcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgICAgICAgIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmKSArXG4gICAgICAgICAgICAgICAgICBcIj47IHJlbD1wcmVjb25uZWN0XCI7XG4gICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjcm9zc09yaWdpbikge1xuICAgICAgICAgICAgICAgICAgdmFyIGVzY2FwZWRDcm9zc09yaWdpbiA9XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dChcbiAgICAgICAgICAgICAgICAgICAgICBjcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICBcImNyb3NzT3JpZ2luXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCArPVxuICAgICAgICAgICAgICAgICAgICAnOyBjcm9zc29yaWdpbj1cIicgKyBlc2NhcGVkQ3Jvc3NPcmlnaW4gKyAnXCInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgKChoZWFkZXIgPSBKU0NvbXBpbGVyX3RlbXApLFxuICAgICAgICAgICAgICAgICAgMCA8PSAocmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCArIDIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXBcbiAgICAgICAgICAgICAgICA/ICgocmVuZGVyU3RhdGUucmVzZXRzLmNvbm5lY3RbYnVja2V0XVtocmVmXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyAmJlxuICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyArPSBoZWFkZXIpKVxuICAgICAgICAgICAgICAgIDogKChidWNrZXQgPSBbXSksXG4gICAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwoYnVja2V0LCB7XG4gICAgICAgICAgICAgICAgICAgIHJlbDogXCJwcmVjb25uZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5hZGQoYnVja2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLkMoaHJlZiwgY3Jvc3NPcmlnaW4pO1xuICAgICAgfSxcbiAgICAgIEw6IGZ1bmN0aW9uIChocmVmLCBhcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoYXMgJiYgaHJlZikge1xuICAgICAgICAgICAgc3dpdGNoIChhcykge1xuICAgICAgICAgICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgdmFyIGltYWdlU3JjU2V0ID0gb3B0aW9ucy5pbWFnZVNyY1NldDtcbiAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVNpemVzID0gb3B0aW9ucy5pbWFnZVNpemVzO1xuICAgICAgICAgICAgICAgICAgdmFyIGZldGNoUHJpb3JpdHkgPSBvcHRpb25zLmZldGNoUHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBpbWFnZVNyY1NldFxuICAgICAgICAgICAgICAgICAgPyBpbWFnZVNyY1NldCArIFwiXFxuXCIgKyAoaW1hZ2VTaXplcyB8fCBcIlwiKVxuICAgICAgICAgICAgICAgICAgOiBocmVmO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXNba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAwIDwgcmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgJiZcbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgaW1hZ2VTcmNTZXQgJiZcbiAgICAgICAgICAgICAgICBcImhpZ2hcIiA9PT0gZmV0Y2hQcmlvcml0eSAmJlxuICAgICAgICAgICAgICAgICgoaGVhZGVyID0gZ2V0UHJlbG9hZEFzSGVhZGVyKGhyZWYsIGFzLCBvcHRpb25zKSksXG4gICAgICAgICAgICAgICAgMCA8PSAocmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCArIDIpKVxuICAgICAgICAgICAgICAgICAgPyAoKHJlbmRlclN0YXRlLnJlc2V0cy5pbWFnZVtrZXldID0gUFJFTE9BRF9OT19DUkVEUyksXG4gICAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5oaWdoSW1hZ2VQcmVsb2FkcyArPSBoZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgOiAoKHJlc3VtYWJsZVN0YXRlID0gW10pLFxuICAgICAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwoXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiBpbWFnZVNyY1NldCA/IHZvaWQgMCA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFzOiBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFwiaGlnaFwiID09PSBmZXRjaFByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgICAgPyByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5hZGQocmVzdW1hYmxlU3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgOiAocmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChyZXN1bWFibGVTdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5pbWFnZXMuc2V0KGtleSwgcmVzdW1hYmxlU3RhdGUpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0ID0gW107XG4gICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQsXG4gICAgICAgICAgICAgICAgICBhc3NpZ24oeyByZWw6IFwicHJlbG9hZFwiLCBocmVmOiBocmVmLCBhczogYXMgfSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdID1cbiAgICAgICAgICAgICAgICAgICFvcHRpb25zIHx8XG4gICAgICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5KVxuICAgICAgICAgICAgICAgICAgICA/IFBSRUxPQURfTk9fQ1JFRFNcbiAgICAgICAgICAgICAgICAgICAgOiBbb3B0aW9ucy5jcm9zc09yaWdpbiwgb3B0aW9ucy5pbnRlZ3JpdHldO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLnN0eWxlc2hlZXRzLnNldChocmVmLCBpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQgPSBbXTtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zY3JpcHRzLnNldChocmVmLCBpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQsXG4gICAgICAgICAgICAgICAgICBhc3NpZ24oeyByZWw6IFwicHJlbG9hZFwiLCBocmVmOiBocmVmLCBhczogYXMgfSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1tocmVmXSA9XG4gICAgICAgICAgICAgICAgICAhb3B0aW9ucyB8fFxuICAgICAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSlcbiAgICAgICAgICAgICAgICAgICAgPyBQUkVMT0FEX05PX0NSRURTXG4gICAgICAgICAgICAgICAgICAgIDogW29wdGlvbnMuY3Jvc3NPcmlnaW4sIG9wdGlvbnMuaW50ZWdyaXR5XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUudW5rbm93blJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShhcykpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKChpbWFnZVNyY1NldCA9IHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXNbYXNdKSxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQuaGFzT3duUHJvcGVydHkoaHJlZikpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIChpbWFnZVNyY1NldCA9IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXNbYXNdID0gaW1hZ2VTcmNTZXQpO1xuICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0W2hyZWZdID0gUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUgPSByZW5kZXJTdGF0ZS5oZWFkZXJzKSAmJlxuICAgICAgICAgICAgICAgICAgMCA8IHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5ICYmXG4gICAgICAgICAgICAgICAgICBcImZvbnRcIiA9PT0gYXMgJiZcbiAgICAgICAgICAgICAgICAgICgoa2V5ID0gZ2V0UHJlbG9hZEFzSGVhZGVyKGhyZWYsIGFzLCBvcHRpb25zKSksXG4gICAgICAgICAgICAgICAgICAwIDw9IChyZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAtPSBrZXkubGVuZ3RoICsgMikpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKHJlbmRlclN0YXRlLnJlc2V0cy5mb250W2hyZWZdID0gUFJFTE9BRF9OT19DUkVEUyksXG4gICAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmZvbnRQcmVsb2FkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5mb250UHJlbG9hZHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmZvbnRQcmVsb2FkcyArPSBrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgICAgICAgICAgICgocmVzdW1hYmxlU3RhdGUgPSBbXSksXG4gICAgICAgICAgICAgICAgICAgIChocmVmID0gYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICAgIHsgcmVsOiBcInByZWxvYWRcIiwgaHJlZjogaHJlZiwgYXM6IGFzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKHJlc3VtYWJsZVN0YXRlLCBocmVmKSxcbiAgICAgICAgICAgICAgICAgICAgYXMpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZvbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuYWRkKHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuTChocmVmLCBhcywgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgIHZhciBhcyA9XG4gICAgICAgICAgICAgIG9wdGlvbnMgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMgPyBvcHRpb25zLmFzIDogXCJzY3JpcHRcIjtcbiAgICAgICAgICAgIHN3aXRjaCAoYXMpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgYXMgPSBbXTtcbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXNbaHJlZl0gPVxuICAgICAgICAgICAgICAgICAgIW9wdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5jcm9zc09yaWdpbiAmJlxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkpXG4gICAgICAgICAgICAgICAgICAgID8gUFJFTE9BRF9OT19DUkVEU1xuICAgICAgICAgICAgICAgICAgICA6IFtvcHRpb25zLmNyb3NzT3JpZ2luLCBvcHRpb25zLmludGVncml0eV07XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMubW9kdWxlU2NyaXB0cy5zZXQoaHJlZiwgYXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5tb2R1bGVVbmtub3duUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGFzKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc291cmNlcyA9IHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXNbYXNdO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgKHJlc291cmNlcyA9IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLm1vZHVsZVVua25vd25SZXNvdXJjZXNbYXNdID0gcmVzb3VyY2VzKTtcbiAgICAgICAgICAgICAgICBhcyA9IFtdO1xuICAgICAgICAgICAgICAgIHJlc291cmNlc1tocmVmXSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwdXNoTGlua0ltcGwoXG4gICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICBhc3NpZ24oeyByZWw6IFwibW9kdWxlcHJlbG9hZFwiLCBocmVmOiBocmVmIH0sIG9wdGlvbnMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChhcyk7XG4gICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLm0oaHJlZiwgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgWDogZnVuY3Rpb24gKHNyYywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2VTdGF0ZSA9IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgc3JjXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgID8gcmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzW3NyY11cbiAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXNvdXJjZVN0YXRlICE9PSBFWElTVFMgJiZcbiAgICAgICAgICAgICAgKChyZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNbc3JjXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgIChvcHRpb25zID0gYXNzaWduKHsgc3JjOiBzcmMsIGFzeW5jOiAhMCB9LCBvcHRpb25zKSksXG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAoMiA9PT0gcmVzb3VyY2VTdGF0ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKG9wdGlvbnMsIHJlc291cmNlU3RhdGUpLFxuICAgICAgICAgICAgICAgIChzcmMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zY3JpcHRzLmdldChzcmMpKSkgJiZcbiAgICAgICAgICAgICAgICAoc3JjLmxlbmd0aCA9IDApLFxuICAgICAgICAgICAgICAoc3JjID0gW10pLFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmFkZChzcmMpLFxuICAgICAgICAgICAgICBwdXNoU2NyaXB0SW1wbChzcmMsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5YKHNyYywgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgUzogZnVuY3Rpb24gKGhyZWYsIHByZWNlZGVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgIHByZWNlZGVuY2UgPSBwcmVjZWRlbmNlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgdmFyIHN0eWxlUXVldWUgPSByZW5kZXJTdGF0ZS5zdHlsZXMuZ2V0KHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlID0gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZilcbiAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXNvdXJjZVN0YXRlICE9PSBFWElTVFMgJiZcbiAgICAgICAgICAgICAgKChyZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tocmVmXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgIHN0eWxlUXVldWUgfHxcbiAgICAgICAgICAgICAgICAoKHN0eWxlUXVldWUgPSB7XG4gICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSxcbiAgICAgICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgIGhyZWZzOiBbXSxcbiAgICAgICAgICAgICAgICAgIHNoZWV0czogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc3R5bGVzLnNldChwcmVjZWRlbmNlLCBzdHlsZVF1ZXVlKSksXG4gICAgICAgICAgICAgIChwcmVjZWRlbmNlID0ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiBQRU5ESU5HJDEsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGFzc2lnbihcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsOiBcInN0eWxlc2hlZXRcIixcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgKDIgPT09IHJlc291cmNlU3RhdGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhwcmVjZWRlbmNlLnByb3BzLCByZXNvdXJjZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAocmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zdHlsZXNoZWV0cy5nZXQoaHJlZikpICYmXG4gICAgICAgICAgICAgICAgMCA8IHJlbmRlclN0YXRlLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyAocmVuZGVyU3RhdGUubGVuZ3RoID0gMClcbiAgICAgICAgICAgICAgICAgIDogKHByZWNlZGVuY2Uuc3RhdGUgPSBQUkVMT0FERUQpKSxcbiAgICAgICAgICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuc2V0KGhyZWYsIHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5TKGhyZWYsIHByZWNlZGVuY2UsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIE06IGZ1bmN0aW9uIChzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgdmFyIHJlc291cmNlU3RhdGUgPVxuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoc3JjKVxuICAgICAgICAgICAgICAgID8gcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW3NyY11cbiAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJlc291cmNlU3RhdGUgIT09IEVYSVNUUyAmJlxuICAgICAgICAgICAgICAoKHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlc1tzcmNdID0gRVhJU1RTKSxcbiAgICAgICAgICAgICAgKG9wdGlvbnMgPSBhc3NpZ24oXG4gICAgICAgICAgICAgICAgeyBzcmM6IHNyYywgdHlwZTogXCJtb2R1bGVcIiwgYXN5bmM6ICEwIH0sXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICgyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMob3B0aW9ucywgcmVzb3VyY2VTdGF0ZSksXG4gICAgICAgICAgICAgICAgKHNyYyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHMuZ2V0KHNyYykpKSAmJlxuICAgICAgICAgICAgICAgIChzcmMubGVuZ3RoID0gMCksXG4gICAgICAgICAgICAgIChzcmMgPSBbXSksXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHNyYyksXG4gICAgICAgICAgICAgIHB1c2hTY3JpcHRJbXBsKHNyYywgb3B0aW9ucyksXG4gICAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLk0oc3JjLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBOb3RoaW5nU2VudCA9IDAsXG4gICAgICBTZW50Q29tcGxldGVTZWdtZW50RnVuY3Rpb24gPSAxLFxuICAgICAgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbiA9IDIsXG4gICAgICBTZW50Q2xpZW50UmVuZGVyRnVuY3Rpb24gPSA0LFxuICAgICAgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24gPSA4LFxuICAgICAgRVhJU1RTID0gbnVsbCxcbiAgICAgIFBSRUxPQURfTk9fQ1JFRFMgPSBbXTtcbiAgICBPYmplY3QuZnJlZXplKFBSRUxPQURfTk9fQ1JFRFMpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+PC90ZW1wbGF0ZT4nKTtcbiAgICB2YXIgc3RhcnRJbmxpbmVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8c2NyaXB0PlwiKSxcbiAgICAgIGVuZElubGluZVNjcmlwdCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjL3NjcmlwdD5cIiksXG4gICAgICBzdGFydFNjcmlwdFNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCBzcmM9XCInKSxcbiAgICAgIHN0YXJ0TW9kdWxlU3JjID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c2NyaXB0IHR5cGU9XCJtb2R1bGVcIiBzcmM9XCInKSxcbiAgICAgIHNjcmlwdE5vbmNlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBub25jZT1cIicpLFxuICAgICAgc2NyaXB0SW50ZWdpcnR5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBpbnRlZ3JpdHk9XCInKSxcbiAgICAgIHNjcmlwdENyb3NzT3JpZ2luID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBjcm9zc29yaWdpbj1cIicpLFxuICAgICAgZW5kQXN5bmNTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGFzeW5jPVwiXCI+XFx4M2Mvc2NyaXB0PicpLFxuICAgICAgc2NyaXB0UmVnZXggPSAvKDxcXC98PCkocykoY3JpcHQpL2dpLFxuICAgICAgaW1wb3J0TWFwU2NyaXB0U3RhcnQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICc8c2NyaXB0IHR5cGU9XCJpbXBvcnRtYXBcIj4nXG4gICAgICApLFxuICAgICAgaW1wb3J0TWFwU2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiXFx4M2Mvc2NyaXB0PlwiKTtcbiAgICB2YXIgZGlkV2FybkZvck5ld0Jvb2xlYW5Qcm9wc1dpdGhFbXB0eVZhbHVlID0ge307XG4gICAgdmFyIE5vQ29udHJpYnV0aW9uID0gMCxcbiAgICAgIFJPT1RfSFRNTF9NT0RFID0gMCxcbiAgICAgIEhUTUxfSFRNTF9NT0RFID0gMSxcbiAgICAgIEhUTUxfTU9ERSA9IDIsXG4gICAgICBIVE1MX0hFQURfTU9ERSA9IDMsXG4gICAgICBTVkdfTU9ERSA9IDQsXG4gICAgICBNQVRITUxfTU9ERSA9IDUsXG4gICAgICBIVE1MX1RBQkxFX01PREUgPSA2LFxuICAgICAgSFRNTF9UQUJMRV9CT0RZX01PREUgPSA3LFxuICAgICAgSFRNTF9UQUJMRV9ST1dfTU9ERSA9IDgsXG4gICAgICBIVE1MX0NPTEdST1VQX01PREUgPSA5LFxuICAgICAgdGV4dFNlcGFyYXRvciA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tIC0tXFx4M2VcIiksXG4gICAgICBzdHlsZU5hbWVDYWNoZSA9IG5ldyBNYXAoKSxcbiAgICAgIHN0eWxlQXR0cmlidXRlU3RhcnQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBzdHlsZT1cIicpLFxuICAgICAgc3R5bGVBc3NpZ24gPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI6XCIpLFxuICAgICAgc3R5bGVTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI7XCIpLFxuICAgICAgYXR0cmlidXRlU2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiIFwiKSxcbiAgICAgIGF0dHJpYnV0ZUFzc2lnbiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPVwiJyksXG4gICAgICBhdHRyaWJ1dGVFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyksXG4gICAgICBhdHRyaWJ1dGVFbXB0eVN0cmluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPVwiXCInKSxcbiAgICAgIGFjdGlvbkphdmFTY3JpcHRVUkwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKFxuICAgICAgICAgIFwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IGZvcm0gdW5leHBlY3RlZGx5IHN1Ym1pdHRlZC4nKVwiXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBzdGFydEhpZGRlbklucHV0Q2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCInKSxcbiAgICAgIGVuZE9mU3RhcnRUYWcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI+XCIpLFxuICAgICAgZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiLz5cIiksXG4gICAgICBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSAhMSxcbiAgICAgIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9ICExLFxuICAgICAgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9ICExLFxuICAgICAgZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlID0gITEsXG4gICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gITEsXG4gICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9ICExLFxuICAgICAgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9ICExLFxuICAgICAgZGlkV2FybkZvcm1BY3Rpb25OYW1lID0gITEsXG4gICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCA9ICExLFxuICAgICAgZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgPSAhMSxcbiAgICAgIHNlbGVjdGVkTWFya2VyQXR0cmlidXRlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgc2VsZWN0ZWQ9XCJcIicpLFxuICAgICAgZm9ybVJlcGxheWluZ1J1bnRpbWVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICdhZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsZnVuY3Rpb24oYSl7aWYoIWEuZGVmYXVsdFByZXZlbnRlZCl7dmFyIGM9YS50YXJnZXQsZD1hLnN1Ym1pdHRlcixlPWMuYWN0aW9uLGI9ZDtpZihkKXt2YXIgZj1kLmdldEF0dHJpYnV0ZShcImZvcm1BY3Rpb25cIik7bnVsbCE9ZiYmKGU9ZixiPW51bGwpfVwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoXFwnUmVhY3QgZm9ybSB1bmV4cGVjdGVkbHkgc3VibWl0dGVkLlxcJylcIj09PWUmJihhLnByZXZlbnREZWZhdWx0KCksYj8oYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksYS5uYW1lPWIubmFtZSxhLnZhbHVlPWIudmFsdWUsYi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLGIpLGI9bmV3IEZvcm1EYXRhKGMpLGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSk6Yj1uZXcgRm9ybURhdGEoYyksYT1jLm93bmVyRG9jdW1lbnR8fGMsKGEuJCRyZWFjdEZvcm1SZXBsYXk9YS4kJHJlYWN0Rm9ybVJlcGxheXx8W10pLnB1c2goYyxkLGIpKX19KTsnXG4gICAgICApLFxuICAgICAgZm9ybVN0YXRlTWFya2VySXNNYXRjaGluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tRiEtLVxceDNlXCIpLFxuICAgICAgZm9ybVN0YXRlTWFya2VySXNOb3RNYXRjaGluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tRi0tXFx4M2VcIiksXG4gICAgICBzdHlsZVJlZ2V4ID0gLyg8XFwvfDwpKHMpKHR5bGUpL2dpLFxuICAgICAgbGVhZGluZ05ld2xpbmUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXG5cIiksXG4gICAgICBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLyxcbiAgICAgIHZhbGlkYXRlZFRhZ0NhY2hlID0gbmV3IE1hcCgpLFxuICAgICAgZG9jdHlwZUNodW5rID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPCFET0NUWVBFIGh0bWw+XCIpLFxuICAgICAgZW5kVGFnQ2FjaGUgPSBuZXcgTWFwKCksXG4gICAgICBwbGFjZWhvbGRlcjEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBpZD1cIicpLFxuICAgICAgcGxhY2Vob2xkZXIyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj48L3RlbXBsYXRlPicpLFxuICAgICAgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5ID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiXFx4M2MhLS0kLS1cXHgzZVwiKSxcbiAgICAgIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnXFx4M2MhLS0kPy0tXFx4M2U8dGVtcGxhdGUgaWQ9XCInXG4gICAgICApLFxuICAgICAgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPjwvdGVtcGxhdGU+JyksXG4gICAgICBzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSA9XG4gICAgICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tJCEtLVxceDNlXCIpLFxuICAgICAgZW5kU3VzcGVuc2VCb3VuZGFyeSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tLyQtLVxceDNlXCIpLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPHRlbXBsYXRlXCIpLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQSA9XG4gICAgICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtZGdzdD1cIicpLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiA9XG4gICAgICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtbXNnPVwiJyksXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFDID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1zdGNrPVwiJyksXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFEID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1jc3Rjaz1cIicpLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IyID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPjwvdGVtcGxhdGU+XCIpLFxuICAgICAgYm91bmRhcnlQcmVhbWJsZUNvbnRyaWJ1dGlvbkNodW5rU3RhcnQgPVxuICAgICAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXHgzYyEtLVwiKSxcbiAgICAgIGJvdW5kYXJ5UHJlYW1ibGVDb250cmlidXRpb25DaHVua0VuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIi0tXFx4M2VcIiksXG4gICAgICBzdGFydFNlZ21lbnRIVE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8ZGl2IGhpZGRlbiBpZD1cIicpLFxuICAgICAgc3RhcnRTZWdtZW50SFRNTDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpLFxuICAgICAgZW5kU2VnbWVudEhUTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L2Rpdj5cIiksXG4gICAgICBzdGFydFNlZ21lbnRTVkcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICc8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHN0eWxlPVwiZGlzcGxheTpub25lXCIgaWQ9XCInXG4gICAgICApLFxuICAgICAgc3RhcnRTZWdtZW50U1ZHMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBlbmRTZWdtZW50U1ZHID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPC9zdmc+XCIpLFxuICAgICAgc3RhcnRTZWdtZW50TWF0aE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnPG1hdGggYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIidcbiAgICAgICksXG4gICAgICBzdGFydFNlZ21lbnRNYXRoTUwyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKSxcbiAgICAgIGVuZFNlZ21lbnRNYXRoTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L21hdGg+XCIpLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0YWJsZSBoaWRkZW4gaWQ9XCInKSxcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBlbmRTZWdtZW50VGFibGUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L3RhYmxlPlwiKSxcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlQm9keSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgJzx0YWJsZSBoaWRkZW4+PHRib2R5IGlkPVwiJ1xuICAgICAgKSxcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlQm9keTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpLFxuICAgICAgZW5kU2VnbWVudFRhYmxlQm9keSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIjwvdGJvZHk+PC90YWJsZT5cIiksXG4gICAgICBzdGFydFNlZ21lbnRUYWJsZVJvdyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48dHIgaWQ9XCInKSxcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlUm93MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBlbmRTZWdtZW50VGFibGVSb3cgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L3RyPjwvdGFibGU+XCIpLFxuICAgICAgc3RhcnRTZWdtZW50Q29sR3JvdXAgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICc8dGFibGUgaGlkZGVuPjxjb2xncm91cCBpZD1cIidcbiAgICAgICksXG4gICAgICBzdGFydFNlZ21lbnRDb2xHcm91cDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpLFxuICAgICAgZW5kU2VnbWVudENvbEdyb3VwID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPC9jb2xncm91cD48L3RhYmxlPlwiKSxcbiAgICAgIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnJFJTPWZ1bmN0aW9uKGEsYil7YT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKTtiPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2ZvcihhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSk7YS5maXJzdENoaWxkOyliLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEuZmlyc3RDaGlsZCxiKTtiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYil9OyRSUyhcIidcbiAgICAgICksXG4gICAgICBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJTKFwiJyksXG4gICAgICBjb21wbGV0ZVNlZ21lbnRTY3JpcHQyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIixcIicpLFxuICAgICAgY29tcGxldGVTZWdtZW50U2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIilcXHgzYy9zY3JpcHQ+Jyk7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1yc2k9XCJcIiBkYXRhLXNpZD1cIicpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1waWQ9XCInKTtcbiAgICB2YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnJFJDPWZ1bmN0aW9uKGIsYyxlKXtjPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGMpO2MucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTtpZihhKXtiPWEucHJldmlvdXNTaWJsaW5nO2lmKGUpYi5kYXRhPVwiJCFcIixhLnNldEF0dHJpYnV0ZShcImRhdGEtZGdzdFwiLGUpO2Vsc2V7ZT1iLnBhcmVudE5vZGU7YT1iLm5leHRTaWJsaW5nO3ZhciBmPTA7ZG97aWYoYSYmOD09PWEubm9kZVR5cGUpe3ZhciBkPWEuZGF0YTtpZihcIi8kXCI9PT1kKWlmKDA9PT1mKWJyZWFrO2Vsc2UgZi0tO2Vsc2VcIiRcIiE9PWQmJlwiJD9cIiE9PWQmJlwiJCFcIiE9PWR8fGYrK31kPWEubmV4dFNpYmxpbmc7ZS5yZW1vdmVDaGlsZChhKTthPWR9d2hpbGUoYSk7Zm9yKDtjLmZpcnN0Q2hpbGQ7KWUuaW5zZXJ0QmVmb3JlKGMuZmlyc3RDaGlsZCxhKTtiLmRhdGE9XCIkXCJ9Yi5fcmVhY3RSZXRyeSYmYi5fcmVhY3RSZXRyeSgpfX07JFJDKFwiJ1xuICAgICAgKSxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJDKFwiJyksXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsQm90aCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgJyRSQz1mdW5jdGlvbihiLGMsZSl7Yz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChjKTtjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyk7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7aWYoYSl7Yj1hLnByZXZpb3VzU2libGluZztpZihlKWIuZGF0YT1cIiQhXCIsYS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWRnc3RcIixlKTtlbHNle2U9Yi5wYXJlbnROb2RlO2E9Yi5uZXh0U2libGluZzt2YXIgZj0wO2Rve2lmKGEmJjg9PT1hLm5vZGVUeXBlKXt2YXIgZD1hLmRhdGE7aWYoXCIvJFwiPT09ZClpZigwPT09ZilicmVhaztlbHNlIGYtLTtlbHNlXCIkXCIhPT1kJiZcIiQ/XCIhPT1kJiZcIiQhXCIhPT1kfHxmKyt9ZD1hLm5leHRTaWJsaW5nO2UucmVtb3ZlQ2hpbGQoYSk7YT1kfXdoaWxlKGEpO2Zvcig7Yy5maXJzdENoaWxkOyllLmluc2VydEJlZm9yZShjLmZpcnN0Q2hpbGQsYSk7Yi5kYXRhPVwiJFwifWIuX3JlYWN0UmV0cnkmJmIuX3JlYWN0UmV0cnkoKX19OyRSTT1uZXcgTWFwO1xcbiRSUj1mdW5jdGlvbih0LHUseSl7ZnVuY3Rpb24gdihuKXt0aGlzLl9wPW51bGw7bigpfWZvcih2YXIgdz0kUkMscD0kUk0scT1uZXcgTWFwLHI9ZG9jdW1lbnQsZyxiLGg9ci5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tkYXRhLXByZWNlZGVuY2VdLHN0eWxlW2RhdGEtcHJlY2VkZW5jZV1cIikseD1bXSxrPTA7Yj1oW2srK107KVwibm90IGFsbFwiPT09Yi5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKT94LnB1c2goYik6KFwiTElOS1wiPT09Yi50YWdOYW1lJiZwLnNldChiLmdldEF0dHJpYnV0ZShcImhyZWZcIiksYikscS5zZXQoYi5kYXRhc2V0LnByZWNlZGVuY2UsZz1iKSk7Yj0wO2g9W107dmFyIGwsYTtmb3Ioaz0hMDs7KXtpZihrKXt2YXIgZT15W2IrK107aWYoIWUpe2s9ITE7Yj0wO2NvbnRpbnVlfXZhciBjPSExLG09MDt2YXIgZD1lW20rK107aWYoYT1wLmdldChkKSl7dmFyIGY9YS5fcDtjPSEwfWVsc2V7YT1yLmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO2EuaHJlZj1cXG5kO2EucmVsPVwic3R5bGVzaGVldFwiO2ZvcihhLmRhdGFzZXQucHJlY2VkZW5jZT1sPWVbbSsrXTtmPWVbbSsrXTspYS5zZXRBdHRyaWJ1dGUoZixlW20rK10pO2Y9YS5fcD1uZXcgUHJvbWlzZShmdW5jdGlvbihuLHope2Eub25sb2FkPXYuYmluZChhLG4pO2Eub25lcnJvcj12LmJpbmQoYSx6KX0pO3Auc2V0KGQsYSl9ZD1hLmdldEF0dHJpYnV0ZShcIm1lZGlhXCIpOyFmfHxkJiYhbWF0Y2hNZWRpYShkKS5tYXRjaGVzfHxoLnB1c2goZik7aWYoYyljb250aW51ZX1lbHNle2E9eFtiKytdO2lmKCFhKWJyZWFrO2w9YS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXByZWNlZGVuY2VcIik7YS5yZW1vdmVBdHRyaWJ1dGUoXCJtZWRpYVwiKX1jPXEuZ2V0KGwpfHxnO2M9PT1nJiYoZz1hKTtxLnNldChsLGEpO2M/Yy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLGMubmV4dFNpYmxpbmcpOihjPXIuaGVhZCxjLmluc2VydEJlZm9yZShhLGMuZmlyc3RDaGlsZCkpfVByb21pc2UuYWxsKGgpLnRoZW4ody5iaW5kKG51bGwsXFxudCx1LFwiXCIpLHcuYmluZChudWxsLHQsdSxcIlJlc291cmNlIGZhaWxlZCB0byBsb2FkXCIpKX07JFJSKFwiJ1xuICAgICAgKSxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnJFJNPW5ldyBNYXA7XFxuJFJSPWZ1bmN0aW9uKHQsdSx5KXtmdW5jdGlvbiB2KG4pe3RoaXMuX3A9bnVsbDtuKCl9Zm9yKHZhciB3PSRSQyxwPSRSTSxxPW5ldyBNYXAscj1kb2N1bWVudCxnLGIsaD1yLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW2RhdGEtcHJlY2VkZW5jZV0sc3R5bGVbZGF0YS1wcmVjZWRlbmNlXVwiKSx4PVtdLGs9MDtiPWhbaysrXTspXCJub3QgYWxsXCI9PT1iLmdldEF0dHJpYnV0ZShcIm1lZGlhXCIpP3gucHVzaChiKTooXCJMSU5LXCI9PT1iLnRhZ05hbWUmJnAuc2V0KGIuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxiKSxxLnNldChiLmRhdGFzZXQucHJlY2VkZW5jZSxnPWIpKTtiPTA7aD1bXTt2YXIgbCxhO2ZvcihrPSEwOzspe2lmKGspe3ZhciBlPXlbYisrXTtpZighZSl7az0hMTtiPTA7Y29udGludWV9dmFyIGM9ITEsbT0wO3ZhciBkPWVbbSsrXTtpZihhPXAuZ2V0KGQpKXt2YXIgZj1hLl9wO2M9ITB9ZWxzZXthPXIuY3JlYXRlRWxlbWVudChcImxpbmtcIik7YS5ocmVmPVxcbmQ7YS5yZWw9XCJzdHlsZXNoZWV0XCI7Zm9yKGEuZGF0YXNldC5wcmVjZWRlbmNlPWw9ZVttKytdO2Y9ZVttKytdOylhLnNldEF0dHJpYnV0ZShmLGVbbSsrXSk7Zj1hLl9wPW5ldyBQcm9taXNlKGZ1bmN0aW9uKG4seil7YS5vbmxvYWQ9di5iaW5kKGEsbik7YS5vbmVycm9yPXYuYmluZChhLHopfSk7cC5zZXQoZCxhKX1kPWEuZ2V0QXR0cmlidXRlKFwibWVkaWFcIik7IWZ8fGQmJiFtYXRjaE1lZGlhKGQpLm1hdGNoZXN8fGgucHVzaChmKTtpZihjKWNvbnRpbnVlfWVsc2V7YT14W2IrK107aWYoIWEpYnJlYWs7bD1hLmdldEF0dHJpYnV0ZShcImRhdGEtcHJlY2VkZW5jZVwiKTthLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpfWM9cS5nZXQobCl8fGc7Yz09PWcmJihnPWEpO3Euc2V0KGwsYSk7Yz9jLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsYy5uZXh0U2libGluZyk6KGM9ci5oZWFkLGMuaW5zZXJ0QmVmb3JlKGEsYy5maXJzdENoaWxkKSl9UHJvbWlzZS5hbGwoaCkudGhlbih3LmJpbmQobnVsbCxcXG50LHUsXCJcIiksdy5iaW5kKG51bGwsdCx1LFwiUmVzb3VyY2UgZmFpbGVkIHRvIGxvYWRcIikpfTskUlIoXCInXG4gICAgICApLFxuICAgICAgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxUGFydGlhbCA9XG4gICAgICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJSKFwiJyksXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIsXCInKSxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIsJyksXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyksXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiKVxceDNjL3NjcmlwdD5cIik7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1yY2k9XCJcIiBkYXRhLWJpZD1cIicpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGRhdGEtcnJpPVwiXCIgZGF0YS1iaWQ9XCInKTtcbiAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtc2lkPVwiJyk7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLXN0eT1cIicpO1xuICAgIHZhciBjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgJyRSWD1mdW5jdGlvbihiLGMsZCxlLGYpe3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2EmJihiPWEucHJldmlvdXNTaWJsaW5nLGIuZGF0YT1cIiQhXCIsYT1hLmRhdGFzZXQsYyYmKGEuZGdzdD1jKSxkJiYoYS5tc2c9ZCksZSYmKGEuc3Rjaz1lKSxmJiYoYS5jc3Rjaz1mKSxiLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCkpfTs7JFJYKFwiJ1xuICAgICAgKSxcbiAgICAgIGNsaWVudFJlbmRlclNjcmlwdDFQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUlgoXCInKSxcbiAgICAgIGNsaWVudFJlbmRlclNjcmlwdDFBID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpLFxuICAgICAgY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCIsXCIpLFxuICAgICAgY2xpZW50UmVuZGVyU2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiKVxceDNjL3NjcmlwdD5cIik7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1yeGk9XCJcIiBkYXRhLWJpZD1cIicpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1kZ3N0PVwiJyk7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLW1zZz1cIicpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1zdGNrPVwiJyk7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLWNzdGNrPVwiJyk7XG4gICAgdmFyIHJlZ2V4Rm9ySlNTdHJpbmdzSW5JbnN0cnVjdGlvblNjcmlwdHMgPSAvWzxcXHUyMDI4XFx1MjAyOV0vZyxcbiAgICAgIHJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzID0gL1smPjxcXHUyMDI4XFx1MjAyOV0vZyxcbiAgICAgIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICc8c3R5bGUgbWVkaWE9XCJub3QgYWxsXCIgZGF0YS1wcmVjZWRlbmNlPVwiJ1xuICAgICAgKSxcbiAgICAgIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtaHJlZj1cIicpLFxuICAgICAgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBsYXRlU3R5bGVUYWdUZW1wbGF0ZUNsb3NlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPC9zdHlsZT5cIiksXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSAhMSxcbiAgICAgIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSAhMCxcbiAgICAgIHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlID0gW10sXG4gICAgICBzdHlsZVRhZ1Jlc291cmNlT3BlbjEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICc8c3R5bGUgZGF0YS1wcmVjZWRlbmNlPVwiJ1xuICAgICAgKSxcbiAgICAgIHN0eWxlVGFnUmVzb3VyY2VPcGVuMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1ocmVmPVwiJyksXG4gICAgICBzcGFjZVNlcGFyYXRvciA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIiBcIiksXG4gICAgICBzdHlsZVRhZ1Jlc291cmNlT3BlbjMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpLFxuICAgICAgc3R5bGVUYWdSZXNvdXJjZUNsb3NlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPC9zdHlsZT5cIiksXG4gICAgICBhcnJheUZpcnN0T3BlbkJyYWNrZXQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJbXCIpLFxuICAgICAgYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCIsW1wiKSxcbiAgICAgIGFycmF5SW50ZXJzdGl0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiLFwiKSxcbiAgICAgIGFycmF5Q2xvc2VCcmFja2V0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiXVwiKSxcbiAgICAgIFBFTkRJTkckMSA9IDAsXG4gICAgICBQUkVMT0FERUQgPSAxLFxuICAgICAgUFJFQU1CTEUgPSAyLFxuICAgICAgTEFURSA9IDMsXG4gICAgICByZWdleEZvckhyZWZJbkxpbmtIZWFkZXJVUkxDb250ZXh0ID0gL1s8Plxcclxcbl0vZyxcbiAgICAgIHJlZ2V4Rm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0ID0gL1tcIic7LFxcclxcbl0vZyxcbiAgICAgIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCxcbiAgICAgIHJlcXVlc3RTdG9yYWdlID0gbmV3IGFzeW5jX2hvb2tzLkFzeW5jTG9jYWxTdG9yYWdlKCksXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBlbXB0eUNvbnRleHRPYmplY3QgPSB7fTtcbiAgICBPYmplY3QuZnJlZXplKGVtcHR5Q29udGV4dE9iamVjdCk7XG4gICAgdmFyIHJlbmRlcmVyU2lnaWwgPSB7fTtcbiAgICB2YXIgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbnVsbCxcbiAgICAgIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnQgPSB7fSxcbiAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnQgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgICAgICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgaW50ZXJuYWxzID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICAgICAgbnVsbCA9PT0gaW50ZXJuYWxzLnF1ZXVlXG4gICAgICAgICAgICA/IHdhcm5Ob29wKGluc3QsIFwic2V0U3RhdGVcIilcbiAgICAgICAgICAgIDogKGludGVybmFscy5xdWV1ZS5wdXNoKHBheWxvYWQpLFxuICAgICAgICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIGluc3QucmVwbGFjZSA9ICEwO1xuICAgICAgICAgIGluc3QucXVldWUgPSBbcGF5bG9hZF07XG4gICAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgbnVsbCA9PT0gaW5zdC5fcmVhY3RJbnRlcm5hbHMucXVldWVcbiAgICAgICAgICAgID8gd2Fybk5vb3AoaW5zdCwgXCJmb3JjZVVwZGF0ZVwiKVxuICAgICAgICAgICAgOiB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbXB0eVRyZWVDb250ZXh0ID0geyBpZDogMSwgb3ZlcmZsb3c6IFwiXCIgfSxcbiAgICAgIGNsejMyID0gTWF0aC5jbHozMiA/IE1hdGguY2x6MzIgOiBjbHozMkZhbGxiYWNrLFxuICAgICAgbG9nID0gTWF0aC5sb2csXG4gICAgICBMTjIgPSBNYXRoLkxOMixcbiAgICAgIFN1c3BlbnNlRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIGB1c2VgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciByZXRocm93IGl0IGltbWVkaWF0ZWx5LCBvciBtb3ZlIHRoZSBgdXNlYCBjYWxsIG91dHNpZGUgb2YgdGhlIGB0cnkvY2F0Y2hgIGJsb2NrLiBDYXB0dXJpbmcgd2l0aG91dCByZXRocm93aW5nIHdpbGwgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yLlxcblxcblRvIGhhbmRsZSBhc3luYyBlcnJvcnMsIHdyYXAgeW91ciBjb21wb25lbnQgaW4gYW4gZXJyb3IgYm91bmRhcnksIG9yIGNhbGwgdGhlIHByb21pc2UncyBgLmNhdGNoYCBtZXRob2QgYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBgdXNlYC5cIlxuICAgICAgKSxcbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbCxcbiAgICAgIG9iamVjdElzID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogaXMsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBudWxsLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9IG51bGwsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0ID0gbnVsbCxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGggPSBudWxsLFxuICAgICAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbCxcbiAgICAgIGlzUmVSZW5kZXIgPSAhMSxcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMSxcbiAgICAgIGxvY2FsSWRDb3VudGVyID0gMCxcbiAgICAgIGFjdGlvblN0YXRlQ291bnRlciA9IDAsXG4gICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXggPSAtMSxcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMCxcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsLFxuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbCxcbiAgICAgIG51bWJlck9mUmVSZW5kZXJzID0gMCxcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExLFxuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYsXG4gICAgICBIb29rc0Rpc3BhdGNoZXIgPSB7XG4gICAgICAgIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgICAgICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHVzYWJsZSAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgdXNhYmxlKSB7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdXNhYmxlLnRoZW4pXG4gICAgICAgICAgICAgIHJldHVybiB1bndyYXBUaGVuYWJsZSh1c2FibGUpO1xuICAgICAgICAgICAgaWYgKHVzYWJsZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgICByZXR1cm4gcmVhZENvbnRleHQodXNhYmxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkFuIHVuc3VwcG9ydGVkIHR5cGUgd2FzIHBhc3NlZCB0byB1c2UoKTogXCIgKyBTdHJpbmcodXNhYmxlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlTWVtbzogdXNlTWVtbyxcbiAgICAgICAgdXNlUmVkdWNlcjogdXNlUmVkdWNlcixcbiAgICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgICAgIHZhciBwcmV2aW91c1JlZiA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHJldHVybiBudWxsID09PSBwcmV2aW91c1JlZlxuICAgICAgICAgICAgPyAoKGluaXRpYWxWYWx1ZSA9IHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH0pLFxuICAgICAgICAgICAgICBPYmplY3Quc2VhbChpbml0aWFsVmFsdWUpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsVmFsdWUpKVxuICAgICAgICAgICAgOiBwcmV2aW91c1JlZjtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgICByZXR1cm4gdXNlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlciwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBub29wJDEsXG4gICAgICAgIHVzZUxheW91dEVmZmVjdDogbm9vcCQxLFxuICAgICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgICAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICAgIH0sIGRlcHMpO1xuICAgICAgICB9LFxuICAgICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBub29wJDEsXG4gICAgICAgIHVzZUVmZmVjdDogbm9vcCQxLFxuICAgICAgICB1c2VEZWJ1Z1ZhbHVlOiBub29wJDEsXG4gICAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHJldHVybiB2b2lkIDAgIT09IGluaXRpYWxWYWx1ZSA/IGluaXRpYWxWYWx1ZSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHJldHVybiBbITEsIHVuc3VwcG9ydGVkU3RhcnRUcmFuc2l0aW9uXTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdHJlZUlkID0gY3VycmVudGx5UmVuZGVyaW5nVGFzay50cmVlQ29udGV4dDtcbiAgICAgICAgICB2YXIgb3ZlcmZsb3cgPSB0cmVlSWQub3ZlcmZsb3c7XG4gICAgICAgICAgdHJlZUlkID0gdHJlZUlkLmlkO1xuICAgICAgICAgIHRyZWVJZCA9XG4gICAgICAgICAgICAodHJlZUlkICYgfigxIDw8ICgzMiAtIGNsejMyKHRyZWVJZCkgLSAxKSkpLnRvU3RyaW5nKDMyKSArIG92ZXJmbG93O1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IGN1cnJlbnRSZXN1bWFibGVTdGF0ZTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcmVzdW1hYmxlU3RhdGUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBvdmVyZmxvdyA9IGxvY2FsSWRDb3VudGVyKys7XG4gICAgICAgICAgdHJlZUlkID0gXCJcXHUwMGFiXCIgKyByZXN1bWFibGVTdGF0ZS5pZFByZWZpeCArIFwiUlwiICsgdHJlZUlkO1xuICAgICAgICAgIDAgPCBvdmVyZmxvdyAmJiAodHJlZUlkICs9IFwiSFwiICsgb3ZlcmZsb3cudG9TdHJpbmcoMzIpKTtcbiAgICAgICAgICByZXR1cm4gdHJlZUlkICsgXCJcXHUwMGJiXCI7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiTWlzc2luZyBnZXRTZXJ2ZXJTbmFwc2hvdCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIHNlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuICAgICAgICB9LFxuICAgICAgICB1c2VPcHRpbWlzdGljOiBmdW5jdGlvbiAocGFzc3Rocm91Z2gpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIFtwYXNzdGhyb3VnaCwgdW5zdXBwb3J0ZWRTZXRPcHRpbWlzdGljU3RhdGVdO1xuICAgICAgICB9LFxuICAgICAgICB1c2VBY3Rpb25TdGF0ZTogdXNlQWN0aW9uU3RhdGUsXG4gICAgICAgIHVzZUZvcm1TdGF0ZTogdXNlQWN0aW9uU3RhdGUsXG4gICAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHJldHVybiBOb3RQZW5kaW5nO1xuICAgICAgICB9LFxuICAgICAgICB1c2VNZW1vQ2FjaGU6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgICAgZm9yICh2YXIgZGF0YSA9IEFycmF5KHNpemUpLCBpID0gMDsgaSA8IHNpemU7IGkrKylcbiAgICAgICAgICAgIGRhdGFbaV0gPSBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdW5zdXBwb3J0ZWRSZWZyZXNoO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3VycmVudFJlc3VtYWJsZVN0YXRlID0gbnVsbCxcbiAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSBudWxsLFxuICAgICAgRGVmYXVsdEFzeW5jRGlzcGF0Y2hlciA9IHtcbiAgICAgICAgZ2V0Q2FjaGVGb3JUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRPd25lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBudWxsID09PSBjdXJyZW50VGFza0luREVWXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjaztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgY2FsbENvbXBvbmVudCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICAgICAgICAgIHJldHVybiBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50SW5ERVYgPVxuICAgICAgICBjYWxsQ29tcG9uZW50W1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbENvbXBvbmVudCksXG4gICAgICBjYWxsUmVuZGVyID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsUmVuZGVySW5ERVYgPSBjYWxsUmVuZGVyW1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbFJlbmRlciksXG4gICAgICBjYWxsTGF6eUluaXQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChsYXp5KSB7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Ll9pbml0O1xuICAgICAgICAgIHJldHVybiBpbml0KGxhenkuX3BheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbExhenlJbml0SW5ERVYgPVxuICAgICAgICBjYWxsTGF6eUluaXRbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsTGF6eUluaXQpLFxuICAgICAgQ0xJRU5UX1JFTkRFUkVEID0gNCxcbiAgICAgIFBFTkRJTkcgPSAwLFxuICAgICAgQ09NUExFVEVEID0gMSxcbiAgICAgIEZMVVNIRUQgPSAyLFxuICAgICAgUE9TVFBPTkVEID0gNSxcbiAgICAgIENMT1NFRCA9IDE0LFxuICAgICAgY3VycmVudFJlcXVlc3QgPSBudWxsLFxuICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fSxcbiAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gITEsXG4gICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gITEsXG4gICAgICBkaWRXYXJuQWJvdXRNYXBzID0gITE7XG4gICAgZW5zdXJlQ29ycmVjdElzb21vcnBoaWNSZWFjdFZlcnNpb24oKTtcbiAgICBlbnN1cmVDb3JyZWN0SXNvbW9ycGhpY1JlYWN0VmVyc2lvbigpO1xuICAgIGV4cG9ydHMucHJlcmVuZGVyVG9Ob2RlU3RyZWFtID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBjcmVhdGVSZXN1bWFibGVTdGF0ZShcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggOiB2b2lkIDAsXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy51bnN0YWJsZV9leHRlcm5hbFJ1bnRpbWVTcmMgOiB2b2lkIDAsXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5ib290c3RyYXBTY3JpcHRDb250ZW50IDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0cyA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmJvb3RzdHJhcE1vZHVsZXMgOiB2b2lkIDBcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlcXVlc3QgPSBjcmVhdGVQcmVyZW5kZXJSZXF1ZXN0KFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIGNyZWF0ZVJlbmRlclN0YXRlKFxuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy51bnN0YWJsZV9leHRlcm5hbFJ1bnRpbWVTcmMgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmltcG9ydE1hcCA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMub25IZWFkZXJzIDogdm9pZCAwLFxuICAgICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5tYXhIZWFkZXJzTGVuZ3RoIDogdm9pZCAwXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY3JlYXRlUm9vdEZvcm1hdENvbnRleHQob3B0aW9ucyA/IG9wdGlvbnMubmFtZXNwYWNlVVJJIDogdm9pZCAwKSxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLnByb2dyZXNzaXZlQ2h1bmtTaXplIDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMub25FcnJvciA6IHZvaWQgMCxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHJlYWRhYmxlID0gbmV3IHN0cmVhbS5SZWFkYWJsZSh7XG4gICAgICAgICAgICAgICAgICByZWFkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCB3cml0YWJsZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgd3JpdGFibGUgPSBjcmVhdGVGYWtlV3JpdGFibGUocmVhZGFibGUpO1xuICAgICAgICAgICAgICByZXNvbHZlKHsgcHJlbHVkZTogcmVhZGFibGUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMub25Qb3N0cG9uZSA6IHZvaWQgMFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgdmFyIHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgYWJvcnQocmVxdWVzdCwgc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGFib3J0KHJlcXVlc3QsIHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRXb3JrKHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnJlbmRlclRvUGlwZWFibGVTdHJlYW0gPSBmdW5jdGlvbiAoY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdEltcGwoY2hpbGRyZW4sIG9wdGlvbnMpLFxuICAgICAgICBoYXNTdGFydGVkRmxvd2luZyA9ICExO1xuICAgICAgc3RhcnRXb3JrKHJlcXVlc3QpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGlwZTogZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgaWYgKGhhc1N0YXJ0ZWRGbG93aW5nKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgcGlwaW5nIHRvIG9uZSB3cml0YWJsZSBzdHJlYW0uXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaGFzU3RhcnRlZEZsb3dpbmcgPSAhMDtcbiAgICAgICAgICBzYWZlbHlFbWl0RWFybHlQcmVsb2FkcyhcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXNcbiAgICAgICAgICAgICAgPyAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3NcbiAgICAgICAgICAgICAgOiBudWxsID09PSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50XG4gICAgICAgICAgICAgICAgPyAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3NcbiAgICAgICAgICAgICAgICA6IHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQuc3RhdHVzICE9PSBQT1NUUE9ORURcbiAgICAgICAgICApO1xuICAgICAgICAgIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgZGVzdGluYXRpb24ub24oXCJkcmFpblwiLCBjcmVhdGVEcmFpbkhhbmRsZXIoZGVzdGluYXRpb24sIHJlcXVlc3QpKTtcbiAgICAgICAgICBkZXN0aW5hdGlvbi5vbihcbiAgICAgICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICAgIGNyZWF0ZUNhbmNlbEhhbmRsZXIoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIFwiVGhlIGRlc3RpbmF0aW9uIHN0cmVhbSBlcnJvcmVkIHdoaWxlIHdyaXRpbmcgZGF0YS5cIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgZGVzdGluYXRpb24ub24oXG4gICAgICAgICAgICBcImNsb3NlXCIsXG4gICAgICAgICAgICBjcmVhdGVDYW5jZWxIYW5kbGVyKHJlcXVlc3QsIFwiVGhlIGRlc3RpbmF0aW9uIHN0cmVhbSBjbG9zZWQgZWFybHkuXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgYWJvcnQocmVxdWVzdCwgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMudmVyc2lvbiA9IFwiMTkuMS4wLWNhbmFyeS0wMjllOGJkNi0yMDI1MDMwNlwiO1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.node.development.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom.development.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/cjs/react-dom.development.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @license React\n * react-dom.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function noop() {}\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function createPortal$1(children, containerInfo, implementation) {\n      var key =\n        3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n      try {\n        testStringCoercion(key);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      JSCompiler_inline_result &&\n        (console.error(\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            key[Symbol.toStringTag]) ||\n            key.constructor.name ||\n            \"Object\"\n        ),\n        testStringCoercion(key));\n      return {\n        $$typeof: REACT_PORTAL_TYPE,\n        key: null == key ? null : \"\" + key,\n        children: children,\n        containerInfo: containerInfo,\n        implementation: implementation\n      };\n    }\n    function getCrossOriginStringAs(as, input) {\n      if (\"font\" === as) return \"\";\n      if (\"string\" === typeof input)\n        return \"use-credentials\" === input ? input : \"\";\n    }\n    function getValueDescriptorExpectingObjectForWarning(thing) {\n      return null === thing\n        ? \"`null`\"\n        : void 0 === thing\n          ? \"`undefined`\"\n          : \"\" === thing\n            ? \"an empty string\"\n            : 'something with type \"' + typeof thing + '\"';\n    }\n    function getValueDescriptorExpectingEnumForWarning(thing) {\n      return null === thing\n        ? \"`null`\"\n        : void 0 === thing\n          ? \"`undefined`\"\n          : \"\" === thing\n            ? \"an empty string\"\n            : \"string\" === typeof thing\n              ? JSON.stringify(thing)\n              : \"number\" === typeof thing\n                ? \"`\" + thing + \"`\"\n                : 'something with type \"' + typeof thing + '\"';\n    }\n    function resolveDispatcher() {\n      var dispatcher = ReactSharedInternals.H;\n      null === dispatcher &&\n        console.error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      return dispatcher;\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(rsc)/./node_modules/next/dist/compiled/react/index.js\"),\n      Internals = {\n        d: {\n          f: noop,\n          r: function () {\n            throw Error(\n              \"Invalid form element. requestFormReset must be passed a form that was rendered by React.\"\n            );\n          },\n          D: noop,\n          C: noop,\n          L: noop,\n          m: noop,\n          X: noop,\n          S: noop,\n          M: noop\n        },\n        p: 0,\n        findDOMNode: null\n      },\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n    (\"function\" === typeof Map &&\n      null != Map.prototype &&\n      \"function\" === typeof Map.prototype.forEach &&\n      \"function\" === typeof Set &&\n      null != Set.prototype &&\n      \"function\" === typeof Set.prototype.clear &&\n      \"function\" === typeof Set.prototype.forEach) ||\n      console.error(\n        \"React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills\"\n      );\n    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n      Internals;\n    exports.createPortal = function (children, container) {\n      var key =\n        2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;\n      if (\n        !container ||\n        (1 !== container.nodeType &&\n          9 !== container.nodeType &&\n          11 !== container.nodeType)\n      )\n        throw Error(\"Target container is not a DOM element.\");\n      return createPortal$1(children, container, null, key);\n    };\n    exports.flushSync = function (fn) {\n      var previousTransition = ReactSharedInternals.T,\n        previousUpdatePriority = Internals.p;\n      try {\n        if (((ReactSharedInternals.T = null), (Internals.p = 2), fn))\n          return fn();\n      } finally {\n        (ReactSharedInternals.T = previousTransition),\n          (Internals.p = previousUpdatePriority),\n          Internals.d.f() &&\n            console.error(\n              \"flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.\"\n            );\n      }\n    };\n    exports.preconnect = function (href, options) {\n      \"string\" === typeof href && href\n        ? null != options && \"object\" !== typeof options\n          ? console.error(\n              \"ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.\",\n              getValueDescriptorExpectingEnumForWarning(options)\n            )\n          : null != options &&\n            \"string\" !== typeof options.crossOrigin &&\n            console.error(\n              \"ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.\",\n              getValueDescriptorExpectingObjectForWarning(options.crossOrigin)\n            )\n        : console.error(\n            \"ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\",\n            getValueDescriptorExpectingObjectForWarning(href)\n          );\n      \"string\" === typeof href &&\n        (options\n          ? ((options = options.crossOrigin),\n            (options =\n              \"string\" === typeof options\n                ? \"use-credentials\" === options\n                  ? options\n                  : \"\"\n                : void 0))\n          : (options = null),\n        Internals.d.C(href, options));\n    };\n    exports.prefetchDNS = function (href) {\n      if (\"string\" !== typeof href || !href)\n        console.error(\n          \"ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\",\n          getValueDescriptorExpectingObjectForWarning(href)\n        );\n      else if (1 < arguments.length) {\n        var options = arguments[1];\n        \"object\" === typeof options && options.hasOwnProperty(\"crossOrigin\")\n          ? console.error(\n              \"ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.\",\n              getValueDescriptorExpectingEnumForWarning(options)\n            )\n          : console.error(\n              \"ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.\",\n              getValueDescriptorExpectingEnumForWarning(options)\n            );\n      }\n      \"string\" === typeof href && Internals.d.D(href);\n    };\n    exports.preinit = function (href, options) {\n      \"string\" === typeof href && href\n        ? null == options || \"object\" !== typeof options\n          ? console.error(\n              \"ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.\",\n              getValueDescriptorExpectingEnumForWarning(options)\n            )\n          : \"style\" !== options.as &&\n            \"script\" !== options.as &&\n            console.error(\n              'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are \"style\" and \"script\".',\n              getValueDescriptorExpectingEnumForWarning(options.as)\n            )\n        : console.error(\n            \"ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\",\n            getValueDescriptorExpectingObjectForWarning(href)\n          );\n      if (\n        \"string\" === typeof href &&\n        options &&\n        \"string\" === typeof options.as\n      ) {\n        var as = options.as,\n          crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),\n          integrity =\n            \"string\" === typeof options.integrity ? options.integrity : void 0,\n          fetchPriority =\n            \"string\" === typeof options.fetchPriority\n              ? options.fetchPriority\n              : void 0;\n        \"style\" === as\n          ? Internals.d.S(\n              href,\n              \"string\" === typeof options.precedence\n                ? options.precedence\n                : void 0,\n              {\n                crossOrigin: crossOrigin,\n                integrity: integrity,\n                fetchPriority: fetchPriority\n              }\n            )\n          : \"script\" === as &&\n            Internals.d.X(href, {\n              crossOrigin: crossOrigin,\n              integrity: integrity,\n              fetchPriority: fetchPriority,\n              nonce: \"string\" === typeof options.nonce ? options.nonce : void 0\n            });\n      }\n    };\n    exports.preinitModule = function (href, options) {\n      var encountered = \"\";\n      (\"string\" === typeof href && href) ||\n        (encountered +=\n          \" The `href` argument encountered was \" +\n          getValueDescriptorExpectingObjectForWarning(href) +\n          \".\");\n      void 0 !== options && \"object\" !== typeof options\n        ? (encountered +=\n            \" The `options` argument encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options) +\n            \".\")\n        : options &&\n          \"as\" in options &&\n          \"script\" !== options.as &&\n          (encountered +=\n            \" The `as` option encountered was \" +\n            getValueDescriptorExpectingEnumForWarning(options.as) +\n            \".\");\n      if (encountered)\n        console.error(\n          \"ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s\",\n          encountered\n        );\n      else\n        switch (\n          ((encountered =\n            options && \"string\" === typeof options.as ? options.as : \"script\"),\n          encountered)\n        ) {\n          case \"script\":\n            break;\n          default:\n            (encountered =\n              getValueDescriptorExpectingEnumForWarning(encountered)),\n              console.error(\n                'ReactDOM.preinitModule(): Currently the only supported \"as\" type for this function is \"script\" but received \"%s\" instead. This warning was generated for `href` \"%s\". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',\n                encountered,\n                href\n              );\n        }\n      if (\"string\" === typeof href)\n        if (\"object\" === typeof options && null !== options) {\n          if (null == options.as || \"script\" === options.as)\n            (encountered = getCrossOriginStringAs(\n              options.as,\n              options.crossOrigin\n            )),\n              Internals.d.M(href, {\n                crossOrigin: encountered,\n                integrity:\n                  \"string\" === typeof options.integrity\n                    ? options.integrity\n                    : void 0,\n                nonce:\n                  \"string\" === typeof options.nonce ? options.nonce : void 0\n              });\n        } else null == options && Internals.d.M(href);\n    };\n    exports.preload = function (href, options) {\n      var encountered = \"\";\n      (\"string\" === typeof href && href) ||\n        (encountered +=\n          \" The `href` argument encountered was \" +\n          getValueDescriptorExpectingObjectForWarning(href) +\n          \".\");\n      null == options || \"object\" !== typeof options\n        ? (encountered +=\n            \" The `options` argument encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options) +\n            \".\")\n        : (\"string\" === typeof options.as && options.as) ||\n          (encountered +=\n            \" The `as` option encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options.as) +\n            \".\");\n      encountered &&\n        console.error(\n          'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel=\"preload\" as=\"...\" />` tag.%s',\n          encountered\n        );\n      if (\n        \"string\" === typeof href &&\n        \"object\" === typeof options &&\n        null !== options &&\n        \"string\" === typeof options.as\n      ) {\n        encountered = options.as;\n        var crossOrigin = getCrossOriginStringAs(\n          encountered,\n          options.crossOrigin\n        );\n        Internals.d.L(href, encountered, {\n          crossOrigin: crossOrigin,\n          integrity:\n            \"string\" === typeof options.integrity ? options.integrity : void 0,\n          nonce: \"string\" === typeof options.nonce ? options.nonce : void 0,\n          type: \"string\" === typeof options.type ? options.type : void 0,\n          fetchPriority:\n            \"string\" === typeof options.fetchPriority\n              ? options.fetchPriority\n              : void 0,\n          referrerPolicy:\n            \"string\" === typeof options.referrerPolicy\n              ? options.referrerPolicy\n              : void 0,\n          imageSrcSet:\n            \"string\" === typeof options.imageSrcSet\n              ? options.imageSrcSet\n              : void 0,\n          imageSizes:\n            \"string\" === typeof options.imageSizes\n              ? options.imageSizes\n              : void 0,\n          media: \"string\" === typeof options.media ? options.media : void 0\n        });\n      }\n    };\n    exports.preloadModule = function (href, options) {\n      var encountered = \"\";\n      (\"string\" === typeof href && href) ||\n        (encountered +=\n          \" The `href` argument encountered was \" +\n          getValueDescriptorExpectingObjectForWarning(href) +\n          \".\");\n      void 0 !== options && \"object\" !== typeof options\n        ? (encountered +=\n            \" The `options` argument encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options) +\n            \".\")\n        : options &&\n          \"as\" in options &&\n          \"string\" !== typeof options.as &&\n          (encountered +=\n            \" The `as` option encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options.as) +\n            \".\");\n      encountered &&\n        console.error(\n          'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel=\"modulepreload\" as=\"...\" />` tag.%s',\n          encountered\n        );\n      \"string\" === typeof href &&\n        (options\n          ? ((encountered = getCrossOriginStringAs(\n              options.as,\n              options.crossOrigin\n            )),\n            Internals.d.m(href, {\n              as:\n                \"string\" === typeof options.as && \"script\" !== options.as\n                  ? options.as\n                  : void 0,\n              crossOrigin: encountered,\n              integrity:\n                \"string\" === typeof options.integrity\n                  ? options.integrity\n                  : void 0\n            }))\n          : Internals.d.m(href));\n    };\n    exports.requestFormReset = function (form) {\n      Internals.d.r(form);\n    };\n    exports.unstable_batchedUpdates = function (fn, a) {\n      return fn(a);\n    };\n    exports.useFormState = function (action, initialState, permalink) {\n      return resolveDispatcher().useFormState(action, initialState, permalink);\n    };\n    exports.useFormStatus = function () {\n      return resolveDispatcher().useHostTransitionStatus();\n    };\n    exports.version = \"19.1.0-canary-029e8bd6-20250306\";\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiLEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHdGQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvRUFBb0U7QUFDeEU7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixVQUFVO0FBQ1Y7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBLElBQUksK0JBQStCO0FBQ25DO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxccmVhY3QtZG9tXFxjanNcXHJlYWN0LWRvbS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kb20uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVySW5mbywgaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIHZhciBrZXkgPVxuICAgICAgICAzIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1szXSA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24oa2V5KTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCAmJlxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICBrZXlbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICAgIGtleS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgICBcIk9iamVjdFwiXG4gICAgICAgICksXG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbihrZXkpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICAgICAga2V5OiBudWxsID09IGtleSA/IG51bGwgOiBcIlwiICsga2V5LFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmdBcyhhcywgaW5wdXQpIHtcbiAgICAgIGlmIChcImZvbnRcIiA9PT0gYXMpIHJldHVybiBcIlwiO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnB1dClcbiAgICAgICAgcmV0dXJuIFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IGlucHV0ID8gaW5wdXQgOiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKHRoaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gdGhpbmdcbiAgICAgICAgPyBcImBudWxsYFwiXG4gICAgICAgIDogdm9pZCAwID09PSB0aGluZ1xuICAgICAgICAgID8gXCJgdW5kZWZpbmVkYFwiXG4gICAgICAgICAgOiBcIlwiID09PSB0aGluZ1xuICAgICAgICAgICAgPyBcImFuIGVtcHR5IHN0cmluZ1wiXG4gICAgICAgICAgICA6ICdzb21ldGhpbmcgd2l0aCB0eXBlIFwiJyArIHR5cGVvZiB0aGluZyArICdcIic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKHRoaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gdGhpbmdcbiAgICAgICAgPyBcImBudWxsYFwiXG4gICAgICAgIDogdm9pZCAwID09PSB0aGluZ1xuICAgICAgICAgID8gXCJgdW5kZWZpbmVkYFwiXG4gICAgICAgICAgOiBcIlwiID09PSB0aGluZ1xuICAgICAgICAgICAgPyBcImFuIGVtcHR5IHN0cmluZ1wiXG4gICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGluZ1xuICAgICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHRoaW5nKVxuICAgICAgICAgICAgICA6IFwibnVtYmVyXCIgPT09IHR5cGVvZiB0aGluZ1xuICAgICAgICAgICAgICAgID8gXCJgXCIgKyB0aGluZyArIFwiYFwiXG4gICAgICAgICAgICAgICAgOiAnc29tZXRoaW5nIHdpdGggdHlwZSBcIicgKyB0eXBlb2YgdGhpbmcgKyAnXCInO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIG51bGwgPT09IGRpc3BhdGNoZXIgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXI7XG4gICAgfVxuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQoRXJyb3IoKSk7XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIEludGVybmFscyA9IHtcbiAgICAgICAgZDoge1xuICAgICAgICAgIGY6IG5vb3AsXG4gICAgICAgICAgcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBmb3JtIGVsZW1lbnQuIHJlcXVlc3RGb3JtUmVzZXQgbXVzdCBiZSBwYXNzZWQgYSBmb3JtIHRoYXQgd2FzIHJlbmRlcmVkIGJ5IFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgRDogbm9vcCxcbiAgICAgICAgICBDOiBub29wLFxuICAgICAgICAgIEw6IG5vb3AsXG4gICAgICAgICAgbTogbm9vcCxcbiAgICAgICAgICBYOiBub29wLFxuICAgICAgICAgIFM6IG5vb3AsXG4gICAgICAgICAgTTogbm9vcFxuICAgICAgICB9LFxuICAgICAgICBwOiAwLFxuICAgICAgICBmaW5kRE9NTm9kZTogbnVsbFxuICAgICAgfSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFO1xuICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBNYXAgJiZcbiAgICAgIG51bGwgIT0gTWFwLnByb3RvdHlwZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgTWFwLnByb3RvdHlwZS5mb3JFYWNoICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTZXQgJiZcbiAgICAgIG51bGwgIT0gU2V0LnByb3RvdHlwZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoKSB8fFxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhIHBvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtcG9seWZpbGxzXCJcbiAgICAgICk7XG4gICAgZXhwb3J0cy5fX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUgPVxuICAgICAgSW50ZXJuYWxzO1xuICAgIGV4cG9ydHMuY3JlYXRlUG9ydGFsID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgICAgIHZhciBrZXkgPVxuICAgICAgICAyIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICBpZiAoXG4gICAgICAgICFjb250YWluZXIgfHxcbiAgICAgICAgKDEgIT09IGNvbnRhaW5lci5ub2RlVHlwZSAmJlxuICAgICAgICAgIDkgIT09IGNvbnRhaW5lci5ub2RlVHlwZSAmJlxuICAgICAgICAgIDExICE9PSBjb250YWluZXIubm9kZVR5cGUpXG4gICAgICApXG4gICAgICAgIHRocm93IEVycm9yKFwiVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC5cIik7XG4gICAgICByZXR1cm4gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lciwgbnVsbCwga2V5KTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmx1c2hTeW5jID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICB2YXIgcHJldmlvdXNUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNVcGRhdGVQcmlvcml0eSA9IEludGVybmFscy5wO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCgoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLCAoSW50ZXJuYWxzLnAgPSAyKSwgZm4pKVxuICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2aW91c1RyYW5zaXRpb24pLFxuICAgICAgICAgIChJbnRlcm5hbHMucCA9IHByZXZpb3VzVXBkYXRlUHJpb3JpdHkpLFxuICAgICAgICAgIEludGVybmFscy5kLmYoKSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJmbHVzaFN5bmMgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuIFJlYWN0IGNhbm5vdCBmbHVzaCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLiBDb25zaWRlciBtb3ZpbmcgdGhpcyBjYWxsIHRvIGEgc2NoZWR1bGVyIHRhc2sgb3IgbWljcm8gdGFzay5cIlxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMucHJlY29ubmVjdCA9IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmXG4gICAgICAgID8gbnVsbCAhPSBvcHRpb25zICYmIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvcHRpb25zXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0RE9NLnByZWNvbm5lY3QoKTogRXhwZWN0ZWQgdGhlIGBvcHRpb25zYCBhcmd1bWVudCAoc2Vjb25kKSB0byBiZSBhbiBvYmplY3QgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuIFRoZSBvbmx5IHN1cHBvcnRlZCBvcHRpb24gYXQgdGhpcyB0aW1lIGlzIGBjcm9zc09yaWdpbmAgd2hpY2ggYWNjZXB0cyBhIHN0cmluZy5cIixcbiAgICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucylcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IG51bGwgIT0gb3B0aW9ucyAmJlxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3RET00ucHJlY29ubmVjdCgpOiBFeHBlY3RlZCB0aGUgYGNyb3NzT3JpZ2luYCBvcHRpb24gKHNlY29uZCBhcmd1bWVudCkgdG8gYmUgYSBzdHJpbmcgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuIFRyeSByZW1vdmluZyB0aGlzIG9wdGlvbiBvciBwYXNzaW5nIGEgc3RyaW5nIHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcob3B0aW9ucy5jcm9zc09yaWdpbilcbiAgICAgICAgICAgIClcbiAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdERPTS5wcmVjb25uZWN0KCk6IEV4cGVjdGVkIHRoZSBgaHJlZmAgYXJndW1lbnQgKGZpcnN0KSB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuXCIsXG4gICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKGhyZWYpXG4gICAgICAgICAgKTtcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmXG4gICAgICAgIChvcHRpb25zXG4gICAgICAgICAgPyAoKG9wdGlvbnMgPSBvcHRpb25zLmNyb3NzT3JpZ2luKSxcbiAgICAgICAgICAgIChvcHRpb25zID1cbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgICAgICAgICA/IFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgID8gb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICAgOiB2b2lkIDApKVxuICAgICAgICAgIDogKG9wdGlvbnMgPSBudWxsKSxcbiAgICAgICAgSW50ZXJuYWxzLmQuQyhocmVmLCBvcHRpb25zKSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnByZWZldGNoRE5TID0gZnVuY3Rpb24gKGhyZWYpIHtcbiAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2YgaHJlZiB8fCAhaHJlZilcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0RE9NLnByZWZldGNoRE5TKCk6IEV4cGVjdGVkIHRoZSBgaHJlZmAgYXJndW1lbnQgKGZpcnN0KSB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuXCIsXG4gICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhocmVmKVxuICAgICAgICApO1xuICAgICAgZWxzZSBpZiAoMSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBvcHRpb25zICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJjcm9zc09yaWdpblwiKVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdERPTS5wcmVmZXRjaEROUygpOiBFeHBlY3RlZCBvbmx5IG9uZSBhcmd1bWVudCwgYGhyZWZgLCBidXQgZW5jb3VudGVyZWQgJXMgYXMgYSBzZWNvbmQgYXJndW1lbnQgaW5zdGVhZC4gVGhpcyBhcmd1bWVudCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIG9wdGlvbnMgYW5kIGlzIGN1cnJlbnRseSBkaXNhbGxvd2VkLiBJdCBsb29rcyBsaWtlIHRoZSB5b3UgYXJlIGF0dGVtcHRpbmcgdG8gc2V0IGEgY3Jvc3NPcmlnaW4gcHJvcGVydHkgZm9yIHRoaXMgRE5TIGxvb2t1cCBoaW50LiBCcm93c2VycyBkbyBub3QgcGVyZm9ybSBETlMgcXVlcmllcyB1c2luZyBDT1JTIGFuZCBzZXR0aW5nIHRoaXMgYXR0cmlidXRlIG9uIHRoZSByZXNvdXJjZSBoaW50IGhhcyBubyBlZmZlY3QuIFRyeSBjYWxsaW5nIFJlYWN0RE9NLnByZWZldGNoRE5TKCkgd2l0aCBqdXN0IGEgc2luZ2xlIHN0cmluZyBhcmd1bWVudCwgYGhyZWZgLlwiLFxuICAgICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcHRpb25zKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdERPTS5wcmVmZXRjaEROUygpOiBFeHBlY3RlZCBvbmx5IG9uZSBhcmd1bWVudCwgYGhyZWZgLCBidXQgZW5jb3VudGVyZWQgJXMgYXMgYSBzZWNvbmQgYXJndW1lbnQgaW5zdGVhZC4gVGhpcyBhcmd1bWVudCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIG9wdGlvbnMgYW5kIGlzIGN1cnJlbnRseSBkaXNhbGxvd2VkLiBUcnkgY2FsbGluZyBSZWFjdERPTS5wcmVmZXRjaEROUygpIHdpdGgganVzdCBhIHNpbmdsZSBzdHJpbmcgYXJndW1lbnQsIGBocmVmYC5cIixcbiAgICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucylcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBJbnRlcm5hbHMuZC5EKGhyZWYpO1xuICAgIH07XG4gICAgZXhwb3J0cy5wcmVpbml0ID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWZcbiAgICAgICAgPyBudWxsID09IG9wdGlvbnMgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3RET00ucHJlaW5pdCgpOiBFeHBlY3RlZCB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IChzZWNvbmQpIHRvIGJlIGFuIG9iamVjdCB3aXRoIGFuIGBhc2AgcHJvcGVydHkgZGVzY3JpYmluZyB0aGUgdHlwZSBvZiByZXNvdXJjZSB0byBiZSBwcmVpbml0aWFsaXplZCBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucylcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IFwic3R5bGVcIiAhPT0gb3B0aW9ucy5hcyAmJlxuICAgICAgICAgICAgXCJzY3JpcHRcIiAhPT0gb3B0aW9ucy5hcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ1JlYWN0RE9NLnByZWluaXQoKTogRXhwZWN0ZWQgdGhlIGBhc2AgcHJvcGVydHkgaW4gdGhlIGBvcHRpb25zYCBhcmd1bWVudCAoc2Vjb25kKSB0byBjb250YWluIGEgdmFsaWQgdmFsdWUgZGVzY3JpYmluZyB0aGUgdHlwZSBvZiByZXNvdXJjZSB0byBiZSBwcmVpbml0aWFsaXplZCBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC4gVmFsaWQgdmFsdWVzIGZvciBgYXNgIGFyZSBcInN0eWxlXCIgYW5kIFwic2NyaXB0XCIuJyxcbiAgICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucy5hcylcbiAgICAgICAgICAgIClcbiAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdERPTS5wcmVpbml0KCk6IEV4cGVjdGVkIHRoZSBgaHJlZmAgYXJndW1lbnQgKGZpcnN0KSB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuXCIsXG4gICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKGhyZWYpXG4gICAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiZcbiAgICAgICAgb3B0aW9ucyAmJlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hc1xuICAgICAgKSB7XG4gICAgICAgIHZhciBhcyA9IG9wdGlvbnMuYXMsXG4gICAgICAgICAgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKGFzLCBvcHRpb25zLmNyb3NzT3JpZ2luKSxcbiAgICAgICAgICBpbnRlZ3JpdHkgPVxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID8gb3B0aW9ucy5pbnRlZ3JpdHkgOiB2b2lkIDAsXG4gICAgICAgICAgZmV0Y2hQcmlvcml0eSA9XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgICAgID8gb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICBcInN0eWxlXCIgPT09IGFzXG4gICAgICAgICAgPyBJbnRlcm5hbHMuZC5TKFxuICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5wcmVjZWRlbmNlXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLnByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IGludGVncml0eSxcbiAgICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBmZXRjaFByaW9yaXR5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IFwic2NyaXB0XCIgPT09IGFzICYmXG4gICAgICAgICAgICBJbnRlcm5hbHMuZC5YKGhyZWYsIHtcbiAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICBpbnRlZ3JpdHk6IGludGVncml0eSxcbiAgICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICAgICAgbm9uY2U6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLnByZWluaXRNb2R1bGUgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICAgICAgdmFyIGVuY291bnRlcmVkID0gXCJcIjtcbiAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB8fFxuICAgICAgICAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICBcIiBUaGUgYGhyZWZgIGFyZ3VtZW50IGVuY291bnRlcmVkIHdhcyBcIiArXG4gICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhocmVmKSArXG4gICAgICAgICAgXCIuXCIpO1xuICAgICAgdm9pZCAwICE9PSBvcHRpb25zICYmIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvcHRpb25zXG4gICAgICAgID8gKGVuY291bnRlcmVkICs9XG4gICAgICAgICAgICBcIiBUaGUgYG9wdGlvbnNgIGFyZ3VtZW50IGVuY291bnRlcmVkIHdhcyBcIiArXG4gICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKG9wdGlvbnMpICtcbiAgICAgICAgICAgIFwiLlwiKVxuICAgICAgICA6IG9wdGlvbnMgJiZcbiAgICAgICAgICBcImFzXCIgaW4gb3B0aW9ucyAmJlxuICAgICAgICAgIFwic2NyaXB0XCIgIT09IG9wdGlvbnMuYXMgJiZcbiAgICAgICAgICAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICAgIFwiIFRoZSBgYXNgIG9wdGlvbiBlbmNvdW50ZXJlZCB3YXMgXCIgK1xuICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucy5hcykgK1xuICAgICAgICAgICAgXCIuXCIpO1xuICAgICAgaWYgKGVuY291bnRlcmVkKVxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3RET00ucHJlaW5pdE1vZHVsZSgpOiBFeHBlY3RlZCB1cCB0byB0d28gYXJndW1lbnRzLCBhIG5vbi1lbXB0eSBgaHJlZmAgc3RyaW5nIGFuZCwgb3B0aW9uYWxseSwgYW4gYG9wdGlvbnNgIG9iamVjdCB3aXRoIGEgdmFsaWQgYGFzYCBwcm9wZXJ0eS4lc1wiLFxuICAgICAgICAgIGVuY291bnRlcmVkXG4gICAgICAgICk7XG4gICAgICBlbHNlXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKChlbmNvdW50ZXJlZCA9XG4gICAgICAgICAgICBvcHRpb25zICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzID8gb3B0aW9ucy5hcyA6IFwic2NyaXB0XCIpLFxuICAgICAgICAgIGVuY291bnRlcmVkKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgKGVuY291bnRlcmVkID1cbiAgICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcoZW5jb3VudGVyZWQpKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnUmVhY3RET00ucHJlaW5pdE1vZHVsZSgpOiBDdXJyZW50bHkgdGhlIG9ubHkgc3VwcG9ydGVkIFwiYXNcIiB0eXBlIGZvciB0aGlzIGZ1bmN0aW9uIGlzIFwic2NyaXB0XCIgYnV0IHJlY2VpdmVkIFwiJXNcIiBpbnN0ZWFkLiBUaGlzIHdhcm5pbmcgd2FzIGdlbmVyYXRlZCBmb3IgYGhyZWZgIFwiJXNcIi4gSW4gdGhlIGZ1dHVyZSBvdGhlciBtb2R1bGUgdHlwZXMgd2lsbCBiZSBzdXBwb3J0ZWQsIGFsaWduaW5nIHdpdGggdGhlIGltcG9ydC1hdHRyaWJ1dGVzIHByb3Bvc2FsLiBMZWFybiBtb3JlIGhlcmU6IChodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1pbXBvcnQtYXR0cmlidXRlcyknLFxuICAgICAgICAgICAgICAgIGVuY291bnRlcmVkLFxuICAgICAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmKVxuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgbnVsbCAhPT0gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChudWxsID09IG9wdGlvbnMuYXMgfHwgXCJzY3JpcHRcIiA9PT0gb3B0aW9ucy5hcylcbiAgICAgICAgICAgIChlbmNvdW50ZXJlZCA9IGdldENyb3NzT3JpZ2luU3RyaW5nQXMoXG4gICAgICAgICAgICAgIG9wdGlvbnMuYXMsXG4gICAgICAgICAgICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBJbnRlcm5hbHMuZC5NKGhyZWYsIHtcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogZW5jb3VudGVyZWQsXG4gICAgICAgICAgICAgICAgaW50ZWdyaXR5OlxuICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbm9uY2U6XG4gICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5ub25jZSA/IG9wdGlvbnMubm9uY2UgOiB2b2lkIDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBudWxsID09IG9wdGlvbnMgJiYgSW50ZXJuYWxzLmQuTShocmVmKTtcbiAgICB9O1xuICAgIGV4cG9ydHMucHJlbG9hZCA9IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZW5jb3VudGVyZWQgPSBcIlwiO1xuICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWYpIHx8XG4gICAgICAgIChlbmNvdW50ZXJlZCArPVxuICAgICAgICAgIFwiIFRoZSBgaHJlZmAgYXJndW1lbnQgZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKGhyZWYpICtcbiAgICAgICAgICBcIi5cIik7XG4gICAgICBudWxsID09IG9wdGlvbnMgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgPyAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICAgIFwiIFRoZSBgb3B0aW9uc2AgYXJndW1lbnQgZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcob3B0aW9ucykgK1xuICAgICAgICAgICAgXCIuXCIpXG4gICAgICAgIDogKFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzICYmIG9wdGlvbnMuYXMpIHx8XG4gICAgICAgICAgKGVuY291bnRlcmVkICs9XG4gICAgICAgICAgICBcIiBUaGUgYGFzYCBvcHRpb24gZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcob3B0aW9ucy5hcykgK1xuICAgICAgICAgICAgXCIuXCIpO1xuICAgICAgZW5jb3VudGVyZWQgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnUmVhY3RET00ucHJlbG9hZCgpOiBFeHBlY3RlZCB0d28gYXJndW1lbnRzLCBhIG5vbi1lbXB0eSBgaHJlZmAgc3RyaW5nIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0IHdpdGggYW4gYGFzYCBwcm9wZXJ0eSB2YWxpZCBmb3IgYSBgPGxpbmsgcmVsPVwicHJlbG9hZFwiIGFzPVwiLi4uXCIgLz5gIHRhZy4lcycsXG4gICAgICAgICAgZW5jb3VudGVyZWRcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiZcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiZcbiAgICAgICAgbnVsbCAhPT0gb3B0aW9ucyAmJlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hc1xuICAgICAgKSB7XG4gICAgICAgIGVuY291bnRlcmVkID0gb3B0aW9ucy5hcztcbiAgICAgICAgdmFyIGNyb3NzT3JpZ2luID0gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmdBcyhcbiAgICAgICAgICBlbmNvdW50ZXJlZCxcbiAgICAgICAgICBvcHRpb25zLmNyb3NzT3JpZ2luXG4gICAgICAgICk7XG4gICAgICAgIEludGVybmFscy5kLkwoaHJlZiwgZW5jb3VudGVyZWQsIHtcbiAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgaW50ZWdyaXR5OlxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID8gb3B0aW9ucy5pbnRlZ3JpdHkgOiB2b2lkIDAsXG4gICAgICAgICAgbm9uY2U6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHZvaWQgMCxcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy50eXBlID8gb3B0aW9ucy50eXBlIDogdm9pZCAwLFxuICAgICAgICAgIGZldGNoUHJpb3JpdHk6XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgICAgID8gb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICAgIHJlZmVycmVyUG9saWN5OlxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgICAgICAgPyBvcHRpb25zLnJlZmVycmVyUG9saWN5XG4gICAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICAgIGltYWdlU3JjU2V0OlxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW1hZ2VTcmNTZXRcbiAgICAgICAgICAgICAgPyBvcHRpb25zLmltYWdlU3JjU2V0XG4gICAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICAgIGltYWdlU2l6ZXM6XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbWFnZVNpemVzXG4gICAgICAgICAgICAgID8gb3B0aW9ucy5pbWFnZVNpemVzXG4gICAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICAgIG1lZGlhOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5tZWRpYSA/IG9wdGlvbnMubWVkaWEgOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLnByZWxvYWRNb2R1bGUgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICAgICAgdmFyIGVuY291bnRlcmVkID0gXCJcIjtcbiAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB8fFxuICAgICAgICAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICBcIiBUaGUgYGhyZWZgIGFyZ3VtZW50IGVuY291bnRlcmVkIHdhcyBcIiArXG4gICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhocmVmKSArXG4gICAgICAgICAgXCIuXCIpO1xuICAgICAgdm9pZCAwICE9PSBvcHRpb25zICYmIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvcHRpb25zXG4gICAgICAgID8gKGVuY291bnRlcmVkICs9XG4gICAgICAgICAgICBcIiBUaGUgYG9wdGlvbnNgIGFyZ3VtZW50IGVuY291bnRlcmVkIHdhcyBcIiArXG4gICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKG9wdGlvbnMpICtcbiAgICAgICAgICAgIFwiLlwiKVxuICAgICAgICA6IG9wdGlvbnMgJiZcbiAgICAgICAgICBcImFzXCIgaW4gb3B0aW9ucyAmJlxuICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmFzICYmXG4gICAgICAgICAgKGVuY291bnRlcmVkICs9XG4gICAgICAgICAgICBcIiBUaGUgYGFzYCBvcHRpb24gZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcob3B0aW9ucy5hcykgK1xuICAgICAgICAgICAgXCIuXCIpO1xuICAgICAgZW5jb3VudGVyZWQgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnUmVhY3RET00ucHJlbG9hZE1vZHVsZSgpOiBFeHBlY3RlZCB0d28gYXJndW1lbnRzLCBhIG5vbi1lbXB0eSBgaHJlZmAgc3RyaW5nIGFuZCwgb3B0aW9uYWxseSwgYW4gYG9wdGlvbnNgIG9iamVjdCB3aXRoIGFuIGBhc2AgcHJvcGVydHkgdmFsaWQgZm9yIGEgYDxsaW5rIHJlbD1cIm1vZHVsZXByZWxvYWRcIiBhcz1cIi4uLlwiIC8+YCB0YWcuJXMnLFxuICAgICAgICAgIGVuY291bnRlcmVkXG4gICAgICAgICk7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJlxuICAgICAgICAob3B0aW9uc1xuICAgICAgICAgID8gKChlbmNvdW50ZXJlZCA9IGdldENyb3NzT3JpZ2luU3RyaW5nQXMoXG4gICAgICAgICAgICAgIG9wdGlvbnMuYXMsXG4gICAgICAgICAgICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgSW50ZXJuYWxzLmQubShocmVmLCB7XG4gICAgICAgICAgICAgIGFzOlxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzICYmIFwic2NyaXB0XCIgIT09IG9wdGlvbnMuYXNcbiAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5hc1xuICAgICAgICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBlbmNvdW50ZXJlZCxcbiAgICAgICAgICAgICAgaW50ZWdyaXR5OlxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgOiB2b2lkIDBcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIDogSW50ZXJuYWxzLmQubShocmVmKSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnJlcXVlc3RGb3JtUmVzZXQgPSBmdW5jdGlvbiAoZm9ybSkge1xuICAgICAgSW50ZXJuYWxzLmQucihmb3JtKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoZm4sIGEpIHtcbiAgICAgIHJldHVybiBmbihhKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUZvcm1TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRm9ybVN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzKCk7XG4gICAgfTtcbiAgICBleHBvcnRzLnZlcnNpb24gPSBcIjE5LjEuMC1jYW5hcnktMDI5ZThiZDYtMjAyNTAzMDZcIjtcbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChFcnJvcigpKTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom.development.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react-dom/index.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFLMUMsQ0FBQztBQUNGLEVBQUUsNEpBQTBEO0FBQzVEIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHJlYWN0LWRvbVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react-dom/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react-dom/server.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/server.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./server.node */ \"(rsc)/./node_modules/next/dist/compiled/react-dom/server.node.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsNkhBQXlDIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHJlYWN0LWRvbVxcc2VydmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NlcnZlci5ub2RlJyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react-dom/server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react-dom/server.node.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/server.node.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar l, s;\nif (false) {} else {\n  l = __webpack_require__(/*! ./cjs/react-dom-server-legacy.node.development.js */ \"(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.node.development.js\");\n  s = __webpack_require__(/*! ./cjs/react-dom-server.node.development.js */ \"(rsc)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.node.development.js\");\n}\n\nexports.version = l.version;\nexports.renderToString = l.renderToString;\nexports.renderToStaticMarkup = l.renderToStaticMarkup;\nexports.renderToPipeableStream = s.renderToPipeableStream;\nif (s.resumeToPipeableStream) {\n  exports.resumeToPipeableStream = s.resumeToPipeableStream;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9zZXJ2ZXIubm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBLElBQUksS0FBcUMsRUFBRSxFQUcxQyxDQUFDO0FBQ0YsTUFBTSxtQkFBTyxDQUFDLDRKQUFtRDtBQUNqRSxNQUFNLG1CQUFPLENBQUMsOElBQTRDO0FBQzFEOztBQUVBLGVBQWU7QUFDZixzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QjtBQUNBLEVBQUUsOEJBQThCO0FBQ2hDIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHJlYWN0LWRvbVxcc2VydmVyLm5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbCwgcztcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGwgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tc2VydmVyLWxlZ2FjeS5ub2RlLnByb2R1Y3Rpb24uanMnKTtcbiAgcyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBsID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci1sZWdhY3kubm9kZS5kZXZlbG9wbWVudC5qcycpO1xuICBzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzJyk7XG59XG5cbmV4cG9ydHMudmVyc2lvbiA9IGwudmVyc2lvbjtcbmV4cG9ydHMucmVuZGVyVG9TdHJpbmcgPSBsLnJlbmRlclRvU3RyaW5nO1xuZXhwb3J0cy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGwucmVuZGVyVG9TdGF0aWNNYXJrdXA7XG5leHBvcnRzLnJlbmRlclRvUGlwZWFibGVTdHJlYW0gPSBzLnJlbmRlclRvUGlwZWFibGVTdHJlYW07XG5pZiAocy5yZXN1bWVUb1BpcGVhYmxlU3RyZWFtKSB7XG4gIGV4cG9ydHMucmVzdW1lVG9QaXBlYWJsZVN0cmVhbSA9IHMucmVzdW1lVG9QaXBlYWJsZVN0cmVhbTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react-dom/server.node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react/cjs/react.development.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react.development.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function defineDeprecationWarning(methodName, info) {\n      Object.defineProperty(Component.prototype, methodName, {\n        get: function () {\n          console.warn(\n            \"%s(...) is deprecated in plain JavaScript React classes. %s\",\n            info[0],\n            info[1]\n          );\n        }\n      });\n    }\n    function getIteratorFn(maybeIterable) {\n      if (null === maybeIterable || \"object\" !== typeof maybeIterable)\n        return null;\n      maybeIterable =\n        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n        maybeIterable[\"@@iterator\"];\n      return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function warnNoop(publicInstance, callerName) {\n      publicInstance =\n        ((publicInstance = publicInstance.constructor) &&\n          (publicInstance.displayName || publicInstance.name)) ||\n        \"ReactClass\";\n      var warningKey = publicInstance + \".\" + callerName;\n      didWarnStateUpdateForUnmountedComponent[warningKey] ||\n        (console.error(\n          \"Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.\",\n          callerName,\n          publicInstance\n        ),\n        (didWarnStateUpdateForUnmountedComponent[warningKey] = !0));\n    }\n    function Component(props, context, updater) {\n      this.props = props;\n      this.context = context;\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    function ComponentDummy() {}\n    function PureComponent(props, context, updater) {\n      this.props = props;\n      this.context = context;\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$1\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function cloneAndReplaceKey(oldElement, newKey) {\n      newKey = ReactElement(\n        oldElement.type,\n        newKey,\n        void 0,\n        void 0,\n        oldElement._owner,\n        oldElement.props,\n        oldElement._debugStack,\n        oldElement._debugTask\n      );\n      oldElement._store &&\n        (newKey._store.validated = oldElement._store.validated);\n      return newKey;\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function escape(key) {\n      var escaperLookup = { \"=\": \"=0\", \":\": \"=2\" };\n      return (\n        \"$\" +\n        key.replace(/[=:]/g, function (match) {\n          return escaperLookup[match];\n        })\n      );\n    }\n    function getElementKey(element, index) {\n      return \"object\" === typeof element &&\n        null !== element &&\n        null != element.key\n        ? (checkKeyStringCoercion(element.key), escape(\"\" + element.key))\n        : index.toString(36);\n    }\n    function noop$1() {}\n    function resolveThenable(thenable) {\n      switch (thenable.status) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n        default:\n          switch (\n            (\"string\" === typeof thenable.status\n              ? thenable.then(noop$1, noop$1)\n              : ((thenable.status = \"pending\"),\n                thenable.then(\n                  function (fulfilledValue) {\n                    \"pending\" === thenable.status &&\n                      ((thenable.status = \"fulfilled\"),\n                      (thenable.value = fulfilledValue));\n                  },\n                  function (error) {\n                    \"pending\" === thenable.status &&\n                      ((thenable.status = \"rejected\"),\n                      (thenable.reason = error));\n                  }\n                )),\n            thenable.status)\n          ) {\n            case \"fulfilled\":\n              return thenable.value;\n            case \"rejected\":\n              throw thenable.reason;\n          }\n      }\n      throw thenable;\n    }\n    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n      var type = typeof children;\n      if (\"undefined\" === type || \"boolean\" === type) children = null;\n      var invokeCallback = !1;\n      if (null === children) invokeCallback = !0;\n      else\n        switch (type) {\n          case \"bigint\":\n          case \"string\":\n          case \"number\":\n            invokeCallback = !0;\n            break;\n          case \"object\":\n            switch (children.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                invokeCallback = !0;\n                break;\n              case REACT_LAZY_TYPE:\n                return (\n                  (invokeCallback = children._init),\n                  mapIntoArray(\n                    invokeCallback(children._payload),\n                    array,\n                    escapedPrefix,\n                    nameSoFar,\n                    callback\n                  )\n                );\n            }\n        }\n      if (invokeCallback) {\n        invokeCallback = children;\n        callback = callback(invokeCallback);\n        var childKey =\n          \"\" === nameSoFar ? \".\" + getElementKey(invokeCallback, 0) : nameSoFar;\n        isArrayImpl(callback)\n          ? ((escapedPrefix = \"\"),\n            null != childKey &&\n              (escapedPrefix =\n                childKey.replace(userProvidedKeyEscapeRegex, \"$&/\") + \"/\"),\n            mapIntoArray(callback, array, escapedPrefix, \"\", function (c) {\n              return c;\n            }))\n          : null != callback &&\n            (isValidElement(callback) &&\n              (null != callback.key &&\n                ((invokeCallback && invokeCallback.key === callback.key) ||\n                  checkKeyStringCoercion(callback.key)),\n              (escapedPrefix = cloneAndReplaceKey(\n                callback,\n                escapedPrefix +\n                  (null == callback.key ||\n                  (invokeCallback && invokeCallback.key === callback.key)\n                    ? \"\"\n                    : (\"\" + callback.key).replace(\n                        userProvidedKeyEscapeRegex,\n                        \"$&/\"\n                      ) + \"/\") +\n                  childKey\n              )),\n              \"\" !== nameSoFar &&\n                null != invokeCallback &&\n                isValidElement(invokeCallback) &&\n                null == invokeCallback.key &&\n                invokeCallback._store &&\n                !invokeCallback._store.validated &&\n                (escapedPrefix._store.validated = 2),\n              (callback = escapedPrefix)),\n            array.push(callback));\n        return 1;\n      }\n      invokeCallback = 0;\n      childKey = \"\" === nameSoFar ? \".\" : nameSoFar + \":\";\n      if (isArrayImpl(children))\n        for (var i = 0; i < children.length; i++)\n          (nameSoFar = children[i]),\n            (type = childKey + getElementKey(nameSoFar, i)),\n            (invokeCallback += mapIntoArray(\n              nameSoFar,\n              array,\n              escapedPrefix,\n              type,\n              callback\n            ));\n      else if (((i = getIteratorFn(children)), \"function\" === typeof i))\n        for (\n          i === children.entries &&\n            (didWarnAboutMaps ||\n              console.warn(\n                \"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"\n              ),\n            (didWarnAboutMaps = !0)),\n            children = i.call(children),\n            i = 0;\n          !(nameSoFar = children.next()).done;\n\n        )\n          (nameSoFar = nameSoFar.value),\n            (type = childKey + getElementKey(nameSoFar, i++)),\n            (invokeCallback += mapIntoArray(\n              nameSoFar,\n              array,\n              escapedPrefix,\n              type,\n              callback\n            ));\n      else if (\"object\" === type) {\n        if (\"function\" === typeof children.then)\n          return mapIntoArray(\n            resolveThenable(children),\n            array,\n            escapedPrefix,\n            nameSoFar,\n            callback\n          );\n        array = String(children);\n        throw Error(\n          \"Objects are not valid as a React child (found: \" +\n            (\"[object Object]\" === array\n              ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\"\n              : array) +\n            \"). If you meant to render a collection of children, use an array instead.\"\n        );\n      }\n      return invokeCallback;\n    }\n    function mapChildren(children, func, context) {\n      if (null == children) return children;\n      var result = [],\n        count = 0;\n      mapIntoArray(children, result, \"\", \"\", function (child) {\n        return func.call(context, child, count++);\n      });\n      return result;\n    }\n    function lazyInitializer(payload) {\n      if (-1 === payload._status) {\n        var ctor = payload._result;\n        ctor = ctor();\n        ctor.then(\n          function (moduleObject) {\n            if (0 === payload._status || -1 === payload._status)\n              (payload._status = 1), (payload._result = moduleObject);\n          },\n          function (error) {\n            if (0 === payload._status || -1 === payload._status)\n              (payload._status = 2), (payload._result = error);\n          }\n        );\n        -1 === payload._status &&\n          ((payload._status = 0), (payload._result = ctor));\n      }\n      if (1 === payload._status)\n        return (\n          (ctor = payload._result),\n          void 0 === ctor &&\n            console.error(\n              \"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\\n\\nDid you accidentally put curly braces around the import?\",\n              ctor\n            ),\n          \"default\" in ctor ||\n            console.error(\n              \"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\",\n              ctor\n            ),\n          ctor.default\n        );\n      throw payload._result;\n    }\n    function resolveDispatcher() {\n      var dispatcher = ReactSharedInternals.H;\n      null === dispatcher &&\n        console.error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      return dispatcher;\n    }\n    function noop() {}\n    function enqueueTask(task) {\n      if (null === enqueueTaskImpl)\n        try {\n          var requireString = (\"require\" + Math.random()).slice(0, 7);\n          enqueueTaskImpl = (module && module[requireString]).call(\n            module,\n            \"timers\"\n          ).setImmediate;\n        } catch (_err) {\n          enqueueTaskImpl = function (callback) {\n            !1 === didWarnAboutMessageChannel &&\n              ((didWarnAboutMessageChannel = !0),\n              \"undefined\" === typeof MessageChannel &&\n                console.error(\n                  \"This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.\"\n                ));\n            var channel = new MessageChannel();\n            channel.port1.onmessage = callback;\n            channel.port2.postMessage(void 0);\n          };\n        }\n      return enqueueTaskImpl(task);\n    }\n    function aggregateErrors(errors) {\n      return 1 < errors.length && \"function\" === typeof AggregateError\n        ? new AggregateError(errors)\n        : errors[0];\n    }\n    function popActScope(prevActQueue, prevActScopeDepth) {\n      prevActScopeDepth !== actScopeDepth - 1 &&\n        console.error(\n          \"You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. \"\n        );\n      actScopeDepth = prevActScopeDepth;\n    }\n    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n      var queue = ReactSharedInternals.actQueue;\n      if (null !== queue)\n        if (0 !== queue.length)\n          try {\n            flushActQueue(queue);\n            enqueueTask(function () {\n              return recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            });\n            return;\n          } catch (error) {\n            ReactSharedInternals.thrownErrors.push(error);\n          }\n        else ReactSharedInternals.actQueue = null;\n      0 < ReactSharedInternals.thrownErrors.length\n        ? ((queue = aggregateErrors(ReactSharedInternals.thrownErrors)),\n          (ReactSharedInternals.thrownErrors.length = 0),\n          reject(queue))\n        : resolve(returnValue);\n    }\n    function flushActQueue(queue) {\n      if (!isFlushing) {\n        isFlushing = !0;\n        var i = 0;\n        try {\n          for (; i < queue.length; i++) {\n            var callback = queue[i];\n            do {\n              ReactSharedInternals.didUsePromise = !1;\n              var continuation = callback(!1);\n              if (null !== continuation) {\n                if (ReactSharedInternals.didUsePromise) {\n                  queue[i] = callback;\n                  queue.splice(0, i);\n                  return;\n                }\n                callback = continuation;\n              } else break;\n            } while (1);\n          }\n          queue.length = 0;\n        } catch (error) {\n          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);\n        } finally {\n          isFlushing = !1;\n        }\n      }\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      didWarnStateUpdateForUnmountedComponent = {},\n      ReactNoopUpdateQueue = {\n        isMounted: function () {\n          return !1;\n        },\n        enqueueForceUpdate: function (publicInstance) {\n          warnNoop(publicInstance, \"forceUpdate\");\n        },\n        enqueueReplaceState: function (publicInstance) {\n          warnNoop(publicInstance, \"replaceState\");\n        },\n        enqueueSetState: function (publicInstance) {\n          warnNoop(publicInstance, \"setState\");\n        }\n      },\n      assign = Object.assign,\n      emptyObject = {};\n    Object.freeze(emptyObject);\n    Component.prototype.isReactComponent = {};\n    Component.prototype.setState = function (partialState, callback) {\n      if (\n        \"object\" !== typeof partialState &&\n        \"function\" !== typeof partialState &&\n        null != partialState\n      )\n        throw Error(\n          \"takes an object of state variables to update or a function which returns an object of state variables.\"\n        );\n      this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n    };\n    Component.prototype.forceUpdate = function (callback) {\n      this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n    };\n    var deprecatedAPIs = {\n        isMounted: [\n          \"isMounted\",\n          \"Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.\"\n        ],\n        replaceState: [\n          \"replaceState\",\n          \"Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).\"\n        ]\n      },\n      fnName;\n    for (fnName in deprecatedAPIs)\n      deprecatedAPIs.hasOwnProperty(fnName) &&\n        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    ComponentDummy.prototype = Component.prototype;\n    deprecatedAPIs = PureComponent.prototype = new ComponentDummy();\n    deprecatedAPIs.constructor = PureComponent;\n    assign(deprecatedAPIs, Component.prototype);\n    deprecatedAPIs.isPureReactComponent = !0;\n    var isArrayImpl = Array.isArray,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals = {\n        H: null,\n        A: null,\n        T: null,\n        S: null,\n        V: null,\n        actQueue: null,\n        isBatchingLegacy: !1,\n        didScheduleLegacyUpdate: !1,\n        didUsePromise: !1,\n        thrownErrors: [],\n        getCurrentStack: null\n      },\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          },\n      specialPropKeyWarningShown,\n      didWarnAboutOldJSXRuntime;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutMaps = !1,\n      userProvidedKeyEscapeRegex = /\\/+/g,\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      reportGlobalError =\n        \"function\" === typeof reportError\n          ? reportError\n          : function (error) {\n              if (\n                \"object\" === typeof window &&\n                \"function\" === typeof window.ErrorEvent\n              ) {\n                var event = new window.ErrorEvent(\"error\", {\n                  bubbles: !0,\n                  cancelable: !0,\n                  message:\n                    \"object\" === typeof error &&\n                    null !== error &&\n                    \"string\" === typeof error.message\n                      ? String(error.message)\n                      : String(error),\n                  error: error\n                });\n                if (!window.dispatchEvent(event)) return;\n              } else if (\n                \"object\" === typeof process &&\n                \"function\" === typeof process.emit\n              ) {\n                process.emit(\"uncaughtException\", error);\n                return;\n              }\n              console.error(error);\n            },\n      didWarnAboutMessageChannel = !1,\n      enqueueTaskImpl = null,\n      actScopeDepth = 0,\n      didWarnNoAwaitAct = !1,\n      isFlushing = !1,\n      queueSeveralMicrotasks =\n        \"function\" === typeof queueMicrotask\n          ? function (callback) {\n              queueMicrotask(function () {\n                return queueMicrotask(callback);\n              });\n            }\n          : enqueueTask;\n    deprecatedAPIs = Object.freeze({\n      __proto__: null,\n      c: function (size) {\n        return resolveDispatcher().useMemoCache(size);\n      }\n    });\n    exports.Children = {\n      map: mapChildren,\n      forEach: function (children, forEachFunc, forEachContext) {\n        mapChildren(\n          children,\n          function () {\n            forEachFunc.apply(this, arguments);\n          },\n          forEachContext\n        );\n      },\n      count: function (children) {\n        var n = 0;\n        mapChildren(children, function () {\n          n++;\n        });\n        return n;\n      },\n      toArray: function (children) {\n        return (\n          mapChildren(children, function (child) {\n            return child;\n          }) || []\n        );\n      },\n      only: function (children) {\n        if (!isValidElement(children))\n          throw Error(\n            \"React.Children.only expected to receive a single React element child.\"\n          );\n        return children;\n      }\n    };\n    exports.Component = Component;\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.Profiler = REACT_PROFILER_TYPE;\n    exports.PureComponent = PureComponent;\n    exports.StrictMode = REACT_STRICT_MODE_TYPE;\n    exports.Suspense = REACT_SUSPENSE_TYPE;\n    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n      ReactSharedInternals;\n    exports.__COMPILER_RUNTIME = deprecatedAPIs;\n    exports.act = function (callback) {\n      var prevActQueue = ReactSharedInternals.actQueue,\n        prevActScopeDepth = actScopeDepth;\n      actScopeDepth++;\n      var queue = (ReactSharedInternals.actQueue =\n          null !== prevActQueue ? prevActQueue : []),\n        didAwaitActCall = !1;\n      try {\n        var result = callback();\n      } catch (error) {\n        ReactSharedInternals.thrownErrors.push(error);\n      }\n      if (0 < ReactSharedInternals.thrownErrors.length)\n        throw (\n          (popActScope(prevActQueue, prevActScopeDepth),\n          (callback = aggregateErrors(ReactSharedInternals.thrownErrors)),\n          (ReactSharedInternals.thrownErrors.length = 0),\n          callback)\n        );\n      if (\n        null !== result &&\n        \"object\" === typeof result &&\n        \"function\" === typeof result.then\n      ) {\n        var thenable = result;\n        queueSeveralMicrotasks(function () {\n          didAwaitActCall ||\n            didWarnNoAwaitAct ||\n            ((didWarnNoAwaitAct = !0),\n            console.error(\n              \"You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);\"\n            ));\n        });\n        return {\n          then: function (resolve, reject) {\n            didAwaitActCall = !0;\n            thenable.then(\n              function (returnValue) {\n                popActScope(prevActQueue, prevActScopeDepth);\n                if (0 === prevActScopeDepth) {\n                  try {\n                    flushActQueue(queue),\n                      enqueueTask(function () {\n                        return recursivelyFlushAsyncActWork(\n                          returnValue,\n                          resolve,\n                          reject\n                        );\n                      });\n                  } catch (error$0) {\n                    ReactSharedInternals.thrownErrors.push(error$0);\n                  }\n                  if (0 < ReactSharedInternals.thrownErrors.length) {\n                    var _thrownError = aggregateErrors(\n                      ReactSharedInternals.thrownErrors\n                    );\n                    ReactSharedInternals.thrownErrors.length = 0;\n                    reject(_thrownError);\n                  }\n                } else resolve(returnValue);\n              },\n              function (error) {\n                popActScope(prevActQueue, prevActScopeDepth);\n                0 < ReactSharedInternals.thrownErrors.length\n                  ? ((error = aggregateErrors(\n                      ReactSharedInternals.thrownErrors\n                    )),\n                    (ReactSharedInternals.thrownErrors.length = 0),\n                    reject(error))\n                  : reject(error);\n              }\n            );\n          }\n        };\n      }\n      var returnValue$jscomp$0 = result;\n      popActScope(prevActQueue, prevActScopeDepth);\n      0 === prevActScopeDepth &&\n        (flushActQueue(queue),\n        0 !== queue.length &&\n          queueSeveralMicrotasks(function () {\n            didAwaitActCall ||\n              didWarnNoAwaitAct ||\n              ((didWarnNoAwaitAct = !0),\n              console.error(\n                \"A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\\n\\nawait act(() => ...)\"\n              ));\n          }),\n        (ReactSharedInternals.actQueue = null));\n      if (0 < ReactSharedInternals.thrownErrors.length)\n        throw (\n          ((callback = aggregateErrors(ReactSharedInternals.thrownErrors)),\n          (ReactSharedInternals.thrownErrors.length = 0),\n          callback)\n        );\n      return {\n        then: function (resolve, reject) {\n          didAwaitActCall = !0;\n          0 === prevActScopeDepth\n            ? ((ReactSharedInternals.actQueue = queue),\n              enqueueTask(function () {\n                return recursivelyFlushAsyncActWork(\n                  returnValue$jscomp$0,\n                  resolve,\n                  reject\n                );\n              }))\n            : resolve(returnValue$jscomp$0);\n        }\n      };\n    };\n    exports.cache = function (fn) {\n      return function () {\n        return fn.apply(null, arguments);\n      };\n    };\n    exports.captureOwnerStack = function () {\n      var getCurrentStack = ReactSharedInternals.getCurrentStack;\n      return null === getCurrentStack ? null : getCurrentStack();\n    };\n    exports.cloneElement = function (element, config, children) {\n      if (null === element || void 0 === element)\n        throw Error(\n          \"The argument must be a React element, but you passed \" +\n            element +\n            \".\"\n        );\n      var props = assign({}, element.props),\n        key = element.key,\n        owner = element._owner;\n      if (null != config) {\n        var JSCompiler_inline_result;\n        a: {\n          if (\n            hasOwnProperty.call(config, \"ref\") &&\n            (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(\n              config,\n              \"ref\"\n            ).get) &&\n            JSCompiler_inline_result.isReactWarning\n          ) {\n            JSCompiler_inline_result = !1;\n            break a;\n          }\n          JSCompiler_inline_result = void 0 !== config.ref;\n        }\n        JSCompiler_inline_result && (owner = getOwner());\n        hasValidKey(config) &&\n          (checkKeyStringCoercion(config.key), (key = \"\" + config.key));\n        for (propName in config)\n          !hasOwnProperty.call(config, propName) ||\n            \"key\" === propName ||\n            \"__self\" === propName ||\n            \"__source\" === propName ||\n            (\"ref\" === propName && void 0 === config.ref) ||\n            (props[propName] = config[propName]);\n      }\n      var propName = arguments.length - 2;\n      if (1 === propName) props.children = children;\n      else if (1 < propName) {\n        JSCompiler_inline_result = Array(propName);\n        for (var i = 0; i < propName; i++)\n          JSCompiler_inline_result[i] = arguments[i + 2];\n        props.children = JSCompiler_inline_result;\n      }\n      props = ReactElement(\n        element.type,\n        key,\n        void 0,\n        void 0,\n        owner,\n        props,\n        element._debugStack,\n        element._debugTask\n      );\n      for (key = 2; key < arguments.length; key++)\n        (owner = arguments[key]),\n          isValidElement(owner) && owner._store && (owner._store.validated = 1);\n      return props;\n    };\n    exports.createContext = function (defaultValue) {\n      defaultValue = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        _currentValue: defaultValue,\n        _currentValue2: defaultValue,\n        _threadCount: 0,\n        Provider: null,\n        Consumer: null\n      };\n      defaultValue.Provider = defaultValue;\n      defaultValue.Consumer = {\n        $$typeof: REACT_CONSUMER_TYPE,\n        _context: defaultValue\n      };\n      defaultValue._currentRenderer = null;\n      defaultValue._currentRenderer2 = null;\n      return defaultValue;\n    };\n    exports.createElement = function (type, config, children) {\n      for (var i = 2; i < arguments.length; i++) {\n        var node = arguments[i];\n        isValidElement(node) && node._store && (node._store.validated = 1);\n      }\n      var propName;\n      i = {};\n      node = null;\n      if (null != config)\n        for (propName in (didWarnAboutOldJSXRuntime ||\n          !(\"__self\" in config) ||\n          \"key\" in config ||\n          ((didWarnAboutOldJSXRuntime = !0),\n          console.warn(\n            \"Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform\"\n          )),\n        hasValidKey(config) &&\n          (checkKeyStringCoercion(config.key), (node = \"\" + config.key)),\n        config))\n          hasOwnProperty.call(config, propName) &&\n            \"key\" !== propName &&\n            \"__self\" !== propName &&\n            \"__source\" !== propName &&\n            (i[propName] = config[propName]);\n      var childrenLength = arguments.length - 2;\n      if (1 === childrenLength) i.children = children;\n      else if (1 < childrenLength) {\n        for (\n          var childArray = Array(childrenLength), _i = 0;\n          _i < childrenLength;\n          _i++\n        )\n          childArray[_i] = arguments[_i + 2];\n        Object.freeze && Object.freeze(childArray);\n        i.children = childArray;\n      }\n      if (type && type.defaultProps)\n        for (propName in ((childrenLength = type.defaultProps), childrenLength))\n          void 0 === i[propName] && (i[propName] = childrenLength[propName]);\n      node &&\n        defineKeyPropWarningGetter(\n          i,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        node,\n        void 0,\n        void 0,\n        getOwner(),\n        i,\n        Error(\"react-stack-top-frame\"),\n        createTask(getTaskName(type))\n      );\n    };\n    exports.createRef = function () {\n      var refObject = { current: null };\n      Object.seal(refObject);\n      return refObject;\n    };\n    exports.forwardRef = function (render) {\n      null != render && render.$$typeof === REACT_MEMO_TYPE\n        ? console.error(\n            \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).\"\n          )\n        : \"function\" !== typeof render\n          ? console.error(\n              \"forwardRef requires a render function but was given %s.\",\n              null === render ? \"null\" : typeof render\n            )\n          : 0 !== render.length &&\n            2 !== render.length &&\n            console.error(\n              \"forwardRef render functions accept exactly two parameters: props and ref. %s\",\n              1 === render.length\n                ? \"Did you forget to use the ref parameter?\"\n                : \"Any additional parameter will be undefined.\"\n            );\n      null != render &&\n        null != render.defaultProps &&\n        console.error(\n          \"forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?\"\n        );\n      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render: render },\n        ownName;\n      Object.defineProperty(elementType, \"displayName\", {\n        enumerable: !1,\n        configurable: !0,\n        get: function () {\n          return ownName;\n        },\n        set: function (name) {\n          ownName = name;\n          render.name ||\n            render.displayName ||\n            (Object.defineProperty(render, \"name\", { value: name }),\n            (render.displayName = name));\n        }\n      });\n      return elementType;\n    };\n    exports.isValidElement = isValidElement;\n    exports.lazy = function (ctor) {\n      return {\n        $$typeof: REACT_LAZY_TYPE,\n        _payload: { _status: -1, _result: ctor },\n        _init: lazyInitializer\n      };\n    };\n    exports.memo = function (type, compare) {\n      \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE ||\n            void 0 !== type.getModuleId)) ||\n        console.error(\n          \"memo: The first argument must be a component. Instead received: %s\",\n          null === type ? \"null\" : typeof type\n        );\n      compare = {\n        $$typeof: REACT_MEMO_TYPE,\n        type: type,\n        compare: void 0 === compare ? null : compare\n      };\n      var ownName;\n      Object.defineProperty(compare, \"displayName\", {\n        enumerable: !1,\n        configurable: !0,\n        get: function () {\n          return ownName;\n        },\n        set: function (name) {\n          ownName = name;\n          type.name ||\n            type.displayName ||\n            (Object.defineProperty(type, \"name\", { value: name }),\n            (type.displayName = name));\n        }\n      });\n      return compare;\n    };\n    exports.startTransition = function (scope) {\n      var prevTransition = ReactSharedInternals.T,\n        currentTransition = {};\n      ReactSharedInternals.T = currentTransition;\n      currentTransition._updatedFibers = new Set();\n      try {\n        var returnValue = scope(),\n          onStartTransitionFinish = ReactSharedInternals.S;\n        null !== onStartTransitionFinish &&\n          onStartTransitionFinish(currentTransition, returnValue);\n        \"object\" === typeof returnValue &&\n          null !== returnValue &&\n          \"function\" === typeof returnValue.then &&\n          returnValue.then(noop, reportGlobalError);\n      } catch (error) {\n        reportGlobalError(error);\n      } finally {\n        null === prevTransition &&\n          currentTransition._updatedFibers &&\n          ((scope = currentTransition._updatedFibers.size),\n          currentTransition._updatedFibers.clear(),\n          10 < scope &&\n            console.warn(\n              \"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"\n            )),\n          (ReactSharedInternals.T = prevTransition);\n      }\n    };\n    exports.unstable_useCacheRefresh = function () {\n      return resolveDispatcher().useCacheRefresh();\n    };\n    exports.use = function (usable) {\n      return resolveDispatcher().use(usable);\n    };\n    exports.useActionState = function (action, initialState, permalink) {\n      return resolveDispatcher().useActionState(\n        action,\n        initialState,\n        permalink\n      );\n    };\n    exports.useCallback = function (callback, deps) {\n      return resolveDispatcher().useCallback(callback, deps);\n    };\n    exports.useContext = function (Context) {\n      var dispatcher = resolveDispatcher();\n      Context.$$typeof === REACT_CONSUMER_TYPE &&\n        console.error(\n          \"Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?\"\n        );\n      return dispatcher.useContext(Context);\n    };\n    exports.useDebugValue = function (value, formatterFn) {\n      return resolveDispatcher().useDebugValue(value, formatterFn);\n    };\n    exports.useDeferredValue = function (value, initialValue) {\n      return resolveDispatcher().useDeferredValue(value, initialValue);\n    };\n    exports.useEffect = function (create, createDeps, update) {\n      null == create &&\n        console.warn(\n          \"React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?\"\n        );\n      var dispatcher = resolveDispatcher();\n      if (\"function\" === typeof update)\n        throw Error(\n          \"useEffect CRUD overload is not enabled in this build of React.\"\n        );\n      return dispatcher.useEffect(create, createDeps);\n    };\n    exports.useId = function () {\n      return resolveDispatcher().useId();\n    };\n    exports.useImperativeHandle = function (ref, create, deps) {\n      return resolveDispatcher().useImperativeHandle(ref, create, deps);\n    };\n    exports.useInsertionEffect = function (create, deps) {\n      null == create &&\n        console.warn(\n          \"React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?\"\n        );\n      return resolveDispatcher().useInsertionEffect(create, deps);\n    };\n    exports.useLayoutEffect = function (create, deps) {\n      null == create &&\n        console.warn(\n          \"React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?\"\n        );\n      return resolveDispatcher().useLayoutEffect(create, deps);\n    };\n    exports.useMemo = function (create, deps) {\n      return resolveDispatcher().useMemo(create, deps);\n    };\n    exports.useOptimistic = function (passthrough, reducer) {\n      return resolveDispatcher().useOptimistic(passthrough, reducer);\n    };\n    exports.useReducer = function (reducer, initialArg, init) {\n      return resolveDispatcher().useReducer(reducer, initialArg, init);\n    };\n    exports.useRef = function (initialValue) {\n      return resolveDispatcher().useRef(initialValue);\n    };\n    exports.useState = function (initialState) {\n      return resolveDispatcher().useState(initialState);\n    };\n    exports.useSyncExternalStore = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot\n    ) {\n      return resolveDispatcher().useSyncExternalStore(\n        subscribe,\n        getSnapshot,\n        getServerSnapshot\n      );\n    };\n    exports.useTransition = function () {\n      return resolveDispatcher().useTransition();\n    };\n    exports.version = \"19.1.0-canary-029e8bd6-20250306\";\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9NQUFvTTtBQUNwTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlDQUF5QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckIsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxxQkFBcUI7QUFDekIsSUFBSSxrQkFBa0I7QUFDdEIsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSx1RUFBdUU7QUFDM0U7QUFDQSxJQUFJLDBCQUEwQjtBQUM5QixJQUFJLFdBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnTkFBZ047QUFDaE47QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5QkFBeUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQkFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QixzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLElBQUksa0JBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtEQUFrRDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsYUFBYTtBQUNsRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQixJQUFJLFlBQVk7QUFDaEI7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSxZQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYTtBQUNoRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxJQUFJLHVCQUF1QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBZ0M7QUFDcEM7QUFDQTtBQUNBLElBQUksV0FBVztBQUNmO0FBQ0E7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0EsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGFBQWE7QUFDakI7QUFDQTtBQUNBLElBQUksMkJBQTJCO0FBQy9CO0FBQ0E7QUFDQSxJQUFJLDBCQUEwQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVCQUF1QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLGtCQUFrQjtBQUN0QjtBQUNBO0FBQ0EsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0EsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGNvbXBpbGVkXFxyZWFjdFxcY2pzXFxyZWFjdC5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcobWV0aG9kTmFtZSwgaW5mbykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCIlcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlc1wiLFxuICAgICAgICAgICAgaW5mb1swXSxcbiAgICAgICAgICAgIGluZm9bMV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gbWF5YmVJdGVyYWJsZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBtYXliZUl0ZXJhYmxlID1cbiAgICAgICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICAgIG1heWJlSXRlcmFibGVbXCJAQGl0ZXJhdG9yXCJdO1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlSXRlcmFibGUgPyBtYXliZUl0ZXJhYmxlIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgICAgIHB1YmxpY0luc3RhbmNlID1cbiAgICAgICAgKChwdWJsaWNJbnN0YW5jZSA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yKSAmJlxuICAgICAgICAgIChwdWJsaWNJbnN0YW5jZS5kaXNwbGF5TmFtZSB8fCBwdWJsaWNJbnN0YW5jZS5uYW1lKSkgfHxcbiAgICAgICAgXCJSZWFjdENsYXNzXCI7XG4gICAgICB2YXIgd2FybmluZ0tleSA9IHB1YmxpY0luc3RhbmNlICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldIHx8XG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgIGNsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC5cIixcbiAgICAgICAgICBjYWxsZXJOYW1lLFxuICAgICAgICAgIHB1YmxpY0luc3RhbmNlXG4gICAgICAgICksXG4gICAgICAgIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSAhMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbiAgICBmdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGNvbnNvbGU7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZXJyb3I7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgXCJPYmplY3RcIjtcbiAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0LmNhbGwoXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRhc2tOYW1lKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSByZXR1cm4gXCI8PlwiO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRVxuICAgICAgKVxuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHJldHVybiBuYW1lID8gXCI8XCIgKyBuYW1lICsgXCI+XCIgOiBcIjwuLi4+XCI7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE93bmVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGRpc3BhdGNoZXIgPyBudWxsIDogZGlzcGF0Y2hlci5nZXRPd25lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudChcbiAgICAgIHR5cGUsXG4gICAgICBrZXksXG4gICAgICBzZWxmLFxuICAgICAgc291cmNlLFxuICAgICAgb3duZXIsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnU3RhY2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnVGFza1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1Rhc2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh0eXBlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh0eXBlKSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICAgICAgbmV3S2V5ID0gUmVhY3RFbGVtZW50KFxuICAgICAgICBvbGRFbGVtZW50LnR5cGUsXG4gICAgICAgIG5ld0tleSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIG9sZEVsZW1lbnQuX293bmVyLFxuICAgICAgICBvbGRFbGVtZW50LnByb3BzLFxuICAgICAgICBvbGRFbGVtZW50Ll9kZWJ1Z1N0YWNrLFxuICAgICAgICBvbGRFbGVtZW50Ll9kZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgICBvbGRFbGVtZW50Ll9zdG9yZSAmJlxuICAgICAgICAobmV3S2V5Ll9zdG9yZS52YWxpZGF0ZWQgPSBvbGRFbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQpO1xuICAgICAgcmV0dXJuIG5ld0tleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICAgICAgdmFyIGVzY2FwZXJMb29rdXAgPSB7IFwiPVwiOiBcIj0wXCIsIFwiOlwiOiBcIj0yXCIgfTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIFwiJFwiICtcbiAgICAgICAga2V5LnJlcGxhY2UoL1s9Ol0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAgICAgcmV0dXJuIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlbGVtZW50ICYmXG4gICAgICAgIG51bGwgIT09IGVsZW1lbnQgJiZcbiAgICAgICAgbnVsbCAhPSBlbGVtZW50LmtleVxuICAgICAgICA/IChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGVsZW1lbnQua2V5KSwgZXNjYXBlKFwiXCIgKyBlbGVtZW50LmtleSkpXG4gICAgICAgIDogaW5kZXgudG9TdHJpbmcoMzYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wJDEoKSB7fVxuICAgIGZ1bmN0aW9uIHJlc29sdmVUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoZW5hYmxlLnN0YXR1c1xuICAgICAgICAgICAgICA/IHRoZW5hYmxlLnRoZW4obm9vcCQxLCBub29wJDEpXG4gICAgICAgICAgICAgIDogKCh0aGVuYWJsZS5zdGF0dXMgPSBcInBlbmRpbmdcIiksXG4gICAgICAgICAgICAgICAgdGhlbmFibGUudGhlbihcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAodGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICh0aGVuYWJsZS5yZWFzb24gPSBlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgdGhlbmFibGUuc3RhdHVzKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcbiAgICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlIHx8IFwiYm9vbGVhblwiID09PSB0eXBlKSBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2YXIgaW52b2tlQ2FsbGJhY2sgPSAhMTtcbiAgICAgIGlmIChudWxsID09PSBjaGlsZHJlbikgaW52b2tlQ2FsbGJhY2sgPSAhMDtcbiAgICAgIGVsc2VcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgKGludm9rZUNhbGxiYWNrID0gY2hpbGRyZW4uX2luaXQpLFxuICAgICAgICAgICAgICAgICAgbWFwSW50b0FycmF5KFxuICAgICAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayhjaGlsZHJlbi5fcGF5bG9hZCksXG4gICAgICAgICAgICAgICAgICAgIGFycmF5LFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gY2hpbGRyZW47XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soaW52b2tlQ2FsbGJhY2spO1xuICAgICAgICB2YXIgY2hpbGRLZXkgPVxuICAgICAgICAgIFwiXCIgPT09IG5hbWVTb0ZhciA/IFwiLlwiICsgZ2V0RWxlbWVudEtleShpbnZva2VDYWxsYmFjaywgMCkgOiBuYW1lU29GYXI7XG4gICAgICAgIGlzQXJyYXlJbXBsKGNhbGxiYWNrKVxuICAgICAgICAgID8gKChlc2NhcGVkUHJlZml4ID0gXCJcIiksXG4gICAgICAgICAgICBudWxsICE9IGNoaWxkS2V5ICYmXG4gICAgICAgICAgICAgIChlc2NhcGVkUHJlZml4ID1cbiAgICAgICAgICAgICAgICBjaGlsZEtleS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCBcIiQmL1wiKSArIFwiL1wiKSxcbiAgICAgICAgICAgIG1hcEludG9BcnJheShjYWxsYmFjaywgYXJyYXksIGVzY2FwZWRQcmVmaXgsIFwiXCIsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgOiBudWxsICE9IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAoaXNWYWxpZEVsZW1lbnQoY2FsbGJhY2spICYmXG4gICAgICAgICAgICAgIChudWxsICE9IGNhbGxiYWNrLmtleSAmJlxuICAgICAgICAgICAgICAgICgoaW52b2tlQ2FsbGJhY2sgJiYgaW52b2tlQ2FsbGJhY2sua2V5ID09PSBjYWxsYmFjay5rZXkpIHx8XG4gICAgICAgICAgICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNhbGxiYWNrLmtleSkpLFxuICAgICAgICAgICAgICAoZXNjYXBlZFByZWZpeCA9IGNsb25lQW5kUmVwbGFjZUtleShcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4ICtcbiAgICAgICAgICAgICAgICAgIChudWxsID09IGNhbGxiYWNrLmtleSB8fFxuICAgICAgICAgICAgICAgICAgKGludm9rZUNhbGxiYWNrICYmIGludm9rZUNhbGxiYWNrLmtleSA9PT0gY2FsbGJhY2sua2V5KVxuICAgICAgICAgICAgICAgICAgICA/IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgOiAoXCJcIiArIGNhbGxiYWNrLmtleSkucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIkJi9cIlxuICAgICAgICAgICAgICAgICAgICAgICkgKyBcIi9cIikgK1xuICAgICAgICAgICAgICAgICAgY2hpbGRLZXlcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIFwiXCIgIT09IG5hbWVTb0ZhciAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT0gaW52b2tlQ2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChpbnZva2VDYWxsYmFjaykgJiZcbiAgICAgICAgICAgICAgICBudWxsID09IGludm9rZUNhbGxiYWNrLmtleSAmJlxuICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrLl9zdG9yZSAmJlxuICAgICAgICAgICAgICAgICFpbnZva2VDYWxsYmFjay5fc3RvcmUudmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgKGVzY2FwZWRQcmVmaXguX3N0b3JlLnZhbGlkYXRlZCA9IDIpLFxuICAgICAgICAgICAgICAoY2FsbGJhY2sgPSBlc2NhcGVkUHJlZml4KSksXG4gICAgICAgICAgICBhcnJheS5wdXNoKGNhbGxiYWNrKSk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaW52b2tlQ2FsbGJhY2sgPSAwO1xuICAgICAgY2hpbGRLZXkgPSBcIlwiID09PSBuYW1lU29GYXIgPyBcIi5cIiA6IG5hbWVTb0ZhciArIFwiOlwiO1xuICAgICAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAobmFtZVNvRmFyID0gY2hpbGRyZW5baV0pLFxuICAgICAgICAgICAgKHR5cGUgPSBjaGlsZEtleSArIGdldEVsZW1lbnRLZXkobmFtZVNvRmFyLCBpKSksXG4gICAgICAgICAgICAoaW52b2tlQ2FsbGJhY2sgKz0gbWFwSW50b0FycmF5KFxuICAgICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICAgIGFycmF5LFxuICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICAgKSk7XG4gICAgICBlbHNlIGlmICgoKGkgPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKSksIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGkpKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGkgPT09IGNoaWxkcmVuLmVudHJpZXMgJiZcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRNYXBzIHx8XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcIlVzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dE1hcHMgPSAhMCkpLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBpLmNhbGwoY2hpbGRyZW4pLFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgIShuYW1lU29GYXIgPSBjaGlsZHJlbi5uZXh0KCkpLmRvbmU7XG5cbiAgICAgICAgKVxuICAgICAgICAgIChuYW1lU29GYXIgPSBuYW1lU29GYXIudmFsdWUpLFxuICAgICAgICAgICAgKHR5cGUgPSBjaGlsZEtleSArIGdldEVsZW1lbnRLZXkobmFtZVNvRmFyLCBpKyspKSxcbiAgICAgICAgICAgIChpbnZva2VDYWxsYmFjayArPSBtYXBJbnRvQXJyYXkoXG4gICAgICAgICAgICAgIG5hbWVTb0ZhcixcbiAgICAgICAgICAgICAgYXJyYXksXG4gICAgICAgICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICApKTtcbiAgICAgIGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGUpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkcmVuLnRoZW4pXG4gICAgICAgICAgcmV0dXJuIG1hcEludG9BcnJheShcbiAgICAgICAgICAgIHJlc29sdmVUaGVuYWJsZShjaGlsZHJlbiksXG4gICAgICAgICAgICBhcnJheSxcbiAgICAgICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGFycmF5ID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICtcbiAgICAgICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSBhcnJheVxuICAgICAgICAgICAgICA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgICAgOiBhcnJheSkgK1xuICAgICAgICAgICAgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgIGlmIChudWxsID09IGNoaWxkcmVuKSByZXR1cm4gY2hpbGRyZW47XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCBcIlwiLCBcIlwiLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gICAgICBpZiAoLTEgPT09IHBheWxvYWQuX3N0YXR1cykge1xuICAgICAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICAgICAgY3RvciA9IGN0b3IoKTtcbiAgICAgICAgY3Rvci50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgICAgICAgIGlmICgwID09PSBwYXlsb2FkLl9zdGF0dXMgfHwgLTEgPT09IHBheWxvYWQuX3N0YXR1cylcbiAgICAgICAgICAgICAgKHBheWxvYWQuX3N0YXR1cyA9IDEpLCAocGF5bG9hZC5fcmVzdWx0ID0gbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKDAgPT09IHBheWxvYWQuX3N0YXR1cyB8fCAtMSA9PT0gcGF5bG9hZC5fc3RhdHVzKVxuICAgICAgICAgICAgICAocGF5bG9hZC5fc3RhdHVzID0gMiksIChwYXlsb2FkLl9yZXN1bHQgPSBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICAtMSA9PT0gcGF5bG9hZC5fc3RhdHVzICYmXG4gICAgICAgICAgKChwYXlsb2FkLl9zdGF0dXMgPSAwKSwgKHBheWxvYWQuX3Jlc3VsdCA9IGN0b3IpKTtcbiAgICAgIH1cbiAgICAgIGlmICgxID09PSBwYXlsb2FkLl9zdGF0dXMpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gY3RvciAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiBJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gIGNvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXBvcnQoJy4vTXlDb21wb25lbnQnKSlcXG5cXG5EaWQgeW91IGFjY2lkZW50YWxseSBwdXQgY3VybHkgYnJhY2VzIGFyb3VuZCB0aGUgaW1wb3J0P1wiLFxuICAgICAgICAgICAgICBjdG9yXG4gICAgICAgICAgICApLFxuICAgICAgICAgIFwiZGVmYXVsdFwiIGluIGN0b3IgfHxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwibGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICBjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wb3J0KCcuL015Q29tcG9uZW50JykpXCIsXG4gICAgICAgICAgICAgIGN0b3JcbiAgICAgICAgICAgICksXG4gICAgICAgICAgY3Rvci5kZWZhdWx0XG4gICAgICAgICk7XG4gICAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgbnVsbCA9PT0gZGlzcGF0Y2hlciAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZVRhc2sodGFzaykge1xuICAgICAgaWYgKG51bGwgPT09IGVucXVldWVUYXNrSW1wbClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmVxdWlyZVN0cmluZyA9IChcInJlcXVpcmVcIiArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDAsIDcpO1xuICAgICAgICAgIGVucXVldWVUYXNrSW1wbCA9IChtb2R1bGUgJiYgbW9kdWxlW3JlcXVpcmVTdHJpbmddKS5jYWxsKFxuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICAgICAgXCJ0aW1lcnNcIlxuICAgICAgICAgICkuc2V0SW1tZWRpYXRlO1xuICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAhMSA9PT0gZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgJiZcbiAgICAgICAgICAgICAgKChkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9ICEwKSxcbiAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIE1lc3NhZ2VDaGFubmVsICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IGhhdmUgYSBNZXNzYWdlQ2hhbm5lbCBpbXBsZW1lbnRhdGlvbiwgc28gZW5xdWV1aW5nIHRhc2tzIHZpYSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aWxsIGZhaWwuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMgaWYgeW91IGVuY291bnRlciB0aGlzIHdhcm5pbmcuXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSh2b2lkIDApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBlbnF1ZXVlVGFza0ltcGwodGFzayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFnZ3JlZ2F0ZUVycm9ycyhlcnJvcnMpIHtcbiAgICAgIHJldHVybiAxIDwgZXJyb3JzLmxlbmd0aCAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBBZ2dyZWdhdGVFcnJvclxuICAgICAgICA/IG5ldyBBZ2dyZWdhdGVFcnJvcihlcnJvcnMpXG4gICAgICAgIDogZXJyb3JzWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKSB7XG4gICAgICBwcmV2QWN0U2NvcGVEZXB0aCAhPT0gYWN0U2NvcGVEZXB0aCAtIDEgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIllvdSBzZWVtIHRvIGhhdmUgb3ZlcmxhcHBpbmcgYWN0KCkgY2FsbHMsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gQmUgc3VyZSB0byBhd2FpdCBwcmV2aW91cyBhY3QoKSBjYWxscyBiZWZvcmUgbWFraW5nIGEgbmV3IG9uZS4gXCJcbiAgICAgICAgKTtcbiAgICAgIGFjdFNjb3BlRGVwdGggPSBwcmV2QWN0U2NvcGVEZXB0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZTtcbiAgICAgIGlmIChudWxsICE9PSBxdWV1ZSlcbiAgICAgICAgaWYgKDAgIT09IHF1ZXVlLmxlbmd0aClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSk7XG4gICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPSBudWxsO1xuICAgICAgMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGhcbiAgICAgICAgPyAoKHF1ZXVlID0gYWdncmVnYXRlRXJyb3JzKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgcmVqZWN0KHF1ZXVlKSlcbiAgICAgICAgOiByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hBY3RRdWV1ZShxdWV1ZSkge1xuICAgICAgaWYgKCFpc0ZsdXNoaW5nKSB7XG4gICAgICAgIGlzRmx1c2hpbmcgPSAhMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5kaWRVc2VQcm9taXNlID0gITE7XG4gICAgICAgICAgICAgIHZhciBjb250aW51YXRpb24gPSBjYWxsYmFjayghMSk7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSBjb250aW51YXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuZGlkVXNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgcXVldWVbaV0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjb250aW51YXRpb247XG4gICAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpICsgMSksIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpc0ZsdXNoaW5nID0gITE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChFcnJvcigpKTtcbiAgICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgICB2YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksXG4gICAgICBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3IsXG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fSxcbiAgICAgIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAgICAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIFwiZm9yY2VVcGRhdGVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBcInJlcGxhY2VTdGF0ZVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgXCJzZXRTdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBlbXB0eU9iamVjdCA9IHt9O1xuICAgIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2YgcGFydGlhbFN0YXRlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHBhcnRpYWxTdGF0ZSAmJlxuICAgICAgICBudWxsICE9IHBhcnRpYWxTdGF0ZVxuICAgICAgKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcInRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiXG4gICAgICAgICk7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIFwic2V0U3RhdGVcIik7XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCBcImZvcmNlVXBkYXRlXCIpO1xuICAgIH07XG4gICAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgICAgICBpc01vdW50ZWQ6IFtcbiAgICAgICAgICBcImlzTW91bnRlZFwiLFxuICAgICAgICAgIFwiSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuXCJcbiAgICAgICAgXSxcbiAgICAgICAgcmVwbGFjZVN0YXRlOiBbXG4gICAgICAgICAgXCJyZXBsYWNlU3RhdGVcIixcbiAgICAgICAgICBcIlJlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuXCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGZuTmFtZTtcbiAgICBmb3IgKGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcylcbiAgICAgIGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkgJiZcbiAgICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgICBkZXByZWNhdGVkQVBJcyA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG4gICAgZGVwcmVjYXRlZEFQSXMuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50O1xuICAgIGFzc2lnbihkZXByZWNhdGVkQVBJcywgQ29tcG9uZW50LnByb3RvdHlwZSk7XG4gICAgZGVwcmVjYXRlZEFQSXMuaXNQdXJlUmVhY3RDb21wb25lbnQgPSAhMDtcbiAgICB2YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcbiAgICAgICAgSDogbnVsbCxcbiAgICAgICAgQTogbnVsbCxcbiAgICAgICAgVDogbnVsbCxcbiAgICAgICAgUzogbnVsbCxcbiAgICAgICAgVjogbnVsbCxcbiAgICAgICAgYWN0UXVldWU6IG51bGwsXG4gICAgICAgIGlzQmF0Y2hpbmdMZWdhY3k6ICExLFxuICAgICAgICBkaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZTogITEsXG4gICAgICAgIGRpZFVzZVByb21pc2U6ICExLFxuICAgICAgICB0aHJvd25FcnJvcnM6IFtdLFxuICAgICAgICBnZXRDdXJyZW50U3RhY2s6IG51bGxcbiAgICAgIH0sXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBjcmVhdGVUYXNrID0gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgID8gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSxcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLFxuICAgICAgZGlkV2FybkFib3V0T2xkSlNYUnVudGltZTtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRNYXBzID0gITEsXG4gICAgICB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2csXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICByZXBvcnRHbG9iYWxFcnJvciA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlcG9ydEVycm9yXG4gICAgICAgICAgPyByZXBvcnRFcnJvclxuICAgICAgICAgIDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygd2luZG93ICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygd2luZG93LkVycm9yRXZlbnRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IHdpbmRvdy5FcnJvckV2ZW50KFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgYnViYmxlczogITAsXG4gICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCkpIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHByb2Nlc3MuZW1pdFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgIGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID0gITEsXG4gICAgICBlbnF1ZXVlVGFza0ltcGwgPSBudWxsLFxuICAgICAgYWN0U2NvcGVEZXB0aCA9IDAsXG4gICAgICBkaWRXYXJuTm9Bd2FpdEFjdCA9ICExLFxuICAgICAgaXNGbHVzaGluZyA9ICExLFxuICAgICAgcXVldWVTZXZlcmFsTWljcm90YXNrcyA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHF1ZXVlTWljcm90YXNrXG4gICAgICAgICAgPyBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxdWV1ZU1pY3JvdGFzayhjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIDogZW5xdWV1ZVRhc2s7XG4gICAgZGVwcmVjYXRlZEFQSXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgIGM6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZU1lbW9DYWNoZShzaXplKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBleHBvcnRzLkNoaWxkcmVuID0ge1xuICAgICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIChjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gICAgICAgIG1hcENoaWxkcmVuKFxuICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb3JFYWNoQ29udGV4dFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIGNvdW50OiBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSxcbiAgICAgIHRvQXJyYXk6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICB9KSB8fCBbXVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIG9ubHk6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLlByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgICBleHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuICAgIGV4cG9ydHMuU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG4gICAgZXhwb3J0cy5TdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG4gICAgZXhwb3J0cy5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUgPVxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG4gICAgZXhwb3J0cy5fX0NPTVBJTEVSX1JVTlRJTUUgPSBkZXByZWNhdGVkQVBJcztcbiAgICBleHBvcnRzLmFjdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdmFyIHByZXZBY3RRdWV1ZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlLFxuICAgICAgICBwcmV2QWN0U2NvcGVEZXB0aCA9IGFjdFNjb3BlRGVwdGg7XG4gICAgICBhY3RTY29wZURlcHRoKys7XG4gICAgICB2YXIgcXVldWUgPSAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPVxuICAgICAgICAgIG51bGwgIT09IHByZXZBY3RRdWV1ZSA/IHByZXZBY3RRdWV1ZSA6IFtdKSxcbiAgICAgICAgZGlkQXdhaXRBY3RDYWxsID0gITE7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGlmICgwIDwgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgKFxuICAgICAgICAgIChwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKSxcbiAgICAgICAgICAoY2FsbGJhY2sgPSBhZ2dyZWdhdGVFcnJvcnMoUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzKSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGggPSAwKSxcbiAgICAgICAgICBjYWxsYmFjaylcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gcmVzdWx0ICYmXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXN1bHQgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVzdWx0LnRoZW5cbiAgICAgICkge1xuICAgICAgICB2YXIgdGhlbmFibGUgPSByZXN1bHQ7XG4gICAgICAgIHF1ZXVlU2V2ZXJhbE1pY3JvdGFza3MoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpZEF3YWl0QWN0Q2FsbCB8fFxuICAgICAgICAgICAgZGlkV2Fybk5vQXdhaXRBY3QgfHxcbiAgICAgICAgICAgICgoZGlkV2Fybk5vQXdhaXRBY3QgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIllvdSBjYWxsZWQgYWN0KGFzeW5jICgpID0+IC4uLikgd2l0aG91dCBhd2FpdC4gVGhpcyBjb3VsZCBsZWFkIHRvIHVuZXhwZWN0ZWQgdGVzdGluZyBiZWhhdmlvdXIsIGludGVybGVhdmluZyBtdWx0aXBsZSBhY3QgY2FsbHMgYW5kIG1peGluZyB0aGVpciBzY29wZXMuIFlvdSBzaG91bGQgLSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKTtcIlxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGRpZEF3YWl0QWN0Q2FsbCA9ICEwO1xuICAgICAgICAgICAgdGhlbmFibGUudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHByZXZBY3RTY29wZURlcHRoKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yJDApIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLnB1c2goZXJyb3IkMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aHJvd25FcnJvciA9IGFnZ3JlZ2F0ZUVycm9ycyhcbiAgICAgICAgICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChfdGhyb3duRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAgICAgICAgICAgMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gKChlcnJvciA9IGFnZ3JlZ2F0ZUVycm9ycyhcbiAgICAgICAgICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcikpXG4gICAgICAgICAgICAgICAgICA6IHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHJldHVyblZhbHVlJGpzY29tcCQwID0gcmVzdWx0O1xuICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAwID09PSBwcmV2QWN0U2NvcGVEZXB0aCAmJlxuICAgICAgICAoZmx1c2hBY3RRdWV1ZShxdWV1ZSksXG4gICAgICAgIDAgIT09IHF1ZXVlLmxlbmd0aCAmJlxuICAgICAgICAgIHF1ZXVlU2V2ZXJhbE1pY3JvdGFza3MoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGlkQXdhaXRBY3RDYWxsIHx8XG4gICAgICAgICAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0IHx8XG4gICAgICAgICAgICAgICgoZGlkV2Fybk5vQXdhaXRBY3QgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudCBzdXNwZW5kZWQgaW5zaWRlIGFuIGBhY3RgIHNjb3BlLCBidXQgdGhlIGBhY3RgIGNhbGwgd2FzIG5vdCBhd2FpdGVkLiBXaGVuIHRlc3RpbmcgUmVhY3QgY29tcG9uZW50cyB0aGF0IGRlcGVuZCBvbiBhc3luY2hyb25vdXMgZGF0YSwgeW91IG11c3QgYXdhaXQgdGhlIHJlc3VsdDpcXG5cXG5hd2FpdCBhY3QoKCkgPT4gLi4uKVwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPSBudWxsKSk7XG4gICAgICBpZiAoMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGgpXG4gICAgICAgIHRocm93IChcbiAgICAgICAgICAoKGNhbGxiYWNrID0gYWdncmVnYXRlRXJyb3JzKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgY2FsbGJhY2spXG4gICAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgZGlkQXdhaXRBY3RDYWxsID0gITA7XG4gICAgICAgICAgMCA9PT0gcHJldkFjdFNjb3BlRGVwdGhcbiAgICAgICAgICAgID8gKChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSA9IHF1ZXVlKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZVRhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKFxuICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA6IHJlc29sdmUocmV0dXJuVmFsdWUkanNjb21wJDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jYWNoZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jYXB0dXJlT3duZXJTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBnZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZ2V0Q3VycmVudFN0YWNrID8gbnVsbCA6IGdldEN1cnJlbnRTdGFjaygpO1xuICAgIH07XG4gICAgZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICAgICAgaWYgKG51bGwgPT09IGVsZW1lbnQgfHwgdm9pZCAwID09PSBlbGVtZW50KVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgK1xuICAgICAgICAgICAgZWxlbWVudCArXG4gICAgICAgICAgICBcIi5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKSxcbiAgICAgICAga2V5ID0gZWxlbWVudC5rZXksXG4gICAgICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICBpZiAobnVsbCAhPSBjb25maWcpIHtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgYToge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcInJlZlwiKSAmJlxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgXCJyZWZcIlxuICAgICAgICAgICAgKS5nZXQpICYmXG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuaXNSZWFjdFdhcm5pbmdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gdm9pZCAwICE9PSBjb25maWcucmVmO1xuICAgICAgICB9XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCAmJiAob3duZXIgPSBnZXRPd25lcigpKTtcbiAgICAgICAgaGFzVmFsaWRLZXkoY29uZmlnKSAmJlxuICAgICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoa2V5ID0gXCJcIiArIGNvbmZpZy5rZXkpKTtcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpXG4gICAgICAgICAgIWhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgfHxcbiAgICAgICAgICAgIFwia2V5XCIgPT09IHByb3BOYW1lIHx8XG4gICAgICAgICAgICBcIl9fc2VsZlwiID09PSBwcm9wTmFtZSB8fFxuICAgICAgICAgICAgXCJfX3NvdXJjZVwiID09PSBwcm9wTmFtZSB8fFxuICAgICAgICAgICAgKFwicmVmXCIgPT09IHByb3BOYW1lICYmIHZvaWQgMCA9PT0gY29uZmlnLnJlZikgfHxcbiAgICAgICAgICAgIChwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgaWYgKDEgPT09IHByb3BOYW1lKSBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgZWxzZSBpZiAoMSA8IHByb3BOYW1lKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IEFycmF5KHByb3BOYW1lKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wTmFtZTsgaSsrKVxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgICAgIHByb3BzLmNoaWxkcmVuID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBSZWFjdEVsZW1lbnQoXG4gICAgICAgIGVsZW1lbnQudHlwZSxcbiAgICAgICAga2V5LFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgb3duZXIsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBlbGVtZW50Ll9kZWJ1Z1N0YWNrLFxuICAgICAgICBlbGVtZW50Ll9kZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgICBmb3IgKGtleSA9IDI7IGtleSA8IGFyZ3VtZW50cy5sZW5ndGg7IGtleSsrKVxuICAgICAgICAob3duZXIgPSBhcmd1bWVudHNba2V5XSksXG4gICAgICAgICAgaXNWYWxpZEVsZW1lbnQob3duZXIpICYmIG93bmVyLl9zdG9yZSAmJiAob3duZXIuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgZGVmYXVsdFZhbHVlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAgICAgUHJvdmlkZXI6IG51bGwsXG4gICAgICAgIENvbnN1bWVyOiBudWxsXG4gICAgICB9O1xuICAgICAgZGVmYXVsdFZhbHVlLlByb3ZpZGVyID0gZGVmYXVsdFZhbHVlO1xuICAgICAgZGVmYXVsdFZhbHVlLkNvbnN1bWVyID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OU1VNRVJfVFlQRSxcbiAgICAgICAgX2NvbnRleHQ6IGRlZmF1bHRWYWx1ZVxuICAgICAgfTtcbiAgICAgIGRlZmF1bHRWYWx1ZS5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICAgIGRlZmF1bHRWYWx1ZS5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpc1ZhbGlkRWxlbWVudChub2RlKSAmJiBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcE5hbWU7XG4gICAgICBpID0ge307XG4gICAgICBub2RlID0gbnVsbDtcbiAgICAgIGlmIChudWxsICE9IGNvbmZpZylcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiAoZGlkV2FybkFib3V0T2xkSlNYUnVudGltZSB8fFxuICAgICAgICAgICEoXCJfX3NlbGZcIiBpbiBjb25maWcpIHx8XG4gICAgICAgICAgXCJrZXlcIiBpbiBjb25maWcgfHxcbiAgICAgICAgICAoKGRpZFdhcm5BYm91dE9sZEpTWFJ1bnRpbWUgPSAhMCksXG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJZb3VyIGFwcCAob3Igb25lIG9mIGl0cyBkZXBlbmRlbmNpZXMpIGlzIHVzaW5nIGFuIG91dGRhdGVkIEpTWCB0cmFuc2Zvcm0uIFVwZGF0ZSB0byB0aGUgbW9kZXJuIEpTWCB0cmFuc2Zvcm0gZm9yIGZhc3RlciBwZXJmb3JtYW5jZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9uZXctanN4LXRyYW5zZm9ybVwiXG4gICAgICAgICAgKSksXG4gICAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KSwgKG5vZGUgPSBcIlwiICsgY29uZmlnLmtleSkpLFxuICAgICAgICBjb25maWcpKVxuICAgICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiZcbiAgICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmXG4gICAgICAgICAgICBcIl9fc2VsZlwiICE9PSBwcm9wTmFtZSAmJlxuICAgICAgICAgICAgXCJfX3NvdXJjZVwiICE9PSBwcm9wTmFtZSAmJlxuICAgICAgICAgICAgKGlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICAgIGlmICgxID09PSBjaGlsZHJlbkxlbmd0aCkgaS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgZWxzZSBpZiAoMSA8IGNoaWxkcmVuTGVuZ3RoKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCksIF9pID0gMDtcbiAgICAgICAgICBfaSA8IGNoaWxkcmVuTGVuZ3RoO1xuICAgICAgICAgIF9pKytcbiAgICAgICAgKVxuICAgICAgICAgIGNoaWxkQXJyYXlbX2ldID0gYXJndW1lbnRzW19pICsgMl07XG4gICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgICAgaS5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcylcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiAoKGNoaWxkcmVuTGVuZ3RoID0gdHlwZS5kZWZhdWx0UHJvcHMpLCBjaGlsZHJlbkxlbmd0aCkpXG4gICAgICAgICAgdm9pZCAwID09PSBpW3Byb3BOYW1lXSAmJiAoaVtwcm9wTmFtZV0gPSBjaGlsZHJlbkxlbmd0aFtwcm9wTmFtZV0pO1xuICAgICAgbm9kZSAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBpLFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGdldE93bmVyKCksXG4gICAgICAgIGksXG4gICAgICAgIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpLFxuICAgICAgICBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKHR5cGUpKVxuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlZk9iamVjdCA9IHsgY3VycmVudDogbnVsbCB9O1xuICAgICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgICAgIHJldHVybiByZWZPYmplY3Q7XG4gICAgfTtcbiAgICBleHBvcnRzLmZvcndhcmRSZWYgPSBmdW5jdGlvbiAocmVuZGVyKSB7XG4gICAgICBudWxsICE9IHJlbmRlciAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRVxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gIGNvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSBtZW1vKGZvcndhcmRSZWYoLi4uKSkuXCJcbiAgICAgICAgICApXG4gICAgICAgIDogXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcmVuZGVyXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy5cIixcbiAgICAgICAgICAgICAgbnVsbCA9PT0gcmVuZGVyID8gXCJudWxsXCIgOiB0eXBlb2YgcmVuZGVyXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiAwICE9PSByZW5kZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAyICE9PSByZW5kZXIubGVuZ3RoICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXNcIixcbiAgICAgICAgICAgICAgMSA9PT0gcmVuZGVyLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gXCJEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/XCJcbiAgICAgICAgICAgICAgICA6IFwiQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgbnVsbCAhPSByZW5kZXIgJiZcbiAgICAgICAgbnVsbCAhPSByZW5kZXIuZGVmYXVsdFByb3BzICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgZGVmYXVsdFByb3BzLiBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50P1wiXG4gICAgICAgICk7XG4gICAgICB2YXIgZWxlbWVudFR5cGUgPSB7ICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLCByZW5kZXI6IHJlbmRlciB9LFxuICAgICAgICBvd25OYW1lO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgb3duTmFtZSA9IG5hbWU7XG4gICAgICAgICAgcmVuZGVyLm5hbWUgfHxcbiAgICAgICAgICAgIHJlbmRlci5kaXNwbGF5TmFtZSB8fFxuICAgICAgICAgICAgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZW5kZXIsIFwibmFtZVwiLCB7IHZhbHVlOiBuYW1lIH0pLFxuICAgICAgICAgICAgKHJlbmRlci5kaXNwbGF5TmFtZSA9IG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxlbWVudFR5cGU7XG4gICAgfTtcbiAgICBleHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG4gICAgZXhwb3J0cy5sYXp5ID0gZnVuY3Rpb24gKGN0b3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgICAgIF9wYXlsb2FkOiB7IF9zdGF0dXM6IC0xLCBfcmVzdWx0OiBjdG9yIH0sXG4gICAgICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgICAgIH07XG4gICAgfTtcbiAgICBleHBvcnRzLm1lbW8gPSBmdW5jdGlvbiAodHlwZSwgY29tcGFyZSkge1xuICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fFxuICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgfHxcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZS5nZXRNb2R1bGVJZCkpIHx8XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCByZWNlaXZlZDogJXNcIixcbiAgICAgICAgICBudWxsID09PSB0eXBlID8gXCJudWxsXCIgOiB0eXBlb2YgdHlwZVxuICAgICAgICApO1xuICAgICAgY29tcGFyZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgY29tcGFyZTogdm9pZCAwID09PSBjb21wYXJlID8gbnVsbCA6IGNvbXBhcmVcbiAgICAgIH07XG4gICAgICB2YXIgb3duTmFtZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb21wYXJlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgb3duTmFtZSA9IG5hbWU7XG4gICAgICAgICAgdHlwZS5uYW1lIHx8XG4gICAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lIHx8XG4gICAgICAgICAgICAoT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwibmFtZVwiLCB7IHZhbHVlOiBuYW1lIH0pLFxuICAgICAgICAgICAgKHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgfTtcbiAgICBleHBvcnRzLnN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24gPSB7fTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBjdXJyZW50VHJhbnNpdGlvbjtcbiAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gc2NvcGUoKSxcbiAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgICAgIG51bGwgIT09IG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICYmXG4gICAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlICYmXG4gICAgICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuICYmXG4gICAgICAgICAgcmV0dXJuVmFsdWUudGhlbihub29wLCByZXBvcnRHbG9iYWxFcnJvcik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBudWxsID09PSBwcmV2VHJhbnNpdGlvbiAmJlxuICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzICYmXG4gICAgICAgICAgKChzY29wZSA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemUpLFxuICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCksXG4gICAgICAgICAgMTAgPCBzY29wZSAmJlxuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcIkRldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLlwiXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfdXNlQ2FjaGVSZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlQ2FjaGVSZWZyZXNoKCk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZSA9IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZSh1c2FibGUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VBY3Rpb25TdGF0ZShcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBpbml0aWFsU3RhdGUsXG4gICAgICAgIHBlcm1hbGlua1xuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlQ29udGV4dCA9IGZ1bmN0aW9uIChDb250ZXh0KSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICBDb250ZXh0LiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBidWdzLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/XCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZURlYnVnVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZURlZmVycmVkVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRWZmZWN0ID0gZnVuY3Rpb24gKGNyZWF0ZSwgY3JlYXRlRGVwcywgdXBkYXRlKSB7XG4gICAgICBudWxsID09IGNyZWF0ZSAmJlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJSZWFjdCBIb29rIHVzZUVmZmVjdCByZXF1aXJlcyBhbiBlZmZlY3QgY2FsbGJhY2suIERpZCB5b3UgZm9yZ2V0IHRvIHBhc3MgYSBjYWxsYmFjayB0byB0aGUgaG9vaz9cIlxuICAgICAgICApO1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVwZGF0ZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJ1c2VFZmZlY3QgQ1JVRCBvdmVybG9hZCBpcyBub3QgZW5hYmxlZCBpbiB0aGlzIGJ1aWxkIG9mIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBjcmVhdGVEZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VJZCgpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlSW5zZXJ0aW9uRWZmZWN0ID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgbnVsbCA9PSBjcmVhdGUgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiUmVhY3QgSG9vayB1c2VJbnNlcnRpb25FZmZlY3QgcmVxdWlyZXMgYW4gZWZmZWN0IGNhbGxiYWNrLiBEaWQgeW91IGZvcmdldCB0byBwYXNzIGEgY2FsbGJhY2sgdG8gdGhlIGhvb2s/XCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VMYXlvdXRFZmZlY3QgPSBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBudWxsID09IGNyZWF0ZSAmJlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJSZWFjdCBIb29rIHVzZUxheW91dEVmZmVjdCByZXF1aXJlcyBhbiBlZmZlY3QgY2FsbGJhY2suIERpZCB5b3UgZm9yZ2V0IHRvIHBhc3MgYSBjYWxsYmFjayB0byB0aGUgaG9vaz9cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZU1lbW8gPSBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VSZWR1Y2VyID0gZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZVJlZiA9IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZVJlZihpbml0aWFsVmFsdWUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VTdGF0ZSA9IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gZnVuY3Rpb24gKFxuICAgICAgc3Vic2NyaWJlLFxuICAgICAgZ2V0U25hcHNob3QsXG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlVHJhbnNpdGlvbigpO1xuICAgIH07XG4gICAgZXhwb3J0cy52ZXJzaW9uID0gXCIxOS4xLjAtY2FuYXJ5LTAyOWU4YmQ2LTIwMjUwMzA2XCI7XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AoRXJyb3IoKSk7XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react/cjs/react.development.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/react/index.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"(rsc)/./node_modules/next/dist/compiled/react/cjs/react.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxnSkFBc0Q7QUFDeEQiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxccmVhY3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/react/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/compiled/ua-parser-js/ua-parser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/ua-parser-js/ua-parser.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;(()=>{var i={226:function(i,e){(function(o,a){\"use strict\";var r=\"1.0.35\",t=\"\",n=\"?\",s=\"function\",b=\"undefined\",w=\"object\",l=\"string\",d=\"major\",c=\"model\",u=\"name\",p=\"type\",m=\"vendor\",f=\"version\",h=\"architecture\",v=\"console\",g=\"mobile\",k=\"tablet\",x=\"smarttv\",_=\"wearable\",y=\"embedded\",q=350;var T=\"Amazon\",S=\"Apple\",z=\"ASUS\",N=\"BlackBerry\",A=\"Browser\",C=\"Chrome\",E=\"Edge\",O=\"Firefox\",U=\"Google\",j=\"Huawei\",P=\"LG\",R=\"Microsoft\",M=\"Motorola\",B=\"Opera\",V=\"Samsung\",D=\"Sharp\",I=\"Sony\",W=\"Viera\",F=\"Xiaomi\",G=\"Zebra\",H=\"Facebook\",L=\"Chromium OS\",Z=\"Mac OS\";var extend=function(i,e){var o={};for(var a in i){if(e[a]&&e[a].length%2===0){o[a]=e[a].concat(i[a])}else{o[a]=i[a]}}return o},enumerize=function(i){var e={};for(var o=0;o<i.length;o++){e[i[o].toUpperCase()]=i[o]}return e},has=function(i,e){return typeof i===l?lowerize(e).indexOf(lowerize(i))!==-1:false},lowerize=function(i){return i.toLowerCase()},majorize=function(i){return typeof i===l?i.replace(/[^\\d\\.]/g,t).split(\".\")[0]:a},trim=function(i,e){if(typeof i===l){i=i.replace(/^\\s\\s*/,t);return typeof e===b?i:i.substring(0,q)}};var rgxMapper=function(i,e){var o=0,r,t,n,b,l,d;while(o<e.length&&!l){var c=e[o],u=e[o+1];r=t=0;while(r<c.length&&!l){if(!c[r]){break}l=c[r++].exec(i);if(!!l){for(n=0;n<u.length;n++){d=l[++t];b=u[n];if(typeof b===w&&b.length>0){if(b.length===2){if(typeof b[1]==s){this[b[0]]=b[1].call(this,d)}else{this[b[0]]=b[1]}}else if(b.length===3){if(typeof b[1]===s&&!(b[1].exec&&b[1].test)){this[b[0]]=d?b[1].call(this,d,b[2]):a}else{this[b[0]]=d?d.replace(b[1],b[2]):a}}else if(b.length===4){this[b[0]]=d?b[3].call(this,d.replace(b[1],b[2])):a}}else{this[b]=d?d:a}}}}o+=2}},strMapper=function(i,e){for(var o in e){if(typeof e[o]===w&&e[o].length>0){for(var r=0;r<e[o].length;r++){if(has(e[o][r],i)){return o===n?a:o}}}else if(has(e[o],i)){return o===n?a:o}}return i};var $={\"1.0\":\"/8\",1.2:\"/1\",1.3:\"/3\",\"2.0\":\"/412\",\"2.0.2\":\"/416\",\"2.0.3\":\"/417\",\"2.0.4\":\"/419\",\"?\":\"/\"},X={ME:\"4.90\",\"NT 3.11\":\"NT3.51\",\"NT 4.0\":\"NT4.0\",2e3:\"NT 5.0\",XP:[\"NT 5.1\",\"NT 5.2\"],Vista:\"NT 6.0\",7:\"NT 6.1\",8:\"NT 6.2\",8.1:\"NT 6.3\",10:[\"NT 6.4\",\"NT 10.0\"],RT:\"ARM\"};var K={browser:[[/\\b(?:crmo|crios)\\/([\\w\\.]+)/i],[f,[u,\"Chrome\"]],[/edg(?:e|ios|a)?\\/([\\w\\.]+)/i],[f,[u,\"Edge\"]],[/(opera mini)\\/([-\\w\\.]+)/i,/(opera [mobiletab]{3,6})\\b.+version\\/([-\\w\\.]+)/i,/(opera)(?:.+version\\/|[\\/ ]+)([\\w\\.]+)/i],[u,f],[/opios[\\/ ]+([\\w\\.]+)/i],[f,[u,B+\" Mini\"]],[/\\bopr\\/([\\w\\.]+)/i],[f,[u,B]],[/(kindle)\\/([\\w\\.]+)/i,/(lunascape|maxthon|netfront|jasmine|blazer)[\\/ ]?([\\w\\.]*)/i,/(avant |iemobile|slim)(?:browser)?[\\/ ]?([\\w\\.]*)/i,/(ba?idubrowser)[\\/ ]?([\\w\\.]+)/i,/(?:ms|\\()(ie) ([\\w\\.]+)/i,/(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\\/([-\\w\\.]+)/i,/(heytap|ovi)browser\\/([\\d\\.]+)/i,/(weibo)__([\\d\\.]+)/i],[u,f],[/(?:\\buc? ?browser|(?:juc.+)ucweb)[\\/ ]?([\\w\\.]+)/i],[f,[u,\"UC\"+A]],[/microm.+\\bqbcore\\/([\\w\\.]+)/i,/\\bqbcore\\/([\\w\\.]+).+microm/i],[f,[u,\"WeChat(Win) Desktop\"]],[/micromessenger\\/([\\w\\.]+)/i],[f,[u,\"WeChat\"]],[/konqueror\\/([\\w\\.]+)/i],[f,[u,\"Konqueror\"]],[/trident.+rv[: ]([\\w\\.]{1,9})\\b.+like gecko/i],[f,[u,\"IE\"]],[/ya(?:search)?browser\\/([\\w\\.]+)/i],[f,[u,\"Yandex\"]],[/(avast|avg)\\/([\\w\\.]+)/i],[[u,/(.+)/,\"$1 Secure \"+A],f],[/\\bfocus\\/([\\w\\.]+)/i],[f,[u,O+\" Focus\"]],[/\\bopt\\/([\\w\\.]+)/i],[f,[u,B+\" Touch\"]],[/coc_coc\\w+\\/([\\w\\.]+)/i],[f,[u,\"Coc Coc\"]],[/dolfin\\/([\\w\\.]+)/i],[f,[u,\"Dolphin\"]],[/coast\\/([\\w\\.]+)/i],[f,[u,B+\" Coast\"]],[/miuibrowser\\/([\\w\\.]+)/i],[f,[u,\"MIUI \"+A]],[/fxios\\/([-\\w\\.]+)/i],[f,[u,O]],[/\\bqihu|(qi?ho?o?|360)browser/i],[[u,\"360 \"+A]],[/(oculus|samsung|sailfish|huawei)browser\\/([\\w\\.]+)/i],[[u,/(.+)/,\"$1 \"+A],f],[/(comodo_dragon)\\/([\\w\\.]+)/i],[[u,/_/g,\" \"],f],[/(electron)\\/([\\w\\.]+) safari/i,/(tesla)(?: qtcarbrowser|\\/(20\\d\\d\\.[-\\w\\.]+))/i,/m?(qqbrowser|baiduboxapp|2345Explorer)[\\/ ]?([\\w\\.]+)/i],[u,f],[/(metasr)[\\/ ]?([\\w\\.]+)/i,/(lbbrowser)/i,/\\[(linkedin)app\\]/i],[u],[/((?:fban\\/fbios|fb_iab\\/fb4a)(?!.+fbav)|;fbav\\/([\\w\\.]+);)/i],[[u,H],f],[/(kakao(?:talk|story))[\\/ ]([\\w\\.]+)/i,/(naver)\\(.*?(\\d+\\.[\\w\\.]+).*\\)/i,/safari (line)\\/([\\w\\.]+)/i,/\\b(line)\\/([\\w\\.]+)\\/iab/i,/(chromium|instagram)[\\/ ]([-\\w\\.]+)/i],[u,f],[/\\bgsa\\/([\\w\\.]+) .*safari\\//i],[f,[u,\"GSA\"]],[/musical_ly(?:.+app_?version\\/|_)([\\w\\.]+)/i],[f,[u,\"TikTok\"]],[/headlesschrome(?:\\/([\\w\\.]+)| )/i],[f,[u,C+\" Headless\"]],[/ wv\\).+(chrome)\\/([\\w\\.]+)/i],[[u,C+\" WebView\"],f],[/droid.+ version\\/([\\w\\.]+)\\b.+(?:mobile safari|safari)/i],[f,[u,\"Android \"+A]],[/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\\/v?([\\w\\.]+)/i],[u,f],[/version\\/([\\w\\.\\,]+) .*mobile\\/\\w+ (safari)/i],[f,[u,\"Mobile Safari\"]],[/version\\/([\\w(\\.|\\,)]+) .*(mobile ?safari|safari)/i],[f,u],[/webkit.+?(mobile ?safari|safari)(\\/[\\w\\.]+)/i],[u,[f,strMapper,$]],[/(webkit|khtml)\\/([\\w\\.]+)/i],[u,f],[/(navigator|netscape\\d?)\\/([-\\w\\.]+)/i],[[u,\"Netscape\"],f],[/mobile vr; rv:([\\w\\.]+)\\).+firefox/i],[f,[u,O+\" Reality\"]],[/ekiohf.+(flow)\\/([\\w\\.]+)/i,/(swiftfox)/i,/(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\\/ ]?([\\w\\.\\+]+)/i,/(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\\/([-\\w\\.]+)$/i,/(firefox)\\/([\\w\\.]+)/i,/(mozilla)\\/([\\w\\.]+) .+rv\\:.+gecko\\/\\d+/i,/(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\\. ]?browser)[-\\/ ]?v?([\\w\\.]+)/i,/(links) \\(([\\w\\.]+)/i,/panasonic;(viera)/i],[u,f],[/(cobalt)\\/([\\w\\.]+)/i],[u,[f,/master.|lts./,\"\"]]],cpu:[[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\\)]/i],[[h,\"amd64\"]],[/(ia32(?=;))/i],[[h,lowerize]],[/((?:i[346]|x)86)[;\\)]/i],[[h,\"ia32\"]],[/\\b(aarch64|arm(v?8e?l?|_?64))\\b/i],[[h,\"arm64\"]],[/\\b(arm(?:v[67])?ht?n?[fl]p?)\\b/i],[[h,\"armhf\"]],[/windows (ce|mobile); ppc;/i],[[h,\"arm\"]],[/((?:ppc|powerpc)(?:64)?)(?: mac|;|\\))/i],[[h,/ower/,t,lowerize]],[/(sun4\\w)[;\\)]/i],[[h,\"sparc\"]],[/((?:avr32|ia64(?=;))|68k(?=\\))|\\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\\b|pa-risc)/i],[[h,lowerize]]],device:[[/\\b(sch-i[89]0\\d|shw-m380s|sm-[ptx]\\w{2,4}|gt-[pn]\\d{2,4}|sgh-t8[56]9|nexus 10)/i],[c,[m,V],[p,k]],[/\\b((?:s[cgp]h|gt|sm)-\\w+|sc[g-]?[\\d]+a?|galaxy nexus)/i,/samsung[- ]([-\\w]+)/i,/sec-(sgh\\w+)/i],[c,[m,V],[p,g]],[/(?:\\/|\\()(ip(?:hone|od)[\\w, ]*)(?:\\/|;)/i],[c,[m,S],[p,g]],[/\\((ipad);[-\\w\\),; ]+apple/i,/applecoremedia\\/[\\w\\.]+ \\((ipad)/i,/\\b(ipad)\\d\\d?,\\d\\d?[;\\]].+ios/i],[c,[m,S],[p,k]],[/(macintosh);/i],[c,[m,S]],[/\\b(sh-?[altvz]?\\d\\d[a-ekm]?)/i],[c,[m,D],[p,g]],[/\\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\\d{2})\\b(?!.+d\\/s)/i],[c,[m,j],[p,k]],[/(?:huawei|honor)([-\\w ]+)[;\\)]/i,/\\b(nexus 6p|\\w{2,4}e?-[atu]?[ln][\\dx][012359c][adn]?)\\b(?!.+d\\/s)/i],[c,[m,j],[p,g]],[/\\b(poco[\\w ]+)(?: bui|\\))/i,/\\b; (\\w+) build\\/hm\\1/i,/\\b(hm[-_ ]?note?[_ ]?(?:\\d\\w)?) bui/i,/\\b(redmi[\\-_ ]?(?:note|k)?[\\w_ ]+)(?: bui|\\))/i,/\\b(mi[-_ ]?(?:a\\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\\d?\\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\\))/i],[[c,/_/g,\" \"],[m,F],[p,g]],[/\\b(mi[-_ ]?(?:pad)(?:[\\w_ ]+))(?: bui|\\))/i],[[c,/_/g,\" \"],[m,F],[p,k]],[/; (\\w+) bui.+ oppo/i,/\\b(cph[12]\\d{3}|p(?:af|c[al]|d\\w|e[ar])[mt]\\d0|x9007|a101op)\\b/i],[c,[m,\"OPPO\"],[p,g]],[/vivo (\\w+)(?: bui|\\))/i,/\\b(v[12]\\d{3}\\w?[at])(?: bui|;)/i],[c,[m,\"Vivo\"],[p,g]],[/\\b(rmx[12]\\d{3})(?: bui|;|\\))/i],[c,[m,\"Realme\"],[p,g]],[/\\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\\b[\\w ]+build\\//i,/\\bmot(?:orola)?[- ](\\w*)/i,/((?:moto[\\w\\(\\) ]+|xt\\d{3,4}|nexus 6)(?= bui|\\)))/i],[c,[m,M],[p,g]],[/\\b(mz60\\d|xoom[2 ]{0,2}) build\\//i],[c,[m,M],[p,k]],[/((?=lg)?[vl]k\\-?\\d{3}) bui| 3\\.[-\\w; ]{10}lg?-([06cv9]{3,4})/i],[c,[m,P],[p,k]],[/(lm(?:-?f100[nv]?|-[\\w\\.]+)(?= bui|\\))|nexus [45])/i,/\\blg[-e;\\/ ]+((?!browser|netcast|android tv)\\w+)/i,/\\blg-?([\\d\\w]+) bui/i],[c,[m,P],[p,g]],[/(ideatab[-\\w ]+)/i,/lenovo ?(s[56]000[-\\w]+|tab(?:[\\w ]+)|yt[-\\d\\w]{6}|tb[-\\d\\w]{6})/i],[c,[m,\"Lenovo\"],[p,k]],[/(?:maemo|nokia).*(n900|lumia \\d+)/i,/nokia[-_ ]?([-\\w\\.]*)/i],[[c,/_/g,\" \"],[m,\"Nokia\"],[p,g]],[/(pixel c)\\b/i],[c,[m,U],[p,k]],[/droid.+; (pixel[\\daxl ]{0,6})(?: bui|\\))/i],[c,[m,U],[p,g]],[/droid.+ (a?\\d[0-2]{2}so|[c-g]\\d{4}|so[-gl]\\w+|xq-a\\w[4-7][12])(?= bui|\\).+chrome\\/(?![1-6]{0,1}\\d\\.))/i],[c,[m,I],[p,g]],[/sony tablet [ps]/i,/\\b(?:sony)?sgp\\w+(?: bui|\\))/i],[[c,\"Xperia Tablet\"],[m,I],[p,k]],[/ (kb2005|in20[12]5|be20[12][59])\\b/i,/(?:one)?(?:plus)? (a\\d0\\d\\d)(?: b|\\))/i],[c,[m,\"OnePlus\"],[p,g]],[/(alexa)webm/i,/(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\\))/i,/(kf[a-z]+)( bui|\\)).+silk\\//i],[c,[m,T],[p,k]],[/((?:sd|kf)[0349hijorstuw]+)( bui|\\)).+silk\\//i],[[c,/(.+)/g,\"Fire Phone $1\"],[m,T],[p,g]],[/(playbook);[-\\w\\),; ]+(rim)/i],[c,m,[p,k]],[/\\b((?:bb[a-f]|st[hv])100-\\d)/i,/\\(bb10; (\\w+)/i],[c,[m,N],[p,g]],[/(?:\\b|asus_)(transfo[prime ]{4,10} \\w+|eeepc|slider \\w+|nexus 7|padfone|p00[cj])/i],[c,[m,z],[p,k]],[/ (z[bes]6[027][012][km][ls]|zenfone \\d\\w?)\\b/i],[c,[m,z],[p,g]],[/(nexus 9)/i],[c,[m,\"HTC\"],[p,k]],[/(htc)[-;_ ]{1,2}([\\w ]+(?=\\)| bui)|\\w+)/i,/(zte)[- ]([\\w ]+?)(?: bui|\\/|\\))/i,/(alcatel|geeksphone|nexian|panasonic(?!(?:;|\\.))|sony(?!-bra))[-_ ]?([-\\w]*)/i],[m,[c,/_/g,\" \"],[p,g]],[/droid.+; ([ab][1-7]-?[0178a]\\d\\d?)/i],[c,[m,\"Acer\"],[p,k]],[/droid.+; (m[1-5] note) bui/i,/\\bmz-([-\\w]{2,})/i],[c,[m,\"Meizu\"],[p,g]],[/(blackberry|benq|palm(?=\\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\\w]*)/i,/(hp) ([\\w ]+\\w)/i,/(asus)-?(\\w+)/i,/(microsoft); (lumia[\\w ]+)/i,/(lenovo)[-_ ]?([-\\w]+)/i,/(jolla)/i,/(oppo) ?([\\w ]+) bui/i],[m,c,[p,g]],[/(kobo)\\s(ereader|touch)/i,/(archos) (gamepad2?)/i,/(hp).+(touchpad(?!.+tablet)|tablet)/i,/(kindle)\\/([\\w\\.]+)/i,/(nook)[\\w ]+build\\/(\\w+)/i,/(dell) (strea[kpr\\d ]*[\\dko])/i,/(le[- ]+pan)[- ]+(\\w{1,9}) bui/i,/(trinity)[- ]*(t\\d{3}) bui/i,/(gigaset)[- ]+(q\\w{1,9}) bui/i,/(vodafone) ([\\w ]+)(?:\\)| bui)/i],[m,c,[p,k]],[/(surface duo)/i],[c,[m,R],[p,k]],[/droid [\\d\\.]+; (fp\\du?)(?: b|\\))/i],[c,[m,\"Fairphone\"],[p,g]],[/(u304aa)/i],[c,[m,\"AT&T\"],[p,g]],[/\\bsie-(\\w*)/i],[c,[m,\"Siemens\"],[p,g]],[/\\b(rct\\w+) b/i],[c,[m,\"RCA\"],[p,k]],[/\\b(venue[\\d ]{2,7}) b/i],[c,[m,\"Dell\"],[p,k]],[/\\b(q(?:mv|ta)\\w+) b/i],[c,[m,\"Verizon\"],[p,k]],[/\\b(?:barnes[& ]+noble |bn[rt])([\\w\\+ ]*) b/i],[c,[m,\"Barnes & Noble\"],[p,k]],[/\\b(tm\\d{3}\\w+) b/i],[c,[m,\"NuVision\"],[p,k]],[/\\b(k88) b/i],[c,[m,\"ZTE\"],[p,k]],[/\\b(nx\\d{3}j) b/i],[c,[m,\"ZTE\"],[p,g]],[/\\b(gen\\d{3}) b.+49h/i],[c,[m,\"Swiss\"],[p,g]],[/\\b(zur\\d{3}) b/i],[c,[m,\"Swiss\"],[p,k]],[/\\b((zeki)?tb.*\\b) b/i],[c,[m,\"Zeki\"],[p,k]],[/\\b([yr]\\d{2}) b/i,/\\b(dragon[- ]+touch |dt)(\\w{5}) b/i],[[m,\"Dragon Touch\"],c,[p,k]],[/\\b(ns-?\\w{0,9}) b/i],[c,[m,\"Insignia\"],[p,k]],[/\\b((nxa|next)-?\\w{0,9}) b/i],[c,[m,\"NextBook\"],[p,k]],[/\\b(xtreme\\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],[[m,\"Voice\"],c,[p,g]],[/\\b(lvtel\\-)?(v1[12]) b/i],[[m,\"LvTel\"],c,[p,g]],[/\\b(ph-1) /i],[c,[m,\"Essential\"],[p,g]],[/\\b(v(100md|700na|7011|917g).*\\b) b/i],[c,[m,\"Envizen\"],[p,k]],[/\\b(trio[-\\w\\. ]+) b/i],[c,[m,\"MachSpeed\"],[p,k]],[/\\btu_(1491) b/i],[c,[m,\"Rotor\"],[p,k]],[/(shield[\\w ]+) b/i],[c,[m,\"Nvidia\"],[p,k]],[/(sprint) (\\w+)/i],[m,c,[p,g]],[/(kin\\.[onetw]{3})/i],[[c,/\\./g,\" \"],[m,R],[p,g]],[/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\\)/i],[c,[m,G],[p,k]],[/droid.+; (ec30|ps20|tc[2-8]\\d[kx])\\)/i],[c,[m,G],[p,g]],[/smart-tv.+(samsung)/i],[m,[p,x]],[/hbbtv.+maple;(\\d+)/i],[[c,/^/,\"SmartTV\"],[m,V],[p,x]],[/(nux; netcast.+smarttv|lg (netcast\\.tv-201\\d|android tv))/i],[[m,P],[p,x]],[/(apple) ?tv/i],[m,[c,S+\" TV\"],[p,x]],[/crkey/i],[[c,C+\"cast\"],[m,U],[p,x]],[/droid.+aft(\\w)( bui|\\))/i],[c,[m,T],[p,x]],[/\\(dtv[\\);].+(aquos)/i,/(aquos-tv[\\w ]+)\\)/i],[c,[m,D],[p,x]],[/(bravia[\\w ]+)( bui|\\))/i],[c,[m,I],[p,x]],[/(mitv-\\w{5}) bui/i],[c,[m,F],[p,x]],[/Hbbtv.*(technisat) (.*);/i],[m,c,[p,x]],[/\\b(roku)[\\dx]*[\\)\\/]((?:dvp-)?[\\d\\.]*)/i,/hbbtv\\/\\d+\\.\\d+\\.\\d+ +\\([\\w\\+ ]*; *([\\w\\d][^;]*);([^;]*)/i],[[m,trim],[c,trim],[p,x]],[/\\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\\b/i],[[p,x]],[/(ouya)/i,/(nintendo) ([wids3utch]+)/i],[m,c,[p,v]],[/droid.+; (shield) bui/i],[c,[m,\"Nvidia\"],[p,v]],[/(playstation [345portablevi]+)/i],[c,[m,I],[p,v]],[/\\b(xbox(?: one)?(?!; xbox))[\\); ]/i],[c,[m,R],[p,v]],[/((pebble))app/i],[m,c,[p,_]],[/(watch)(?: ?os[,\\/]|\\d,\\d\\/)[\\d\\.]+/i],[c,[m,S],[p,_]],[/droid.+; (glass) \\d/i],[c,[m,U],[p,_]],[/droid.+; (wt63?0{2,3})\\)/i],[c,[m,G],[p,_]],[/(quest( 2| pro)?)/i],[c,[m,H],[p,_]],[/(tesla)(?: qtcarbrowser|\\/[-\\w\\.]+)/i],[m,[p,y]],[/(aeobc)\\b/i],[c,[m,T],[p,y]],[/droid .+?; ([^;]+?)(?: bui|\\) applew).+? mobile safari/i],[c,[p,g]],[/droid .+?; ([^;]+?)(?: bui|\\) applew).+?(?! mobile) safari/i],[c,[p,k]],[/\\b((tablet|tab)[;\\/]|focus\\/\\d(?!.+mobile))/i],[[p,k]],[/(phone|mobile(?:[;\\/]| [ \\w\\/\\.]*safari)|pda(?=.+windows ce))/i],[[p,g]],[/(android[-\\w\\. ]{0,9});.+buil/i],[c,[m,\"Generic\"]]],engine:[[/windows.+ edge\\/([\\w\\.]+)/i],[f,[u,E+\"HTML\"]],[/webkit\\/537\\.36.+chrome\\/(?!27)([\\w\\.]+)/i],[f,[u,\"Blink\"]],[/(presto)\\/([\\w\\.]+)/i,/(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\\/([\\w\\.]+)/i,/ekioh(flow)\\/([\\w\\.]+)/i,/(khtml|tasman|links)[\\/ ]\\(?([\\w\\.]+)/i,/(icab)[\\/ ]([23]\\.[\\d\\.]+)/i,/\\b(libweb)/i],[u,f],[/rv\\:([\\w\\.]{1,9})\\b.+(gecko)/i],[f,u]],os:[[/microsoft (windows) (vista|xp)/i],[u,f],[/(windows) nt 6\\.2; (arm)/i,/(windows (?:phone(?: os)?|mobile))[\\/ ]?([\\d\\.\\w ]*)/i,/(windows)[\\/ ]?([ntce\\d\\. ]+\\w)(?!.+xbox)/i],[u,[f,strMapper,X]],[/(win(?=3|9|n)|win 9x )([nt\\d\\.]+)/i],[[u,\"Windows\"],[f,strMapper,X]],[/ip[honead]{2,4}\\b(?:.*os ([\\w]+) like mac|; opera)/i,/ios;fbsv\\/([\\d\\.]+)/i,/cfnetwork\\/.+darwin/i],[[f,/_/g,\".\"],[u,\"iOS\"]],[/(mac os x) ?([\\w\\. ]*)/i,/(macintosh|mac_powerpc\\b)(?!.+haiku)/i],[[u,Z],[f,/_/g,\".\"]],[/droid ([\\w\\.]+)\\b.+(android[- ]x86|harmonyos)/i],[f,u],[/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\\/ ]?([\\w\\.]*)/i,/(blackberry)\\w*\\/([\\w\\.]*)/i,/(tizen|kaios)[\\/ ]([\\w\\.]+)/i,/\\((series40);/i],[u,f],[/\\(bb(10);/i],[f,[u,N]],[/(?:symbian ?os|symbos|s60(?=;)|series60)[-\\/ ]?([\\w\\.]*)/i],[f,[u,\"Symbian\"]],[/mozilla\\/[\\d\\.]+ \\((?:mobile|tablet|tv|mobile; [\\w ]+); rv:.+ gecko\\/([\\w\\.]+)/i],[f,[u,O+\" OS\"]],[/web0s;.+rt(tv)/i,/\\b(?:hp)?wos(?:browser)?\\/([\\w\\.]+)/i],[f,[u,\"webOS\"]],[/watch(?: ?os[,\\/]|\\d,\\d\\/)([\\d\\.]+)/i],[f,[u,\"watchOS\"]],[/crkey\\/([\\d\\.]+)/i],[f,[u,C+\"cast\"]],[/(cros) [\\w]+(?:\\)| ([\\w\\.]+)\\b)/i],[[u,L],f],[/panasonic;(viera)/i,/(netrange)mmh/i,/(nettv)\\/(\\d+\\.[\\w\\.]+)/i,/(nintendo|playstation) ([wids345portablevuch]+)/i,/(xbox); +xbox ([^\\);]+)/i,/\\b(joli|palm)\\b ?(?:os)?\\/?([\\w\\.]*)/i,/(mint)[\\/\\(\\) ]?(\\w*)/i,/(mageia|vectorlinux)[; ]/i,/([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\\/ ]?(?!chrom|package)([-\\w\\.]*)/i,/(hurd|linux) ?([\\w\\.]*)/i,/(gnu) ?([\\w\\.]*)/i,/\\b([-frentopcghs]{0,5}bsd|dragonfly)[\\/ ]?(?!amd|[ix346]{1,2}86)([\\w\\.]*)/i,/(haiku) (\\w+)/i],[u,f],[/(sunos) ?([\\w\\.\\d]*)/i],[[u,\"Solaris\"],f],[/((?:open)?solaris)[-\\/ ]?([\\w\\.]*)/i,/(aix) ((\\d)(?=\\.|\\)| )[\\w\\.])*/i,/\\b(beos|os\\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,/(unix) ?([\\w\\.]*)/i],[u,f]]};var UAParser=function(i,e){if(typeof i===w){e=i;i=a}if(!(this instanceof UAParser)){return new UAParser(i,e).getResult()}var r=typeof o!==b&&o.navigator?o.navigator:a;var n=i||(r&&r.userAgent?r.userAgent:t);var v=r&&r.userAgentData?r.userAgentData:a;var x=e?extend(K,e):K;var _=r&&r.userAgent==n;this.getBrowser=function(){var i={};i[u]=a;i[f]=a;rgxMapper.call(i,n,x.browser);i[d]=majorize(i[f]);if(_&&r&&r.brave&&typeof r.brave.isBrave==s){i[u]=\"Brave\"}return i};this.getCPU=function(){var i={};i[h]=a;rgxMapper.call(i,n,x.cpu);return i};this.getDevice=function(){var i={};i[m]=a;i[c]=a;i[p]=a;rgxMapper.call(i,n,x.device);if(_&&!i[p]&&v&&v.mobile){i[p]=g}if(_&&i[c]==\"Macintosh\"&&r&&typeof r.standalone!==b&&r.maxTouchPoints&&r.maxTouchPoints>2){i[c]=\"iPad\";i[p]=k}return i};this.getEngine=function(){var i={};i[u]=a;i[f]=a;rgxMapper.call(i,n,x.engine);return i};this.getOS=function(){var i={};i[u]=a;i[f]=a;rgxMapper.call(i,n,x.os);if(_&&!i[u]&&v&&v.platform!=\"Unknown\"){i[u]=v.platform.replace(/chrome os/i,L).replace(/macos/i,Z)}return i};this.getResult=function(){return{ua:this.getUA(),browser:this.getBrowser(),engine:this.getEngine(),os:this.getOS(),device:this.getDevice(),cpu:this.getCPU()}};this.getUA=function(){return n};this.setUA=function(i){n=typeof i===l&&i.length>q?trim(i,q):i;return this};this.setUA(n);return this};UAParser.VERSION=r;UAParser.BROWSER=enumerize([u,f,d]);UAParser.CPU=enumerize([h]);UAParser.DEVICE=enumerize([c,m,p,v,g,x,k,_,y]);UAParser.ENGINE=UAParser.OS=enumerize([u,f]);if(typeof e!==b){if(\"object\"!==b&&i.exports){e=i.exports=UAParser}e.UAParser=UAParser}else{if(\"function\"===s&&__webpack_require__.amdO){!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return UAParser}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}else if(typeof o!==b){o.UAParser=UAParser}}var Q=typeof o!==b&&(o.jQuery||o.Zepto);if(Q&&!Q.ua){var Y=new UAParser;Q.ua=Y.getResult();Q.ua.get=function(){return Y.getUA()};Q.ua.set=function(i){Y.setUA(i);var e=Y.getResult();for(var o in e){Q.ua[o]=e[o]}}}})(typeof window===\"object\"?window:this)}};var e={};function __nccwpck_require__(o){var a=e[o];if(a!==undefined){return a.exports}var r=e[o]={exports:{}};var t=true;try{i[o].call(r.exports,r,r.exports,__nccwpck_require__);t=false}finally{if(t)delete e[o]}return r.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var o=__nccwpck_require__(226);module.exports=o})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3VhLXBhcnNlci1qcy91YS1wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsd0NBQU0sT0FBTyxrQkFBa0IsZUFBZSxhQUFhLHVPQUF1TyxxUUFBcVEseUJBQXlCLFNBQVMsZ0JBQWdCLDRCQUE0Qix1QkFBdUIsS0FBSyxXQUFXLFNBQVMsdUJBQXVCLFNBQVMsWUFBWSxXQUFXLEtBQUssMkJBQTJCLFNBQVMsbUJBQW1CLGdFQUFnRSxzQkFBc0IsdUJBQXVCLHNCQUFzQiw0REFBNEQsb0JBQW9CLGlCQUFpQix3QkFBd0IseUNBQXlDLDRCQUE0QixvQkFBb0Isc0JBQXNCLG9CQUFvQixNQUFNLHNCQUFzQixVQUFVLE1BQU0saUJBQWlCLFFBQVEsUUFBUSxXQUFXLEtBQUssU0FBUyxPQUFPLDZCQUE2QixpQkFBaUIsbUJBQW1CLDZCQUE2QixLQUFLLGlCQUFpQixzQkFBc0IsNkNBQTZDLHNDQUFzQyxLQUFLLHFDQUFxQyxzQkFBc0IscURBQXFELEtBQUssaUJBQWlCLE1BQU0seUJBQXlCLGdCQUFnQixtQ0FBbUMsWUFBWSxjQUFjLEtBQUssbUJBQW1CLG1CQUFtQixxQkFBcUIsa0JBQWtCLFVBQVUsT0FBTywrRkFBK0YsSUFBSSxzS0FBc0ssT0FBTywySkFBMkosSUFBSSx3M0JBQXczQixJQUFJLHEyQkFBcTJCLGdCQUFnQixraEJBQWtoQixHQUFHLHlWQUF5ViwyZkFBMmYscUhBQXFILGdDQUFnQyx5Q0FBeUMsZ0pBQWdKLElBQUksbURBQW1ELDRDQUE0Qyx5Q0FBeUMsMENBQTBDLDZIQUE2SCxJQUFJLFdBQVcsSUFBSSxvTUFBb00sZ0NBQWdDLFNBQVMsb0VBQW9FLDBDQUEwQyw2R0FBNkcsRUFBRSw4REFBOEQsc0JBQXNCLElBQUkscUdBQXFHLDhUQUE4VCxpQ0FBaUMsRUFBRSw4R0FBOEcsRUFBRSxpQkFBaUIseUNBQXlDLEVBQUUsVUFBVSxzS0FBc0ssSUFBSSw4REFBOEQsSUFBSSxrREFBa0QsRUFBRSxnQkFBZ0IsRUFBRSxHQUFHLGFBQWEsSUFBSSxxRkFBcUYseUpBQXlKLEVBQUUsV0FBVyxFQUFFLHlLQUF5SyxlQUFlLElBQUkscURBQXFELEVBQUUsV0FBVyxFQUFFLHlEQUF5RCxJQUFJLHFQQUFxUCxFQUFFLFlBQVksRUFBRSxzS0FBc0ssU0FBUyxpRUFBaUUsd0RBQXdELE1BQU0sZ0xBQWdMLElBQUksSUFBSSwwR0FBMEcsdUVBQXVFLDZEQUE2RCxpQ0FBaUMsR0FBRyxnTEFBZ0wsK1JBQStSLElBQUksNEJBQTRCLEVBQUUsNEJBQTRCLElBQUksMkdBQTJHLGlMQUFpTCxJQUFJLHNLQUFzSyxFQUFFLGdGQUFnRixFQUFFLHVDQUF1QyxFQUFFLDZDQUE2QyxFQUFFLHVGQUF1RixFQUFFLG1DQUFtQyxFQUFFLGdEQUFnRCxJQUFJLG9EQUFvRCxJQUFJLCtiQUErYixFQUFFLDRDQUE0QywwRUFBMEUsaUdBQWlHLGlEQUFpRCwwTUFBME0sNEdBQTRHLEVBQUUsbURBQW1ELDhGQUE4RixXQUFXLElBQUksSUFBSSwyRUFBMkUsa0ZBQWtGLGtIQUFrSCxXQUFXLHdIQUF3SCx5Q0FBeUMsUUFBUSxJQUFJLDZKQUE2SixJQUFJLGtFQUFrRSxJQUFJLDRFQUE0RSwwREFBMEQsMEVBQTBFLElBQUksRUFBRSxxWEFBcVgsSUFBSSwwRkFBMEYsc05BQXNOLElBQUksNkJBQTZCLGNBQWMsZ1hBQWdYLHFCQUFxQiw2Q0FBNkMsa0dBQWtHLFNBQVMsa0RBQWtELGdPQUFnTyxrSEFBa0gsWUFBWSwrRkFBK0Ysb1hBQW9YLElBQUksbUNBQW1DLElBQUksNlBBQTZQLDJCQUEyQixpQkFBaUIsSUFBSSxJQUFJLGdDQUFnQyxxQ0FBcUMsOENBQThDLHdDQUF3QywyQ0FBMkMsc0JBQXNCLHdCQUF3QiwyQkFBMkIsU0FBUyxPQUFPLE9BQU8sOEJBQThCLG9CQUFvQiw2Q0FBNkMsYUFBYSxVQUFVLHVCQUF1QixTQUFTLE9BQU8sMEJBQTBCLFVBQVUsMEJBQTBCLFNBQVMsT0FBTyxPQUFPLE9BQU8sNkJBQTZCLDBCQUEwQixPQUFPLDJGQUEyRixZQUFZLE9BQU8sVUFBVSwwQkFBMEIsU0FBUyxPQUFPLE9BQU8sNkJBQTZCLFVBQVUsc0JBQXNCLFNBQVMsT0FBTyxPQUFPLHlCQUF5Qix1Q0FBdUMsNERBQTRELFVBQVUsMEJBQTBCLE9BQU8sOEhBQThILHNCQUFzQixVQUFVLHVCQUF1Qix1Q0FBdUMsYUFBYSxjQUFjLGFBQWEsbUJBQW1CLG9DQUFvQyw0QkFBNEIsK0NBQStDLDZDQUE2QyxpQkFBaUIsNEJBQTRCLHFCQUFxQixvQkFBb0IsS0FBSyxHQUFHLFVBQWEsTUFBTSx3QkFBVSxFQUFFLG1DQUFRLFdBQVcsZ0JBQWdCO0FBQUEsa0dBQUUsQ0FBQyxzQkFBc0IscUJBQXFCLHdDQUF3QyxhQUFhLG1CQUFtQixtQkFBbUIsb0JBQW9CLGtCQUFrQixxQkFBcUIsV0FBVyxvQkFBb0IsZ0JBQWdCLGdCQUFnQiwwQ0FBMEMsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUkscURBQXFELFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLGlGQUFpRiwrQkFBK0IsaUJBQWlCIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHVhLXBhcnNlci1qc1xcdWEtcGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e3ZhciBpPXsyMjY6ZnVuY3Rpb24oaSxlKXsoZnVuY3Rpb24obyxhKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1cIjEuMC4zNVwiLHQ9XCJcIixuPVwiP1wiLHM9XCJmdW5jdGlvblwiLGI9XCJ1bmRlZmluZWRcIix3PVwib2JqZWN0XCIsbD1cInN0cmluZ1wiLGQ9XCJtYWpvclwiLGM9XCJtb2RlbFwiLHU9XCJuYW1lXCIscD1cInR5cGVcIixtPVwidmVuZG9yXCIsZj1cInZlcnNpb25cIixoPVwiYXJjaGl0ZWN0dXJlXCIsdj1cImNvbnNvbGVcIixnPVwibW9iaWxlXCIsaz1cInRhYmxldFwiLHg9XCJzbWFydHR2XCIsXz1cIndlYXJhYmxlXCIseT1cImVtYmVkZGVkXCIscT0zNTA7dmFyIFQ9XCJBbWF6b25cIixTPVwiQXBwbGVcIix6PVwiQVNVU1wiLE49XCJCbGFja0JlcnJ5XCIsQT1cIkJyb3dzZXJcIixDPVwiQ2hyb21lXCIsRT1cIkVkZ2VcIixPPVwiRmlyZWZveFwiLFU9XCJHb29nbGVcIixqPVwiSHVhd2VpXCIsUD1cIkxHXCIsUj1cIk1pY3Jvc29mdFwiLE09XCJNb3Rvcm9sYVwiLEI9XCJPcGVyYVwiLFY9XCJTYW1zdW5nXCIsRD1cIlNoYXJwXCIsST1cIlNvbnlcIixXPVwiVmllcmFcIixGPVwiWGlhb21pXCIsRz1cIlplYnJhXCIsSD1cIkZhY2Vib29rXCIsTD1cIkNocm9taXVtIE9TXCIsWj1cIk1hYyBPU1wiO3ZhciBleHRlbmQ9ZnVuY3Rpb24oaSxlKXt2YXIgbz17fTtmb3IodmFyIGEgaW4gaSl7aWYoZVthXSYmZVthXS5sZW5ndGglMj09PTApe29bYV09ZVthXS5jb25jYXQoaVthXSl9ZWxzZXtvW2FdPWlbYV19fXJldHVybiBvfSxlbnVtZXJpemU9ZnVuY3Rpb24oaSl7dmFyIGU9e307Zm9yKHZhciBvPTA7bzxpLmxlbmd0aDtvKyspe2VbaVtvXS50b1VwcGVyQ2FzZSgpXT1pW29dfXJldHVybiBlfSxoYXM9ZnVuY3Rpb24oaSxlKXtyZXR1cm4gdHlwZW9mIGk9PT1sP2xvd2VyaXplKGUpLmluZGV4T2YobG93ZXJpemUoaSkpIT09LTE6ZmFsc2V9LGxvd2VyaXplPWZ1bmN0aW9uKGkpe3JldHVybiBpLnRvTG93ZXJDYXNlKCl9LG1ham9yaXplPWZ1bmN0aW9uKGkpe3JldHVybiB0eXBlb2YgaT09PWw/aS5yZXBsYWNlKC9bXlxcZFxcLl0vZyx0KS5zcGxpdChcIi5cIilbMF06YX0sdHJpbT1mdW5jdGlvbihpLGUpe2lmKHR5cGVvZiBpPT09bCl7aT1pLnJlcGxhY2UoL15cXHNcXHMqLyx0KTtyZXR1cm4gdHlwZW9mIGU9PT1iP2k6aS5zdWJzdHJpbmcoMCxxKX19O3ZhciByZ3hNYXBwZXI9ZnVuY3Rpb24oaSxlKXt2YXIgbz0wLHIsdCxuLGIsbCxkO3doaWxlKG88ZS5sZW5ndGgmJiFsKXt2YXIgYz1lW29dLHU9ZVtvKzFdO3I9dD0wO3doaWxlKHI8Yy5sZW5ndGgmJiFsKXtpZighY1tyXSl7YnJlYWt9bD1jW3IrK10uZXhlYyhpKTtpZighIWwpe2ZvcihuPTA7bjx1Lmxlbmd0aDtuKyspe2Q9bFsrK3RdO2I9dVtuXTtpZih0eXBlb2YgYj09PXcmJmIubGVuZ3RoPjApe2lmKGIubGVuZ3RoPT09Mil7aWYodHlwZW9mIGJbMV09PXMpe3RoaXNbYlswXV09YlsxXS5jYWxsKHRoaXMsZCl9ZWxzZXt0aGlzW2JbMF1dPWJbMV19fWVsc2UgaWYoYi5sZW5ndGg9PT0zKXtpZih0eXBlb2YgYlsxXT09PXMmJiEoYlsxXS5leGVjJiZiWzFdLnRlc3QpKXt0aGlzW2JbMF1dPWQ/YlsxXS5jYWxsKHRoaXMsZCxiWzJdKTphfWVsc2V7dGhpc1tiWzBdXT1kP2QucmVwbGFjZShiWzFdLGJbMl0pOmF9fWVsc2UgaWYoYi5sZW5ndGg9PT00KXt0aGlzW2JbMF1dPWQ/YlszXS5jYWxsKHRoaXMsZC5yZXBsYWNlKGJbMV0sYlsyXSkpOmF9fWVsc2V7dGhpc1tiXT1kP2Q6YX19fX1vKz0yfX0sc3RyTWFwcGVyPWZ1bmN0aW9uKGksZSl7Zm9yKHZhciBvIGluIGUpe2lmKHR5cGVvZiBlW29dPT09dyYmZVtvXS5sZW5ndGg+MCl7Zm9yKHZhciByPTA7cjxlW29dLmxlbmd0aDtyKyspe2lmKGhhcyhlW29dW3JdLGkpKXtyZXR1cm4gbz09PW4/YTpvfX19ZWxzZSBpZihoYXMoZVtvXSxpKSl7cmV0dXJuIG89PT1uP2E6b319cmV0dXJuIGl9O3ZhciAkPXtcIjEuMFwiOlwiLzhcIiwxLjI6XCIvMVwiLDEuMzpcIi8zXCIsXCIyLjBcIjpcIi80MTJcIixcIjIuMC4yXCI6XCIvNDE2XCIsXCIyLjAuM1wiOlwiLzQxN1wiLFwiMi4wLjRcIjpcIi80MTlcIixcIj9cIjpcIi9cIn0sWD17TUU6XCI0LjkwXCIsXCJOVCAzLjExXCI6XCJOVDMuNTFcIixcIk5UIDQuMFwiOlwiTlQ0LjBcIiwyZTM6XCJOVCA1LjBcIixYUDpbXCJOVCA1LjFcIixcIk5UIDUuMlwiXSxWaXN0YTpcIk5UIDYuMFwiLDc6XCJOVCA2LjFcIiw4OlwiTlQgNi4yXCIsOC4xOlwiTlQgNi4zXCIsMTA6W1wiTlQgNi40XCIsXCJOVCAxMC4wXCJdLFJUOlwiQVJNXCJ9O3ZhciBLPXticm93c2VyOltbL1xcYig/OmNybW98Y3Jpb3MpXFwvKFtcXHdcXC5dKykvaV0sW2YsW3UsXCJDaHJvbWVcIl1dLFsvZWRnKD86ZXxpb3N8YSk/XFwvKFtcXHdcXC5dKykvaV0sW2YsW3UsXCJFZGdlXCJdXSxbLyhvcGVyYSBtaW5pKVxcLyhbLVxcd1xcLl0rKS9pLC8ob3BlcmEgW21vYmlsZXRhYl17Myw2fSlcXGIuK3ZlcnNpb25cXC8oWy1cXHdcXC5dKykvaSwvKG9wZXJhKSg/Oi4rdmVyc2lvblxcL3xbXFwvIF0rKShbXFx3XFwuXSspL2ldLFt1LGZdLFsvb3Bpb3NbXFwvIF0rKFtcXHdcXC5dKykvaV0sW2YsW3UsQitcIiBNaW5pXCJdXSxbL1xcYm9wclxcLyhbXFx3XFwuXSspL2ldLFtmLFt1LEJdXSxbLyhraW5kbGUpXFwvKFtcXHdcXC5dKykvaSwvKGx1bmFzY2FwZXxtYXh0aG9ufG5ldGZyb250fGphc21pbmV8YmxhemVyKVtcXC8gXT8oW1xcd1xcLl0qKS9pLC8oYXZhbnQgfGllbW9iaWxlfHNsaW0pKD86YnJvd3Nlcik/W1xcLyBdPyhbXFx3XFwuXSopL2ksLyhiYT9pZHVicm93c2VyKVtcXC8gXT8oW1xcd1xcLl0rKS9pLC8oPzptc3xcXCgpKGllKSAoW1xcd1xcLl0rKS9pLC8oZmxvY2t8cm9ja21lbHR8bWlkb3JpfGVwaXBoYW55fHNpbGt8c2t5ZmlyZXxib2x0fGlyb258dml2YWxkaXxpcmlkaXVtfHBoYW50b21qc3xib3dzZXJ8cXVhcmt8cXVwemlsbGF8ZmFsa29ufHJla29ucXxwdWZmaW58YnJhdmV8d2hhbGUoPyEuK25hdmVyKXxxcWJyb3dzZXJsaXRlfHFxfGR1Y2tkdWNrZ28pXFwvKFstXFx3XFwuXSspL2ksLyhoZXl0YXB8b3ZpKWJyb3dzZXJcXC8oW1xcZFxcLl0rKS9pLC8od2VpYm8pX18oW1xcZFxcLl0rKS9pXSxbdSxmXSxbLyg/OlxcYnVjPyA/YnJvd3NlcnwoPzpqdWMuKyl1Y3dlYilbXFwvIF0/KFtcXHdcXC5dKykvaV0sW2YsW3UsXCJVQ1wiK0FdXSxbL21pY3JvbS4rXFxicWJjb3JlXFwvKFtcXHdcXC5dKykvaSwvXFxicWJjb3JlXFwvKFtcXHdcXC5dKykuK21pY3JvbS9pXSxbZixbdSxcIldlQ2hhdChXaW4pIERlc2t0b3BcIl1dLFsvbWljcm9tZXNzZW5nZXJcXC8oW1xcd1xcLl0rKS9pXSxbZixbdSxcIldlQ2hhdFwiXV0sWy9rb25xdWVyb3JcXC8oW1xcd1xcLl0rKS9pXSxbZixbdSxcIktvbnF1ZXJvclwiXV0sWy90cmlkZW50Litydls6IF0oW1xcd1xcLl17MSw5fSlcXGIuK2xpa2UgZ2Vja28vaV0sW2YsW3UsXCJJRVwiXV0sWy95YSg/OnNlYXJjaCk/YnJvd3NlclxcLyhbXFx3XFwuXSspL2ldLFtmLFt1LFwiWWFuZGV4XCJdXSxbLyhhdmFzdHxhdmcpXFwvKFtcXHdcXC5dKykvaV0sW1t1LC8oLispLyxcIiQxIFNlY3VyZSBcIitBXSxmXSxbL1xcYmZvY3VzXFwvKFtcXHdcXC5dKykvaV0sW2YsW3UsTytcIiBGb2N1c1wiXV0sWy9cXGJvcHRcXC8oW1xcd1xcLl0rKS9pXSxbZixbdSxCK1wiIFRvdWNoXCJdXSxbL2NvY19jb2NcXHcrXFwvKFtcXHdcXC5dKykvaV0sW2YsW3UsXCJDb2MgQ29jXCJdXSxbL2RvbGZpblxcLyhbXFx3XFwuXSspL2ldLFtmLFt1LFwiRG9scGhpblwiXV0sWy9jb2FzdFxcLyhbXFx3XFwuXSspL2ldLFtmLFt1LEIrXCIgQ29hc3RcIl1dLFsvbWl1aWJyb3dzZXJcXC8oW1xcd1xcLl0rKS9pXSxbZixbdSxcIk1JVUkgXCIrQV1dLFsvZnhpb3NcXC8oWy1cXHdcXC5dKykvaV0sW2YsW3UsT11dLFsvXFxicWlodXwocWk/aG8/bz98MzYwKWJyb3dzZXIvaV0sW1t1LFwiMzYwIFwiK0FdXSxbLyhvY3VsdXN8c2Ftc3VuZ3xzYWlsZmlzaHxodWF3ZWkpYnJvd3NlclxcLyhbXFx3XFwuXSspL2ldLFtbdSwvKC4rKS8sXCIkMSBcIitBXSxmXSxbLyhjb21vZG9fZHJhZ29uKVxcLyhbXFx3XFwuXSspL2ldLFtbdSwvXy9nLFwiIFwiXSxmXSxbLyhlbGVjdHJvbilcXC8oW1xcd1xcLl0rKSBzYWZhcmkvaSwvKHRlc2xhKSg/OiBxdGNhcmJyb3dzZXJ8XFwvKDIwXFxkXFxkXFwuWy1cXHdcXC5dKykpL2ksL20/KHFxYnJvd3NlcnxiYWlkdWJveGFwcHwyMzQ1RXhwbG9yZXIpW1xcLyBdPyhbXFx3XFwuXSspL2ldLFt1LGZdLFsvKG1ldGFzcilbXFwvIF0/KFtcXHdcXC5dKykvaSwvKGxiYnJvd3NlcikvaSwvXFxbKGxpbmtlZGluKWFwcFxcXS9pXSxbdV0sWy8oKD86ZmJhblxcL2ZiaW9zfGZiX2lhYlxcL2ZiNGEpKD8hLitmYmF2KXw7ZmJhdlxcLyhbXFx3XFwuXSspOykvaV0sW1t1LEhdLGZdLFsvKGtha2FvKD86dGFsa3xzdG9yeSkpW1xcLyBdKFtcXHdcXC5dKykvaSwvKG5hdmVyKVxcKC4qPyhcXGQrXFwuW1xcd1xcLl0rKS4qXFwpL2ksL3NhZmFyaSAobGluZSlcXC8oW1xcd1xcLl0rKS9pLC9cXGIobGluZSlcXC8oW1xcd1xcLl0rKVxcL2lhYi9pLC8oY2hyb21pdW18aW5zdGFncmFtKVtcXC8gXShbLVxcd1xcLl0rKS9pXSxbdSxmXSxbL1xcYmdzYVxcLyhbXFx3XFwuXSspIC4qc2FmYXJpXFwvL2ldLFtmLFt1LFwiR1NBXCJdXSxbL211c2ljYWxfbHkoPzouK2FwcF8/dmVyc2lvblxcL3xfKShbXFx3XFwuXSspL2ldLFtmLFt1LFwiVGlrVG9rXCJdXSxbL2hlYWRsZXNzY2hyb21lKD86XFwvKFtcXHdcXC5dKyl8ICkvaV0sW2YsW3UsQytcIiBIZWFkbGVzc1wiXV0sWy8gd3ZcXCkuKyhjaHJvbWUpXFwvKFtcXHdcXC5dKykvaV0sW1t1LEMrXCIgV2ViVmlld1wiXSxmXSxbL2Ryb2lkLisgdmVyc2lvblxcLyhbXFx3XFwuXSspXFxiLisoPzptb2JpbGUgc2FmYXJpfHNhZmFyaSkvaV0sW2YsW3UsXCJBbmRyb2lkIFwiK0FdXSxbLyhjaHJvbWV8b21uaXdlYnxhcm9yYXxbdGl6ZW5va2FdezV9ID9icm93c2VyKVxcL3Y/KFtcXHdcXC5dKykvaV0sW3UsZl0sWy92ZXJzaW9uXFwvKFtcXHdcXC5cXCxdKykgLiptb2JpbGVcXC9cXHcrIChzYWZhcmkpL2ldLFtmLFt1LFwiTW9iaWxlIFNhZmFyaVwiXV0sWy92ZXJzaW9uXFwvKFtcXHcoXFwufFxcLCldKykgLioobW9iaWxlID9zYWZhcml8c2FmYXJpKS9pXSxbZix1XSxbL3dlYmtpdC4rPyhtb2JpbGUgP3NhZmFyaXxzYWZhcmkpKFxcL1tcXHdcXC5dKykvaV0sW3UsW2Ysc3RyTWFwcGVyLCRdXSxbLyh3ZWJraXR8a2h0bWwpXFwvKFtcXHdcXC5dKykvaV0sW3UsZl0sWy8obmF2aWdhdG9yfG5ldHNjYXBlXFxkPylcXC8oWy1cXHdcXC5dKykvaV0sW1t1LFwiTmV0c2NhcGVcIl0sZl0sWy9tb2JpbGUgdnI7IHJ2OihbXFx3XFwuXSspXFwpLitmaXJlZm94L2ldLFtmLFt1LE8rXCIgUmVhbGl0eVwiXV0sWy9la2lvaGYuKyhmbG93KVxcLyhbXFx3XFwuXSspL2ksLyhzd2lmdGZveCkvaSwvKGljZWRyYWdvbnxpY2V3ZWFzZWx8Y2FtaW5vfGNoaW1lcmF8ZmVubmVjfG1hZW1vIGJyb3dzZXJ8bWluaW1vfGNvbmtlcm9yfGtsYXIpW1xcLyBdPyhbXFx3XFwuXFwrXSspL2ksLyhzZWFtb25rZXl8ay1tZWxlb258aWNlY2F0fGljZWFwZXxmaXJlYmlyZHxwaG9lbml4fHBhbGVtb29ufGJhc2lsaXNrfHdhdGVyZm94KVxcLyhbLVxcd1xcLl0rKSQvaSwvKGZpcmVmb3gpXFwvKFtcXHdcXC5dKykvaSwvKG1vemlsbGEpXFwvKFtcXHdcXC5dKykgLitydlxcOi4rZ2Vja29cXC9cXGQrL2ksLyhwb2xhcmlzfGx5bnh8ZGlsbG98aWNhYnxkb3Jpc3xhbWF5YXx3M218bmV0c3VyZnxzbGVpcG5pcnxvYmlnb3xtb3NhaWN8KD86Z298aWNlfHVwKVtcXC4gXT9icm93c2VyKVstXFwvIF0/dj8oW1xcd1xcLl0rKS9pLC8obGlua3MpIFxcKChbXFx3XFwuXSspL2ksL3BhbmFzb25pYzsodmllcmEpL2ldLFt1LGZdLFsvKGNvYmFsdClcXC8oW1xcd1xcLl0rKS9pXSxbdSxbZiwvbWFzdGVyLnxsdHMuLyxcIlwiXV1dLGNwdTpbWy8oPzooYW1kfHgoPzooPzo4Nnw2NClbLV9dKT98d293fHdpbik2NClbO1xcKV0vaV0sW1toLFwiYW1kNjRcIl1dLFsvKGlhMzIoPz07KSkvaV0sW1toLGxvd2VyaXplXV0sWy8oKD86aVszNDZdfHgpODYpWztcXCldL2ldLFtbaCxcImlhMzJcIl1dLFsvXFxiKGFhcmNoNjR8YXJtKHY/OGU/bD98Xz82NCkpXFxiL2ldLFtbaCxcImFybTY0XCJdXSxbL1xcYihhcm0oPzp2WzY3XSk/aHQ/bj9bZmxdcD8pXFxiL2ldLFtbaCxcImFybWhmXCJdXSxbL3dpbmRvd3MgKGNlfG1vYmlsZSk7IHBwYzsvaV0sW1toLFwiYXJtXCJdXSxbLygoPzpwcGN8cG93ZXJwYykoPzo2NCk/KSg/OiBtYWN8O3xcXCkpL2ldLFtbaCwvb3dlci8sdCxsb3dlcml6ZV1dLFsvKHN1bjRcXHcpWztcXCldL2ldLFtbaCxcInNwYXJjXCJdXSxbLygoPzphdnIzMnxpYTY0KD89OykpfDY4ayg/PVxcKSl8XFxiYXJtKD89dig/OlsxLTddfFs1LTddMSlsP3w7fGVhYmkpfCg/PWF0bWVsIClhdnJ8KD86aXJpeHxtaXBzfHNwYXJjKSg/OjY0KT9cXGJ8cGEtcmlzYykvaV0sW1toLGxvd2VyaXplXV1dLGRldmljZTpbWy9cXGIoc2NoLWlbODldMFxcZHxzaHctbTM4MHN8c20tW3B0eF1cXHd7Miw0fXxndC1bcG5dXFxkezIsNH18c2doLXQ4WzU2XTl8bmV4dXMgMTApL2ldLFtjLFttLFZdLFtwLGtdXSxbL1xcYigoPzpzW2NncF1ofGd0fHNtKS1cXHcrfHNjW2ctXT9bXFxkXSthP3xnYWxheHkgbmV4dXMpL2ksL3NhbXN1bmdbLSBdKFstXFx3XSspL2ksL3NlYy0oc2doXFx3KykvaV0sW2MsW20sVl0sW3AsZ11dLFsvKD86XFwvfFxcKCkoaXAoPzpob25lfG9kKVtcXHcsIF0qKSg/OlxcL3w7KS9pXSxbYyxbbSxTXSxbcCxnXV0sWy9cXCgoaXBhZCk7Wy1cXHdcXCksOyBdK2FwcGxlL2ksL2FwcGxlY29yZW1lZGlhXFwvW1xcd1xcLl0rIFxcKChpcGFkKS9pLC9cXGIoaXBhZClcXGRcXGQ/LFxcZFxcZD9bO1xcXV0uK2lvcy9pXSxbYyxbbSxTXSxbcCxrXV0sWy8obWFjaW50b3NoKTsvaV0sW2MsW20sU11dLFsvXFxiKHNoLT9bYWx0dnpdP1xcZFxcZFthLWVrbV0/KS9pXSxbYyxbbSxEXSxbcCxnXV0sWy9cXGIoKD86YWdbcnNdWzIzXT98YmFoMj98c2h0P3xidHYpLWE/W2x3XVxcZHsyfSlcXGIoPyEuK2RcXC9zKS9pXSxbYyxbbSxqXSxbcCxrXV0sWy8oPzpodWF3ZWl8aG9ub3IpKFstXFx3IF0rKVs7XFwpXS9pLC9cXGIobmV4dXMgNnB8XFx3ezIsNH1lPy1bYXR1XT9bbG5dW1xcZHhdWzAxMjM1OWNdW2Fkbl0/KVxcYig/IS4rZFxcL3MpL2ldLFtjLFttLGpdLFtwLGddXSxbL1xcYihwb2NvW1xcdyBdKykoPzogYnVpfFxcKSkvaSwvXFxiOyAoXFx3KykgYnVpbGRcXC9obVxcMS9pLC9cXGIoaG1bLV8gXT9ub3RlP1tfIF0/KD86XFxkXFx3KT8pIGJ1aS9pLC9cXGIocmVkbWlbXFwtXyBdPyg/Om5vdGV8ayk/W1xcd18gXSspKD86IGJ1aXxcXCkpL2ksL1xcYihtaVstXyBdPyg/OmFcXGR8b25lfG9uZVtfIF1wbHVzfG5vdGUgbHRlfG1heHxjYyk/W18gXT8oPzpcXGQ/XFx3PylbXyBdPyg/OnBsdXN8c2V8bGl0ZSk/KSg/OiBidWl8XFwpKS9pXSxbW2MsL18vZyxcIiBcIl0sW20sRl0sW3AsZ11dLFsvXFxiKG1pWy1fIF0/KD86cGFkKSg/OltcXHdfIF0rKSkoPzogYnVpfFxcKSkvaV0sW1tjLC9fL2csXCIgXCJdLFttLEZdLFtwLGtdXSxbLzsgKFxcdyspIGJ1aS4rIG9wcG8vaSwvXFxiKGNwaFsxMl1cXGR7M318cCg/OmFmfGNbYWxdfGRcXHd8ZVthcl0pW210XVxcZDB8eDkwMDd8YTEwMW9wKVxcYi9pXSxbYyxbbSxcIk9QUE9cIl0sW3AsZ11dLFsvdml2byAoXFx3KykoPzogYnVpfFxcKSkvaSwvXFxiKHZbMTJdXFxkezN9XFx3P1thdF0pKD86IGJ1aXw7KS9pXSxbYyxbbSxcIlZpdm9cIl0sW3AsZ11dLFsvXFxiKHJteFsxMl1cXGR7M30pKD86IGJ1aXw7fFxcKSkvaV0sW2MsW20sXCJSZWFsbWVcIl0sW3AsZ11dLFsvXFxiKG1pbGVzdG9uZXxkcm9pZCg/OlsyLTR4XXwgKD86YmlvbmljfHgyfHByb3xyYXpyKSk/Oj8oIDRnKT8pXFxiW1xcdyBdK2J1aWxkXFwvL2ksL1xcYm1vdCg/Om9yb2xhKT9bLSBdKFxcdyopL2ksLygoPzptb3RvW1xcd1xcKFxcKSBdK3x4dFxcZHszLDR9fG5leHVzIDYpKD89IGJ1aXxcXCkpKS9pXSxbYyxbbSxNXSxbcCxnXV0sWy9cXGIobXo2MFxcZHx4b29tWzIgXXswLDJ9KSBidWlsZFxcLy9pXSxbYyxbbSxNXSxbcCxrXV0sWy8oKD89bGcpP1t2bF1rXFwtP1xcZHszfSkgYnVpfCAzXFwuWy1cXHc7IF17MTB9bGc/LShbMDZjdjldezMsNH0pL2ldLFtjLFttLFBdLFtwLGtdXSxbLyhsbSg/Oi0/ZjEwMFtudl0/fC1bXFx3XFwuXSspKD89IGJ1aXxcXCkpfG5leHVzIFs0NV0pL2ksL1xcYmxnWy1lO1xcLyBdKygoPyFicm93c2VyfG5ldGNhc3R8YW5kcm9pZCB0dilcXHcrKS9pLC9cXGJsZy0/KFtcXGRcXHddKykgYnVpL2ldLFtjLFttLFBdLFtwLGddXSxbLyhpZGVhdGFiWy1cXHcgXSspL2ksL2xlbm92byA/KHNbNTZdMDAwWy1cXHddK3x0YWIoPzpbXFx3IF0rKXx5dFstXFxkXFx3XXs2fXx0YlstXFxkXFx3XXs2fSkvaV0sW2MsW20sXCJMZW5vdm9cIl0sW3Asa11dLFsvKD86bWFlbW98bm9raWEpLioobjkwMHxsdW1pYSBcXGQrKS9pLC9ub2tpYVstXyBdPyhbLVxcd1xcLl0qKS9pXSxbW2MsL18vZyxcIiBcIl0sW20sXCJOb2tpYVwiXSxbcCxnXV0sWy8ocGl4ZWwgYylcXGIvaV0sW2MsW20sVV0sW3Asa11dLFsvZHJvaWQuKzsgKHBpeGVsW1xcZGF4bCBdezAsNn0pKD86IGJ1aXxcXCkpL2ldLFtjLFttLFVdLFtwLGddXSxbL2Ryb2lkLisgKGE/XFxkWzAtMl17Mn1zb3xbYy1nXVxcZHs0fXxzb1stZ2xdXFx3K3x4cS1hXFx3WzQtN11bMTJdKSg/PSBidWl8XFwpLitjaHJvbWVcXC8oPyFbMS02XXswLDF9XFxkXFwuKSkvaV0sW2MsW20sSV0sW3AsZ11dLFsvc29ueSB0YWJsZXQgW3BzXS9pLC9cXGIoPzpzb255KT9zZ3BcXHcrKD86IGJ1aXxcXCkpL2ldLFtbYyxcIlhwZXJpYSBUYWJsZXRcIl0sW20sSV0sW3Asa11dLFsvIChrYjIwMDV8aW4yMFsxMl01fGJlMjBbMTJdWzU5XSlcXGIvaSwvKD86b25lKT8oPzpwbHVzKT8gKGFcXGQwXFxkXFxkKSg/OiBifFxcKSkvaV0sW2MsW20sXCJPbmVQbHVzXCJdLFtwLGddXSxbLyhhbGV4YSl3ZWJtL2ksLyhrZlthLXpdezJ9d2l8YWVvW2Mtcl17Mn0pKCBidWl8XFwpKS9pLC8oa2ZbYS16XSspKCBidWl8XFwpKS4rc2lsa1xcLy9pXSxbYyxbbSxUXSxbcCxrXV0sWy8oKD86c2R8a2YpWzAzNDloaWpvcnN0dXddKykoIGJ1aXxcXCkpLitzaWxrXFwvL2ldLFtbYywvKC4rKS9nLFwiRmlyZSBQaG9uZSAkMVwiXSxbbSxUXSxbcCxnXV0sWy8ocGxheWJvb2spO1stXFx3XFwpLDsgXSsocmltKS9pXSxbYyxtLFtwLGtdXSxbL1xcYigoPzpiYlthLWZdfHN0W2h2XSkxMDAtXFxkKS9pLC9cXChiYjEwOyAoXFx3KykvaV0sW2MsW20sTl0sW3AsZ11dLFsvKD86XFxifGFzdXNfKSh0cmFuc2ZvW3ByaW1lIF17NCwxMH0gXFx3K3xlZWVwY3xzbGlkZXIgXFx3K3xuZXh1cyA3fHBhZGZvbmV8cDAwW2NqXSkvaV0sW2MsW20sel0sW3Asa11dLFsvICh6W2Jlc102WzAyN11bMDEyXVtrbV1bbHNdfHplbmZvbmUgXFxkXFx3PylcXGIvaV0sW2MsW20sel0sW3AsZ11dLFsvKG5leHVzIDkpL2ldLFtjLFttLFwiSFRDXCJdLFtwLGtdXSxbLyhodGMpWy07XyBdezEsMn0oW1xcdyBdKyg/PVxcKXwgYnVpKXxcXHcrKS9pLC8oenRlKVstIF0oW1xcdyBdKz8pKD86IGJ1aXxcXC98XFwpKS9pLC8oYWxjYXRlbHxnZWVrc3Bob25lfG5leGlhbnxwYW5hc29uaWMoPyEoPzo7fFxcLikpfHNvbnkoPyEtYnJhKSlbLV8gXT8oWy1cXHddKikvaV0sW20sW2MsL18vZyxcIiBcIl0sW3AsZ11dLFsvZHJvaWQuKzsgKFthYl1bMS03XS0/WzAxNzhhXVxcZFxcZD8pL2ldLFtjLFttLFwiQWNlclwiXSxbcCxrXV0sWy9kcm9pZC4rOyAobVsxLTVdIG5vdGUpIGJ1aS9pLC9cXGJtei0oWy1cXHddezIsfSkvaV0sW2MsW20sXCJNZWl6dVwiXSxbcCxnXV0sWy8oYmxhY2tiZXJyeXxiZW5xfHBhbG0oPz1cXC0pfHNvbnllcmljc3NvbnxhY2VyfGFzdXN8ZGVsbHxtZWl6dXxtb3Rvcm9sYXxwb2x5dHJvbilbLV8gXT8oWy1cXHddKikvaSwvKGhwKSAoW1xcdyBdK1xcdykvaSwvKGFzdXMpLT8oXFx3KykvaSwvKG1pY3Jvc29mdCk7IChsdW1pYVtcXHcgXSspL2ksLyhsZW5vdm8pWy1fIF0/KFstXFx3XSspL2ksLyhqb2xsYSkvaSwvKG9wcG8pID8oW1xcdyBdKykgYnVpL2ldLFttLGMsW3AsZ11dLFsvKGtvYm8pXFxzKGVyZWFkZXJ8dG91Y2gpL2ksLyhhcmNob3MpIChnYW1lcGFkMj8pL2ksLyhocCkuKyh0b3VjaHBhZCg/IS4rdGFibGV0KXx0YWJsZXQpL2ksLyhraW5kbGUpXFwvKFtcXHdcXC5dKykvaSwvKG5vb2spW1xcdyBdK2J1aWxkXFwvKFxcdyspL2ksLyhkZWxsKSAoc3RyZWFba3ByXFxkIF0qW1xcZGtvXSkvaSwvKGxlWy0gXStwYW4pWy0gXSsoXFx3ezEsOX0pIGJ1aS9pLC8odHJpbml0eSlbLSBdKih0XFxkezN9KSBidWkvaSwvKGdpZ2FzZXQpWy0gXSsocVxcd3sxLDl9KSBidWkvaSwvKHZvZGFmb25lKSAoW1xcdyBdKykoPzpcXCl8IGJ1aSkvaV0sW20sYyxbcCxrXV0sWy8oc3VyZmFjZSBkdW8pL2ldLFtjLFttLFJdLFtwLGtdXSxbL2Ryb2lkIFtcXGRcXC5dKzsgKGZwXFxkdT8pKD86IGJ8XFwpKS9pXSxbYyxbbSxcIkZhaXJwaG9uZVwiXSxbcCxnXV0sWy8odTMwNGFhKS9pXSxbYyxbbSxcIkFUJlRcIl0sW3AsZ11dLFsvXFxic2llLShcXHcqKS9pXSxbYyxbbSxcIlNpZW1lbnNcIl0sW3AsZ11dLFsvXFxiKHJjdFxcdyspIGIvaV0sW2MsW20sXCJSQ0FcIl0sW3Asa11dLFsvXFxiKHZlbnVlW1xcZCBdezIsN30pIGIvaV0sW2MsW20sXCJEZWxsXCJdLFtwLGtdXSxbL1xcYihxKD86bXZ8dGEpXFx3KykgYi9pXSxbYyxbbSxcIlZlcml6b25cIl0sW3Asa11dLFsvXFxiKD86YmFybmVzWyYgXStub2JsZSB8Ym5bcnRdKShbXFx3XFwrIF0qKSBiL2ldLFtjLFttLFwiQmFybmVzICYgTm9ibGVcIl0sW3Asa11dLFsvXFxiKHRtXFxkezN9XFx3KykgYi9pXSxbYyxbbSxcIk51VmlzaW9uXCJdLFtwLGtdXSxbL1xcYihrODgpIGIvaV0sW2MsW20sXCJaVEVcIl0sW3Asa11dLFsvXFxiKG54XFxkezN9aikgYi9pXSxbYyxbbSxcIlpURVwiXSxbcCxnXV0sWy9cXGIoZ2VuXFxkezN9KSBiLis0OWgvaV0sW2MsW20sXCJTd2lzc1wiXSxbcCxnXV0sWy9cXGIoenVyXFxkezN9KSBiL2ldLFtjLFttLFwiU3dpc3NcIl0sW3Asa11dLFsvXFxiKCh6ZWtpKT90Yi4qXFxiKSBiL2ldLFtjLFttLFwiWmVraVwiXSxbcCxrXV0sWy9cXGIoW3lyXVxcZHsyfSkgYi9pLC9cXGIoZHJhZ29uWy0gXSt0b3VjaCB8ZHQpKFxcd3s1fSkgYi9pXSxbW20sXCJEcmFnb24gVG91Y2hcIl0sYyxbcCxrXV0sWy9cXGIobnMtP1xcd3swLDl9KSBiL2ldLFtjLFttLFwiSW5zaWduaWFcIl0sW3Asa11dLFsvXFxiKChueGF8bmV4dCktP1xcd3swLDl9KSBiL2ldLFtjLFttLFwiTmV4dEJvb2tcIl0sW3Asa11dLFsvXFxiKHh0cmVtZVxcXyk/KHYoMVswNDVdfDJbMDE1XXxbMzQ2OV0wfDdbMDVdKSkgYi9pXSxbW20sXCJWb2ljZVwiXSxjLFtwLGddXSxbL1xcYihsdnRlbFxcLSk/KHYxWzEyXSkgYi9pXSxbW20sXCJMdlRlbFwiXSxjLFtwLGddXSxbL1xcYihwaC0xKSAvaV0sW2MsW20sXCJFc3NlbnRpYWxcIl0sW3AsZ11dLFsvXFxiKHYoMTAwbWR8NzAwbmF8NzAxMXw5MTdnKS4qXFxiKSBiL2ldLFtjLFttLFwiRW52aXplblwiXSxbcCxrXV0sWy9cXGIodHJpb1stXFx3XFwuIF0rKSBiL2ldLFtjLFttLFwiTWFjaFNwZWVkXCJdLFtwLGtdXSxbL1xcYnR1XygxNDkxKSBiL2ldLFtjLFttLFwiUm90b3JcIl0sW3Asa11dLFsvKHNoaWVsZFtcXHcgXSspIGIvaV0sW2MsW20sXCJOdmlkaWFcIl0sW3Asa11dLFsvKHNwcmludCkgKFxcdyspL2ldLFttLGMsW3AsZ11dLFsvKGtpblxcLltvbmV0d117M30pL2ldLFtbYywvXFwuL2csXCIgXCJdLFttLFJdLFtwLGddXSxbL2Ryb2lkLis7IChjYzY2NjY/fGV0NVsxNl18bWNbMjM5XVsyM114P3x2YzhbMDNdeD8pXFwpL2ldLFtjLFttLEddLFtwLGtdXSxbL2Ryb2lkLis7IChlYzMwfHBzMjB8dGNbMi04XVxcZFtreF0pXFwpL2ldLFtjLFttLEddLFtwLGddXSxbL3NtYXJ0LXR2Lisoc2Ftc3VuZykvaV0sW20sW3AseF1dLFsvaGJidHYuK21hcGxlOyhcXGQrKS9pXSxbW2MsL14vLFwiU21hcnRUVlwiXSxbbSxWXSxbcCx4XV0sWy8obnV4OyBuZXRjYXN0LitzbWFydHR2fGxnIChuZXRjYXN0XFwudHYtMjAxXFxkfGFuZHJvaWQgdHYpKS9pXSxbW20sUF0sW3AseF1dLFsvKGFwcGxlKSA/dHYvaV0sW20sW2MsUytcIiBUVlwiXSxbcCx4XV0sWy9jcmtleS9pXSxbW2MsQytcImNhc3RcIl0sW20sVV0sW3AseF1dLFsvZHJvaWQuK2FmdChcXHcpKCBidWl8XFwpKS9pXSxbYyxbbSxUXSxbcCx4XV0sWy9cXChkdHZbXFwpO10uKyhhcXVvcykvaSwvKGFxdW9zLXR2W1xcdyBdKylcXCkvaV0sW2MsW20sRF0sW3AseF1dLFsvKGJyYXZpYVtcXHcgXSspKCBidWl8XFwpKS9pXSxbYyxbbSxJXSxbcCx4XV0sWy8obWl0di1cXHd7NX0pIGJ1aS9pXSxbYyxbbSxGXSxbcCx4XV0sWy9IYmJ0di4qKHRlY2huaXNhdCkgKC4qKTsvaV0sW20sYyxbcCx4XV0sWy9cXGIocm9rdSlbXFxkeF0qW1xcKVxcL10oKD86ZHZwLSk/W1xcZFxcLl0qKS9pLC9oYmJ0dlxcL1xcZCtcXC5cXGQrXFwuXFxkKyArXFwoW1xcd1xcKyBdKjsgKihbXFx3XFxkXVteO10qKTsoW147XSopL2ldLFtbbSx0cmltXSxbYyx0cmltXSxbcCx4XV0sWy9cXGIoYW5kcm9pZCB0dnxzbWFydFstIF0/dHZ8b3BlcmEgdHZ8dHY7IHJ2OilcXGIvaV0sW1twLHhdXSxbLyhvdXlhKS9pLC8obmludGVuZG8pIChbd2lkczN1dGNoXSspL2ldLFttLGMsW3Asdl1dLFsvZHJvaWQuKzsgKHNoaWVsZCkgYnVpL2ldLFtjLFttLFwiTnZpZGlhXCJdLFtwLHZdXSxbLyhwbGF5c3RhdGlvbiBbMzQ1cG9ydGFibGV2aV0rKS9pXSxbYyxbbSxJXSxbcCx2XV0sWy9cXGIoeGJveCg/OiBvbmUpPyg/ITsgeGJveCkpW1xcKTsgXS9pXSxbYyxbbSxSXSxbcCx2XV0sWy8oKHBlYmJsZSkpYXBwL2ldLFttLGMsW3AsX11dLFsvKHdhdGNoKSg/OiA/b3NbLFxcL118XFxkLFxcZFxcLylbXFxkXFwuXSsvaV0sW2MsW20sU10sW3AsX11dLFsvZHJvaWQuKzsgKGdsYXNzKSBcXGQvaV0sW2MsW20sVV0sW3AsX11dLFsvZHJvaWQuKzsgKHd0NjM/MHsyLDN9KVxcKS9pXSxbYyxbbSxHXSxbcCxfXV0sWy8ocXVlc3QoIDJ8IHBybyk/KS9pXSxbYyxbbSxIXSxbcCxfXV0sWy8odGVzbGEpKD86IHF0Y2FyYnJvd3NlcnxcXC9bLVxcd1xcLl0rKS9pXSxbbSxbcCx5XV0sWy8oYWVvYmMpXFxiL2ldLFtjLFttLFRdLFtwLHldXSxbL2Ryb2lkIC4rPzsgKFteO10rPykoPzogYnVpfFxcKSBhcHBsZXcpLis/IG1vYmlsZSBzYWZhcmkvaV0sW2MsW3AsZ11dLFsvZHJvaWQgLis/OyAoW147XSs/KSg/OiBidWl8XFwpIGFwcGxldykuKz8oPyEgbW9iaWxlKSBzYWZhcmkvaV0sW2MsW3Asa11dLFsvXFxiKCh0YWJsZXR8dGFiKVs7XFwvXXxmb2N1c1xcL1xcZCg/IS4rbW9iaWxlKSkvaV0sW1twLGtdXSxbLyhwaG9uZXxtb2JpbGUoPzpbO1xcL118IFsgXFx3XFwvXFwuXSpzYWZhcmkpfHBkYSg/PS4rd2luZG93cyBjZSkpL2ldLFtbcCxnXV0sWy8oYW5kcm9pZFstXFx3XFwuIF17MCw5fSk7LitidWlsL2ldLFtjLFttLFwiR2VuZXJpY1wiXV1dLGVuZ2luZTpbWy93aW5kb3dzLisgZWRnZVxcLyhbXFx3XFwuXSspL2ldLFtmLFt1LEUrXCJIVE1MXCJdXSxbL3dlYmtpdFxcLzUzN1xcLjM2LitjaHJvbWVcXC8oPyEyNykoW1xcd1xcLl0rKS9pXSxbZixbdSxcIkJsaW5rXCJdXSxbLyhwcmVzdG8pXFwvKFtcXHdcXC5dKykvaSwvKHdlYmtpdHx0cmlkZW50fG5ldGZyb250fG5ldHN1cmZ8YW1heWF8bHlueHx3M218Z29hbm5hKVxcLyhbXFx3XFwuXSspL2ksL2VraW9oKGZsb3cpXFwvKFtcXHdcXC5dKykvaSwvKGtodG1sfHRhc21hbnxsaW5rcylbXFwvIF1cXCg/KFtcXHdcXC5dKykvaSwvKGljYWIpW1xcLyBdKFsyM11cXC5bXFxkXFwuXSspL2ksL1xcYihsaWJ3ZWIpL2ldLFt1LGZdLFsvcnZcXDooW1xcd1xcLl17MSw5fSlcXGIuKyhnZWNrbykvaV0sW2YsdV1dLG9zOltbL21pY3Jvc29mdCAod2luZG93cykgKHZpc3RhfHhwKS9pXSxbdSxmXSxbLyh3aW5kb3dzKSBudCA2XFwuMjsgKGFybSkvaSwvKHdpbmRvd3MgKD86cGhvbmUoPzogb3MpP3xtb2JpbGUpKVtcXC8gXT8oW1xcZFxcLlxcdyBdKikvaSwvKHdpbmRvd3MpW1xcLyBdPyhbbnRjZVxcZFxcLiBdK1xcdykoPyEuK3hib3gpL2ldLFt1LFtmLHN0ck1hcHBlcixYXV0sWy8od2luKD89M3w5fG4pfHdpbiA5eCApKFtudFxcZFxcLl0rKS9pXSxbW3UsXCJXaW5kb3dzXCJdLFtmLHN0ck1hcHBlcixYXV0sWy9pcFtob25lYWRdezIsNH1cXGIoPzouKm9zIChbXFx3XSspIGxpa2UgbWFjfDsgb3BlcmEpL2ksL2lvcztmYnN2XFwvKFtcXGRcXC5dKykvaSwvY2ZuZXR3b3JrXFwvLitkYXJ3aW4vaV0sW1tmLC9fL2csXCIuXCJdLFt1LFwiaU9TXCJdXSxbLyhtYWMgb3MgeCkgPyhbXFx3XFwuIF0qKS9pLC8obWFjaW50b3NofG1hY19wb3dlcnBjXFxiKSg/IS4raGFpa3UpL2ldLFtbdSxaXSxbZiwvXy9nLFwiLlwiXV0sWy9kcm9pZCAoW1xcd1xcLl0rKVxcYi4rKGFuZHJvaWRbLSBdeDg2fGhhcm1vbnlvcykvaV0sW2YsdV0sWy8oYW5kcm9pZHx3ZWJvc3xxbnh8YmFkYXxyaW0gdGFibGV0IG9zfG1hZW1vfG1lZWdvfHNhaWxmaXNoKVstXFwvIF0/KFtcXHdcXC5dKikvaSwvKGJsYWNrYmVycnkpXFx3KlxcLyhbXFx3XFwuXSopL2ksLyh0aXplbnxrYWlvcylbXFwvIF0oW1xcd1xcLl0rKS9pLC9cXCgoc2VyaWVzNDApOy9pXSxbdSxmXSxbL1xcKGJiKDEwKTsvaV0sW2YsW3UsTl1dLFsvKD86c3ltYmlhbiA/b3N8c3ltYm9zfHM2MCg/PTspfHNlcmllczYwKVstXFwvIF0/KFtcXHdcXC5dKikvaV0sW2YsW3UsXCJTeW1iaWFuXCJdXSxbL21vemlsbGFcXC9bXFxkXFwuXSsgXFwoKD86bW9iaWxlfHRhYmxldHx0dnxtb2JpbGU7IFtcXHcgXSspOyBydjouKyBnZWNrb1xcLyhbXFx3XFwuXSspL2ldLFtmLFt1LE8rXCIgT1NcIl1dLFsvd2ViMHM7LitydCh0dikvaSwvXFxiKD86aHApP3dvcyg/OmJyb3dzZXIpP1xcLyhbXFx3XFwuXSspL2ldLFtmLFt1LFwid2ViT1NcIl1dLFsvd2F0Y2goPzogP29zWyxcXC9dfFxcZCxcXGRcXC8pKFtcXGRcXC5dKykvaV0sW2YsW3UsXCJ3YXRjaE9TXCJdXSxbL2Nya2V5XFwvKFtcXGRcXC5dKykvaV0sW2YsW3UsQytcImNhc3RcIl1dLFsvKGNyb3MpIFtcXHddKyg/OlxcKXwgKFtcXHdcXC5dKylcXGIpL2ldLFtbdSxMXSxmXSxbL3BhbmFzb25pYzsodmllcmEpL2ksLyhuZXRyYW5nZSltbWgvaSwvKG5ldHR2KVxcLyhcXGQrXFwuW1xcd1xcLl0rKS9pLC8obmludGVuZG98cGxheXN0YXRpb24pIChbd2lkczM0NXBvcnRhYmxldnVjaF0rKS9pLC8oeGJveCk7ICt4Ym94IChbXlxcKTtdKykvaSwvXFxiKGpvbGl8cGFsbSlcXGIgPyg/Om9zKT9cXC8/KFtcXHdcXC5dKikvaSwvKG1pbnQpW1xcL1xcKFxcKSBdPyhcXHcqKS9pLC8obWFnZWlhfHZlY3RvcmxpbnV4KVs7IF0vaSwvKFtreGxuXT91YnVudHV8ZGViaWFufHN1c2V8b3BlbnN1c2V8Z2VudG9vfGFyY2goPz0gbGludXgpfHNsYWNrd2FyZXxmZWRvcmF8bWFuZHJpdmF8Y2VudG9zfHBjbGludXhvc3xyZWQgP2hhdHx6ZW53YWxrfGxpbnB1c3xyYXNwYmlhbnxwbGFuIDl8bWluaXh8cmlzYyBvc3xjb250aWtpfGRlZXBpbnxtYW5qYXJvfGVsZW1lbnRhcnkgb3N8c2FiYXlvbnxsaW5zcGlyZSkoPzogZ251XFwvbGludXgpPyg/OiBlbnRlcnByaXNlKT8oPzpbLSBdbGludXgpPyg/Oi1nbnUpP1stXFwvIF0/KD8hY2hyb218cGFja2FnZSkoWy1cXHdcXC5dKikvaSwvKGh1cmR8bGludXgpID8oW1xcd1xcLl0qKS9pLC8oZ251KSA/KFtcXHdcXC5dKikvaSwvXFxiKFstZnJlbnRvcGNnaHNdezAsNX1ic2R8ZHJhZ29uZmx5KVtcXC8gXT8oPyFhbWR8W2l4MzQ2XXsxLDJ9ODYpKFtcXHdcXC5dKikvaSwvKGhhaWt1KSAoXFx3KykvaV0sW3UsZl0sWy8oc3Vub3MpID8oW1xcd1xcLlxcZF0qKS9pXSxbW3UsXCJTb2xhcmlzXCJdLGZdLFsvKCg/Om9wZW4pP3NvbGFyaXMpWy1cXC8gXT8oW1xcd1xcLl0qKS9pLC8oYWl4KSAoKFxcZCkoPz1cXC58XFwpfCApW1xcd1xcLl0pKi9pLC9cXGIoYmVvc3xvc1xcLzJ8YW1pZ2Fvc3xtb3JwaG9zfG9wZW52bXN8ZnVjaHNpYXxocC11eHxzZXJlbml0eW9zKS9pLC8odW5peCkgPyhbXFx3XFwuXSopL2ldLFt1LGZdXX07dmFyIFVBUGFyc2VyPWZ1bmN0aW9uKGksZSl7aWYodHlwZW9mIGk9PT13KXtlPWk7aT1hfWlmKCEodGhpcyBpbnN0YW5jZW9mIFVBUGFyc2VyKSl7cmV0dXJuIG5ldyBVQVBhcnNlcihpLGUpLmdldFJlc3VsdCgpfXZhciByPXR5cGVvZiBvIT09YiYmby5uYXZpZ2F0b3I/by5uYXZpZ2F0b3I6YTt2YXIgbj1pfHwociYmci51c2VyQWdlbnQ/ci51c2VyQWdlbnQ6dCk7dmFyIHY9ciYmci51c2VyQWdlbnREYXRhP3IudXNlckFnZW50RGF0YTphO3ZhciB4PWU/ZXh0ZW5kKEssZSk6Szt2YXIgXz1yJiZyLnVzZXJBZ2VudD09bjt0aGlzLmdldEJyb3dzZXI9ZnVuY3Rpb24oKXt2YXIgaT17fTtpW3VdPWE7aVtmXT1hO3JneE1hcHBlci5jYWxsKGksbix4LmJyb3dzZXIpO2lbZF09bWFqb3JpemUoaVtmXSk7aWYoXyYmciYmci5icmF2ZSYmdHlwZW9mIHIuYnJhdmUuaXNCcmF2ZT09cyl7aVt1XT1cIkJyYXZlXCJ9cmV0dXJuIGl9O3RoaXMuZ2V0Q1BVPWZ1bmN0aW9uKCl7dmFyIGk9e307aVtoXT1hO3JneE1hcHBlci5jYWxsKGksbix4LmNwdSk7cmV0dXJuIGl9O3RoaXMuZ2V0RGV2aWNlPWZ1bmN0aW9uKCl7dmFyIGk9e307aVttXT1hO2lbY109YTtpW3BdPWE7cmd4TWFwcGVyLmNhbGwoaSxuLHguZGV2aWNlKTtpZihfJiYhaVtwXSYmdiYmdi5tb2JpbGUpe2lbcF09Z31pZihfJiZpW2NdPT1cIk1hY2ludG9zaFwiJiZyJiZ0eXBlb2Ygci5zdGFuZGFsb25lIT09YiYmci5tYXhUb3VjaFBvaW50cyYmci5tYXhUb3VjaFBvaW50cz4yKXtpW2NdPVwiaVBhZFwiO2lbcF09a31yZXR1cm4gaX07dGhpcy5nZXRFbmdpbmU9ZnVuY3Rpb24oKXt2YXIgaT17fTtpW3VdPWE7aVtmXT1hO3JneE1hcHBlci5jYWxsKGksbix4LmVuZ2luZSk7cmV0dXJuIGl9O3RoaXMuZ2V0T1M9ZnVuY3Rpb24oKXt2YXIgaT17fTtpW3VdPWE7aVtmXT1hO3JneE1hcHBlci5jYWxsKGksbix4Lm9zKTtpZihfJiYhaVt1XSYmdiYmdi5wbGF0Zm9ybSE9XCJVbmtub3duXCIpe2lbdV09di5wbGF0Zm9ybS5yZXBsYWNlKC9jaHJvbWUgb3MvaSxMKS5yZXBsYWNlKC9tYWNvcy9pLFopfXJldHVybiBpfTt0aGlzLmdldFJlc3VsdD1mdW5jdGlvbigpe3JldHVybnt1YTp0aGlzLmdldFVBKCksYnJvd3Nlcjp0aGlzLmdldEJyb3dzZXIoKSxlbmdpbmU6dGhpcy5nZXRFbmdpbmUoKSxvczp0aGlzLmdldE9TKCksZGV2aWNlOnRoaXMuZ2V0RGV2aWNlKCksY3B1OnRoaXMuZ2V0Q1BVKCl9fTt0aGlzLmdldFVBPWZ1bmN0aW9uKCl7cmV0dXJuIG59O3RoaXMuc2V0VUE9ZnVuY3Rpb24oaSl7bj10eXBlb2YgaT09PWwmJmkubGVuZ3RoPnE/dHJpbShpLHEpOmk7cmV0dXJuIHRoaXN9O3RoaXMuc2V0VUEobik7cmV0dXJuIHRoaXN9O1VBUGFyc2VyLlZFUlNJT049cjtVQVBhcnNlci5CUk9XU0VSPWVudW1lcml6ZShbdSxmLGRdKTtVQVBhcnNlci5DUFU9ZW51bWVyaXplKFtoXSk7VUFQYXJzZXIuREVWSUNFPWVudW1lcml6ZShbYyxtLHAsdixnLHgsayxfLHldKTtVQVBhcnNlci5FTkdJTkU9VUFQYXJzZXIuT1M9ZW51bWVyaXplKFt1LGZdKTtpZih0eXBlb2YgZSE9PWIpe2lmKFwib2JqZWN0XCIhPT1iJiZpLmV4cG9ydHMpe2U9aS5leHBvcnRzPVVBUGFyc2VyfWUuVUFQYXJzZXI9VUFQYXJzZXJ9ZWxzZXtpZih0eXBlb2YgZGVmaW5lPT09cyYmZGVmaW5lLmFtZCl7ZGVmaW5lKChmdW5jdGlvbigpe3JldHVybiBVQVBhcnNlcn0pKX1lbHNlIGlmKHR5cGVvZiBvIT09Yil7by5VQVBhcnNlcj1VQVBhcnNlcn19dmFyIFE9dHlwZW9mIG8hPT1iJiYoby5qUXVlcnl8fG8uWmVwdG8pO2lmKFEmJiFRLnVhKXt2YXIgWT1uZXcgVUFQYXJzZXI7US51YT1ZLmdldFJlc3VsdCgpO1EudWEuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIFkuZ2V0VUEoKX07US51YS5zZXQ9ZnVuY3Rpb24oaSl7WS5zZXRVQShpKTt2YXIgZT1ZLmdldFJlc3VsdCgpO2Zvcih2YXIgbyBpbiBlKXtRLnVhW29dPWVbb119fX19KSh0eXBlb2Ygd2luZG93PT09XCJvYmplY3RcIj93aW5kb3c6dGhpcyl9fTt2YXIgZT17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKG8pe3ZhciBhPWVbb107aWYoYSE9PXVuZGVmaW5lZCl7cmV0dXJuIGEuZXhwb3J0c312YXIgcj1lW29dPXtleHBvcnRzOnt9fTt2YXIgdD10cnVlO3RyeXtpW29dLmNhbGwoci5leHBvcnRzLHIsci5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3Q9ZmFsc2V9ZmluYWxseXtpZih0KWRlbGV0ZSBlW29dfXJldHVybiByLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciBvPV9fbmNjd3Bja19yZXF1aXJlX18oMjI2KTttb2R1bGUuZXhwb3J0cz1vfSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/compiled/ua-parser-js/ua-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/lib/batcher.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/lib/batcher.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Batcher\", ({\n    enumerable: true,\n    get: function() {\n        return Batcher;\n    }\n}));\nconst _detachedpromise = __webpack_require__(/*! ./detached-promise */ \"(rsc)/./node_modules/next/dist/lib/detached-promise.js\");\nclass Batcher {\n    constructor(cacheKeyFn, /**\n     * A function that will be called to schedule the wrapped function to be\n     * executed. This defaults to a function that will execute the function\n     * immediately.\n     */ schedulerFn = (fn)=>fn()){\n        this.cacheKeyFn = cacheKeyFn;\n        this.schedulerFn = schedulerFn;\n        this.pending = new Map();\n    }\n    static create(options) {\n        return new Batcher(options == null ? void 0 : options.cacheKeyFn, options == null ? void 0 : options.schedulerFn);\n    }\n    /**\n   * Wraps a function in a promise that will be resolved or rejected only once\n   * for a given key. This will allow multiple calls to the function to be\n   * made, but only one will be executed at a time. The result of the first\n   * call will be returned to all callers.\n   *\n   * @param key the key to use for the cache\n   * @param fn the function to wrap\n   * @returns a promise that resolves to the result of the function\n   */ async batch(key, fn) {\n        const cacheKey = this.cacheKeyFn ? await this.cacheKeyFn(key) : key;\n        if (cacheKey === null) {\n            return fn(cacheKey, Promise.resolve);\n        }\n        const pending = this.pending.get(cacheKey);\n        if (pending) return pending;\n        const { promise, resolve, reject } = new _detachedpromise.DetachedPromise();\n        this.pending.set(cacheKey, promise);\n        this.schedulerFn(async ()=>{\n            try {\n                const result = await fn(cacheKey, resolve);\n                // Resolving a promise multiple times is a no-op, so we can safely\n                // resolve all pending promises with the same result.\n                resolve(result);\n            } catch (err) {\n                reject(err);\n            } finally{\n                this.pending.delete(cacheKey);\n            }\n        });\n        return promise;\n    }\n}\n\n//# sourceMappingURL=batcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9iYXRjaGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkNBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseUJBQXlCLG1CQUFPLENBQUMsa0ZBQW9CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcbGliXFxiYXRjaGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmF0Y2hlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQmF0Y2hlcjtcbiAgICB9XG59KTtcbmNvbnN0IF9kZXRhY2hlZHByb21pc2UgPSByZXF1aXJlKFwiLi9kZXRhY2hlZC1wcm9taXNlXCIpO1xuY2xhc3MgQmF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IoY2FjaGVLZXlGbiwgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIHNjaGVkdWxlIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIHRvIGJlXG4gICAgICogZXhlY3V0ZWQuIFRoaXMgZGVmYXVsdHMgdG8gYSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSB0aGUgZnVuY3Rpb25cbiAgICAgKiBpbW1lZGlhdGVseS5cbiAgICAgKi8gc2NoZWR1bGVyRm4gPSAoZm4pPT5mbigpKXtcbiAgICAgICAgdGhpcy5jYWNoZUtleUZuID0gY2FjaGVLZXlGbjtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXJGbiA9IHNjaGVkdWxlckZuO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEJhdGNoZXIob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jYWNoZUtleUZuLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNjaGVkdWxlckZuKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFdyYXBzIGEgZnVuY3Rpb24gaW4gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCBvciByZWplY3RlZCBvbmx5IG9uY2VcbiAgICogZm9yIGEgZ2l2ZW4ga2V5LiBUaGlzIHdpbGwgYWxsb3cgbXVsdGlwbGUgY2FsbHMgdG8gdGhlIGZ1bmN0aW9uIHRvIGJlXG4gICAqIG1hZGUsIGJ1dCBvbmx5IG9uZSB3aWxsIGJlIGV4ZWN1dGVkIGF0IGEgdGltZS4gVGhlIHJlc3VsdCBvZiB0aGUgZmlyc3RcbiAgICogY2FsbCB3aWxsIGJlIHJldHVybmVkIHRvIGFsbCBjYWxsZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlIGZvciB0aGUgY2FjaGVcbiAgICogQHBhcmFtIGZuIHRoZSBmdW5jdGlvbiB0byB3cmFwXG4gICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uXG4gICAqLyBhc3luYyBiYXRjaChrZXksIGZuKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5jYWNoZUtleUZuID8gYXdhaXQgdGhpcy5jYWNoZUtleUZuKGtleSkgOiBrZXk7XG4gICAgICAgIGlmIChjYWNoZUtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKGNhY2hlS2V5LCBQcm9taXNlLnJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmcuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgaWYgKHBlbmRpbmcpIHJldHVybiBwZW5kaW5nO1xuICAgICAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gbmV3IF9kZXRhY2hlZHByb21pc2UuRGV0YWNoZWRQcm9taXNlKCk7XG4gICAgICAgIHRoaXMucGVuZGluZy5zZXQoY2FjaGVLZXksIHByb21pc2UpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlckZuKGFzeW5jICgpPT57XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKGNhY2hlS2V5LCByZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAvLyBSZXNvbHZpbmcgYSBwcm9taXNlIG11bHRpcGxlIHRpbWVzIGlzIGEgbm8tb3AsIHNvIHdlIGNhbiBzYWZlbHlcbiAgICAgICAgICAgICAgICAvLyByZXNvbHZlIGFsbCBwZW5kaW5nIHByb21pc2VzIHdpdGggdGhlIHNhbWUgcmVzdWx0LlxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZy5kZWxldGUoY2FjaGVLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXRjaGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/lib/batcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/lib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/lib/constants.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_SUFFIX: function() {\n        return ACTION_SUFFIX;\n    },\n    APP_DIR_ALIAS: function() {\n        return APP_DIR_ALIAS;\n    },\n    CACHE_ONE_YEAR: function() {\n        return CACHE_ONE_YEAR;\n    },\n    DOT_NEXT_ALIAS: function() {\n        return DOT_NEXT_ALIAS;\n    },\n    ESLINT_DEFAULT_DIRS: function() {\n        return ESLINT_DEFAULT_DIRS;\n    },\n    GSP_NO_RETURNED_VALUE: function() {\n        return GSP_NO_RETURNED_VALUE;\n    },\n    GSSP_COMPONENT_MEMBER_ERROR: function() {\n        return GSSP_COMPONENT_MEMBER_ERROR;\n    },\n    GSSP_NO_RETURNED_VALUE: function() {\n        return GSSP_NO_RETURNED_VALUE;\n    },\n    INFINITE_CACHE: function() {\n        return INFINITE_CACHE;\n    },\n    INSTRUMENTATION_HOOK_FILENAME: function() {\n        return INSTRUMENTATION_HOOK_FILENAME;\n    },\n    MATCHED_PATH_HEADER: function() {\n        return MATCHED_PATH_HEADER;\n    },\n    MIDDLEWARE_FILENAME: function() {\n        return MIDDLEWARE_FILENAME;\n    },\n    MIDDLEWARE_LOCATION_REGEXP: function() {\n        return MIDDLEWARE_LOCATION_REGEXP;\n    },\n    NEXT_BODY_SUFFIX: function() {\n        return NEXT_BODY_SUFFIX;\n    },\n    NEXT_CACHE_IMPLICIT_TAG_ID: function() {\n        return NEXT_CACHE_IMPLICIT_TAG_ID;\n    },\n    NEXT_CACHE_REVALIDATED_TAGS_HEADER: function() {\n        return NEXT_CACHE_REVALIDATED_TAGS_HEADER;\n    },\n    NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER: function() {\n        return NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER;\n    },\n    NEXT_CACHE_SOFT_TAG_MAX_LENGTH: function() {\n        return NEXT_CACHE_SOFT_TAG_MAX_LENGTH;\n    },\n    NEXT_CACHE_TAGS_HEADER: function() {\n        return NEXT_CACHE_TAGS_HEADER;\n    },\n    NEXT_CACHE_TAG_MAX_ITEMS: function() {\n        return NEXT_CACHE_TAG_MAX_ITEMS;\n    },\n    NEXT_CACHE_TAG_MAX_LENGTH: function() {\n        return NEXT_CACHE_TAG_MAX_LENGTH;\n    },\n    NEXT_DATA_SUFFIX: function() {\n        return NEXT_DATA_SUFFIX;\n    },\n    NEXT_INTERCEPTION_MARKER_PREFIX: function() {\n        return NEXT_INTERCEPTION_MARKER_PREFIX;\n    },\n    NEXT_META_SUFFIX: function() {\n        return NEXT_META_SUFFIX;\n    },\n    NEXT_QUERY_PARAM_PREFIX: function() {\n        return NEXT_QUERY_PARAM_PREFIX;\n    },\n    NEXT_RESUME_HEADER: function() {\n        return NEXT_RESUME_HEADER;\n    },\n    NON_STANDARD_NODE_ENV: function() {\n        return NON_STANDARD_NODE_ENV;\n    },\n    PAGES_DIR_ALIAS: function() {\n        return PAGES_DIR_ALIAS;\n    },\n    PRERENDER_REVALIDATE_HEADER: function() {\n        return PRERENDER_REVALIDATE_HEADER;\n    },\n    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER: function() {\n        return PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER;\n    },\n    PUBLIC_DIR_MIDDLEWARE_CONFLICT: function() {\n        return PUBLIC_DIR_MIDDLEWARE_CONFLICT;\n    },\n    ROOT_DIR_ALIAS: function() {\n        return ROOT_DIR_ALIAS;\n    },\n    RSC_ACTION_CLIENT_WRAPPER_ALIAS: function() {\n        return RSC_ACTION_CLIENT_WRAPPER_ALIAS;\n    },\n    RSC_ACTION_ENCRYPTION_ALIAS: function() {\n        return RSC_ACTION_ENCRYPTION_ALIAS;\n    },\n    RSC_ACTION_PROXY_ALIAS: function() {\n        return RSC_ACTION_PROXY_ALIAS;\n    },\n    RSC_ACTION_VALIDATE_ALIAS: function() {\n        return RSC_ACTION_VALIDATE_ALIAS;\n    },\n    RSC_CACHE_WRAPPER_ALIAS: function() {\n        return RSC_CACHE_WRAPPER_ALIAS;\n    },\n    RSC_MOD_REF_PROXY_ALIAS: function() {\n        return RSC_MOD_REF_PROXY_ALIAS;\n    },\n    RSC_PREFETCH_SUFFIX: function() {\n        return RSC_PREFETCH_SUFFIX;\n    },\n    RSC_SEGMENTS_DIR_SUFFIX: function() {\n        return RSC_SEGMENTS_DIR_SUFFIX;\n    },\n    RSC_SEGMENT_SUFFIX: function() {\n        return RSC_SEGMENT_SUFFIX;\n    },\n    RSC_SUFFIX: function() {\n        return RSC_SUFFIX;\n    },\n    SERVER_PROPS_EXPORT_ERROR: function() {\n        return SERVER_PROPS_EXPORT_ERROR;\n    },\n    SERVER_PROPS_GET_INIT_PROPS_CONFLICT: function() {\n        return SERVER_PROPS_GET_INIT_PROPS_CONFLICT;\n    },\n    SERVER_PROPS_SSG_CONFLICT: function() {\n        return SERVER_PROPS_SSG_CONFLICT;\n    },\n    SERVER_RUNTIME: function() {\n        return SERVER_RUNTIME;\n    },\n    SSG_FALLBACK_EXPORT_ERROR: function() {\n        return SSG_FALLBACK_EXPORT_ERROR;\n    },\n    SSG_GET_INITIAL_PROPS_CONFLICT: function() {\n        return SSG_GET_INITIAL_PROPS_CONFLICT;\n    },\n    STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR: function() {\n        return STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR;\n    },\n    UNSTABLE_REVALIDATE_RENAME_ERROR: function() {\n        return UNSTABLE_REVALIDATE_RENAME_ERROR;\n    },\n    WEBPACK_LAYERS: function() {\n        return WEBPACK_LAYERS;\n    },\n    WEBPACK_RESOURCE_QUERIES: function() {\n        return WEBPACK_RESOURCE_QUERIES;\n    }\n});\nconst NEXT_QUERY_PARAM_PREFIX = 'nxtP';\nconst NEXT_INTERCEPTION_MARKER_PREFIX = 'nxtI';\nconst MATCHED_PATH_HEADER = 'x-matched-path';\nconst PRERENDER_REVALIDATE_HEADER = 'x-prerender-revalidate';\nconst PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = 'x-prerender-revalidate-if-generated';\nconst RSC_PREFETCH_SUFFIX = '.prefetch.rsc';\nconst RSC_SEGMENTS_DIR_SUFFIX = '.segments';\nconst RSC_SEGMENT_SUFFIX = '.segment.rsc';\nconst RSC_SUFFIX = '.rsc';\nconst ACTION_SUFFIX = '.action';\nconst NEXT_DATA_SUFFIX = '.json';\nconst NEXT_META_SUFFIX = '.meta';\nconst NEXT_BODY_SUFFIX = '.body';\nconst NEXT_CACHE_TAGS_HEADER = 'x-next-cache-tags';\nconst NEXT_CACHE_REVALIDATED_TAGS_HEADER = 'x-next-revalidated-tags';\nconst NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER = 'x-next-revalidate-tag-token';\nconst NEXT_RESUME_HEADER = 'next-resume';\nconst NEXT_CACHE_TAG_MAX_ITEMS = 128;\nconst NEXT_CACHE_TAG_MAX_LENGTH = 256;\nconst NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024;\nconst NEXT_CACHE_IMPLICIT_TAG_ID = '_N_T_';\nconst CACHE_ONE_YEAR = 31536000;\nconst INFINITE_CACHE = 0xfffffffe;\nconst MIDDLEWARE_FILENAME = 'middleware';\nconst MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`;\nconst INSTRUMENTATION_HOOK_FILENAME = 'instrumentation';\nconst PAGES_DIR_ALIAS = 'private-next-pages';\nconst DOT_NEXT_ALIAS = 'private-dot-next';\nconst ROOT_DIR_ALIAS = 'private-next-root-dir';\nconst APP_DIR_ALIAS = 'private-next-app-dir';\nconst RSC_MOD_REF_PROXY_ALIAS = 'next/dist/build/webpack/loaders/next-flight-loader/module-proxy';\nconst RSC_ACTION_VALIDATE_ALIAS = 'private-next-rsc-action-validate';\nconst RSC_ACTION_PROXY_ALIAS = 'private-next-rsc-server-reference';\nconst RSC_CACHE_WRAPPER_ALIAS = 'private-next-rsc-cache-wrapper';\nconst RSC_ACTION_ENCRYPTION_ALIAS = 'private-next-rsc-action-encryption';\nconst RSC_ACTION_CLIENT_WRAPPER_ALIAS = 'private-next-rsc-action-client-wrapper';\nconst PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`;\nconst SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`;\nconst SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`;\nconst SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`;\nconst STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`;\nconst SERVER_PROPS_EXPORT_ERROR = `pages with \\`getServerSideProps\\` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`;\nconst GSP_NO_RETURNED_VALUE = 'Your `getStaticProps` function did not return an object. Did you forget to add a `return`?';\nconst GSSP_NO_RETURNED_VALUE = 'Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?';\nconst UNSTABLE_REVALIDATE_RENAME_ERROR = 'The `unstable_revalidate` property is available for general use.\\n' + 'Please use `revalidate` instead.';\nconst GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`;\nconst NON_STANDARD_NODE_ENV = `You are using a non-standard \"NODE_ENV\" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;\nconst SSG_FALLBACK_EXPORT_ERROR = `Pages with \\`fallback\\` enabled in \\`getStaticPaths\\` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`;\nconst ESLINT_DEFAULT_DIRS = [\n    'app',\n    'pages',\n    'components',\n    'lib',\n    'src'\n];\nconst SERVER_RUNTIME = {\n    edge: 'edge',\n    experimentalEdge: 'experimental-edge',\n    nodejs: 'nodejs'\n};\n/**\n * The names of the webpack layers. These layers are the primitives for the\n * webpack chunks.\n */ const WEBPACK_LAYERS_NAMES = {\n    /**\n   * The layer for the shared code between the client and server bundles.\n   */ shared: 'shared',\n    /**\n   * The layer for server-only runtime and picking up `react-server` export conditions.\n   * Including app router RSC pages and app router custom routes and metadata routes.\n   */ reactServerComponents: 'rsc',\n    /**\n   * Server Side Rendering layer for app (ssr).\n   */ serverSideRendering: 'ssr',\n    /**\n   * The browser client bundle layer for actions.\n   */ actionBrowser: 'action-browser',\n    /**\n   * The Node.js bundle layer for the API routes.\n   */ apiNode: 'api-node',\n    /**\n   * The Edge Lite bundle layer for the API routes.\n   */ apiEdge: 'api-edge',\n    /**\n   * The layer for the middleware code.\n   */ middleware: 'middleware',\n    /**\n   * The layer for the instrumentation hooks.\n   */ instrument: 'instrument',\n    /**\n   * The layer for assets on the edge.\n   */ edgeAsset: 'edge-asset',\n    /**\n   * The browser client bundle layer for App directory.\n   */ appPagesBrowser: 'app-pages-browser',\n    /**\n   * The browser client bundle layer for Pages directory.\n   */ pagesDirBrowser: 'pages-dir-browser',\n    /**\n   * The Edge Lite bundle layer for Pages directory.\n   */ pagesDirEdge: 'pages-dir-edge',\n    /**\n   * The Node.js bundle layer for Pages directory.\n   */ pagesDirNode: 'pages-dir-node'\n};\nconst WEBPACK_LAYERS = {\n    ...WEBPACK_LAYERS_NAMES,\n    GROUP: {\n        builtinReact: [\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\n            WEBPACK_LAYERS_NAMES.actionBrowser\n        ],\n        serverOnly: [\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\n            WEBPACK_LAYERS_NAMES.actionBrowser,\n            WEBPACK_LAYERS_NAMES.instrument,\n            WEBPACK_LAYERS_NAMES.middleware\n        ],\n        neutralTarget: [\n            // pages api\n            WEBPACK_LAYERS_NAMES.apiNode,\n            WEBPACK_LAYERS_NAMES.apiEdge\n        ],\n        clientOnly: [\n            WEBPACK_LAYERS_NAMES.serverSideRendering,\n            WEBPACK_LAYERS_NAMES.appPagesBrowser\n        ],\n        bundled: [\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\n            WEBPACK_LAYERS_NAMES.actionBrowser,\n            WEBPACK_LAYERS_NAMES.serverSideRendering,\n            WEBPACK_LAYERS_NAMES.appPagesBrowser,\n            WEBPACK_LAYERS_NAMES.shared,\n            WEBPACK_LAYERS_NAMES.instrument,\n            WEBPACK_LAYERS_NAMES.middleware\n        ],\n        appPages: [\n            // app router pages and layouts\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\n            WEBPACK_LAYERS_NAMES.serverSideRendering,\n            WEBPACK_LAYERS_NAMES.appPagesBrowser,\n            WEBPACK_LAYERS_NAMES.actionBrowser\n        ]\n    }\n};\nconst WEBPACK_RESOURCE_QUERIES = {\n    edgeSSREntry: '__next_edge_ssr_entry__',\n    metadata: '__next_metadata__',\n    metadataRoute: '__next_metadata_route__',\n    metadataImageMeta: '__next_metadata_image_meta__'\n};\n\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixNQUFNLENBcURMO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msb0JBQW9CO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGxpYlxcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQUNUSU9OX1NVRkZJWDogbnVsbCxcbiAgICBBUFBfRElSX0FMSUFTOiBudWxsLFxuICAgIENBQ0hFX09ORV9ZRUFSOiBudWxsLFxuICAgIERPVF9ORVhUX0FMSUFTOiBudWxsLFxuICAgIEVTTElOVF9ERUZBVUxUX0RJUlM6IG51bGwsXG4gICAgR1NQX05PX1JFVFVSTkVEX1ZBTFVFOiBudWxsLFxuICAgIEdTU1BfQ09NUE9ORU5UX01FTUJFUl9FUlJPUjogbnVsbCxcbiAgICBHU1NQX05PX1JFVFVSTkVEX1ZBTFVFOiBudWxsLFxuICAgIElORklOSVRFX0NBQ0hFOiBudWxsLFxuICAgIElOU1RSVU1FTlRBVElPTl9IT09LX0ZJTEVOQU1FOiBudWxsLFxuICAgIE1BVENIRURfUEFUSF9IRUFERVI6IG51bGwsXG4gICAgTUlERExFV0FSRV9GSUxFTkFNRTogbnVsbCxcbiAgICBNSURETEVXQVJFX0xPQ0FUSU9OX1JFR0VYUDogbnVsbCxcbiAgICBORVhUX0JPRFlfU1VGRklYOiBudWxsLFxuICAgIE5FWFRfQ0FDSEVfSU1QTElDSVRfVEFHX0lEOiBudWxsLFxuICAgIE5FWFRfQ0FDSEVfUkVWQUxJREFURURfVEFHU19IRUFERVI6IG51bGwsXG4gICAgTkVYVF9DQUNIRV9SRVZBTElEQVRFX1RBR19UT0tFTl9IRUFERVI6IG51bGwsXG4gICAgTkVYVF9DQUNIRV9TT0ZUX1RBR19NQVhfTEVOR1RIOiBudWxsLFxuICAgIE5FWFRfQ0FDSEVfVEFHU19IRUFERVI6IG51bGwsXG4gICAgTkVYVF9DQUNIRV9UQUdfTUFYX0lURU1TOiBudWxsLFxuICAgIE5FWFRfQ0FDSEVfVEFHX01BWF9MRU5HVEg6IG51bGwsXG4gICAgTkVYVF9EQVRBX1NVRkZJWDogbnVsbCxcbiAgICBORVhUX0lOVEVSQ0VQVElPTl9NQVJLRVJfUFJFRklYOiBudWxsLFxuICAgIE5FWFRfTUVUQV9TVUZGSVg6IG51bGwsXG4gICAgTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVg6IG51bGwsXG4gICAgTkVYVF9SRVNVTUVfSEVBREVSOiBudWxsLFxuICAgIE5PTl9TVEFOREFSRF9OT0RFX0VOVjogbnVsbCxcbiAgICBQQUdFU19ESVJfQUxJQVM6IG51bGwsXG4gICAgUFJFUkVOREVSX1JFVkFMSURBVEVfSEVBREVSOiBudWxsLFxuICAgIFBSRVJFTkRFUl9SRVZBTElEQVRFX09OTFlfR0VORVJBVEVEX0hFQURFUjogbnVsbCxcbiAgICBQVUJMSUNfRElSX01JRERMRVdBUkVfQ09ORkxJQ1Q6IG51bGwsXG4gICAgUk9PVF9ESVJfQUxJQVM6IG51bGwsXG4gICAgUlNDX0FDVElPTl9DTElFTlRfV1JBUFBFUl9BTElBUzogbnVsbCxcbiAgICBSU0NfQUNUSU9OX0VOQ1JZUFRJT05fQUxJQVM6IG51bGwsXG4gICAgUlNDX0FDVElPTl9QUk9YWV9BTElBUzogbnVsbCxcbiAgICBSU0NfQUNUSU9OX1ZBTElEQVRFX0FMSUFTOiBudWxsLFxuICAgIFJTQ19DQUNIRV9XUkFQUEVSX0FMSUFTOiBudWxsLFxuICAgIFJTQ19NT0RfUkVGX1BST1hZX0FMSUFTOiBudWxsLFxuICAgIFJTQ19QUkVGRVRDSF9TVUZGSVg6IG51bGwsXG4gICAgUlNDX1NFR01FTlRTX0RJUl9TVUZGSVg6IG51bGwsXG4gICAgUlNDX1NFR01FTlRfU1VGRklYOiBudWxsLFxuICAgIFJTQ19TVUZGSVg6IG51bGwsXG4gICAgU0VSVkVSX1BST1BTX0VYUE9SVF9FUlJPUjogbnVsbCxcbiAgICBTRVJWRVJfUFJPUFNfR0VUX0lOSVRfUFJPUFNfQ09ORkxJQ1Q6IG51bGwsXG4gICAgU0VSVkVSX1BST1BTX1NTR19DT05GTElDVDogbnVsbCxcbiAgICBTRVJWRVJfUlVOVElNRTogbnVsbCxcbiAgICBTU0dfRkFMTEJBQ0tfRVhQT1JUX0VSUk9SOiBudWxsLFxuICAgIFNTR19HRVRfSU5JVElBTF9QUk9QU19DT05GTElDVDogbnVsbCxcbiAgICBTVEFUSUNfU1RBVFVTX1BBR0VfR0VUX0lOSVRJQUxfUFJPUFNfRVJST1I6IG51bGwsXG4gICAgVU5TVEFCTEVfUkVWQUxJREFURV9SRU5BTUVfRVJST1I6IG51bGwsXG4gICAgV0VCUEFDS19MQVlFUlM6IG51bGwsXG4gICAgV0VCUEFDS19SRVNPVVJDRV9RVUVSSUVTOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIEFDVElPTl9TVUZGSVg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OX1NVRkZJWDtcbiAgICB9LFxuICAgIEFQUF9ESVJfQUxJQVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQVBQX0RJUl9BTElBUztcbiAgICB9LFxuICAgIENBQ0hFX09ORV9ZRUFSOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIENBQ0hFX09ORV9ZRUFSO1xuICAgIH0sXG4gICAgRE9UX05FWFRfQUxJQVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRE9UX05FWFRfQUxJQVM7XG4gICAgfSxcbiAgICBFU0xJTlRfREVGQVVMVF9ESVJTOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEVTTElOVF9ERUZBVUxUX0RJUlM7XG4gICAgfSxcbiAgICBHU1BfTk9fUkVUVVJORURfVkFMVUU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gR1NQX05PX1JFVFVSTkVEX1ZBTFVFO1xuICAgIH0sXG4gICAgR1NTUF9DT01QT05FTlRfTUVNQkVSX0VSUk9SOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEdTU1BfQ09NUE9ORU5UX01FTUJFUl9FUlJPUjtcbiAgICB9LFxuICAgIEdTU1BfTk9fUkVUVVJORURfVkFMVUU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gR1NTUF9OT19SRVRVUk5FRF9WQUxVRTtcbiAgICB9LFxuICAgIElORklOSVRFX0NBQ0hFOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIElORklOSVRFX0NBQ0hFO1xuICAgIH0sXG4gICAgSU5TVFJVTUVOVEFUSU9OX0hPT0tfRklMRU5BTUU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSU5TVFJVTUVOVEFUSU9OX0hPT0tfRklMRU5BTUU7XG4gICAgfSxcbiAgICBNQVRDSEVEX1BBVEhfSEVBREVSOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1BVENIRURfUEFUSF9IRUFERVI7XG4gICAgfSxcbiAgICBNSURETEVXQVJFX0ZJTEVOQU1FOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1JRERMRVdBUkVfRklMRU5BTUU7XG4gICAgfSxcbiAgICBNSURETEVXQVJFX0xPQ0FUSU9OX1JFR0VYUDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNSURETEVXQVJFX0xPQ0FUSU9OX1JFR0VYUDtcbiAgICB9LFxuICAgIE5FWFRfQk9EWV9TVUZGSVg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9CT0RZX1NVRkZJWDtcbiAgICB9LFxuICAgIE5FWFRfQ0FDSEVfSU1QTElDSVRfVEFHX0lEOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfQ0FDSEVfSU1QTElDSVRfVEFHX0lEO1xuICAgIH0sXG4gICAgTkVYVF9DQUNIRV9SRVZBTElEQVRFRF9UQUdTX0hFQURFUjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBORVhUX0NBQ0hFX1JFVkFMSURBVEVEX1RBR1NfSEVBREVSO1xuICAgIH0sXG4gICAgTkVYVF9DQUNIRV9SRVZBTElEQVRFX1RBR19UT0tFTl9IRUFERVI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9DQUNIRV9SRVZBTElEQVRFX1RBR19UT0tFTl9IRUFERVI7XG4gICAgfSxcbiAgICBORVhUX0NBQ0hFX1NPRlRfVEFHX01BWF9MRU5HVEg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9DQUNIRV9TT0ZUX1RBR19NQVhfTEVOR1RIO1xuICAgIH0sXG4gICAgTkVYVF9DQUNIRV9UQUdTX0hFQURFUjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBORVhUX0NBQ0hFX1RBR1NfSEVBREVSO1xuICAgIH0sXG4gICAgTkVYVF9DQUNIRV9UQUdfTUFYX0lURU1TOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfQ0FDSEVfVEFHX01BWF9JVEVNUztcbiAgICB9LFxuICAgIE5FWFRfQ0FDSEVfVEFHX01BWF9MRU5HVEg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9DQUNIRV9UQUdfTUFYX0xFTkdUSDtcbiAgICB9LFxuICAgIE5FWFRfREFUQV9TVUZGSVg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9EQVRBX1NVRkZJWDtcbiAgICB9LFxuICAgIE5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWDtcbiAgICB9LFxuICAgIE5FWFRfTUVUQV9TVUZGSVg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9NRVRBX1NVRkZJWDtcbiAgICB9LFxuICAgIE5FWFRfUVVFUllfUEFSQU1fUFJFRklYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfUVVFUllfUEFSQU1fUFJFRklYO1xuICAgIH0sXG4gICAgTkVYVF9SRVNVTUVfSEVBREVSOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfUkVTVU1FX0hFQURFUjtcbiAgICB9LFxuICAgIE5PTl9TVEFOREFSRF9OT0RFX0VOVjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBOT05fU1RBTkRBUkRfTk9ERV9FTlY7XG4gICAgfSxcbiAgICBQQUdFU19ESVJfQUxJQVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUEFHRVNfRElSX0FMSUFTO1xuICAgIH0sXG4gICAgUFJFUkVOREVSX1JFVkFMSURBVEVfSEVBREVSOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBSRVJFTkRFUl9SRVZBTElEQVRFX0hFQURFUjtcbiAgICB9LFxuICAgIFBSRVJFTkRFUl9SRVZBTElEQVRFX09OTFlfR0VORVJBVEVEX0hFQURFUjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQUkVSRU5ERVJfUkVWQUxJREFURV9PTkxZX0dFTkVSQVRFRF9IRUFERVI7XG4gICAgfSxcbiAgICBQVUJMSUNfRElSX01JRERMRVdBUkVfQ09ORkxJQ1Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUFVCTElDX0RJUl9NSURETEVXQVJFX0NPTkZMSUNUO1xuICAgIH0sXG4gICAgUk9PVF9ESVJfQUxJQVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUk9PVF9ESVJfQUxJQVM7XG4gICAgfSxcbiAgICBSU0NfQUNUSU9OX0NMSUVOVF9XUkFQUEVSX0FMSUFTOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJTQ19BQ1RJT05fQ0xJRU5UX1dSQVBQRVJfQUxJQVM7XG4gICAgfSxcbiAgICBSU0NfQUNUSU9OX0VOQ1JZUFRJT05fQUxJQVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUlNDX0FDVElPTl9FTkNSWVBUSU9OX0FMSUFTO1xuICAgIH0sXG4gICAgUlNDX0FDVElPTl9QUk9YWV9BTElBUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSU0NfQUNUSU9OX1BST1hZX0FMSUFTO1xuICAgIH0sXG4gICAgUlNDX0FDVElPTl9WQUxJREFURV9BTElBUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSU0NfQUNUSU9OX1ZBTElEQVRFX0FMSUFTO1xuICAgIH0sXG4gICAgUlNDX0NBQ0hFX1dSQVBQRVJfQUxJQVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUlNDX0NBQ0hFX1dSQVBQRVJfQUxJQVM7XG4gICAgfSxcbiAgICBSU0NfTU9EX1JFRl9QUk9YWV9BTElBUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSU0NfTU9EX1JFRl9QUk9YWV9BTElBUztcbiAgICB9LFxuICAgIFJTQ19QUkVGRVRDSF9TVUZGSVg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUlNDX1BSRUZFVENIX1NVRkZJWDtcbiAgICB9LFxuICAgIFJTQ19TRUdNRU5UU19ESVJfU1VGRklYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJTQ19TRUdNRU5UU19ESVJfU1VGRklYO1xuICAgIH0sXG4gICAgUlNDX1NFR01FTlRfU1VGRklYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJTQ19TRUdNRU5UX1NVRkZJWDtcbiAgICB9LFxuICAgIFJTQ19TVUZGSVg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUlNDX1NVRkZJWDtcbiAgICB9LFxuICAgIFNFUlZFUl9QUk9QU19FWFBPUlRfRVJST1I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU0VSVkVSX1BST1BTX0VYUE9SVF9FUlJPUjtcbiAgICB9LFxuICAgIFNFUlZFUl9QUk9QU19HRVRfSU5JVF9QUk9QU19DT05GTElDVDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTRVJWRVJfUFJPUFNfR0VUX0lOSVRfUFJPUFNfQ09ORkxJQ1Q7XG4gICAgfSxcbiAgICBTRVJWRVJfUFJPUFNfU1NHX0NPTkZMSUNUOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFNFUlZFUl9QUk9QU19TU0dfQ09ORkxJQ1Q7XG4gICAgfSxcbiAgICBTRVJWRVJfUlVOVElNRTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTRVJWRVJfUlVOVElNRTtcbiAgICB9LFxuICAgIFNTR19GQUxMQkFDS19FWFBPUlRfRVJST1I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU1NHX0ZBTExCQUNLX0VYUE9SVF9FUlJPUjtcbiAgICB9LFxuICAgIFNTR19HRVRfSU5JVElBTF9QUk9QU19DT05GTElDVDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTU0dfR0VUX0lOSVRJQUxfUFJPUFNfQ09ORkxJQ1Q7XG4gICAgfSxcbiAgICBTVEFUSUNfU1RBVFVTX1BBR0VfR0VUX0lOSVRJQUxfUFJPUFNfRVJST1I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU1RBVElDX1NUQVRVU19QQUdFX0dFVF9JTklUSUFMX1BST1BTX0VSUk9SO1xuICAgIH0sXG4gICAgVU5TVEFCTEVfUkVWQUxJREFURV9SRU5BTUVfRVJST1I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gVU5TVEFCTEVfUkVWQUxJREFURV9SRU5BTUVfRVJST1I7XG4gICAgfSxcbiAgICBXRUJQQUNLX0xBWUVSUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBXRUJQQUNLX0xBWUVSUztcbiAgICB9LFxuICAgIFdFQlBBQ0tfUkVTT1VSQ0VfUVVFUklFUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBXRUJQQUNLX1JFU09VUkNFX1FVRVJJRVM7XG4gICAgfVxufSk7XG5jb25zdCBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCA9ICdueHRQJztcbmNvbnN0IE5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVggPSAnbnh0SSc7XG5jb25zdCBNQVRDSEVEX1BBVEhfSEVBREVSID0gJ3gtbWF0Y2hlZC1wYXRoJztcbmNvbnN0IFBSRVJFTkRFUl9SRVZBTElEQVRFX0hFQURFUiA9ICd4LXByZXJlbmRlci1yZXZhbGlkYXRlJztcbmNvbnN0IFBSRVJFTkRFUl9SRVZBTElEQVRFX09OTFlfR0VORVJBVEVEX0hFQURFUiA9ICd4LXByZXJlbmRlci1yZXZhbGlkYXRlLWlmLWdlbmVyYXRlZCc7XG5jb25zdCBSU0NfUFJFRkVUQ0hfU1VGRklYID0gJy5wcmVmZXRjaC5yc2MnO1xuY29uc3QgUlNDX1NFR01FTlRTX0RJUl9TVUZGSVggPSAnLnNlZ21lbnRzJztcbmNvbnN0IFJTQ19TRUdNRU5UX1NVRkZJWCA9ICcuc2VnbWVudC5yc2MnO1xuY29uc3QgUlNDX1NVRkZJWCA9ICcucnNjJztcbmNvbnN0IEFDVElPTl9TVUZGSVggPSAnLmFjdGlvbic7XG5jb25zdCBORVhUX0RBVEFfU1VGRklYID0gJy5qc29uJztcbmNvbnN0IE5FWFRfTUVUQV9TVUZGSVggPSAnLm1ldGEnO1xuY29uc3QgTkVYVF9CT0RZX1NVRkZJWCA9ICcuYm9keSc7XG5jb25zdCBORVhUX0NBQ0hFX1RBR1NfSEVBREVSID0gJ3gtbmV4dC1jYWNoZS10YWdzJztcbmNvbnN0IE5FWFRfQ0FDSEVfUkVWQUxJREFURURfVEFHU19IRUFERVIgPSAneC1uZXh0LXJldmFsaWRhdGVkLXRhZ3MnO1xuY29uc3QgTkVYVF9DQUNIRV9SRVZBTElEQVRFX1RBR19UT0tFTl9IRUFERVIgPSAneC1uZXh0LXJldmFsaWRhdGUtdGFnLXRva2VuJztcbmNvbnN0IE5FWFRfUkVTVU1FX0hFQURFUiA9ICduZXh0LXJlc3VtZSc7XG5jb25zdCBORVhUX0NBQ0hFX1RBR19NQVhfSVRFTVMgPSAxMjg7XG5jb25zdCBORVhUX0NBQ0hFX1RBR19NQVhfTEVOR1RIID0gMjU2O1xuY29uc3QgTkVYVF9DQUNIRV9TT0ZUX1RBR19NQVhfTEVOR1RIID0gMTAyNDtcbmNvbnN0IE5FWFRfQ0FDSEVfSU1QTElDSVRfVEFHX0lEID0gJ19OX1RfJztcbmNvbnN0IENBQ0hFX09ORV9ZRUFSID0gMzE1MzYwMDA7XG5jb25zdCBJTkZJTklURV9DQUNIRSA9IDB4ZmZmZmZmZmU7XG5jb25zdCBNSURETEVXQVJFX0ZJTEVOQU1FID0gJ21pZGRsZXdhcmUnO1xuY29uc3QgTUlERExFV0FSRV9MT0NBVElPTl9SRUdFWFAgPSBgKD86c3JjLyk/JHtNSURETEVXQVJFX0ZJTEVOQU1FfWA7XG5jb25zdCBJTlNUUlVNRU5UQVRJT05fSE9PS19GSUxFTkFNRSA9ICdpbnN0cnVtZW50YXRpb24nO1xuY29uc3QgUEFHRVNfRElSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1wYWdlcyc7XG5jb25zdCBET1RfTkVYVF9BTElBUyA9ICdwcml2YXRlLWRvdC1uZXh0JztcbmNvbnN0IFJPT1RfRElSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yb290LWRpcic7XG5jb25zdCBBUFBfRElSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1hcHAtZGlyJztcbmNvbnN0IFJTQ19NT0RfUkVGX1BST1hZX0FMSUFTID0gJ25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1mbGlnaHQtbG9hZGVyL21vZHVsZS1wcm94eSc7XG5jb25zdCBSU0NfQUNUSU9OX1ZBTElEQVRFX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yc2MtYWN0aW9uLXZhbGlkYXRlJztcbmNvbnN0IFJTQ19BQ1RJT05fUFJPWFlfQUxJQVMgPSAncHJpdmF0ZS1uZXh0LXJzYy1zZXJ2ZXItcmVmZXJlbmNlJztcbmNvbnN0IFJTQ19DQUNIRV9XUkFQUEVSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yc2MtY2FjaGUtd3JhcHBlcic7XG5jb25zdCBSU0NfQUNUSU9OX0VOQ1JZUFRJT05fQUxJQVMgPSAncHJpdmF0ZS1uZXh0LXJzYy1hY3Rpb24tZW5jcnlwdGlvbic7XG5jb25zdCBSU0NfQUNUSU9OX0NMSUVOVF9XUkFQUEVSX0FMSUFTID0gJ3ByaXZhdGUtbmV4dC1yc2MtYWN0aW9uLWNsaWVudC13cmFwcGVyJztcbmNvbnN0IFBVQkxJQ19ESVJfTUlERExFV0FSRV9DT05GTElDVCA9IGBZb3UgY2FuIG5vdCBoYXZlIGEgJ19uZXh0JyBmb2xkZXIgaW5zaWRlIG9mIHlvdXIgcHVibGljIGZvbGRlci4gVGhpcyBjb25mbGljdHMgd2l0aCB0aGUgaW50ZXJuYWwgJy9fbmV4dCcgcm91dGUuIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3B1YmxpYy1uZXh0LWZvbGRlci1jb25mbGljdGA7XG5jb25zdCBTU0dfR0VUX0lOSVRJQUxfUFJPUFNfQ09ORkxJQ1QgPSBgWW91IGNhbiBub3QgdXNlIGdldEluaXRpYWxQcm9wcyB3aXRoIGdldFN0YXRpY1Byb3BzLiBUbyB1c2UgU1NHLCBwbGVhc2UgcmVtb3ZlIHlvdXIgZ2V0SW5pdGlhbFByb3BzYDtcbmNvbnN0IFNFUlZFUl9QUk9QU19HRVRfSU5JVF9QUk9QU19DT05GTElDVCA9IGBZb3UgY2FuIG5vdCB1c2UgZ2V0SW5pdGlhbFByb3BzIHdpdGggZ2V0U2VydmVyU2lkZVByb3BzLiBQbGVhc2UgcmVtb3ZlIGdldEluaXRpYWxQcm9wcy5gO1xuY29uc3QgU0VSVkVSX1BST1BTX1NTR19DT05GTElDVCA9IGBZb3UgY2FuIG5vdCB1c2UgZ2V0U3RhdGljUHJvcHMgb3IgZ2V0U3RhdGljUGF0aHMgd2l0aCBnZXRTZXJ2ZXJTaWRlUHJvcHMuIFRvIHVzZSBTU0csIHBsZWFzZSByZW1vdmUgZ2V0U2VydmVyU2lkZVByb3BzYDtcbmNvbnN0IFNUQVRJQ19TVEFUVVNfUEFHRV9HRVRfSU5JVElBTF9QUk9QU19FUlJPUiA9IGBjYW4gbm90IGhhdmUgZ2V0SW5pdGlhbFByb3BzL2dldFNlcnZlclNpZGVQcm9wcywgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvNDA0LWdldC1pbml0aWFsLXByb3BzYDtcbmNvbnN0IFNFUlZFUl9QUk9QU19FWFBPUlRfRVJST1IgPSBgcGFnZXMgd2l0aCBcXGBnZXRTZXJ2ZXJTaWRlUHJvcHNcXGAgY2FuIG5vdCBiZSBleHBvcnRlZC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9nc3NwLWV4cG9ydGA7XG5jb25zdCBHU1BfTk9fUkVUVVJORURfVkFMVUUgPSAnWW91ciBgZ2V0U3RhdGljUHJvcHNgIGZ1bmN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdC4gRGlkIHlvdSBmb3JnZXQgdG8gYWRkIGEgYHJldHVybmA/JztcbmNvbnN0IEdTU1BfTk9fUkVUVVJORURfVkFMVUUgPSAnWW91ciBgZ2V0U2VydmVyU2lkZVByb3BzYCBmdW5jdGlvbiBkaWQgbm90IHJldHVybiBhbiBvYmplY3QuIERpZCB5b3UgZm9yZ2V0IHRvIGFkZCBhIGByZXR1cm5gPyc7XG5jb25zdCBVTlNUQUJMRV9SRVZBTElEQVRFX1JFTkFNRV9FUlJPUiA9ICdUaGUgYHVuc3RhYmxlX3JldmFsaWRhdGVgIHByb3BlcnR5IGlzIGF2YWlsYWJsZSBmb3IgZ2VuZXJhbCB1c2UuXFxuJyArICdQbGVhc2UgdXNlIGByZXZhbGlkYXRlYCBpbnN0ZWFkLic7XG5jb25zdCBHU1NQX0NPTVBPTkVOVF9NRU1CRVJfRVJST1IgPSBgY2FuIG5vdCBiZSBhdHRhY2hlZCB0byBhIHBhZ2UncyBjb21wb25lbnQgYW5kIG11c3QgYmUgZXhwb3J0ZWQgZnJvbSB0aGUgcGFnZS4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9nc3NwLWNvbXBvbmVudC1tZW1iZXJgO1xuY29uc3QgTk9OX1NUQU5EQVJEX05PREVfRU5WID0gYFlvdSBhcmUgdXNpbmcgYSBub24tc3RhbmRhcmQgXCJOT0RFX0VOVlwiIHZhbHVlIGluIHlvdXIgZW52aXJvbm1lbnQuIFRoaXMgY3JlYXRlcyBpbmNvbnNpc3RlbmNpZXMgaW4gdGhlIHByb2plY3QgYW5kIGlzIHN0cm9uZ2x5IGFkdmlzZWQgYWdhaW5zdC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9ub24tc3RhbmRhcmQtbm9kZS1lbnZgO1xuY29uc3QgU1NHX0ZBTExCQUNLX0VYUE9SVF9FUlJPUiA9IGBQYWdlcyB3aXRoIFxcYGZhbGxiYWNrXFxgIGVuYWJsZWQgaW4gXFxgZ2V0U3RhdGljUGF0aHNcXGAgY2FuIG5vdCBiZSBleHBvcnRlZC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zc2ctZmFsbGJhY2stdHJ1ZS1leHBvcnRgO1xuY29uc3QgRVNMSU5UX0RFRkFVTFRfRElSUyA9IFtcbiAgICAnYXBwJyxcbiAgICAncGFnZXMnLFxuICAgICdjb21wb25lbnRzJyxcbiAgICAnbGliJyxcbiAgICAnc3JjJ1xuXTtcbmNvbnN0IFNFUlZFUl9SVU5USU1FID0ge1xuICAgIGVkZ2U6ICdlZGdlJyxcbiAgICBleHBlcmltZW50YWxFZGdlOiAnZXhwZXJpbWVudGFsLWVkZ2UnLFxuICAgIG5vZGVqczogJ25vZGVqcydcbn07XG4vKipcbiAqIFRoZSBuYW1lcyBvZiB0aGUgd2VicGFjayBsYXllcnMuIFRoZXNlIGxheWVycyBhcmUgdGhlIHByaW1pdGl2ZXMgZm9yIHRoZVxuICogd2VicGFjayBjaHVua3MuXG4gKi8gY29uc3QgV0VCUEFDS19MQVlFUlNfTkFNRVMgPSB7XG4gICAgLyoqXG4gICAqIFRoZSBsYXllciBmb3IgdGhlIHNoYXJlZCBjb2RlIGJldHdlZW4gdGhlIGNsaWVudCBhbmQgc2VydmVyIGJ1bmRsZXMuXG4gICAqLyBzaGFyZWQ6ICdzaGFyZWQnLFxuICAgIC8qKlxuICAgKiBUaGUgbGF5ZXIgZm9yIHNlcnZlci1vbmx5IHJ1bnRpbWUgYW5kIHBpY2tpbmcgdXAgYHJlYWN0LXNlcnZlcmAgZXhwb3J0IGNvbmRpdGlvbnMuXG4gICAqIEluY2x1ZGluZyBhcHAgcm91dGVyIFJTQyBwYWdlcyBhbmQgYXBwIHJvdXRlciBjdXN0b20gcm91dGVzIGFuZCBtZXRhZGF0YSByb3V0ZXMuXG4gICAqLyByZWFjdFNlcnZlckNvbXBvbmVudHM6ICdyc2MnLFxuICAgIC8qKlxuICAgKiBTZXJ2ZXIgU2lkZSBSZW5kZXJpbmcgbGF5ZXIgZm9yIGFwcCAoc3NyKS5cbiAgICovIHNlcnZlclNpZGVSZW5kZXJpbmc6ICdzc3InLFxuICAgIC8qKlxuICAgKiBUaGUgYnJvd3NlciBjbGllbnQgYnVuZGxlIGxheWVyIGZvciBhY3Rpb25zLlxuICAgKi8gYWN0aW9uQnJvd3NlcjogJ2FjdGlvbi1icm93c2VyJyxcbiAgICAvKipcbiAgICogVGhlIE5vZGUuanMgYnVuZGxlIGxheWVyIGZvciB0aGUgQVBJIHJvdXRlcy5cbiAgICovIGFwaU5vZGU6ICdhcGktbm9kZScsXG4gICAgLyoqXG4gICAqIFRoZSBFZGdlIExpdGUgYnVuZGxlIGxheWVyIGZvciB0aGUgQVBJIHJvdXRlcy5cbiAgICovIGFwaUVkZ2U6ICdhcGktZWRnZScsXG4gICAgLyoqXG4gICAqIFRoZSBsYXllciBmb3IgdGhlIG1pZGRsZXdhcmUgY29kZS5cbiAgICovIG1pZGRsZXdhcmU6ICdtaWRkbGV3YXJlJyxcbiAgICAvKipcbiAgICogVGhlIGxheWVyIGZvciB0aGUgaW5zdHJ1bWVudGF0aW9uIGhvb2tzLlxuICAgKi8gaW5zdHJ1bWVudDogJ2luc3RydW1lbnQnLFxuICAgIC8qKlxuICAgKiBUaGUgbGF5ZXIgZm9yIGFzc2V0cyBvbiB0aGUgZWRnZS5cbiAgICovIGVkZ2VBc3NldDogJ2VkZ2UtYXNzZXQnLFxuICAgIC8qKlxuICAgKiBUaGUgYnJvd3NlciBjbGllbnQgYnVuZGxlIGxheWVyIGZvciBBcHAgZGlyZWN0b3J5LlxuICAgKi8gYXBwUGFnZXNCcm93c2VyOiAnYXBwLXBhZ2VzLWJyb3dzZXInLFxuICAgIC8qKlxuICAgKiBUaGUgYnJvd3NlciBjbGllbnQgYnVuZGxlIGxheWVyIGZvciBQYWdlcyBkaXJlY3RvcnkuXG4gICAqLyBwYWdlc0RpckJyb3dzZXI6ICdwYWdlcy1kaXItYnJvd3NlcicsXG4gICAgLyoqXG4gICAqIFRoZSBFZGdlIExpdGUgYnVuZGxlIGxheWVyIGZvciBQYWdlcyBkaXJlY3RvcnkuXG4gICAqLyBwYWdlc0RpckVkZ2U6ICdwYWdlcy1kaXItZWRnZScsXG4gICAgLyoqXG4gICAqIFRoZSBOb2RlLmpzIGJ1bmRsZSBsYXllciBmb3IgUGFnZXMgZGlyZWN0b3J5LlxuICAgKi8gcGFnZXNEaXJOb2RlOiAncGFnZXMtZGlyLW5vZGUnXG59O1xuY29uc3QgV0VCUEFDS19MQVlFUlMgPSB7XG4gICAgLi4uV0VCUEFDS19MQVlFUlNfTkFNRVMsXG4gICAgR1JPVVA6IHtcbiAgICAgICAgYnVpbHRpblJlYWN0OiBbXG4gICAgICAgICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5yZWFjdFNlcnZlckNvbXBvbmVudHMsXG4gICAgICAgICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5hY3Rpb25Ccm93c2VyXG4gICAgICAgIF0sXG4gICAgICAgIHNlcnZlck9ubHk6IFtcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLnJlYWN0U2VydmVyQ29tcG9uZW50cyxcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFjdGlvbkJyb3dzZXIsXG4gICAgICAgICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5pbnN0cnVtZW50LFxuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMubWlkZGxld2FyZVxuICAgICAgICBdLFxuICAgICAgICBuZXV0cmFsVGFyZ2V0OiBbXG4gICAgICAgICAgICAvLyBwYWdlcyBhcGlcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwaU5vZGUsXG4gICAgICAgICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5hcGlFZGdlXG4gICAgICAgIF0sXG4gICAgICAgIGNsaWVudE9ubHk6IFtcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLnNlcnZlclNpZGVSZW5kZXJpbmcsXG4gICAgICAgICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5hcHBQYWdlc0Jyb3dzZXJcbiAgICAgICAgXSxcbiAgICAgICAgYnVuZGxlZDogW1xuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMucmVhY3RTZXJ2ZXJDb21wb25lbnRzLFxuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuYWN0aW9uQnJvd3NlcixcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLnNlcnZlclNpZGVSZW5kZXJpbmcsXG4gICAgICAgICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5hcHBQYWdlc0Jyb3dzZXIsXG4gICAgICAgICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5zaGFyZWQsXG4gICAgICAgICAgICBXRUJQQUNLX0xBWUVSU19OQU1FUy5pbnN0cnVtZW50LFxuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMubWlkZGxld2FyZVxuICAgICAgICBdLFxuICAgICAgICBhcHBQYWdlczogW1xuICAgICAgICAgICAgLy8gYXBwIHJvdXRlciBwYWdlcyBhbmQgbGF5b3V0c1xuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMucmVhY3RTZXJ2ZXJDb21wb25lbnRzLFxuICAgICAgICAgICAgV0VCUEFDS19MQVlFUlNfTkFNRVMuc2VydmVyU2lkZVJlbmRlcmluZyxcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFwcFBhZ2VzQnJvd3NlcixcbiAgICAgICAgICAgIFdFQlBBQ0tfTEFZRVJTX05BTUVTLmFjdGlvbkJyb3dzZXJcbiAgICAgICAgXVxuICAgIH1cbn07XG5jb25zdCBXRUJQQUNLX1JFU09VUkNFX1FVRVJJRVMgPSB7XG4gICAgZWRnZVNTUkVudHJ5OiAnX19uZXh0X2VkZ2Vfc3NyX2VudHJ5X18nLFxuICAgIG1ldGFkYXRhOiAnX19uZXh0X21ldGFkYXRhX18nLFxuICAgIG1ldGFkYXRhUm91dGU6ICdfX25leHRfbWV0YWRhdGFfcm91dGVfXycsXG4gICAgbWV0YWRhdGFJbWFnZU1ldGE6ICdfX25leHRfbWV0YWRhdGFfaW1hZ2VfbWV0YV9fJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/lib/detached-promise.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/lib/detached-promise.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * A `Promise.withResolvers` implementation that exposes the `resolve` and\n * `reject` functions on a `Promise`.\n *\n * @see https://tc39.es/proposal-promise-with-resolvers/\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"DetachedPromise\", ({\n    enumerable: true,\n    get: function() {\n        return DetachedPromise;\n    }\n}));\nclass DetachedPromise {\n    constructor(){\n        let resolve;\n        let reject;\n        // Create the promise and assign the resolvers to the object.\n        this.promise = new Promise((res, rej)=>{\n            resolve = res;\n            reject = rej;\n        });\n        // We know that resolvers is defined because the Promise constructor runs\n        // synchronously.\n        this.resolve = resolve;\n        this.reject = reject;\n    }\n}\n\n//# sourceMappingURL=detached-promise.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9kZXRhY2hlZC1wcm9taXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFpQjtBQUNqQiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixtREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGxpYlxcZGV0YWNoZWQtcHJvbWlzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgYFByb21pc2Uud2l0aFJlc29sdmVyc2AgaW1wbGVtZW50YXRpb24gdGhhdCBleHBvc2VzIHRoZSBgcmVzb2x2ZWAgYW5kXG4gKiBgcmVqZWN0YCBmdW5jdGlvbnMgb24gYSBgUHJvbWlzZWAuXG4gKlxuICogQHNlZSBodHRwczovL3RjMzkuZXMvcHJvcG9zYWwtcHJvbWlzZS13aXRoLXJlc29sdmVycy9cbiAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRldGFjaGVkUHJvbWlzZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRGV0YWNoZWRQcm9taXNlO1xuICAgIH1cbn0pO1xuY2xhc3MgRGV0YWNoZWRQcm9taXNlIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBsZXQgcmVzb2x2ZTtcbiAgICAgICAgbGV0IHJlamVjdDtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBwcm9taXNlIGFuZCBhc3NpZ24gdGhlIHJlc29sdmVycyB0byB0aGUgb2JqZWN0LlxuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopPT57XG4gICAgICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2Uga25vdyB0aGF0IHJlc29sdmVycyBpcyBkZWZpbmVkIGJlY2F1c2UgdGhlIFByb21pc2UgY29uc3RydWN0b3IgcnVuc1xuICAgICAgICAvLyBzeW5jaHJvbm91c2x5LlxuICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGFjaGVkLXByb21pc2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/lib/detached-promise.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/lib/metadata/metadata-constants.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/lib/metadata/metadata-constants.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    METADATA_BOUNDARY_NAME: function() {\n        return METADATA_BOUNDARY_NAME;\n    },\n    OUTLET_BOUNDARY_NAME: function() {\n        return OUTLET_BOUNDARY_NAME;\n    },\n    VIEWPORT_BOUNDARY_NAME: function() {\n        return VIEWPORT_BOUNDARY_NAME;\n    }\n});\nconst METADATA_BOUNDARY_NAME = '__next_metadata_boundary__';\nconst VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__';\nconst OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__';\n\n//# sourceMappingURL=metadata-constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9tZXRhZGF0YS9tZXRhZGF0YS1jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixNQUFNLENBSUw7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxsaWJcXG1ldGFkYXRhXFxtZXRhZGF0YS1jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBNRVRBREFUQV9CT1VOREFSWV9OQU1FOiBudWxsLFxuICAgIE9VVExFVF9CT1VOREFSWV9OQU1FOiBudWxsLFxuICAgIFZJRVdQT1JUX0JPVU5EQVJZX05BTUU6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgTUVUQURBVEFfQk9VTkRBUllfTkFNRTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNRVRBREFUQV9CT1VOREFSWV9OQU1FO1xuICAgIH0sXG4gICAgT1VUTEVUX0JPVU5EQVJZX05BTUU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT1VUTEVUX0JPVU5EQVJZX05BTUU7XG4gICAgfSxcbiAgICBWSUVXUE9SVF9CT1VOREFSWV9OQU1FOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFZJRVdQT1JUX0JPVU5EQVJZX05BTUU7XG4gICAgfVxufSk7XG5jb25zdCBNRVRBREFUQV9CT1VOREFSWV9OQU1FID0gJ19fbmV4dF9tZXRhZGF0YV9ib3VuZGFyeV9fJztcbmNvbnN0IFZJRVdQT1JUX0JPVU5EQVJZX05BTUUgPSAnX19uZXh0X3ZpZXdwb3J0X2JvdW5kYXJ5X18nO1xuY29uc3QgT1VUTEVUX0JPVU5EQVJZX05BTUUgPSAnX19uZXh0X291dGxldF9ib3VuZGFyeV9fJztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEtY29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/lib/metadata/metadata-constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/lib/scheduler.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/lib/scheduler.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    atLeastOneTask: function() {\n        return atLeastOneTask;\n    },\n    scheduleImmediate: function() {\n        return scheduleImmediate;\n    },\n    scheduleOnNextTick: function() {\n        return scheduleOnNextTick;\n    },\n    waitAtLeastOneReactRenderTask: function() {\n        return waitAtLeastOneReactRenderTask;\n    }\n});\nconst scheduleOnNextTick = (cb)=>{\n    // We use Promise.resolve().then() here so that the operation is scheduled at\n    // the end of the promise job queue, we then add it to the next process tick\n    // to ensure it's evaluated afterwards.\n    //\n    // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n    //\n    Promise.resolve().then(()=>{\n        if (false) {} else {\n            process.nextTick(cb);\n        }\n    });\n};\nconst scheduleImmediate = (cb)=>{\n    if (false) {} else {\n        setImmediate(cb);\n    }\n};\nfunction atLeastOneTask() {\n    return new Promise((resolve)=>scheduleImmediate(resolve));\n}\nfunction waitAtLeastOneReactRenderTask() {\n    if (false) {} else {\n        return new Promise((r)=>setImmediate(r));\n    }\n}\n\n//# sourceMappingURL=scheduler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9zY2hlZHVsZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixNQUFNLENBS0w7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQW1DLEVBQUUsRUFFeEMsQ0FBQztBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVEsS0FBbUMsRUFBRSxFQUV4QyxDQUFDO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQW1DLEVBQUUsRUFFeEMsQ0FBQztBQUNOO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGxpYlxcc2NoZWR1bGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXRMZWFzdE9uZVRhc2s6IG51bGwsXG4gICAgc2NoZWR1bGVJbW1lZGlhdGU6IG51bGwsXG4gICAgc2NoZWR1bGVPbk5leHRUaWNrOiBudWxsLFxuICAgIHdhaXRBdExlYXN0T25lUmVhY3RSZW5kZXJUYXNrOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGF0TGVhc3RPbmVUYXNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGF0TGVhc3RPbmVUYXNrO1xuICAgIH0sXG4gICAgc2NoZWR1bGVJbW1lZGlhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVJbW1lZGlhdGU7XG4gICAgfSxcbiAgICBzY2hlZHVsZU9uTmV4dFRpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVPbk5leHRUaWNrO1xuICAgIH0sXG4gICAgd2FpdEF0TGVhc3RPbmVSZWFjdFJlbmRlclRhc2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2FpdEF0TGVhc3RPbmVSZWFjdFJlbmRlclRhc2s7XG4gICAgfVxufSk7XG5jb25zdCBzY2hlZHVsZU9uTmV4dFRpY2sgPSAoY2IpPT57XG4gICAgLy8gV2UgdXNlIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKSBoZXJlIHNvIHRoYXQgdGhlIG9wZXJhdGlvbiBpcyBzY2hlZHVsZWQgYXRcbiAgICAvLyB0aGUgZW5kIG9mIHRoZSBwcm9taXNlIGpvYiBxdWV1ZSwgd2UgdGhlbiBhZGQgaXQgdG8gdGhlIG5leHQgcHJvY2VzcyB0aWNrXG4gICAgLy8gdG8gZW5zdXJlIGl0J3MgZXZhbHVhdGVkIGFmdGVyd2FyZHMuXG4gICAgLy9cbiAgICAvLyBUaGlzIHdhcyBpbnNwaXJlZCBieSB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIERhdGFMb2FkZXIgaW50ZXJmYWNlOiBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9kYXRhbG9hZGVyL2Jsb2IvZDMzNmJkMTUyODI2NjRlMGJlNGI0YTY1N2NiNzk2ZjA5YmFmYmM2Yi9zcmMvaW5kZXguanMjTDIxMy1MMjU1XG4gICAgLy9cbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdlZGdlJykge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IHNjaGVkdWxlSW1tZWRpYXRlID0gKGNiKT0+e1xuICAgIGlmIChwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdlZGdlJykge1xuICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXRJbW1lZGlhdGUoY2IpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBhdExlYXN0T25lVGFzaygpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpPT5zY2hlZHVsZUltbWVkaWF0ZShyZXNvbHZlKSk7XG59XG5mdW5jdGlvbiB3YWl0QXRMZWFzdE9uZVJlYWN0UmVuZGVyVGFzaygpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnZWRnZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyKT0+c2V0VGltZW91dChyLCAwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyKT0+c2V0SW1tZWRpYXRlKHIpKTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVkdWxlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/lib/scheduler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/after/after.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/server/after/after.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"after\", ({\n    enumerable: true,\n    get: function() {\n        return after;\n    }\n}));\nconst _workasyncstorageexternal = __webpack_require__(/*! ../app-render/work-async-storage.external */ \"../app-render/work-async-storage.external\");\nfunction after(task) {\n    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();\n    if (!workStore) {\n        // TODO(after): the linked docs page talks about *dynamic* APIs, which after soon won't be anymore\n        throw Object.defineProperty(new Error('`after` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context'), \"__NEXT_ERROR_CODE\", {\n            value: \"E468\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const { afterContext } = workStore;\n    return afterContext.after(task);\n}\n\n//# sourceMappingURL=after.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9hZnRlci9hZnRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHlDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLGtDQUFrQyxtQkFBTyxDQUFDLDRGQUEyQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxzZXJ2ZXJcXGFmdGVyXFxhZnRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFmdGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhZnRlcjtcbiAgICB9XG59KTtcbmNvbnN0IF93b3JrYXN5bmNzdG9yYWdlZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi4vYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWxcIik7XG5mdW5jdGlvbiBhZnRlcih0YXNrKSB7XG4gICAgY29uc3Qgd29ya1N0b3JlID0gX3dvcmthc3luY3N0b3JhZ2VleHRlcm5hbC53b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKCF3b3JrU3RvcmUpIHtcbiAgICAgICAgLy8gVE9ETyhhZnRlcik6IHRoZSBsaW5rZWQgZG9jcyBwYWdlIHRhbGtzIGFib3V0ICpkeW5hbWljKiBBUElzLCB3aGljaCBhZnRlciBzb29uIHdvbid0IGJlIGFueW1vcmVcbiAgICAgICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcignYGFmdGVyYCB3YXMgY2FsbGVkIG91dHNpZGUgYSByZXF1ZXN0IHNjb3BlLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtZHluYW1pYy1hcGktd3JvbmctY29udGV4dCcpLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBcIkU0NjhcIixcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB7IGFmdGVyQ29udGV4dCB9ID0gd29ya1N0b3JlO1xuICAgIHJldHVybiBhZnRlckNvbnRleHQuYWZ0ZXIodGFzayk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/after/after.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/after/index.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/server/after/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && 0;\n_export_star(__webpack_require__(/*! ./after */ \"(rsc)/./node_modules/next/dist/server/after/after.js\"), exports);\nfunction _export_star(from, to) {\n    Object.keys(from).forEach(function(k) {\n        if (k !== \"default\" && !Object.prototype.hasOwnProperty.call(to, k)) {\n            Object.defineProperty(to, k, {\n                enumerable: true,\n                get: function() {\n                    return from[k];\n                }\n            });\n        }\n    });\n    return from;\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9hZnRlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLEtBQUssQ0FBNEI7QUFDakMsYUFBYSxtQkFBTyxDQUFDLHFFQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxcYWZ0ZXJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiBfX2V4cG9ydChyZXF1aXJlKFwiLi9hZnRlclwiKSk7XG5fZXhwb3J0X3N0YXIocmVxdWlyZShcIi4vYWZ0ZXJcIiksIGV4cG9ydHMpO1xuZnVuY3Rpb24gX2V4cG9ydF9zdGFyKGZyb20sIHRvKSB7XG4gICAgT2JqZWN0LmtleXMoZnJvbSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRvLCBrKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBrLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmcm9tO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/after/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/app-render/dynamic-rendering.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/server/app-render/dynamic-rendering.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    Postpone: function() {\n        return Postpone;\n    },\n    abortAndThrowOnSynchronousRequestDataAccess: function() {\n        return abortAndThrowOnSynchronousRequestDataAccess;\n    },\n    abortOnSynchronousPlatformIOAccess: function() {\n        return abortOnSynchronousPlatformIOAccess;\n    },\n    accessedDynamicData: function() {\n        return accessedDynamicData;\n    },\n    annotateDynamicAccess: function() {\n        return annotateDynamicAccess;\n    },\n    consumeDynamicAccess: function() {\n        return consumeDynamicAccess;\n    },\n    createDynamicTrackingState: function() {\n        return createDynamicTrackingState;\n    },\n    createDynamicValidationState: function() {\n        return createDynamicValidationState;\n    },\n    createHangingInputAbortSignal: function() {\n        return createHangingInputAbortSignal;\n    },\n    createPostponedAbortSignal: function() {\n        return createPostponedAbortSignal;\n    },\n    formatDynamicAPIAccesses: function() {\n        return formatDynamicAPIAccesses;\n    },\n    getFirstDynamicReason: function() {\n        return getFirstDynamicReason;\n    },\n    isDynamicPostpone: function() {\n        return isDynamicPostpone;\n    },\n    isPrerenderInterruptedError: function() {\n        return isPrerenderInterruptedError;\n    },\n    markCurrentScopeAsDynamic: function() {\n        return markCurrentScopeAsDynamic;\n    },\n    postponeWithTracking: function() {\n        return postponeWithTracking;\n    },\n    throwIfDisallowedDynamic: function() {\n        return throwIfDisallowedDynamic;\n    },\n    throwToInterruptStaticGeneration: function() {\n        return throwToInterruptStaticGeneration;\n    },\n    trackAllowedDynamicAccess: function() {\n        return trackAllowedDynamicAccess;\n    },\n    trackDynamicDataInDynamicRender: function() {\n        return trackDynamicDataInDynamicRender;\n    },\n    trackFallbackParamAccessed: function() {\n        return trackFallbackParamAccessed;\n    },\n    trackSynchronousPlatformIOAccessInDev: function() {\n        return trackSynchronousPlatformIOAccessInDev;\n    },\n    trackSynchronousRequestDataAccessInDev: function() {\n        return trackSynchronousRequestDataAccessInDev;\n    },\n    useDynamicRouteParams: function() {\n        return useDynamicRouteParams;\n    }\n});\nconst _react = /*#__PURE__*/ _interop_require_default(__webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js\"));\nconst _hooksservercontext = __webpack_require__(/*! ../../client/components/hooks-server-context */ \"(rsc)/./node_modules/next/dist/client/components/hooks-server-context.js\");\nconst _staticgenerationbailout = __webpack_require__(/*! ../../client/components/static-generation-bailout */ \"(rsc)/./node_modules/next/dist/client/components/static-generation-bailout.js\");\nconst _workunitasyncstorageexternal = __webpack_require__(/*! ./work-unit-async-storage.external */ \"./work-unit-async-storage.external\");\nconst _workasyncstorageexternal = __webpack_require__(/*! ../app-render/work-async-storage.external */ \"../app-render/work-async-storage.external\");\nconst _dynamicrenderingutils = __webpack_require__(/*! ../dynamic-rendering-utils */ \"(rsc)/./node_modules/next/dist/server/dynamic-rendering-utils.js\");\nconst _metadataconstants = __webpack_require__(/*! ../../lib/metadata/metadata-constants */ \"(rsc)/./node_modules/next/dist/lib/metadata/metadata-constants.js\");\nconst _scheduler = __webpack_require__(/*! ../../lib/scheduler */ \"(rsc)/./node_modules/next/dist/lib/scheduler.js\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst hasPostpone = typeof _react.default.unstable_postpone === 'function';\nfunction createDynamicTrackingState(isDebugDynamicAccesses) {\n    return {\n        isDebugDynamicAccesses,\n        dynamicAccesses: [],\n        syncDynamicExpression: undefined,\n        syncDynamicErrorWithStack: null\n    };\n}\nfunction createDynamicValidationState() {\n    return {\n        hasSuspendedDynamic: false,\n        hasDynamicMetadata: false,\n        hasDynamicViewport: false,\n        hasSyncDynamicErrors: false,\n        dynamicErrors: []\n    };\n}\nfunction getFirstDynamicReason(trackingState) {\n    var _trackingState_dynamicAccesses_;\n    return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;\n}\nfunction markCurrentScopeAsDynamic(store, workUnitStore, expression) {\n    if (workUnitStore) {\n        if (workUnitStore.type === 'cache' || workUnitStore.type === 'unstable-cache') {\n            // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n            // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n            // forbidden inside a cache scope.\n            return;\n        }\n    }\n    // If we're forcing dynamic rendering or we're forcing static rendering, we\n    // don't need to do anything here because the entire page is already dynamic\n    // or it's static and it should not throw or postpone here.\n    if (store.forceDynamic || store.forceStatic) return;\n    if (store.dynamicShouldError) {\n        throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n            value: \"E553\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (workUnitStore) {\n        if (workUnitStore.type === 'prerender-ppr') {\n            postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);\n        } else if (workUnitStore.type === 'prerender-legacy') {\n            workUnitStore.revalidate = 0;\n            // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n            const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n                value: \"E550\",\n                enumerable: false,\n                configurable: true\n            });\n            store.dynamicUsageDescription = expression;\n            store.dynamicUsageStack = err.stack;\n            throw err;\n        } else if ( true && workUnitStore && workUnitStore.type === 'request') {\n            workUnitStore.usedDynamic = true;\n        }\n    }\n}\nfunction trackFallbackParamAccessed(store, expression) {\n    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return;\n    postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking);\n}\nfunction throwToInterruptStaticGeneration(expression, store, prerenderStore) {\n    // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n    const err = Object.defineProperty(new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n        value: \"E558\",\n        enumerable: false,\n        configurable: true\n    });\n    prerenderStore.revalidate = 0;\n    store.dynamicUsageDescription = expression;\n    store.dynamicUsageStack = err.stack;\n    throw err;\n}\nfunction trackDynamicDataInDynamicRender(_store, workUnitStore) {\n    if (workUnitStore) {\n        if (workUnitStore.type === 'cache' || workUnitStore.type === 'unstable-cache') {\n            // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n            // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n            // forbidden inside a cache scope.\n            return;\n        }\n        if (workUnitStore.type === 'prerender' || workUnitStore.type === 'prerender-legacy') {\n            workUnitStore.revalidate = 0;\n        }\n        if ( true && workUnitStore.type === 'request') {\n            workUnitStore.usedDynamic = true;\n        }\n    }\n}\n// Despite it's name we don't actually abort unless we have a controller to call abort on\n// There are times when we let a prerender run long to discover caches where we want the semantics\n// of tracking dynamic access without terminating the prerender early\nfunction abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {\n    const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;\n    const error = createPrerenderInterruptedError(reason);\n    prerenderStore.controller.abort(error);\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            // When we aren't debugging, we don't need to create another error for the\n            // stack trace.\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n}\nfunction abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    if (dynamicTracking) {\n        if (dynamicTracking.syncDynamicErrorWithStack === null) {\n            dynamicTracking.syncDynamicExpression = expression;\n            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\n        }\n    }\n    return abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\n}\nfunction trackSynchronousPlatformIOAccessInDev(requestStore) {\n    // We don't actually have a controller to abort but we do the semantic equivalent by\n    // advancing the request store out of prerender mode\n    requestStore.prerenderPhase = false;\n}\nfunction abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    if (dynamicTracking) {\n        if (dynamicTracking.syncDynamicErrorWithStack === null) {\n            dynamicTracking.syncDynamicExpression = expression;\n            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\n            if (prerenderStore.validating === true) {\n                // We always log Request Access in dev at the point of calling the function\n                // So we mark the dynamic validation as not requiring it to be printed\n                dynamicTracking.syncDynamicLogged = true;\n            }\n        }\n    }\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\n    throw createPrerenderInterruptedError(`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`);\n}\nconst trackSynchronousRequestDataAccessInDev = trackSynchronousPlatformIOAccessInDev;\nfunction Postpone({ reason, route }) {\n    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;\n    postponeWithTracking(route, reason, dynamicTracking);\n}\nfunction postponeWithTracking(route, expression, dynamicTracking) {\n    assertPostpone();\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            // When we aren't debugging, we don't need to create another error for the\n            // stack trace.\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n    _react.default.unstable_postpone(createPostponeReason(route, expression));\n}\nfunction createPostponeReason(route, expression) {\n    return `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;\n}\nfunction isDynamicPostpone(err) {\n    if (typeof err === 'object' && err !== null && typeof err.message === 'string') {\n        return isDynamicPostponeReason(err.message);\n    }\n    return false;\n}\nfunction isDynamicPostponeReason(reason) {\n    return reason.includes('needs to bail out of prerendering at this point because it used') && reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error');\n}\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n    throw Object.defineProperty(new Error('Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\n        value: \"E296\",\n        enumerable: false,\n        configurable: true\n    });\n}\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';\nfunction createPrerenderInterruptedError(message) {\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = NEXT_PRERENDER_INTERRUPTED;\n    return error;\n}\nfunction isPrerenderInterruptedError(error) {\n    return typeof error === 'object' && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && 'name' in error && 'message' in error && error instanceof Error;\n}\nfunction accessedDynamicData(dynamicAccesses) {\n    return dynamicAccesses.length > 0;\n}\nfunction consumeDynamicAccess(serverDynamic, clientDynamic) {\n    // We mutate because we only call this once we are no longer writing\n    // to the dynamicTrackingState and it's more efficient than creating a new\n    // array.\n    serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);\n    return serverDynamic.dynamicAccesses;\n}\nfunction formatDynamicAPIAccesses(dynamicAccesses) {\n    return dynamicAccesses.filter((access)=>typeof access.stack === 'string' && access.stack.length > 0).map(({ expression, stack })=>{\n        stack = stack.split('\\n')// Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4).filter((line)=>{\n            // Exclude Next.js internals from the stack trace.\n            if (line.includes('node_modules/next/')) {\n                return false;\n            }\n            // Exclude anonymous functions from the stack trace.\n            if (line.includes(' (<anonymous>)')) {\n                return false;\n            }\n            // Exclude Node.js internals from the stack trace.\n            if (line.includes(' (node:')) {\n                return false;\n            }\n            return true;\n        }).join('\\n');\n        return `Dynamic API Usage Debug - ${expression}:\\n${stack}`;\n    });\n}\nfunction assertPostpone() {\n    if (!hasPostpone) {\n        throw Object.defineProperty(new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`), \"__NEXT_ERROR_CODE\", {\n            value: \"E224\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nfunction createPostponedAbortSignal(reason) {\n    assertPostpone();\n    const controller = new AbortController();\n    // We get our hands on a postpone instance by calling postpone and catching the throw\n    try {\n        _react.default.unstable_postpone(reason);\n    } catch (x) {\n        controller.abort(x);\n    }\n    return controller.signal;\n}\nfunction createHangingInputAbortSignal(workUnitStore) {\n    const controller = new AbortController();\n    if (workUnitStore.cacheSignal) {\n        // If we have a cacheSignal it means we're in a prospective render. If the input\n        // we're waiting on is coming from another cache, we do want to wait for it so that\n        // we can resolve this cache entry too.\n        workUnitStore.cacheSignal.inputReady().then(()=>{\n            controller.abort();\n        });\n    } else {\n        // Otherwise we're in the final render and we should already have all our caches\n        // filled. We might still be waiting on some microtasks so we wait one tick before\n        // giving up. When we give up, we still want to render the content of this cache\n        // as deeply as we can so that we can suspend as deeply as possible in the tree\n        // or not at all if we don't end up waiting for the input.\n        (0, _scheduler.scheduleOnNextTick)(()=>controller.abort());\n    }\n    return controller.signal;\n}\nfunction annotateDynamicAccess(expression, prerenderStore) {\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n}\nfunction useDynamicRouteParams(expression) {\n    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();\n    if (workStore && workStore.isStaticGeneration && workStore.fallbackRouteParams && workStore.fallbackRouteParams.size > 0) {\n        // There are fallback route params, we should track these as dynamic\n        // accesses.\n        const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n        if (workUnitStore) {\n            // We're prerendering with dynamicIO or PPR or both\n            if (workUnitStore.type === 'prerender') {\n                // We are in a prerender with dynamicIO semantics\n                // We are going to hang here and never resolve. This will cause the currently\n                // rendering component to effectively be a dynamic hole\n                _react.default.use((0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, expression));\n            } else if (workUnitStore.type === 'prerender-ppr') {\n                // We're prerendering with PPR\n                postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);\n            } else if (workUnitStore.type === 'prerender-legacy') {\n                throwToInterruptStaticGeneration(expression, workStore, workUnitStore);\n            }\n        }\n    }\n}\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/;\nconst hasMetadataRegex = new RegExp(`\\\\n\\\\s+at ${_metadataconstants.METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`);\nconst hasViewportRegex = new RegExp(`\\\\n\\\\s+at ${_metadataconstants.VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`);\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${_metadataconstants.OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`);\nfunction trackAllowedDynamicAccess(route, componentStack, dynamicValidation, serverDynamic, clientDynamic) {\n    if (hasOutletRegex.test(componentStack)) {\n        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n        return;\n    } else if (hasMetadataRegex.test(componentStack)) {\n        dynamicValidation.hasDynamicMetadata = true;\n        return;\n    } else if (hasViewportRegex.test(componentStack)) {\n        dynamicValidation.hasDynamicViewport = true;\n        return;\n    } else if (hasSuspenseRegex.test(componentStack)) {\n        dynamicValidation.hasSuspendedDynamic = true;\n        return;\n    } else if (serverDynamic.syncDynamicErrorWithStack || clientDynamic.syncDynamicErrorWithStack) {\n        dynamicValidation.hasSyncDynamicErrors = true;\n        return;\n    } else {\n        const message = `Route \"${route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. We don't have the exact line number added to error messages yet but you can see which component in the stack below. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`;\n        const error = createErrorWithComponentStack(message, componentStack);\n        dynamicValidation.dynamicErrors.push(error);\n        return;\n    }\n}\nfunction createErrorWithComponentStack(message, componentStack) {\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.stack = 'Error: ' + message + componentStack;\n    return error;\n}\nfunction throwIfDisallowedDynamic(route, dynamicValidation, serverDynamic, clientDynamic) {\n    let syncError;\n    let syncExpression;\n    let syncLogged;\n    if (serverDynamic.syncDynamicErrorWithStack) {\n        syncError = serverDynamic.syncDynamicErrorWithStack;\n        syncExpression = serverDynamic.syncDynamicExpression;\n        syncLogged = serverDynamic.syncDynamicLogged === true;\n    } else if (clientDynamic.syncDynamicErrorWithStack) {\n        syncError = clientDynamic.syncDynamicErrorWithStack;\n        syncExpression = clientDynamic.syncDynamicExpression;\n        syncLogged = clientDynamic.syncDynamicLogged === true;\n    } else {\n        syncError = null;\n        syncExpression = undefined;\n        syncLogged = false;\n    }\n    if (dynamicValidation.hasSyncDynamicErrors && syncError) {\n        if (!syncLogged) {\n            // In dev we already log errors about sync dynamic access. But during builds we need to ensure\n            // the offending sync error is logged before we exit the build\n            console.error(syncError);\n        }\n        // The actual error should have been logged when the sync access ocurred\n        throw new _staticgenerationbailout.StaticGenBailoutError();\n    }\n    const dynamicErrors = dynamicValidation.dynamicErrors;\n    if (dynamicErrors.length) {\n        for(let i = 0; i < dynamicErrors.length; i++){\n            console.error(dynamicErrors[i]);\n        }\n        throw new _staticgenerationbailout.StaticGenBailoutError();\n    }\n    if (!dynamicValidation.hasSuspendedDynamic) {\n        if (dynamicValidation.hasDynamicMetadata) {\n            if (syncError) {\n                console.error(syncError);\n                throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route \"${route}\" has a \\`generateMetadata\\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E608\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route \"${route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or external data (\\`fetch(...)\\`, etc...) but the rest of the route was static or only used cached data (\\`\"use cache\"\\`). If you expected this route to be prerenderable update your \\`generateMetadata\\` to not use Request data and only use cached external data. Otherwise, add \\`await connection()\\` somewhere within this route to indicate explicitly it should not be prerendered.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E534\",\n                enumerable: false,\n                configurable: true\n            });\n        } else if (dynamicValidation.hasDynamicViewport) {\n            if (syncError) {\n                console.error(syncError);\n                throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route \"${route}\" has a \\`generateViewport\\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E573\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route \"${route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or external data (\\`fetch(...)\\`, etc...) but the rest of the route was static or only used cached data (\\`\"use cache\"\\`). If you expected this route to be prerenderable update your \\`generateViewport\\` to not use Request data and only use cached external data. Otherwise, add \\`await connection()\\` somewhere within this route to indicate explicitly it should not be prerendered.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E590\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n}\n\n//# sourceMappingURL=dynamic-rendering.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFpQjtBQUNqQiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixNQUFNLENBeUJMO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0RBQXNELG1CQUFPLENBQUMsaUdBQU87QUFDckUsNEJBQTRCLG1CQUFPLENBQUMsOEhBQThDO0FBQ2xGLGlDQUFpQyxtQkFBTyxDQUFDLHdJQUFtRDtBQUM1RixzQ0FBc0MsbUJBQU8sQ0FBQyw4RUFBb0M7QUFDbEYsa0NBQWtDLG1CQUFPLENBQUMsNEZBQTJDO0FBQ3JGLCtCQUErQixtQkFBTyxDQUFDLG9HQUE0QjtBQUNuRSwyQkFBMkIsbUJBQU8sQ0FBQyxnSEFBdUM7QUFDMUUsbUJBQW1CLG1CQUFPLENBQUMsNEVBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csYUFBYSwrRUFBK0UsV0FBVztBQUN2TTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGtHQUFrRyxhQUFhLGtEQUFrRCxXQUFXO0FBQzVLO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsS0FBc0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixhQUFhLG9EQUFvRCxXQUFXO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBc0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPLGtFQUFrRSxXQUFXO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxPQUFPLGtFQUFrRSxXQUFXO0FBQ3ZJO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxrRUFBa0UsV0FBVztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCxtQkFBbUI7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0Q0FBNEMsV0FBVyxLQUFLLE1BQU07QUFDbEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDBDQUEwQztBQUMzRixpREFBaUQsMENBQTBDO0FBQzNGLCtDQUErQyx3Q0FBd0M7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTixrQ0FBa0MsTUFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsTUFBTSxzRUFBc0UsZ0JBQWdCO0FBQ3JNO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHFHQUFxRyxNQUFNO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBLHlHQUF5RyxNQUFNLHNFQUFzRSxnQkFBZ0I7QUFDck07QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EscUdBQXFHLE1BQU07QUFDM0c7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxcYXBwLXJlbmRlclxcZHluYW1pYy1yZW5kZXJpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGUgZnVuY3Rpb25zIHByb3ZpZGVkIGJ5IHRoaXMgbW9kdWxlIGFyZSB1c2VkIHRvIGNvbW11bmljYXRlIGNlcnRhaW4gcHJvcGVydGllc1xuICogYWJvdXQgdGhlIGN1cnJlbnRseSBydW5uaW5nIGNvZGUgc28gdGhhdCBOZXh0LmpzIGNhbiBtYWtlIGRlY2lzaW9ucyBvbiBob3cgdG8gaGFuZGxlXG4gKiB0aGUgY3VycmVudCBleGVjdXRpb24gaW4gZGlmZmVyZW50IHJlbmRlcmluZyBtb2RlcyBzdWNoIGFzIHByZS1yZW5kZXJpbmcsIHJlc3VtaW5nLCBhbmQgU1NSLlxuICpcbiAqIFRvZGF5IE5leHQuanMgdHJlYXRzIGFsbCBjb2RlIGFzIHBvdGVudGlhbGx5IHN0YXRpYy4gQ2VydGFpbiBBUElzIG1heSBvbmx5IG1ha2Ugc2Vuc2Ugd2hlbiBkeW5hbWljYWxseSByZW5kZXJpbmcuXG4gKiBUcmFkaXRpb25hbGx5IHRoaXMgbWVhbnQgZGVvcHRpbmcgdGhlIGVudGlyZSByZW5kZXIgdG8gZHluYW1pYyBob3dldmVyIHdpdGggUFBSIHdlIGNhbiBub3cgZGVvcHQgcGFydHNcbiAqIG9mIGEgUmVhY3QgdHJlZSBhcyBkeW5hbWljIHdoaWxlIHN0aWxsIGtlZXBpbmcgb3RoZXIgcGFydHMgc3RhdGljLiBUaGVyZSBhcmUgcmVhbGx5IHR3byBkaWZmZXJlbnQga2luZHMgb2ZcbiAqIER5bmFtaWMgaW5kaWNhdGlvbnMuXG4gKlxuICogVGhlIGZpcnN0IGlzIHNpbXBseSBhbiBpbnRlbnRpb24gdG8gYmUgZHluYW1pYy4gdW5zdGFibGVfbm9TdG9yZSBpcyBhbiBleGFtcGxlIG9mIHRoaXMgd2hlcmVcbiAqIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIGNvZGUgc2ltcGx5IGRlY2xhcmVzIHRoYXQgdGhlIGN1cnJlbnQgc2NvcGUgaXMgZHluYW1pYyBidXQgaWYgeW91IHVzZSBpdFxuICogaW5zaWRlIHVuc3RhYmxlX2NhY2hlIGl0IGNhbiBzdGlsbCBiZSBjYWNoZWQuIFRoaXMgdHlwZSBvZiBpbmRpY2F0aW9uIGNhbiBiZSByZW1vdmVkIGlmIHdlIGV2ZXJcbiAqIG1ha2UgdGhlIGRlZmF1bHQgZHluYW1pYyB0byBiZWdpbiB3aXRoIGJlY2F1c2UgdGhlIG9ubHkgd2F5IHlvdSB3b3VsZCBldmVyIGJlIHN0YXRpYyBpcyBpbnNpZGVcbiAqIGEgY2FjaGUgc2NvcGUgd2hpY2ggdGhpcyBpbmRpY2F0aW9uIGRvZXMgbm90IGFmZmVjdC5cbiAqXG4gKiBUaGUgc2Vjb25kIGlzIGFuIGluZGljYXRpb24gdGhhdCBhIGR5bmFtaWMgZGF0YSBzb3VyY2Ugd2FzIHJlYWQuIFRoaXMgaXMgYSBzdHJvbmdlciBmb3JtIG9mIGR5bmFtaWNcbiAqIGJlY2F1c2UgaXQgbWVhbnMgdGhhdCBpdCBpcyBpbmFwcHJvcHJpYXRlIHRvIGNhY2hlIHRoaXMgYXQgYWxsLiB1c2luZyBhIGR5bmFtaWMgZGF0YSBzb3VyY2UgaW5zaWRlXG4gKiB1bnN0YWJsZV9jYWNoZSBzaG91bGQgZXJyb3IuIElmIHlvdSB3YW50IHRvIHVzZSBzb21lIGR5bmFtaWMgZGF0YSBpbnNpZGUgdW5zdGFibGVfY2FjaGUgeW91IHNob3VsZFxuICogcmVhZCB0aGF0IGRhdGEgb3V0c2lkZSB0aGUgY2FjaGUgYW5kIHBhc3MgaXQgaW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIGNhY2hlZCBmdW5jdGlvbi5cbiAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIFBvc3Rwb25lOiBudWxsLFxuICAgIGFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3M6IG51bGwsXG4gICAgYWJvcnRPblN5bmNocm9ub3VzUGxhdGZvcm1JT0FjY2VzczogbnVsbCxcbiAgICBhY2Nlc3NlZER5bmFtaWNEYXRhOiBudWxsLFxuICAgIGFubm90YXRlRHluYW1pY0FjY2VzczogbnVsbCxcbiAgICBjb25zdW1lRHluYW1pY0FjY2VzczogbnVsbCxcbiAgICBjcmVhdGVEeW5hbWljVHJhY2tpbmdTdGF0ZTogbnVsbCxcbiAgICBjcmVhdGVEeW5hbWljVmFsaWRhdGlvblN0YXRlOiBudWxsLFxuICAgIGNyZWF0ZUhhbmdpbmdJbnB1dEFib3J0U2lnbmFsOiBudWxsLFxuICAgIGNyZWF0ZVBvc3Rwb25lZEFib3J0U2lnbmFsOiBudWxsLFxuICAgIGZvcm1hdER5bmFtaWNBUElBY2Nlc3NlczogbnVsbCxcbiAgICBnZXRGaXJzdER5bmFtaWNSZWFzb246IG51bGwsXG4gICAgaXNEeW5hbWljUG9zdHBvbmU6IG51bGwsXG4gICAgaXNQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yOiBudWxsLFxuICAgIG1hcmtDdXJyZW50U2NvcGVBc0R5bmFtaWM6IG51bGwsXG4gICAgcG9zdHBvbmVXaXRoVHJhY2tpbmc6IG51bGwsXG4gICAgdGhyb3dJZkRpc2FsbG93ZWREeW5hbWljOiBudWxsLFxuICAgIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uOiBudWxsLFxuICAgIHRyYWNrQWxsb3dlZER5bmFtaWNBY2Nlc3M6IG51bGwsXG4gICAgdHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlcjogbnVsbCxcbiAgICB0cmFja0ZhbGxiYWNrUGFyYW1BY2Nlc3NlZDogbnVsbCxcbiAgICB0cmFja1N5bmNocm9ub3VzUGxhdGZvcm1JT0FjY2Vzc0luRGV2OiBudWxsLFxuICAgIHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2OiBudWxsLFxuICAgIHVzZUR5bmFtaWNSb3V0ZVBhcmFtczogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBQb3N0cG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQb3N0cG9uZTtcbiAgICB9LFxuICAgIGFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWJvcnRBbmRUaHJvd09uU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2VzcztcbiAgICB9LFxuICAgIGFib3J0T25TeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWJvcnRPblN5bmNocm9ub3VzUGxhdGZvcm1JT0FjY2VzcztcbiAgICB9LFxuICAgIGFjY2Vzc2VkRHluYW1pY0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWNjZXNzZWREeW5hbWljRGF0YTtcbiAgICB9LFxuICAgIGFubm90YXRlRHluYW1pY0FjY2VzczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhbm5vdGF0ZUR5bmFtaWNBY2Nlc3M7XG4gICAgfSxcbiAgICBjb25zdW1lRHluYW1pY0FjY2VzczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25zdW1lRHluYW1pY0FjY2VzcztcbiAgICB9LFxuICAgIGNyZWF0ZUR5bmFtaWNUcmFja2luZ1N0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNUcmFja2luZ1N0YXRlO1xuICAgIH0sXG4gICAgY3JlYXRlRHluYW1pY1ZhbGlkYXRpb25TdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljVmFsaWRhdGlvblN0YXRlO1xuICAgIH0sXG4gICAgY3JlYXRlSGFuZ2luZ0lucHV0QWJvcnRTaWduYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlSGFuZ2luZ0lucHV0QWJvcnRTaWduYWw7XG4gICAgfSxcbiAgICBjcmVhdGVQb3N0cG9uZWRBYm9ydFNpZ25hbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQb3N0cG9uZWRBYm9ydFNpZ25hbDtcbiAgICB9LFxuICAgIGZvcm1hdER5bmFtaWNBUElBY2Nlc3NlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXREeW5hbWljQVBJQWNjZXNzZXM7XG4gICAgfSxcbiAgICBnZXRGaXJzdER5bmFtaWNSZWFzb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0Rmlyc3REeW5hbWljUmVhc29uO1xuICAgIH0sXG4gICAgaXNEeW5hbWljUG9zdHBvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNEeW5hbWljUG9zdHBvbmU7XG4gICAgfSxcbiAgICBpc1ByZXJlbmRlckludGVycnVwdGVkRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yO1xuICAgIH0sXG4gICAgbWFya0N1cnJlbnRTY29wZUFzRHluYW1pYzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtYXJrQ3VycmVudFNjb3BlQXNEeW5hbWljO1xuICAgIH0sXG4gICAgcG9zdHBvbmVXaXRoVHJhY2tpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcG9zdHBvbmVXaXRoVHJhY2tpbmc7XG4gICAgfSxcbiAgICB0aHJvd0lmRGlzYWxsb3dlZER5bmFtaWM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhyb3dJZkRpc2FsbG93ZWREeW5hbWljO1xuICAgIH0sXG4gICAgdGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb247XG4gICAgfSxcbiAgICB0cmFja0FsbG93ZWREeW5hbWljQWNjZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrQWxsb3dlZER5bmFtaWNBY2Nlc3M7XG4gICAgfSxcbiAgICB0cmFja0R5bmFtaWNEYXRhSW5EeW5hbWljUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXI7XG4gICAgfSxcbiAgICB0cmFja0ZhbGxiYWNrUGFyYW1BY2Nlc3NlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cmFja0ZhbGxiYWNrUGFyYW1BY2Nlc3NlZDtcbiAgICB9LFxuICAgIHRyYWNrU3luY2hyb25vdXNQbGF0Zm9ybUlPQWNjZXNzSW5EZXY6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHJhY2tTeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3NJbkRldjtcbiAgICB9LFxuICAgIHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2O1xuICAgIH0sXG4gICAgdXNlRHluYW1pY1JvdXRlUGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVzZUR5bmFtaWNSb3V0ZVBhcmFtcztcbiAgICB9XG59KTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfaG9va3NzZXJ2ZXJjb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9jb21wb25lbnRzL2hvb2tzLXNlcnZlci1jb250ZXh0XCIpO1xuY29uc3QgX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0ID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXRcIik7XG5jb25zdCBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbCA9IHJlcXVpcmUoXCIuL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsXCIpO1xuY29uc3QgX3dvcmthc3luY3N0b3JhZ2VleHRlcm5hbCA9IHJlcXVpcmUoXCIuLi9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbFwiKTtcbmNvbnN0IF9keW5hbWljcmVuZGVyaW5ndXRpbHMgPSByZXF1aXJlKFwiLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHNcIik7XG5jb25zdCBfbWV0YWRhdGFjb25zdGFudHMgPSByZXF1aXJlKFwiLi4vLi4vbGliL21ldGFkYXRhL21ldGFkYXRhLWNvbnN0YW50c1wiKTtcbmNvbnN0IF9zY2hlZHVsZXIgPSByZXF1aXJlKFwiLi4vLi4vbGliL3NjaGVkdWxlclwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuY29uc3QgaGFzUG9zdHBvbmUgPSB0eXBlb2YgX3JlYWN0LmRlZmF1bHQudW5zdGFibGVfcG9zdHBvbmUgPT09ICdmdW5jdGlvbic7XG5mdW5jdGlvbiBjcmVhdGVEeW5hbWljVHJhY2tpbmdTdGF0ZShpc0RlYnVnRHluYW1pY0FjY2Vzc2VzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNEZWJ1Z0R5bmFtaWNBY2Nlc3NlcyxcbiAgICAgICAgZHluYW1pY0FjY2Vzc2VzOiBbXSxcbiAgICAgICAgc3luY0R5bmFtaWNFeHByZXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2s6IG51bGxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRHluYW1pY1ZhbGlkYXRpb25TdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNTdXNwZW5kZWREeW5hbWljOiBmYWxzZSxcbiAgICAgICAgaGFzRHluYW1pY01ldGFkYXRhOiBmYWxzZSxcbiAgICAgICAgaGFzRHluYW1pY1ZpZXdwb3J0OiBmYWxzZSxcbiAgICAgICAgaGFzU3luY0R5bmFtaWNFcnJvcnM6IGZhbHNlLFxuICAgICAgICBkeW5hbWljRXJyb3JzOiBbXVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRGaXJzdER5bmFtaWNSZWFzb24odHJhY2tpbmdTdGF0ZSkge1xuICAgIHZhciBfdHJhY2tpbmdTdGF0ZV9keW5hbWljQWNjZXNzZXNfO1xuICAgIHJldHVybiAoX3RyYWNraW5nU3RhdGVfZHluYW1pY0FjY2Vzc2VzXyA9IHRyYWNraW5nU3RhdGUuZHluYW1pY0FjY2Vzc2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RyYWNraW5nU3RhdGVfZHluYW1pY0FjY2Vzc2VzXy5leHByZXNzaW9uO1xufVxuZnVuY3Rpb24gbWFya0N1cnJlbnRTY29wZUFzRHluYW1pYyhzdG9yZSwgd29ya1VuaXRTdG9yZSwgZXhwcmVzc2lvbikge1xuICAgIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgICAgIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdjYWNoZScgfHwgd29ya1VuaXRTdG9yZS50eXBlID09PSAndW5zdGFibGUtY2FjaGUnKSB7XG4gICAgICAgICAgICAvLyBpbnNpZGUgY2FjaGUgc2NvcGVzIG1hcmtpbmcgYSBzY29wZSBhcyBkeW5hbWljIGhhcyBubyBlZmZlY3QgYmVjYXVzZSB0aGUgb3V0ZXIgY2FjaGUgc2NvcGVcbiAgICAgICAgICAgIC8vIGNyZWF0ZXMgYSBjYWNoZSBib3VuZGFyeS4gVGhpcyBpcyBzdWJ0bHkgZGlmZmVyZW50IGZyb20gcmVhZGluZyBhIGR5bmFtaWMgZGF0YSBzb3VyY2Ugd2hpY2ggaXNcbiAgICAgICAgICAgIC8vIGZvcmJpZGRlbiBpbnNpZGUgYSBjYWNoZSBzY29wZS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB3ZSdyZSBmb3JjaW5nIGR5bmFtaWMgcmVuZGVyaW5nIG9yIHdlJ3JlIGZvcmNpbmcgc3RhdGljIHJlbmRlcmluZywgd2VcbiAgICAvLyBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIGhlcmUgYmVjYXVzZSB0aGUgZW50aXJlIHBhZ2UgaXMgYWxyZWFkeSBkeW5hbWljXG4gICAgLy8gb3IgaXQncyBzdGF0aWMgYW5kIGl0IHNob3VsZCBub3QgdGhyb3cgb3IgcG9zdHBvbmUgaGVyZS5cbiAgICBpZiAoc3RvcmUuZm9yY2VEeW5hbWljIHx8IHN0b3JlLmZvcmNlU3RhdGljKSByZXR1cm47XG4gICAgaWYgKHN0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IF9zdGF0aWNnZW5lcmF0aW9uYmFpbG91dC5TdGF0aWNHZW5CYWlsb3V0RXJyb3IoYFJvdXRlICR7c3RvcmUucm91dGV9IHdpdGggXFxgZHluYW1pYyA9IFwiZXJyb3JcIlxcYCBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCBcXGAke2V4cHJlc3Npb259XFxgLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zdGF0aWMtYW5kLWR5bmFtaWMjZHluYW1pYy1yZW5kZXJpbmdgKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogXCJFNTUzXCIsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbiwgd29ya1VuaXRTdG9yZS5keW5hbWljVHJhY2tpbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1sZWdhY3knKSB7XG4gICAgICAgICAgICB3b3JrVW5pdFN0b3JlLnJldmFsaWRhdGUgPSAwO1xuICAgICAgICAgICAgLy8gV2UgYXJlbid0IHByZXJlbmRlcmluZyBidXQgd2UgYXJlIGdlbmVyYXRpbmcgYSBzdGF0aWMgcGFnZS4gV2UgbmVlZCB0byBiYWlsIG91dCBvZiBzdGF0aWMgZ2VuZXJhdGlvblxuICAgICAgICAgICAgY29uc3QgZXJyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBfaG9va3NzZXJ2ZXJjb250ZXh0LkR5bmFtaWNTZXJ2ZXJFcnJvcihgUm91dGUgJHtzdG9yZS5yb3V0ZX0gY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9keW5hbWljLXNlcnZlci1lcnJvcmApLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJFNTUwXCIsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0b3JlLmR5bmFtaWNVc2FnZURlc2NyaXB0aW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHN0b3JlLmR5bmFtaWNVc2FnZVN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIHdvcmtVbml0U3RvcmUgJiYgd29ya1VuaXRTdG9yZS50eXBlID09PSAncmVxdWVzdCcpIHtcbiAgICAgICAgICAgIHdvcmtVbml0U3RvcmUudXNlZER5bmFtaWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhY2tGYWxsYmFja1BhcmFtQWNjZXNzZWQoc3RvcmUsIGV4cHJlc3Npb24pIHtcbiAgICBjb25zdCBwcmVyZW5kZXJTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKCFwcmVyZW5kZXJTdG9yZSB8fCBwcmVyZW5kZXJTdG9yZS50eXBlICE9PSAncHJlcmVuZGVyLXBwcicpIHJldHVybjtcbiAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbiwgcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nKTtcbn1cbmZ1bmN0aW9uIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKGV4cHJlc3Npb24sIHN0b3JlLCBwcmVyZW5kZXJTdG9yZSkge1xuICAgIC8vIFdlIGFyZW4ndCBwcmVyZW5kZXJpbmcgYnV0IHdlIGFyZSBnZW5lcmF0aW5nIGEgc3RhdGljIHBhZ2UuIFdlIG5lZWQgdG8gYmFpbCBvdXQgb2Ygc3RhdGljIGdlbmVyYXRpb25cbiAgICBjb25zdCBlcnIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IF9ob29rc3NlcnZlcmNvbnRleHQuRHluYW1pY1NlcnZlckVycm9yKGBSb3V0ZSAke3N0b3JlLnJvdXRlfSBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCBcXGAke2V4cHJlc3Npb259XFxgLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2R5bmFtaWMtc2VydmVyLWVycm9yYCksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICB2YWx1ZTogXCJFNTU4XCIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBwcmVyZW5kZXJTdG9yZS5yZXZhbGlkYXRlID0gMDtcbiAgICBzdG9yZS5keW5hbWljVXNhZ2VEZXNjcmlwdGlvbiA9IGV4cHJlc3Npb247XG4gICAgc3RvcmUuZHluYW1pY1VzYWdlU3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlcihfc3RvcmUsIHdvcmtVbml0U3RvcmUpIHtcbiAgICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgICAgICBpZiAod29ya1VuaXRTdG9yZS50eXBlID09PSAnY2FjaGUnIHx8IHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3Vuc3RhYmxlLWNhY2hlJykge1xuICAgICAgICAgICAgLy8gaW5zaWRlIGNhY2hlIHNjb3BlcyBtYXJraW5nIGEgc2NvcGUgYXMgZHluYW1pYyBoYXMgbm8gZWZmZWN0IGJlY2F1c2UgdGhlIG91dGVyIGNhY2hlIHNjb3BlXG4gICAgICAgICAgICAvLyBjcmVhdGVzIGEgY2FjaGUgYm91bmRhcnkuIFRoaXMgaXMgc3VidGx5IGRpZmZlcmVudCBmcm9tIHJlYWRpbmcgYSBkeW5hbWljIGRhdGEgc291cmNlIHdoaWNoIGlzXG4gICAgICAgICAgICAvLyBmb3JiaWRkZW4gaW5zaWRlIGEgY2FjaGUgc2NvcGUuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicgfHwgd29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLWxlZ2FjeScpIHtcbiAgICAgICAgICAgIHdvcmtVbml0U3RvcmUucmV2YWxpZGF0ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3JlcXVlc3QnKSB7XG4gICAgICAgICAgICB3b3JrVW5pdFN0b3JlLnVzZWREeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIERlc3BpdGUgaXQncyBuYW1lIHdlIGRvbid0IGFjdHVhbGx5IGFib3J0IHVubGVzcyB3ZSBoYXZlIGEgY29udHJvbGxlciB0byBjYWxsIGFib3J0IG9uXG4vLyBUaGVyZSBhcmUgdGltZXMgd2hlbiB3ZSBsZXQgYSBwcmVyZW5kZXIgcnVuIGxvbmcgdG8gZGlzY292ZXIgY2FjaGVzIHdoZXJlIHdlIHdhbnQgdGhlIHNlbWFudGljc1xuLy8gb2YgdHJhY2tpbmcgZHluYW1pYyBhY2Nlc3Mgd2l0aG91dCB0ZXJtaW5hdGluZyB0aGUgcHJlcmVuZGVyIGVhcmx5XG5mdW5jdGlvbiBhYm9ydE9uU3luY2hyb25vdXNEeW5hbWljRGF0YUFjY2Vzcyhyb3V0ZSwgZXhwcmVzc2lvbiwgcHJlcmVuZGVyU3RvcmUpIHtcbiAgICBjb25zdCByZWFzb24gPSBgUm91dGUgJHtyb3V0ZX0gbmVlZHMgdG8gYmFpbCBvdXQgb2YgcHJlcmVuZGVyaW5nIGF0IHRoaXMgcG9pbnQgYmVjYXVzZSBpdCB1c2VkICR7ZXhwcmVzc2lvbn0uYDtcbiAgICBjb25zdCBlcnJvciA9IGNyZWF0ZVByZXJlbmRlckludGVycnVwdGVkRXJyb3IocmVhc29uKTtcbiAgICBwcmVyZW5kZXJTdG9yZS5jb250cm9sbGVyLmFib3J0KGVycm9yKTtcbiAgICBjb25zdCBkeW5hbWljVHJhY2tpbmcgPSBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmc7XG4gICAgaWYgKGR5bmFtaWNUcmFja2luZykge1xuICAgICAgICBkeW5hbWljVHJhY2tpbmcuZHluYW1pY0FjY2Vzc2VzLnB1c2goe1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmVuJ3QgZGVidWdnaW5nLCB3ZSBkb24ndCBuZWVkIHRvIGNyZWF0ZSBhbm90aGVyIGVycm9yIGZvciB0aGVcbiAgICAgICAgICAgIC8vIHN0YWNrIHRyYWNlLlxuICAgICAgICAgICAgc3RhY2s6IGR5bmFtaWNUcmFja2luZy5pc0RlYnVnRHluYW1pY0FjY2Vzc2VzID8gbmV3IEVycm9yKCkuc3RhY2sgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBleHByZXNzaW9uXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFib3J0T25TeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3Mocm91dGUsIGV4cHJlc3Npb24sIGVycm9yV2l0aFN0YWNrLCBwcmVyZW5kZXJTdG9yZSkge1xuICAgIGNvbnN0IGR5bmFtaWNUcmFja2luZyA9IHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZztcbiAgICBpZiAoZHluYW1pY1RyYWNraW5nKSB7XG4gICAgICAgIGlmIChkeW5hbWljVHJhY2tpbmcuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZHluYW1pY1RyYWNraW5nLnN5bmNEeW5hbWljRXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgICAgICBkeW5hbWljVHJhY2tpbmcuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjayA9IGVycm9yV2l0aFN0YWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhYm9ydE9uU3luY2hyb25vdXNEeW5hbWljRGF0YUFjY2Vzcyhyb3V0ZSwgZXhwcmVzc2lvbiwgcHJlcmVuZGVyU3RvcmUpO1xufVxuZnVuY3Rpb24gdHJhY2tTeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3NJbkRldihyZXF1ZXN0U3RvcmUpIHtcbiAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBoYXZlIGEgY29udHJvbGxlciB0byBhYm9ydCBidXQgd2UgZG8gdGhlIHNlbWFudGljIGVxdWl2YWxlbnQgYnlcbiAgICAvLyBhZHZhbmNpbmcgdGhlIHJlcXVlc3Qgc3RvcmUgb3V0IG9mIHByZXJlbmRlciBtb2RlXG4gICAgcmVxdWVzdFN0b3JlLnByZXJlbmRlclBoYXNlID0gZmFsc2U7XG59XG5mdW5jdGlvbiBhYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzKHJvdXRlLCBleHByZXNzaW9uLCBlcnJvcldpdGhTdGFjaywgcHJlcmVuZGVyU3RvcmUpIHtcbiAgICBjb25zdCBkeW5hbWljVHJhY2tpbmcgPSBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmc7XG4gICAgaWYgKGR5bmFtaWNUcmFja2luZykge1xuICAgICAgICBpZiAoZHluYW1pY1RyYWNraW5nLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGR5bmFtaWNUcmFja2luZy5zeW5jRHluYW1pY0V4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgZHluYW1pY1RyYWNraW5nLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2sgPSBlcnJvcldpdGhTdGFjaztcbiAgICAgICAgICAgIGlmIChwcmVyZW5kZXJTdG9yZS52YWxpZGF0aW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYWx3YXlzIGxvZyBSZXF1ZXN0IEFjY2VzcyBpbiBkZXYgYXQgdGhlIHBvaW50IG9mIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgLy8gU28gd2UgbWFyayB0aGUgZHluYW1pYyB2YWxpZGF0aW9uIGFzIG5vdCByZXF1aXJpbmcgaXQgdG8gYmUgcHJpbnRlZFxuICAgICAgICAgICAgICAgIGR5bmFtaWNUcmFja2luZy5zeW5jRHluYW1pY0xvZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWJvcnRPblN5bmNocm9ub3VzRHluYW1pY0RhdGFBY2Nlc3Mocm91dGUsIGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlKTtcbiAgICB0aHJvdyBjcmVhdGVQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yKGBSb3V0ZSAke3JvdXRlfSBuZWVkcyB0byBiYWlsIG91dCBvZiBwcmVyZW5kZXJpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS5gKTtcbn1cbmNvbnN0IHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2ID0gdHJhY2tTeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3NJbkRldjtcbmZ1bmN0aW9uIFBvc3Rwb25lKHsgcmVhc29uLCByb3V0ZSB9KSB7XG4gICAgY29uc3QgcHJlcmVuZGVyU3RvcmUgPSBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbC53b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGNvbnN0IGR5bmFtaWNUcmFja2luZyA9IHByZXJlbmRlclN0b3JlICYmIHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJyA/IHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZyA6IG51bGw7XG4gICAgcG9zdHBvbmVXaXRoVHJhY2tpbmcocm91dGUsIHJlYXNvbiwgZHluYW1pY1RyYWNraW5nKTtcbn1cbmZ1bmN0aW9uIHBvc3Rwb25lV2l0aFRyYWNraW5nKHJvdXRlLCBleHByZXNzaW9uLCBkeW5hbWljVHJhY2tpbmcpIHtcbiAgICBhc3NlcnRQb3N0cG9uZSgpO1xuICAgIGlmIChkeW5hbWljVHJhY2tpbmcpIHtcbiAgICAgICAgZHluYW1pY1RyYWNraW5nLmR5bmFtaWNBY2Nlc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlbid0IGRlYnVnZ2luZywgd2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgYW5vdGhlciBlcnJvciBmb3IgdGhlXG4gICAgICAgICAgICAvLyBzdGFjayB0cmFjZS5cbiAgICAgICAgICAgIHN0YWNrOiBkeW5hbWljVHJhY2tpbmcuaXNEZWJ1Z0R5bmFtaWNBY2Nlc3NlcyA/IG5ldyBFcnJvcigpLnN0YWNrIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3JlYWN0LmRlZmF1bHQudW5zdGFibGVfcG9zdHBvbmUoY3JlYXRlUG9zdHBvbmVSZWFzb24ocm91dGUsIGV4cHJlc3Npb24pKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvc3Rwb25lUmVhc29uKHJvdXRlLCBleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIGBSb3V0ZSAke3JvdXRlfSBuZWVkcyB0byBiYWlsIG91dCBvZiBwcmVyZW5kZXJpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS4gYCArIGBSZWFjdCB0aHJvd3MgdGhpcyBzcGVjaWFsIG9iamVjdCB0byBpbmRpY2F0ZSB3aGVyZS4gSXQgc2hvdWxkIG5vdCBiZSBjYXVnaHQgYnkgYCArIGB5b3VyIG93biB0cnkvY2F0Y2guIExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3Bwci1jYXVnaHQtZXJyb3JgO1xufVxuZnVuY3Rpb24gaXNEeW5hbWljUG9zdHBvbmUoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmIGVyciAhPT0gbnVsbCAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpc0R5bmFtaWNQb3N0cG9uZVJlYXNvbihlcnIubWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzRHluYW1pY1Bvc3Rwb25lUmVhc29uKHJlYXNvbikge1xuICAgIHJldHVybiByZWFzb24uaW5jbHVkZXMoJ25lZWRzIHRvIGJhaWwgb3V0IG9mIHByZXJlbmRlcmluZyBhdCB0aGlzIHBvaW50IGJlY2F1c2UgaXQgdXNlZCcpICYmIHJlYXNvbi5pbmNsdWRlcygnTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcHByLWNhdWdodC1lcnJvcicpO1xufVxuaWYgKGlzRHluYW1pY1Bvc3Rwb25lUmVhc29uKGNyZWF0ZVBvc3Rwb25lUmVhc29uKCclJSUnLCAnXl5eJykpID09PSBmYWxzZSkge1xuICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgRXJyb3IoJ0ludmFyaWFudDogaXNEeW5hbWljUG9zdHBvbmUgbWlzaWRlbnRpZmllZCBhIHBvc3Rwb25lIHJlYXNvbi4gVGhpcyBpcyBhIGJ1ZyBpbiBOZXh0LmpzJyksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICB2YWx1ZTogXCJFMjk2XCIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbn1cbmNvbnN0IE5FWFRfUFJFUkVOREVSX0lOVEVSUlVQVEVEID0gJ05FWFRfUFJFUkVOREVSX0lOVEVSUlVQVEVEJztcbmZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlckludGVycnVwdGVkRXJyb3IobWVzc2FnZSkge1xuICAgIGNvbnN0IGVycm9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcihtZXNzYWdlKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgIHZhbHVlOiBcIkUzOTRcIixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGVycm9yLmRpZ2VzdCA9IE5FWFRfUFJFUkVOREVSX0lOVEVSUlVQVEVEO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbmZ1bmN0aW9uIGlzUHJlcmVuZGVySW50ZXJydXB0ZWRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmIGVycm9yLmRpZ2VzdCA9PT0gTkVYVF9QUkVSRU5ERVJfSU5URVJSVVBURUQgJiYgJ25hbWUnIGluIGVycm9yICYmICdtZXNzYWdlJyBpbiBlcnJvciAmJiBlcnJvciBpbnN0YW5jZW9mIEVycm9yO1xufVxuZnVuY3Rpb24gYWNjZXNzZWREeW5hbWljRGF0YShkeW5hbWljQWNjZXNzZXMpIHtcbiAgICByZXR1cm4gZHluYW1pY0FjY2Vzc2VzLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiBjb25zdW1lRHluYW1pY0FjY2VzcyhzZXJ2ZXJEeW5hbWljLCBjbGllbnREeW5hbWljKSB7XG4gICAgLy8gV2UgbXV0YXRlIGJlY2F1c2Ugd2Ugb25seSBjYWxsIHRoaXMgb25jZSB3ZSBhcmUgbm8gbG9uZ2VyIHdyaXRpbmdcbiAgICAvLyB0byB0aGUgZHluYW1pY1RyYWNraW5nU3RhdGUgYW5kIGl0J3MgbW9yZSBlZmZpY2llbnQgdGhhbiBjcmVhdGluZyBhIG5ld1xuICAgIC8vIGFycmF5LlxuICAgIHNlcnZlckR5bmFtaWMuZHluYW1pY0FjY2Vzc2VzLnB1c2goLi4uY2xpZW50RHluYW1pYy5keW5hbWljQWNjZXNzZXMpO1xuICAgIHJldHVybiBzZXJ2ZXJEeW5hbWljLmR5bmFtaWNBY2Nlc3Nlcztcbn1cbmZ1bmN0aW9uIGZvcm1hdER5bmFtaWNBUElBY2Nlc3NlcyhkeW5hbWljQWNjZXNzZXMpIHtcbiAgICByZXR1cm4gZHluYW1pY0FjY2Vzc2VzLmZpbHRlcigoYWNjZXNzKT0+dHlwZW9mIGFjY2Vzcy5zdGFjayA9PT0gJ3N0cmluZycgJiYgYWNjZXNzLnN0YWNrLmxlbmd0aCA+IDApLm1hcCgoeyBleHByZXNzaW9uLCBzdGFjayB9KT0+e1xuICAgICAgICBzdGFjayA9IHN0YWNrLnNwbGl0KCdcXG4nKS8vIFJlbW92ZSB0aGUgXCJFcnJvcjogXCIgcHJlZml4IGZyb20gdGhlIGZpcnN0IGxpbmUgb2YgdGhlIHN0YWNrIHRyYWNlIGFzXG4gICAgICAgIC8vIHdlbGwgYXMgdGhlIGZpcnN0IDQgbGluZXMgb2YgdGhlIHN0YWNrIHRyYWNlIHdoaWNoIGlzIHRoZSBkaXN0YW5jZVxuICAgICAgICAvLyBmcm9tIHRoZSB1c2VyIGNvZGUgYW5kIHRoZSBgbmV3IEVycm9yKCkuc3RhY2tgIGNhbGwuXG4gICAgICAgIC5zbGljZSg0KS5maWx0ZXIoKGxpbmUpPT57XG4gICAgICAgICAgICAvLyBFeGNsdWRlIE5leHQuanMgaW50ZXJuYWxzIGZyb20gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJ25vZGVfbW9kdWxlcy9uZXh0LycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXhjbHVkZSBhbm9ueW1vdXMgZnVuY3Rpb25zIGZyb20gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJyAoPGFub255bW91cz4pJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeGNsdWRlIE5vZGUuanMgaW50ZXJuYWxzIGZyb20gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJyAobm9kZTonKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgcmV0dXJuIGBEeW5hbWljIEFQSSBVc2FnZSBEZWJ1ZyAtICR7ZXhwcmVzc2lvbn06XFxuJHtzdGFja31gO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYXNzZXJ0UG9zdHBvbmUoKSB7XG4gICAgaWYgKCFoYXNQb3N0cG9uZSkge1xuICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBJbnZhcmlhbnQ6IFJlYWN0LnVuc3RhYmxlX3Bvc3Rwb25lIGlzIG5vdCBkZWZpbmVkLiBUaGlzIHN1Z2dlc3RzIHRoZSB3cm9uZyB2ZXJzaW9uIG9mIFJlYWN0IHdhcyBsb2FkZWQuIFRoaXMgaXMgYSBidWcgaW4gTmV4dC5qc2ApLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBcIkUyMjRcIixcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvc3Rwb25lZEFib3J0U2lnbmFsKHJlYXNvbikge1xuICAgIGFzc2VydFBvc3Rwb25lKCk7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAvLyBXZSBnZXQgb3VyIGhhbmRzIG9uIGEgcG9zdHBvbmUgaW5zdGFuY2UgYnkgY2FsbGluZyBwb3N0cG9uZSBhbmQgY2F0Y2hpbmcgdGhlIHRocm93XG4gICAgdHJ5IHtcbiAgICAgICAgX3JlYWN0LmRlZmF1bHQudW5zdGFibGVfcG9zdHBvbmUocmVhc29uKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoeCk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhhbmdpbmdJbnB1dEFib3J0U2lnbmFsKHdvcmtVbml0U3RvcmUpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGlmICh3b3JrVW5pdFN0b3JlLmNhY2hlU2lnbmFsKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBjYWNoZVNpZ25hbCBpdCBtZWFucyB3ZSdyZSBpbiBhIHByb3NwZWN0aXZlIHJlbmRlci4gSWYgdGhlIGlucHV0XG4gICAgICAgIC8vIHdlJ3JlIHdhaXRpbmcgb24gaXMgY29taW5nIGZyb20gYW5vdGhlciBjYWNoZSwgd2UgZG8gd2FudCB0byB3YWl0IGZvciBpdCBzbyB0aGF0XG4gICAgICAgIC8vIHdlIGNhbiByZXNvbHZlIHRoaXMgY2FjaGUgZW50cnkgdG9vLlxuICAgICAgICB3b3JrVW5pdFN0b3JlLmNhY2hlU2lnbmFsLmlucHV0UmVhZHkoKS50aGVuKCgpPT57XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSdyZSBpbiB0aGUgZmluYWwgcmVuZGVyIGFuZCB3ZSBzaG91bGQgYWxyZWFkeSBoYXZlIGFsbCBvdXIgY2FjaGVzXG4gICAgICAgIC8vIGZpbGxlZC4gV2UgbWlnaHQgc3RpbGwgYmUgd2FpdGluZyBvbiBzb21lIG1pY3JvdGFza3Mgc28gd2Ugd2FpdCBvbmUgdGljayBiZWZvcmVcbiAgICAgICAgLy8gZ2l2aW5nIHVwLiBXaGVuIHdlIGdpdmUgdXAsIHdlIHN0aWxsIHdhbnQgdG8gcmVuZGVyIHRoZSBjb250ZW50IG9mIHRoaXMgY2FjaGVcbiAgICAgICAgLy8gYXMgZGVlcGx5IGFzIHdlIGNhbiBzbyB0aGF0IHdlIGNhbiBzdXNwZW5kIGFzIGRlZXBseSBhcyBwb3NzaWJsZSBpbiB0aGUgdHJlZVxuICAgICAgICAvLyBvciBub3QgYXQgYWxsIGlmIHdlIGRvbid0IGVuZCB1cCB3YWl0aW5nIGZvciB0aGUgaW5wdXQuXG4gICAgICAgICgwLCBfc2NoZWR1bGVyLnNjaGVkdWxlT25OZXh0VGljaykoKCk9PmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbn1cbmZ1bmN0aW9uIGFubm90YXRlRHluYW1pY0FjY2VzcyhleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZSkge1xuICAgIGNvbnN0IGR5bmFtaWNUcmFja2luZyA9IHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZztcbiAgICBpZiAoZHluYW1pY1RyYWNraW5nKSB7XG4gICAgICAgIGR5bmFtaWNUcmFja2luZy5keW5hbWljQWNjZXNzZXMucHVzaCh7XG4gICAgICAgICAgICBzdGFjazogZHluYW1pY1RyYWNraW5nLmlzRGVidWdEeW5hbWljQWNjZXNzZXMgPyBuZXcgRXJyb3IoKS5zdGFjayA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXNlRHluYW1pY1JvdXRlUGFyYW1zKGV4cHJlc3Npb24pIHtcbiAgICBjb25zdCB3b3JrU3RvcmUgPSBfd29ya2FzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICBpZiAod29ya1N0b3JlICYmIHdvcmtTdG9yZS5pc1N0YXRpY0dlbmVyYXRpb24gJiYgd29ya1N0b3JlLmZhbGxiYWNrUm91dGVQYXJhbXMgJiYgd29ya1N0b3JlLmZhbGxiYWNrUm91dGVQYXJhbXMuc2l6ZSA+IDApIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIGZhbGxiYWNrIHJvdXRlIHBhcmFtcywgd2Ugc2hvdWxkIHRyYWNrIHRoZXNlIGFzIGR5bmFtaWNcbiAgICAgICAgLy8gYWNjZXNzZXMuXG4gICAgICAgIGNvbnN0IHdvcmtVbml0U3RvcmUgPSBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbC53b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgICAgICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgICAgICAgICAgLy8gV2UncmUgcHJlcmVuZGVyaW5nIHdpdGggZHluYW1pY0lPIG9yIFBQUiBvciBib3RoXG4gICAgICAgICAgICBpZiAod29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJykge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBpbiBhIHByZXJlbmRlciB3aXRoIGR5bmFtaWNJTyBzZW1hbnRpY3NcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gaGFuZyBoZXJlIGFuZCBuZXZlciByZXNvbHZlLiBUaGlzIHdpbGwgY2F1c2UgdGhlIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgIC8vIHJlbmRlcmluZyBjb21wb25lbnQgdG8gZWZmZWN0aXZlbHkgYmUgYSBkeW5hbWljIGhvbGVcbiAgICAgICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC51c2UoKDAsIF9keW5hbWljcmVuZGVyaW5ndXRpbHMubWFrZUhhbmdpbmdQcm9taXNlKSh3b3JrVW5pdFN0b3JlLnJlbmRlclNpZ25hbCwgZXhwcmVzc2lvbikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJykge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHByZXJlbmRlcmluZyB3aXRoIFBQUlxuICAgICAgICAgICAgICAgIHBvc3Rwb25lV2l0aFRyYWNraW5nKHdvcmtTdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbiwgd29ya1VuaXRTdG9yZS5keW5hbWljVHJhY2tpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItbGVnYWN5Jykge1xuICAgICAgICAgICAgICAgIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKGV4cHJlc3Npb24sIHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBoYXNTdXNwZW5zZVJlZ2V4ID0gL1xcblxccythdCBTdXNwZW5zZSBcXCg8YW5vbnltb3VzPlxcKS87XG5jb25zdCBoYXNNZXRhZGF0YVJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXG5cXFxccythdCAke19tZXRhZGF0YWNvbnN0YW50cy5NRVRBREFUQV9CT1VOREFSWV9OQU1FfVtcXFxcblxcXFxzXWApO1xuY29uc3QgaGFzVmlld3BvcnRSZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxuXFxcXHMrYXQgJHtfbWV0YWRhdGFjb25zdGFudHMuVklFV1BPUlRfQk9VTkRBUllfTkFNRX1bXFxcXG5cXFxcc11gKTtcbmNvbnN0IGhhc091dGxldFJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXG5cXFxccythdCAke19tZXRhZGF0YWNvbnN0YW50cy5PVVRMRVRfQk9VTkRBUllfTkFNRX1bXFxcXG5cXFxcc11gKTtcbmZ1bmN0aW9uIHRyYWNrQWxsb3dlZER5bmFtaWNBY2Nlc3Mocm91dGUsIGNvbXBvbmVudFN0YWNrLCBkeW5hbWljVmFsaWRhdGlvbiwgc2VydmVyRHluYW1pYywgY2xpZW50RHluYW1pYykge1xuICAgIGlmIChoYXNPdXRsZXRSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHRyYWNrIHRoYXQgdGhpcyBpcyBkeW5hbWljLiBJdCBpcyBvbmx5IHNvIHdoZW4gc29tZXRoaW5nIGVsc2UgaXMgYWxzbyBkeW5hbWljLlxuICAgICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChoYXNNZXRhZGF0YVJlZ2V4LnRlc3QoY29tcG9uZW50U3RhY2spKSB7XG4gICAgICAgIGR5bmFtaWNWYWxpZGF0aW9uLmhhc0R5bmFtaWNNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGhhc1ZpZXdwb3J0UmVnZXgudGVzdChjb21wb25lbnRTdGFjaykpIHtcbiAgICAgICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY1ZpZXdwb3J0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoaGFzU3VzcGVuc2VSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgICAgICBkeW5hbWljVmFsaWRhdGlvbi5oYXNTdXNwZW5kZWREeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoc2VydmVyRHluYW1pYy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrIHx8IGNsaWVudER5bmFtaWMuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjaykge1xuICAgICAgICBkeW5hbWljVmFsaWRhdGlvbi5oYXNTeW5jRHluYW1pY0Vycm9ycyA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYFJvdXRlIFwiJHtyb3V0ZX1cIjogQSBjb21wb25lbnQgYWNjZXNzZWQgZGF0YSwgaGVhZGVycywgcGFyYW1zLCBzZWFyY2hQYXJhbXMsIG9yIGEgc2hvcnQtbGl2ZWQgY2FjaGUgd2l0aG91dCBhIFN1c3BlbnNlIGJvdW5kYXJ5IG5vciBhIFwidXNlIGNhY2hlXCIgYWJvdmUgaXQuIFdlIGRvbid0IGhhdmUgdGhlIGV4YWN0IGxpbmUgbnVtYmVyIGFkZGVkIHRvIGVycm9yIG1lc3NhZ2VzIHlldCBidXQgeW91IGNhbiBzZWUgd2hpY2ggY29tcG9uZW50IGluIHRoZSBzdGFjayBiZWxvdy4gU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1wcmVyZW5kZXItbWlzc2luZy1zdXNwZW5zZWA7XG4gICAgICAgIGNvbnN0IGVycm9yID0gY3JlYXRlRXJyb3JXaXRoQ29tcG9uZW50U3RhY2sobWVzc2FnZSwgY29tcG9uZW50U3RhY2spO1xuICAgICAgICBkeW5hbWljVmFsaWRhdGlvbi5keW5hbWljRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRXJyb3JXaXRoQ29tcG9uZW50U3RhY2sobWVzc2FnZSwgY29tcG9uZW50U3RhY2spIHtcbiAgICBjb25zdCBlcnJvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgRXJyb3IobWVzc2FnZSksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICB2YWx1ZTogXCJFMzk0XCIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBlcnJvci5zdGFjayA9ICdFcnJvcjogJyArIG1lc3NhZ2UgKyBjb21wb25lbnRTdGFjaztcbiAgICByZXR1cm4gZXJyb3I7XG59XG5mdW5jdGlvbiB0aHJvd0lmRGlzYWxsb3dlZER5bmFtaWMocm91dGUsIGR5bmFtaWNWYWxpZGF0aW9uLCBzZXJ2ZXJEeW5hbWljLCBjbGllbnREeW5hbWljKSB7XG4gICAgbGV0IHN5bmNFcnJvcjtcbiAgICBsZXQgc3luY0V4cHJlc3Npb247XG4gICAgbGV0IHN5bmNMb2dnZWQ7XG4gICAgaWYgKHNlcnZlckR5bmFtaWMuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjaykge1xuICAgICAgICBzeW5jRXJyb3IgPSBzZXJ2ZXJEeW5hbWljLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2s7XG4gICAgICAgIHN5bmNFeHByZXNzaW9uID0gc2VydmVyRHluYW1pYy5zeW5jRHluYW1pY0V4cHJlc3Npb247XG4gICAgICAgIHN5bmNMb2dnZWQgPSBzZXJ2ZXJEeW5hbWljLnN5bmNEeW5hbWljTG9nZ2VkID09PSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY2xpZW50RHluYW1pYy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrKSB7XG4gICAgICAgIHN5bmNFcnJvciA9IGNsaWVudER5bmFtaWMuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjaztcbiAgICAgICAgc3luY0V4cHJlc3Npb24gPSBjbGllbnREeW5hbWljLnN5bmNEeW5hbWljRXhwcmVzc2lvbjtcbiAgICAgICAgc3luY0xvZ2dlZCA9IGNsaWVudER5bmFtaWMuc3luY0R5bmFtaWNMb2dnZWQgPT09IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3luY0Vycm9yID0gbnVsbDtcbiAgICAgICAgc3luY0V4cHJlc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHN5bmNMb2dnZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGR5bmFtaWNWYWxpZGF0aW9uLmhhc1N5bmNEeW5hbWljRXJyb3JzICYmIHN5bmNFcnJvcikge1xuICAgICAgICBpZiAoIXN5bmNMb2dnZWQpIHtcbiAgICAgICAgICAgIC8vIEluIGRldiB3ZSBhbHJlYWR5IGxvZyBlcnJvcnMgYWJvdXQgc3luYyBkeW5hbWljIGFjY2Vzcy4gQnV0IGR1cmluZyBidWlsZHMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgICAgICAgIC8vIHRoZSBvZmZlbmRpbmcgc3luYyBlcnJvciBpcyBsb2dnZWQgYmVmb3JlIHdlIGV4aXQgdGhlIGJ1aWxkXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKHN5bmNFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGFjdHVhbCBlcnJvciBzaG91bGQgaGF2ZSBiZWVuIGxvZ2dlZCB3aGVuIHRoZSBzeW5jIGFjY2VzcyBvY3VycmVkXG4gICAgICAgIHRocm93IG5ldyBfc3RhdGljZ2VuZXJhdGlvbmJhaWxvdXQuU3RhdGljR2VuQmFpbG91dEVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IGR5bmFtaWNFcnJvcnMgPSBkeW5hbWljVmFsaWRhdGlvbi5keW5hbWljRXJyb3JzO1xuICAgIGlmIChkeW5hbWljRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZHluYW1pY0Vycm9ycy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGR5bmFtaWNFcnJvcnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBfc3RhdGljZ2VuZXJhdGlvbmJhaWxvdXQuU3RhdGljR2VuQmFpbG91dEVycm9yKCk7XG4gICAgfVxuICAgIGlmICghZHluYW1pY1ZhbGlkYXRpb24uaGFzU3VzcGVuZGVkRHluYW1pYykge1xuICAgICAgICBpZiAoZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY01ldGFkYXRhKSB7XG4gICAgICAgICAgICBpZiAoc3luY0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihzeW5jRXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0LlN0YXRpY0dlbkJhaWxvdXRFcnJvcihgUm91dGUgXCIke3JvdXRlfVwiIGhhcyBhIFxcYGdlbmVyYXRlTWV0YWRhdGFcXGAgdGhhdCBjb3VsZCBub3QgZmluaXNoIHJlbmRlcmluZyBiZWZvcmUgJHtzeW5jRXhwcmVzc2lvbn0gd2FzIHVzZWQuIEZvbGxvdyB0aGUgaW5zdHJ1Y3Rpb25zIGluIHRoZSBlcnJvciBmb3IgdGhpcyBleHByZXNzaW9uIHRvIHJlc29sdmUuYCksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJFNjA4XCIsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0LlN0YXRpY0dlbkJhaWxvdXRFcnJvcihgUm91dGUgXCIke3JvdXRlfVwiIGhhcyBhIFxcYGdlbmVyYXRlTWV0YWRhdGFcXGAgdGhhdCBkZXBlbmRzIG9uIFJlcXVlc3QgZGF0YSAoXFxgY29va2llcygpXFxgLCBldGMuLi4pIG9yIGV4dGVybmFsIGRhdGEgKFxcYGZldGNoKC4uLilcXGAsIGV0Yy4uLikgYnV0IHRoZSByZXN0IG9mIHRoZSByb3V0ZSB3YXMgc3RhdGljIG9yIG9ubHkgdXNlZCBjYWNoZWQgZGF0YSAoXFxgXCJ1c2UgY2FjaGVcIlxcYCkuIElmIHlvdSBleHBlY3RlZCB0aGlzIHJvdXRlIHRvIGJlIHByZXJlbmRlcmFibGUgdXBkYXRlIHlvdXIgXFxgZ2VuZXJhdGVNZXRhZGF0YVxcYCB0byBub3QgdXNlIFJlcXVlc3QgZGF0YSBhbmQgb25seSB1c2UgY2FjaGVkIGV4dGVybmFsIGRhdGEuIE90aGVyd2lzZSwgYWRkIFxcYGF3YWl0IGNvbm5lY3Rpb24oKVxcYCBzb21ld2hlcmUgd2l0aGluIHRoaXMgcm91dGUgdG8gaW5kaWNhdGUgZXhwbGljaXRseSBpdCBzaG91bGQgbm90IGJlIHByZXJlbmRlcmVkLmApLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJFNTM0XCIsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChkeW5hbWljVmFsaWRhdGlvbi5oYXNEeW5hbWljVmlld3BvcnQpIHtcbiAgICAgICAgICAgIGlmIChzeW5jRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHN5bmNFcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBfc3RhdGljZ2VuZXJhdGlvbmJhaWxvdXQuU3RhdGljR2VuQmFpbG91dEVycm9yKGBSb3V0ZSBcIiR7cm91dGV9XCIgaGFzIGEgXFxgZ2VuZXJhdGVWaWV3cG9ydFxcYCB0aGF0IGNvdWxkIG5vdCBmaW5pc2ggcmVuZGVyaW5nIGJlZm9yZSAke3N5bmNFeHByZXNzaW9ufSB3YXMgdXNlZC4gRm9sbG93IHRoZSBpbnN0cnVjdGlvbnMgaW4gdGhlIGVycm9yIGZvciB0aGlzIGV4cHJlc3Npb24gdG8gcmVzb2x2ZS5gKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkU1NzNcIixcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBfc3RhdGljZ2VuZXJhdGlvbmJhaWxvdXQuU3RhdGljR2VuQmFpbG91dEVycm9yKGBSb3V0ZSBcIiR7cm91dGV9XCIgaGFzIGEgXFxgZ2VuZXJhdGVWaWV3cG9ydFxcYCB0aGF0IGRlcGVuZHMgb24gUmVxdWVzdCBkYXRhIChcXGBjb29raWVzKClcXGAsIGV0Yy4uLikgb3IgZXh0ZXJuYWwgZGF0YSAoXFxgZmV0Y2goLi4uKVxcYCwgZXRjLi4uKSBidXQgdGhlIHJlc3Qgb2YgdGhlIHJvdXRlIHdhcyBzdGF0aWMgb3Igb25seSB1c2VkIGNhY2hlZCBkYXRhIChcXGBcInVzZSBjYWNoZVwiXFxgKS4gSWYgeW91IGV4cGVjdGVkIHRoaXMgcm91dGUgdG8gYmUgcHJlcmVuZGVyYWJsZSB1cGRhdGUgeW91ciBcXGBnZW5lcmF0ZVZpZXdwb3J0XFxgIHRvIG5vdCB1c2UgUmVxdWVzdCBkYXRhIGFuZCBvbmx5IHVzZSBjYWNoZWQgZXh0ZXJuYWwgZGF0YS4gT3RoZXJ3aXNlLCBhZGQgXFxgYXdhaXQgY29ubmVjdGlvbigpXFxgIHNvbWV3aGVyZSB3aXRoaW4gdGhpcyByb3V0ZSB0byBpbmRpY2F0ZSBleHBsaWNpdGx5IGl0IHNob3VsZCBub3QgYmUgcHJlcmVuZGVyZWQuYCksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIkU1OTBcIixcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1keW5hbWljLXJlbmRlcmluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/app-render/dynamic-rendering.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/base-http/helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/server/base-http/helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isNodeNextRequest: function() {\n        return isNodeNextRequest;\n    },\n    isNodeNextResponse: function() {\n        return isNodeNextResponse;\n    },\n    isWebNextRequest: function() {\n        return isWebNextRequest;\n    },\n    isWebNextResponse: function() {\n        return isWebNextResponse;\n    }\n});\nconst isWebNextRequest = (req)=>\"nodejs\" === 'edge';\nconst isWebNextResponse = (res)=>\"nodejs\" === 'edge';\nconst isNodeNextRequest = (req)=>\"nodejs\" !== 'edge';\nconst isNodeNextResponse = (res)=>\"nodejs\" !== 'edge';\n\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9iYXNlLWh0dHAvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLE1BQU0sQ0FLTDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDLFFBQXdCO0FBQ3hELGlDQUFpQyxRQUF3QjtBQUN6RCxpQ0FBaUMsUUFBd0I7QUFDekQsa0NBQWtDLFFBQXdCOztBQUUxRCIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxcYmFzZS1odHRwXFxoZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNOb2RlTmV4dFJlcXVlc3Q6IG51bGwsXG4gICAgaXNOb2RlTmV4dFJlc3BvbnNlOiBudWxsLFxuICAgIGlzV2ViTmV4dFJlcXVlc3Q6IG51bGwsXG4gICAgaXNXZWJOZXh0UmVzcG9uc2U6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgaXNOb2RlTmV4dFJlcXVlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNOb2RlTmV4dFJlcXVlc3Q7XG4gICAgfSxcbiAgICBpc05vZGVOZXh0UmVzcG9uc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNOb2RlTmV4dFJlc3BvbnNlO1xuICAgIH0sXG4gICAgaXNXZWJOZXh0UmVxdWVzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc1dlYk5leHRSZXF1ZXN0O1xuICAgIH0sXG4gICAgaXNXZWJOZXh0UmVzcG9uc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNXZWJOZXh0UmVzcG9uc2U7XG4gICAgfVxufSk7XG5jb25zdCBpc1dlYk5leHRSZXF1ZXN0ID0gKHJlcSk9PnByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnO1xuY29uc3QgaXNXZWJOZXh0UmVzcG9uc2UgPSAocmVzKT0+cHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnZWRnZSc7XG5jb25zdCBpc05vZGVOZXh0UmVxdWVzdCA9IChyZXEpPT5wcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgIT09ICdlZGdlJztcbmNvbnN0IGlzTm9kZU5leHRSZXNwb25zZSA9IChyZXMpPT5wcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgIT09ICdlZGdlJztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/base-http/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/client-component-renderer-logger.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/server/client-component-renderer-logger.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getClientComponentLoaderMetrics: function() {\n        return getClientComponentLoaderMetrics;\n    },\n    wrapClientComponentLoader: function() {\n        return wrapClientComponentLoader;\n    }\n});\n// Combined load times for loading client components\nlet clientComponentLoadStart = 0;\nlet clientComponentLoadTimes = 0;\nlet clientComponentLoadCount = 0;\nfunction wrapClientComponentLoader(ComponentMod) {\n    if (!('performance' in globalThis)) {\n        return ComponentMod.__next_app__;\n    }\n    return {\n        require: (...args)=>{\n            const startTime = performance.now();\n            if (clientComponentLoadStart === 0) {\n                clientComponentLoadStart = startTime;\n            }\n            try {\n                clientComponentLoadCount += 1;\n                return ComponentMod.__next_app__.require(...args);\n            } finally{\n                clientComponentLoadTimes += performance.now() - startTime;\n            }\n        },\n        loadChunk: (...args)=>{\n            const startTime = performance.now();\n            const result = ComponentMod.__next_app__.loadChunk(...args);\n            // Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.\n            // We only need to know when it's settled.\n            result.finally(()=>{\n                clientComponentLoadTimes += performance.now() - startTime;\n            });\n            return result;\n        }\n    };\n}\nfunction getClientComponentLoaderMetrics(options = {}) {\n    const metrics = clientComponentLoadStart === 0 ? undefined : {\n        clientComponentLoadStart,\n        clientComponentLoadTimes,\n        clientComponentLoadCount\n    };\n    if (options.reset) {\n        clientComponentLoadStart = 0;\n        clientComponentLoadTimes = 0;\n        clientComponentLoadCount = 0;\n    }\n    return metrics;\n}\n\n//# sourceMappingURL=client-component-renderer-logger.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9jbGllbnQtY29tcG9uZW50LXJlbmRlcmVyLWxvZ2dlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLE1BQU0sQ0FHTDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFxjbGllbnQtY29tcG9uZW50LXJlbmRlcmVyLWxvZ2dlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldENsaWVudENvbXBvbmVudExvYWRlck1ldHJpY3M6IG51bGwsXG4gICAgd3JhcENsaWVudENvbXBvbmVudExvYWRlcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBnZXRDbGllbnRDb21wb25lbnRMb2FkZXJNZXRyaWNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldENsaWVudENvbXBvbmVudExvYWRlck1ldHJpY3M7XG4gICAgfSxcbiAgICB3cmFwQ2xpZW50Q29tcG9uZW50TG9hZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBDbGllbnRDb21wb25lbnRMb2FkZXI7XG4gICAgfVxufSk7XG4vLyBDb21iaW5lZCBsb2FkIHRpbWVzIGZvciBsb2FkaW5nIGNsaWVudCBjb21wb25lbnRzXG5sZXQgY2xpZW50Q29tcG9uZW50TG9hZFN0YXJ0ID0gMDtcbmxldCBjbGllbnRDb21wb25lbnRMb2FkVGltZXMgPSAwO1xubGV0IGNsaWVudENvbXBvbmVudExvYWRDb3VudCA9IDA7XG5mdW5jdGlvbiB3cmFwQ2xpZW50Q29tcG9uZW50TG9hZGVyKENvbXBvbmVudE1vZCkge1xuICAgIGlmICghKCdwZXJmb3JtYW5jZScgaW4gZ2xvYmFsVGhpcykpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudE1vZC5fX25leHRfYXBwX187XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVpcmU6ICguLi5hcmdzKT0+e1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBpZiAoY2xpZW50Q29tcG9uZW50TG9hZFN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50Q29tcG9uZW50TG9hZFN0YXJ0ID0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjbGllbnRDb21wb25lbnRMb2FkQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tcG9uZW50TW9kLl9fbmV4dF9hcHBfXy5yZXF1aXJlKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgIGNsaWVudENvbXBvbmVudExvYWRUaW1lcyArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9hZENodW5rOiAoLi4uYXJncyk9PntcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gQ29tcG9uZW50TW9kLl9fbmV4dF9hcHBfXy5sb2FkQ2h1bmsoLi4uYXJncyk7XG4gICAgICAgICAgICAvLyBBdm9pZCB3cmFwcGluZyBgbG9hZENodW5rYCdzIHJlc3VsdCBpbiBhbiBleHRyYSBwcm9taXNlIGluIGNhc2Ugc29tZXRoaW5nIGxpa2UgUmVhY3QgZGVwZW5kcyBvbiBpdHMgaWRlbnRpdHkuXG4gICAgICAgICAgICAvLyBXZSBvbmx5IG5lZWQgdG8ga25vdyB3aGVuIGl0J3Mgc2V0dGxlZC5cbiAgICAgICAgICAgIHJlc3VsdC5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgY2xpZW50Q29tcG9uZW50TG9hZFRpbWVzICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudENvbXBvbmVudExvYWRlck1ldHJpY3Mob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgbWV0cmljcyA9IGNsaWVudENvbXBvbmVudExvYWRTdGFydCA9PT0gMCA/IHVuZGVmaW5lZCA6IHtcbiAgICAgICAgY2xpZW50Q29tcG9uZW50TG9hZFN0YXJ0LFxuICAgICAgICBjbGllbnRDb21wb25lbnRMb2FkVGltZXMsXG4gICAgICAgIGNsaWVudENvbXBvbmVudExvYWRDb3VudFxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMucmVzZXQpIHtcbiAgICAgICAgY2xpZW50Q29tcG9uZW50TG9hZFN0YXJ0ID0gMDtcbiAgICAgICAgY2xpZW50Q29tcG9uZW50TG9hZFRpbWVzID0gMDtcbiAgICAgICAgY2xpZW50Q29tcG9uZW50TG9hZENvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1ldHJpY3M7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC1jb21wb25lbnQtcmVuZGVyZXItbG9nZ2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/client-component-renderer-logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/dynamic-rendering-utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/server/dynamic-rendering-utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isHangingPromiseRejectionError: function() {\n        return isHangingPromiseRejectionError;\n    },\n    makeHangingPromise: function() {\n        return makeHangingPromise;\n    }\n});\nfunction isHangingPromiseRejectionError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err)) {\n        return false;\n    }\n    return err.digest === HANGING_PROMISE_REJECTION;\n}\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';\nclass HangingPromiseRejectionError extends Error {\n    constructor(expression){\n        super(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context.`), this.expression = expression, this.digest = HANGING_PROMISE_REJECTION;\n    }\n}\nfunction makeHangingPromise(signal, expression) {\n    const hangingPromise = new Promise((_, reject)=>{\n        signal.addEventListener('abort', ()=>{\n            reject(new HangingPromiseRejectionError(expression));\n        }, {\n            once: true\n        });\n    });\n    // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n    // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n    // your own promise out of it you'll need to ensure you handle the error when it rejects.\n    hangingPromise.catch(ignoreReject);\n    return hangingPromise;\n}\nfunction ignoreReject() {}\n\n//# sourceMappingURL=dynamic-rendering-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9keW5hbWljLXJlbmRlcmluZy11dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLE1BQU0sQ0FHTDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWSxzR0FBc0csWUFBWTtBQUNwSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFxkeW5hbWljLXJlbmRlcmluZy11dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlzSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvcjogbnVsbCxcbiAgICBtYWtlSGFuZ2luZ1Byb21pc2U6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgaXNIYW5naW5nUHJvbWlzZVJlamVjdGlvbkVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvcjtcbiAgICB9LFxuICAgIG1ha2VIYW5naW5nUHJvbWlzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtYWtlSGFuZ2luZ1Byb21pc2U7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBpc0hhbmdpbmdQcm9taXNlUmVqZWN0aW9uRXJyb3IoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBlcnIgIT09ICdvYmplY3QnIHx8IGVyciA9PT0gbnVsbCB8fCAhKCdkaWdlc3QnIGluIGVycikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZXJyLmRpZ2VzdCA9PT0gSEFOR0lOR19QUk9NSVNFX1JFSkVDVElPTjtcbn1cbmNvbnN0IEhBTkdJTkdfUFJPTUlTRV9SRUpFQ1RJT04gPSAnSEFOR0lOR19QUk9NSVNFX1JFSkVDVElPTic7XG5jbGFzcyBIYW5naW5nUHJvbWlzZVJlamVjdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGV4cHJlc3Npb24pe1xuICAgICAgICBzdXBlcihgRHVyaW5nIHByZXJlbmRlcmluZywgJHtleHByZXNzaW9ufSByZWplY3RzIHdoZW4gdGhlIHByZXJlbmRlciBpcyBjb21wbGV0ZS4gVHlwaWNhbGx5IHRoZXNlIGVycm9ycyBhcmUgaGFuZGxlZCBieSBSZWFjdCBidXQgaWYgeW91IG1vdmUgJHtleHByZXNzaW9ufSB0byBhIGRpZmZlcmVudCBjb250ZXh0IGJ5IHVzaW5nIFxcYHNldFRpbWVvdXRcXGAsIFxcYGFmdGVyXFxgLCBvciBzaW1pbGFyIGZ1bmN0aW9ucyB5b3UgbWF5IG9ic2VydmUgdGhpcyBlcnJvciBhbmQgeW91IHNob3VsZCBoYW5kbGUgaXQgaW4gdGhhdCBjb250ZXh0LmApLCB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uLCB0aGlzLmRpZ2VzdCA9IEhBTkdJTkdfUFJPTUlTRV9SRUpFQ1RJT047XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZUhhbmdpbmdQcm9taXNlKHNpZ25hbCwgZXhwcmVzc2lvbikge1xuICAgIGNvbnN0IGhhbmdpbmdQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCk9PntcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCk9PntcbiAgICAgICAgICAgIHJlamVjdChuZXcgSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvcihleHByZXNzaW9uKSk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gV2UgYXJlIGZpbmUgaWYgbm8gb25lIGFjdHVhbGx5IGF3YWl0cyB0aGlzIHByb21pc2UuIFdlIHNob3VsZG4ndCBjb25zaWRlciB0aGlzIGFuIHVuaGFuZGxlZCByZWplY3Rpb24gc29cbiAgICAvLyB3ZSBhdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgaGVyZSB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcuIElmIHlvdSBhY3R1YWxseSBhd2FpdCBzb21ld2hlcmUgb3IgY29uc3RydWN0XG4gICAgLy8geW91ciBvd24gcHJvbWlzZSBvdXQgb2YgaXQgeW91J2xsIG5lZWQgdG8gZW5zdXJlIHlvdSBoYW5kbGUgdGhlIGVycm9yIHdoZW4gaXQgcmVqZWN0cy5cbiAgICBoYW5naW5nUHJvbWlzZS5jYXRjaChpZ25vcmVSZWplY3QpO1xuICAgIHJldHVybiBoYW5naW5nUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGlnbm9yZVJlamVjdCgpIHt9XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWR5bmFtaWMtcmVuZGVyaW5nLXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/dynamic-rendering-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/lib/clone-response.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/server/lib/clone-response.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * Clones a response by teeing the body so we can return two independent\n * ReadableStreams from it. This avoids the bug in the undici library around\n * response cloning.\n *\n * After cloning, the original response's body will be consumed and closed.\n *\n * @see https://github.com/vercel/next.js/pull/73274\n *\n * @param original - The original response to clone.\n * @returns A tuple containing two independent clones of the original response.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"cloneResponse\", ({\n    enumerable: true,\n    get: function() {\n        return cloneResponse;\n    }\n}));\nfunction cloneResponse(original) {\n    // If the response has no body, then we can just return the original response\n    // twice because it's immutable.\n    if (!original.body) {\n        return [\n            original,\n            original\n        ];\n    }\n    const [body1, body2] = original.body.tee();\n    const cloned1 = new Response(body1, {\n        status: original.status,\n        statusText: original.statusText,\n        headers: original.headers\n    });\n    Object.defineProperty(cloned1, 'url', {\n        value: original.url\n    });\n    const cloned2 = new Response(body2, {\n        status: original.status,\n        statusText: original.statusText,\n        headers: original.headers\n    });\n    Object.defineProperty(cloned2, 'url', {\n        value: original.url\n    });\n    return [\n        cloned1,\n        cloned2\n    ];\n}\n\n//# sourceMappingURL=clone-response.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9saWIvY2xvbmUtcmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQWlCO0FBQ2pCLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGlEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxzZXJ2ZXJcXGxpYlxcY2xvbmUtcmVzcG9uc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDbG9uZXMgYSByZXNwb25zZSBieSB0ZWVpbmcgdGhlIGJvZHkgc28gd2UgY2FuIHJldHVybiB0d28gaW5kZXBlbmRlbnRcbiAqIFJlYWRhYmxlU3RyZWFtcyBmcm9tIGl0LiBUaGlzIGF2b2lkcyB0aGUgYnVnIGluIHRoZSB1bmRpY2kgbGlicmFyeSBhcm91bmRcbiAqIHJlc3BvbnNlIGNsb25pbmcuXG4gKlxuICogQWZ0ZXIgY2xvbmluZywgdGhlIG9yaWdpbmFsIHJlc3BvbnNlJ3MgYm9keSB3aWxsIGJlIGNvbnN1bWVkIGFuZCBjbG9zZWQuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvcHVsbC83MzI3NFxuICpcbiAqIEBwYXJhbSBvcmlnaW5hbCAtIFRoZSBvcmlnaW5hbCByZXNwb25zZSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIEEgdHVwbGUgY29udGFpbmluZyB0d28gaW5kZXBlbmRlbnQgY2xvbmVzIG9mIHRoZSBvcmlnaW5hbCByZXNwb25zZS5cbiAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lUmVzcG9uc2VcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lUmVzcG9uc2U7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBjbG9uZVJlc3BvbnNlKG9yaWdpbmFsKSB7XG4gICAgLy8gSWYgdGhlIHJlc3BvbnNlIGhhcyBubyBib2R5LCB0aGVuIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAgICAvLyB0d2ljZSBiZWNhdXNlIGl0J3MgaW1tdXRhYmxlLlxuICAgIGlmICghb3JpZ2luYWwuYm9keSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgb3JpZ2luYWwsXG4gICAgICAgICAgICBvcmlnaW5hbFxuICAgICAgICBdO1xuICAgIH1cbiAgICBjb25zdCBbYm9keTEsIGJvZHkyXSA9IG9yaWdpbmFsLmJvZHkudGVlKCk7XG4gICAgY29uc3QgY2xvbmVkMSA9IG5ldyBSZXNwb25zZShib2R5MSwge1xuICAgICAgICBzdGF0dXM6IG9yaWdpbmFsLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogb3JpZ2luYWwuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogb3JpZ2luYWwuaGVhZGVyc1xuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9uZWQxLCAndXJsJywge1xuICAgICAgICB2YWx1ZTogb3JpZ2luYWwudXJsXG4gICAgfSk7XG4gICAgY29uc3QgY2xvbmVkMiA9IG5ldyBSZXNwb25zZShib2R5Miwge1xuICAgICAgICBzdGF0dXM6IG9yaWdpbmFsLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogb3JpZ2luYWwuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogb3JpZ2luYWwuaGVhZGVyc1xuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9uZWQyLCAndXJsJywge1xuICAgICAgICB2YWx1ZTogb3JpZ2luYWwudXJsXG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY2xvbmVkMSxcbiAgICAgICAgY2xvbmVkMlxuICAgIF07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb25lLXJlc3BvbnNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/lib/clone-response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/lib/dedupe-fetch.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/server/lib/dedupe-fetch.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Based on https://github.com/facebook/react/blob/d4e78c42a94be027b4dc7ed2659a5fddfbf9bd4e/packages/react/src/ReactFetch.js\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createDedupeFetch\", ({\n    enumerable: true,\n    get: function() {\n        return createDedupeFetch;\n    }\n}));\nconst _react = /*#__PURE__*/ _interop_require_wildcard(__webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js\"));\nconst _cloneresponse = __webpack_require__(/*! ./clone-response */ \"(rsc)/./node_modules/next/dist/server/lib/clone-response.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(rsc)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst simpleCacheKey = '[\"GET\",[],null,\"follow\",null,null,null,null]' // generateCacheKey(new Request('https://blank'));\n;\nfunction generateCacheKey(request) {\n    // We pick the fields that goes into the key used to dedupe requests.\n    // We don't include the `cache` field, because we end up using whatever\n    // caching resulted from the first request.\n    // Notably we currently don't consider non-standard (or future) options.\n    // This might not be safe. TODO: warn for non-standard extensions differing.\n    // IF YOU CHANGE THIS UPDATE THE simpleCacheKey ABOVE.\n    return JSON.stringify([\n        request.method,\n        Array.from(request.headers.entries()),\n        request.mode,\n        request.redirect,\n        request.credentials,\n        request.referrer,\n        request.referrerPolicy,\n        request.integrity\n    ]);\n}\nfunction createDedupeFetch(originalFetch) {\n    const getCacheEntries = _react.cache(// eslint-disable-next-line @typescript-eslint/no-unused-vars -- url is the cache key\n    (url)=>[]);\n    return function dedupeFetch(resource, options) {\n        if (options && options.signal) {\n            // If we're passed a signal, then we assume that\n            // someone else controls the lifetime of this object and opts out of\n            // caching. It's effectively the opt-out mechanism.\n            // Ideally we should be able to check this on the Request but\n            // it always gets initialized with its own signal so we don't\n            // know if it's supposed to override - unless we also override the\n            // Request constructor.\n            return originalFetch(resource, options);\n        }\n        // Normalize the Request\n        let url;\n        let cacheKey;\n        if (typeof resource === 'string' && !options) {\n            // Fast path.\n            cacheKey = simpleCacheKey;\n            url = resource;\n        } else {\n            // Normalize the request.\n            // if resource is not a string or a URL (its an instance of Request)\n            // then do not instantiate a new Request but instead\n            // reuse the request as to not disturb the body in the event it's a ReadableStream.\n            const request = typeof resource === 'string' || resource instanceof URL ? new Request(resource, options) : resource;\n            if (request.method !== 'GET' && request.method !== 'HEAD' || request.keepalive) {\n                // We currently don't dedupe requests that might have side-effects. Those\n                // have to be explicitly cached. We assume that the request doesn't have a\n                // body if it's GET or HEAD.\n                // keepalive gets treated the same as if you passed a custom cache signal.\n                return originalFetch(resource, options);\n            }\n            cacheKey = generateCacheKey(request);\n            url = request.url;\n        }\n        const cacheEntries = getCacheEntries(url);\n        for(let i = 0, j = cacheEntries.length; i < j; i += 1){\n            const [key, promise] = cacheEntries[i];\n            if (key === cacheKey) {\n                return promise.then(()=>{\n                    const response = cacheEntries[i][2];\n                    if (!response) throw Object.defineProperty(new _invarianterror.InvariantError('No cached response'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E579\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                    // We're cloning the response using this utility because there exists\n                    // a bug in the undici library around response cloning. See the\n                    // following pull request for more details:\n                    // https://github.com/vercel/next.js/pull/73274\n                    const [cloned1, cloned2] = (0, _cloneresponse.cloneResponse)(response);\n                    cacheEntries[i][2] = cloned2;\n                    return cloned1;\n                });\n            }\n        }\n        // We pass the original arguments here in case normalizing the Request\n        // doesn't include all the options in this environment.\n        const promise = originalFetch(resource, options);\n        const entry = [\n            cacheKey,\n            promise,\n            null\n        ];\n        cacheEntries.push(entry);\n        return promise.then((response)=>{\n            // We're cloning the response using this utility because there exists\n            // a bug in the undici library around response cloning. See the\n            // following pull request for more details:\n            // https://github.com/vercel/next.js/pull/73274\n            const [cloned1, cloned2] = (0, _cloneresponse.cloneResponse)(response);\n            entry[2] = cloned2;\n            return cloned1;\n        });\n    };\n}\n\n//# sourceMappingURL=dedupe-fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9saWIvZGVkdXBlLWZldGNoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxJQUFpQjtBQUNqQiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixxREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRix1REFBdUQsbUJBQU8sQ0FBQyxpR0FBTztBQUN0RSx1QkFBdUIsbUJBQU8sQ0FBQyxxRkFBa0I7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsc0dBQWtDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxcbGliXFxkZWR1cGUtZmV0Y2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9kNGU3OGM0MmE5NGJlMDI3YjRkYzdlZDI2NTlhNWZkZGZiZjliZDRlL3BhY2thZ2VzL3JlYWN0L3NyYy9SZWFjdEZldGNoLmpzXG4gKi8gXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVEZWR1cGVGZXRjaFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRGVkdXBlRmV0Y2g7XG4gICAgfVxufSk7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9jbG9uZXJlc3BvbnNlID0gcmVxdWlyZShcIi4vY2xvbmUtcmVzcG9uc2VcIik7XG5jb25zdCBfaW52YXJpYW50ZXJyb3IgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3JcIik7XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHtcbiAgICBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7XG4gICAgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTtcbiAgICB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbihub2RlSW50ZXJvcCkge1xuICAgICAgICByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7XG4gICAgfSkobm9kZUludGVyb3ApO1xufVxuZnVuY3Rpb24gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7XG4gICAgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7XG4gICAgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQob2JqKTtcbiAgICB9XG4gICAgdmFyIG5ld09iaiA9IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsXG4gICAgfTtcbiAgICB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgZm9yKHZhciBrZXkgaW4gb2JqKXtcbiAgICAgICAgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdPYmouZGVmYXVsdCA9IG9iajtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld09iajtcbn1cbmNvbnN0IHNpbXBsZUNhY2hlS2V5ID0gJ1tcIkdFVFwiLFtdLG51bGwsXCJmb2xsb3dcIixudWxsLG51bGwsbnVsbCxudWxsXScgLy8gZ2VuZXJhdGVDYWNoZUtleShuZXcgUmVxdWVzdCgnaHR0cHM6Ly9ibGFuaycpKTtcbjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ2FjaGVLZXkocmVxdWVzdCkge1xuICAgIC8vIFdlIHBpY2sgdGhlIGZpZWxkcyB0aGF0IGdvZXMgaW50byB0aGUga2V5IHVzZWQgdG8gZGVkdXBlIHJlcXVlc3RzLlxuICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIGBjYWNoZWAgZmllbGQsIGJlY2F1c2Ugd2UgZW5kIHVwIHVzaW5nIHdoYXRldmVyXG4gICAgLy8gY2FjaGluZyByZXN1bHRlZCBmcm9tIHRoZSBmaXJzdCByZXF1ZXN0LlxuICAgIC8vIE5vdGFibHkgd2UgY3VycmVudGx5IGRvbid0IGNvbnNpZGVyIG5vbi1zdGFuZGFyZCAob3IgZnV0dXJlKSBvcHRpb25zLlxuICAgIC8vIFRoaXMgbWlnaHQgbm90IGJlIHNhZmUuIFRPRE86IHdhcm4gZm9yIG5vbi1zdGFuZGFyZCBleHRlbnNpb25zIGRpZmZlcmluZy5cbiAgICAvLyBJRiBZT1UgQ0hBTkdFIFRISVMgVVBEQVRFIFRIRSBzaW1wbGVDYWNoZUtleSBBQk9WRS5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgICByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgQXJyYXkuZnJvbShyZXF1ZXN0LmhlYWRlcnMuZW50cmllcygpKSxcbiAgICAgICAgcmVxdWVzdC5tb2RlLFxuICAgICAgICByZXF1ZXN0LnJlZGlyZWN0LFxuICAgICAgICByZXF1ZXN0LmNyZWRlbnRpYWxzLFxuICAgICAgICByZXF1ZXN0LnJlZmVycmVyLFxuICAgICAgICByZXF1ZXN0LnJlZmVycmVyUG9saWN5LFxuICAgICAgICByZXF1ZXN0LmludGVncml0eVxuICAgIF0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVkdXBlRmV0Y2gob3JpZ2luYWxGZXRjaCkge1xuICAgIGNvbnN0IGdldENhY2hlRW50cmllcyA9IF9yZWFjdC5jYWNoZSgvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzIC0tIHVybCBpcyB0aGUgY2FjaGUga2V5XG4gICAgKHVybCk9PltdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVkdXBlRmV0Y2gocmVzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHBhc3NlZCBhIHNpZ25hbCwgdGhlbiB3ZSBhc3N1bWUgdGhhdFxuICAgICAgICAgICAgLy8gc29tZW9uZSBlbHNlIGNvbnRyb2xzIHRoZSBsaWZldGltZSBvZiB0aGlzIG9iamVjdCBhbmQgb3B0cyBvdXQgb2ZcbiAgICAgICAgICAgIC8vIGNhY2hpbmcuIEl0J3MgZWZmZWN0aXZlbHkgdGhlIG9wdC1vdXQgbWVjaGFuaXNtLlxuICAgICAgICAgICAgLy8gSWRlYWxseSB3ZSBzaG91bGQgYmUgYWJsZSB0byBjaGVjayB0aGlzIG9uIHRoZSBSZXF1ZXN0IGJ1dFxuICAgICAgICAgICAgLy8gaXQgYWx3YXlzIGdldHMgaW5pdGlhbGl6ZWQgd2l0aCBpdHMgb3duIHNpZ25hbCBzbyB3ZSBkb24ndFxuICAgICAgICAgICAgLy8ga25vdyBpZiBpdCdzIHN1cHBvc2VkIHRvIG92ZXJyaWRlIC0gdW5sZXNzIHdlIGFsc28gb3ZlcnJpZGUgdGhlXG4gICAgICAgICAgICAvLyBSZXF1ZXN0IGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsRmV0Y2gocmVzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgUmVxdWVzdFxuICAgICAgICBsZXQgdXJsO1xuICAgICAgICBsZXQgY2FjaGVLZXk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnICYmICFvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGguXG4gICAgICAgICAgICBjYWNoZUtleSA9IHNpbXBsZUNhY2hlS2V5O1xuICAgICAgICAgICAgdXJsID0gcmVzb3VyY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHJlcXVlc3QuXG4gICAgICAgICAgICAvLyBpZiByZXNvdXJjZSBpcyBub3QgYSBzdHJpbmcgb3IgYSBVUkwgKGl0cyBhbiBpbnN0YW5jZSBvZiBSZXF1ZXN0KVxuICAgICAgICAgICAgLy8gdGhlbiBkbyBub3QgaW5zdGFudGlhdGUgYSBuZXcgUmVxdWVzdCBidXQgaW5zdGVhZFxuICAgICAgICAgICAgLy8gcmV1c2UgdGhlIHJlcXVlc3QgYXMgdG8gbm90IGRpc3R1cmIgdGhlIGJvZHkgaW4gdGhlIGV2ZW50IGl0J3MgYSBSZWFkYWJsZVN0cmVhbS5cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnIHx8IHJlc291cmNlIGluc3RhbmNlb2YgVVJMID8gbmV3IFJlcXVlc3QocmVzb3VyY2UsIG9wdGlvbnMpIDogcmVzb3VyY2U7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdHRVQnICYmIHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcgfHwgcmVxdWVzdC5rZWVwYWxpdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjdXJyZW50bHkgZG9uJ3QgZGVkdXBlIHJlcXVlc3RzIHRoYXQgbWlnaHQgaGF2ZSBzaWRlLWVmZmVjdHMuIFRob3NlXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBiZSBleHBsaWNpdGx5IGNhY2hlZC4gV2UgYXNzdW1lIHRoYXQgdGhlIHJlcXVlc3QgZG9lc24ndCBoYXZlIGFcbiAgICAgICAgICAgICAgICAvLyBib2R5IGlmIGl0J3MgR0VUIG9yIEhFQUQuXG4gICAgICAgICAgICAgICAgLy8ga2VlcGFsaXZlIGdldHMgdHJlYXRlZCB0aGUgc2FtZSBhcyBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNhY2hlIHNpZ25hbC5cbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGZXRjaChyZXNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWNoZUtleSA9IGdlbmVyYXRlQ2FjaGVLZXkocmVxdWVzdCk7XG4gICAgICAgICAgICB1cmwgPSByZXF1ZXN0LnVybDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZUVudHJpZXMgPSBnZXRDYWNoZUVudHJpZXModXJsKTtcbiAgICAgICAgZm9yKGxldCBpID0gMCwgaiA9IGNhY2hlRW50cmllcy5sZW5ndGg7IGkgPCBqOyBpICs9IDEpe1xuICAgICAgICAgICAgY29uc3QgW2tleSwgcHJvbWlzZV0gPSBjYWNoZUVudHJpZXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBjYWNoZUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBjYWNoZUVudHJpZXNbaV1bMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2UpIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgX2ludmFyaWFudGVycm9yLkludmFyaWFudEVycm9yKCdObyBjYWNoZWQgcmVzcG9uc2UnKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJFNTc5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgY2xvbmluZyB0aGUgcmVzcG9uc2UgdXNpbmcgdGhpcyB1dGlsaXR5IGJlY2F1c2UgdGhlcmUgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgYnVnIGluIHRoZSB1bmRpY2kgbGlicmFyeSBhcm91bmQgcmVzcG9uc2UgY2xvbmluZy4gU2VlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBmb2xsb3dpbmcgcHVsbCByZXF1ZXN0IGZvciBtb3JlIGRldGFpbHM6XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9wdWxsLzczMjc0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtjbG9uZWQxLCBjbG9uZWQyXSA9ICgwLCBfY2xvbmVyZXNwb25zZS5jbG9uZVJlc3BvbnNlKShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlRW50cmllc1tpXVsyXSA9IGNsb25lZDI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZWQxO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHBhc3MgdGhlIG9yaWdpbmFsIGFyZ3VtZW50cyBoZXJlIGluIGNhc2Ugbm9ybWFsaXppbmcgdGhlIFJlcXVlc3RcbiAgICAgICAgLy8gZG9lc24ndCBpbmNsdWRlIGFsbCB0aGUgb3B0aW9ucyBpbiB0aGlzIGVudmlyb25tZW50LlxuICAgICAgICBjb25zdCBwcm9taXNlID0gb3JpZ2luYWxGZXRjaChyZXNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gW1xuICAgICAgICAgICAgY2FjaGVLZXksXG4gICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICBdO1xuICAgICAgICBjYWNoZUVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKHJlc3BvbnNlKT0+e1xuICAgICAgICAgICAgLy8gV2UncmUgY2xvbmluZyB0aGUgcmVzcG9uc2UgdXNpbmcgdGhpcyB1dGlsaXR5IGJlY2F1c2UgdGhlcmUgZXhpc3RzXG4gICAgICAgICAgICAvLyBhIGJ1ZyBpbiB0aGUgdW5kaWNpIGxpYnJhcnkgYXJvdW5kIHJlc3BvbnNlIGNsb25pbmcuIFNlZSB0aGVcbiAgICAgICAgICAgIC8vIGZvbGxvd2luZyBwdWxsIHJlcXVlc3QgZm9yIG1vcmUgZGV0YWlsczpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9wdWxsLzczMjc0XG4gICAgICAgICAgICBjb25zdCBbY2xvbmVkMSwgY2xvbmVkMl0gPSAoMCwgX2Nsb25lcmVzcG9uc2UuY2xvbmVSZXNwb25zZSkocmVzcG9uc2UpO1xuICAgICAgICAgICAgZW50cnlbMl0gPSBjbG9uZWQyO1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lZDE7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZHVwZS1mZXRjaC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/lib/dedupe-fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/server/lib/patch-fetch.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    NEXT_PATCH_SYMBOL: function() {\n        return NEXT_PATCH_SYMBOL;\n    },\n    createPatchedFetcher: function() {\n        return createPatchedFetcher;\n    },\n    patchFetch: function() {\n        return patchFetch;\n    },\n    validateRevalidate: function() {\n        return validateRevalidate;\n    },\n    validateTags: function() {\n        return validateTags;\n    }\n});\nconst _constants = __webpack_require__(/*! ./trace/constants */ \"(rsc)/./node_modules/next/dist/server/lib/trace/constants.js\");\nconst _tracer = __webpack_require__(/*! ./trace/tracer */ \"(rsc)/./node_modules/next/dist/server/lib/trace/tracer.js\");\nconst _constants1 = __webpack_require__(/*! ../../lib/constants */ \"(rsc)/./node_modules/next/dist/lib/constants.js\");\nconst _dynamicrendering = __webpack_require__(/*! ../app-render/dynamic-rendering */ \"(rsc)/./node_modules/next/dist/server/app-render/dynamic-rendering.js\");\nconst _dynamicrenderingutils = __webpack_require__(/*! ../dynamic-rendering-utils */ \"(rsc)/./node_modules/next/dist/server/dynamic-rendering-utils.js\");\nconst _dedupefetch = __webpack_require__(/*! ./dedupe-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/dedupe-fetch.js\");\nconst _responsecache = __webpack_require__(/*! ../response-cache */ \"(rsc)/./node_modules/next/dist/server/response-cache/index.js\");\nconst _scheduler = __webpack_require__(/*! ../../lib/scheduler */ \"(rsc)/./node_modules/next/dist/lib/scheduler.js\");\nconst _cloneresponse = __webpack_require__(/*! ./clone-response */ \"(rsc)/./node_modules/next/dist/server/lib/clone-response.js\");\nconst isEdgeRuntime = \"nodejs\" === 'edge';\nconst NEXT_PATCH_SYMBOL = Symbol.for('next-patch');\nfunction isFetchPatched() {\n    return globalThis[NEXT_PATCH_SYMBOL] === true;\n}\nfunction validateRevalidate(revalidateVal, route) {\n    try {\n        let normalizedRevalidate = undefined;\n        if (revalidateVal === false) {\n            normalizedRevalidate = _constants1.INFINITE_CACHE;\n        } else if (typeof revalidateVal === 'number' && !isNaN(revalidateVal) && revalidateVal > -1) {\n            normalizedRevalidate = revalidateVal;\n        } else if (typeof revalidateVal !== 'undefined') {\n            throw Object.defineProperty(new Error(`Invalid revalidate value \"${revalidateVal}\" on \"${route}\", must be a non-negative number or false`), \"__NEXT_ERROR_CODE\", {\n                value: \"E179\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        return normalizedRevalidate;\n    } catch (err) {\n        // handle client component error from attempting to check revalidate value\n        if (err instanceof Error && err.message.includes('Invalid revalidate')) {\n            throw err;\n        }\n        return undefined;\n    }\n}\nfunction validateTags(tags, description) {\n    const validTags = [];\n    const invalidTags = [];\n    for(let i = 0; i < tags.length; i++){\n        const tag = tags[i];\n        if (typeof tag !== 'string') {\n            invalidTags.push({\n                tag,\n                reason: 'invalid type, must be a string'\n            });\n        } else if (tag.length > _constants1.NEXT_CACHE_TAG_MAX_LENGTH) {\n            invalidTags.push({\n                tag,\n                reason: `exceeded max length of ${_constants1.NEXT_CACHE_TAG_MAX_LENGTH}`\n            });\n        } else {\n            validTags.push(tag);\n        }\n        if (validTags.length > _constants1.NEXT_CACHE_TAG_MAX_ITEMS) {\n            console.warn(`Warning: exceeded max tag count for ${description}, dropped tags:`, tags.slice(i).join(', '));\n            break;\n        }\n    }\n    if (invalidTags.length > 0) {\n        console.warn(`Warning: invalid tags passed to ${description}: `);\n        for (const { tag, reason } of invalidTags){\n            console.log(`tag: \"${tag}\" ${reason}`);\n        }\n    }\n    return validTags;\n}\nfunction trackFetchMetric(workStore, ctx) {\n    var _workStore_requestEndedState;\n    // If the static generation store is not available, we can't track the fetch\n    if (!workStore) return;\n    if ((_workStore_requestEndedState = workStore.requestEndedState) == null ? void 0 : _workStore_requestEndedState.ended) return;\n    const isDebugBuild = (!!process.env.NEXT_DEBUG_BUILD || process.env.NEXT_SSG_FETCH_METRICS === '1') && workStore.isStaticGeneration;\n    const isDevelopment = \"development\" === 'development';\n    if (// The only time we want to track fetch metrics outside of development is when\n    // we are performing a static generation & we are in debug mode.\n    !isDebugBuild && !isDevelopment) {\n        return;\n    }\n    workStore.fetchMetrics ??= [];\n    workStore.fetchMetrics.push({\n        ...ctx,\n        end: performance.timeOrigin + performance.now(),\n        idx: workStore.nextFetchId || 0\n    });\n}\nfunction createPatchedFetcher(originFetch, { workAsyncStorage, workUnitAsyncStorage }) {\n    // Create the patched fetch function. We don't set the type here, as it's\n    // verified as the return value of this function.\n    const patched = async (input, init)=>{\n        var _init_method, _init_next;\n        let url;\n        try {\n            url = new URL(input instanceof Request ? input.url : input);\n            url.username = '';\n            url.password = '';\n        } catch  {\n            // Error caused by malformed URL should be handled by native fetch\n            url = undefined;\n        }\n        const fetchUrl = (url == null ? void 0 : url.href) ?? '';\n        const method = (init == null ? void 0 : (_init_method = init.method) == null ? void 0 : _init_method.toUpperCase()) || 'GET';\n        // Do create a new span trace for internal fetches in the\n        // non-verbose mode.\n        const isInternal = (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next.internal) === true;\n        const hideSpan = process.env.NEXT_OTEL_FETCH_DISABLED === '1';\n        // We don't track fetch metrics for internal fetches\n        // so it's not critical that we have a start time, as it won't be recorded.\n        // This is to workaround a flaky issue where performance APIs might\n        // not be available and will require follow-up investigation.\n        const fetchStart = isInternal ? undefined : performance.timeOrigin + performance.now();\n        const workStore = workAsyncStorage.getStore();\n        const workUnitStore = workUnitAsyncStorage.getStore();\n        // During static generation we track cache reads so we can reason about when they fill\n        let cacheSignal = workUnitStore && workUnitStore.type === 'prerender' ? workUnitStore.cacheSignal : null;\n        if (cacheSignal) {\n            cacheSignal.beginRead();\n        }\n        const result = (0, _tracer.getTracer)().trace(isInternal ? _constants.NextNodeServerSpan.internalFetch : _constants.AppRenderSpan.fetch, {\n            hideSpan,\n            kind: _tracer.SpanKind.CLIENT,\n            spanName: [\n                'fetch',\n                method,\n                fetchUrl\n            ].filter(Boolean).join(' '),\n            attributes: {\n                'http.url': fetchUrl,\n                'http.method': method,\n                'net.peer.name': url == null ? void 0 : url.hostname,\n                'net.peer.port': (url == null ? void 0 : url.port) || undefined\n            }\n        }, async ()=>{\n            var _getRequestMeta;\n            // If this is an internal fetch, we should not do any special treatment.\n            if (isInternal) {\n                return originFetch(input, init);\n            }\n            // If the workStore is not available, we can't do any\n            // special treatment of fetch, therefore fallback to the original\n            // fetch implementation.\n            if (!workStore) {\n                return originFetch(input, init);\n            }\n            // We should also fallback to the original fetch implementation if we\n            // are in draft mode, it does not constitute a static generation.\n            if (workStore.isDraftMode) {\n                return originFetch(input, init);\n            }\n            const isRequestInput = input && typeof input === 'object' && typeof input.method === 'string';\n            const getRequestMeta = (field)=>{\n                // If request input is present but init is not, retrieve from input first.\n                const value = init == null ? void 0 : init[field];\n                return value || (isRequestInput ? input[field] : null);\n            };\n            let finalRevalidate = undefined;\n            const getNextField = (field)=>{\n                var _init_next, _init_next1, _input_next;\n                return typeof (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next[field]) !== 'undefined' ? init == null ? void 0 : (_init_next1 = init.next) == null ? void 0 : _init_next1[field] : isRequestInput ? (_input_next = input.next) == null ? void 0 : _input_next[field] : undefined;\n            };\n            // RequestInit doesn't keep extra fields e.g. next so it's\n            // only available if init is used separate\n            let currentFetchRevalidate = getNextField('revalidate');\n            const tags = validateTags(getNextField('tags') || [], `fetch ${input.toString()}`);\n            const revalidateStore = workUnitStore && (workUnitStore.type === 'cache' || workUnitStore.type === 'prerender' || workUnitStore.type === 'prerender-ppr' || workUnitStore.type === 'prerender-legacy') ? workUnitStore : undefined;\n            if (revalidateStore) {\n                if (Array.isArray(tags)) {\n                    // Collect tags onto parent caches or parent prerenders.\n                    const collectedTags = revalidateStore.tags ?? (revalidateStore.tags = []);\n                    for (const tag of tags){\n                        if (!collectedTags.includes(tag)) {\n                            collectedTags.push(tag);\n                        }\n                    }\n                }\n            }\n            const implicitTags = !workUnitStore || workUnitStore.type === 'unstable-cache' ? [] : workUnitStore.implicitTags;\n            // Inside unstable-cache we treat it the same as force-no-store on the\n            // page.\n            const pageFetchCacheMode = workUnitStore && workUnitStore.type === 'unstable-cache' ? 'force-no-store' : workStore.fetchCache;\n            const isUsingNoStore = !!workStore.isUnstableNoStore;\n            let currentFetchCacheConfig = getRequestMeta('cache');\n            let cacheReason = '';\n            let cacheWarning;\n            if (typeof currentFetchCacheConfig === 'string' && typeof currentFetchRevalidate !== 'undefined') {\n                // If the revalidate value conflicts with the cache value, we should warn the user and unset the conflicting values.\n                const isConflictingRevalidate = // revalidate: 0 and cache: force-cache\n                currentFetchCacheConfig === 'force-cache' && currentFetchRevalidate === 0 || // revalidate: >0 or revalidate: false and cache: no-store\n                currentFetchCacheConfig === 'no-store' && (currentFetchRevalidate > 0 || currentFetchRevalidate === false);\n                if (isConflictingRevalidate) {\n                    cacheWarning = `Specified \"cache: ${currentFetchCacheConfig}\" and \"revalidate: ${currentFetchRevalidate}\", only one should be specified.`;\n                    currentFetchCacheConfig = undefined;\n                    currentFetchRevalidate = undefined;\n                }\n            }\n            const hasExplicitFetchCacheOptOut = // fetch config itself signals not to cache\n            currentFetchCacheConfig === 'no-cache' || currentFetchCacheConfig === 'no-store' || // the fetch isn't explicitly caching and the segment level cache config signals not to cache\n            // note: `pageFetchCacheMode` is also set by being in an unstable_cache context.\n            pageFetchCacheMode === 'force-no-store' || pageFetchCacheMode === 'only-no-store';\n            // If no explicit fetch cache mode is set, but dynamic = `force-dynamic` is set,\n            // we shouldn't consider caching the fetch. This is because the `dynamic` cache\n            // is considered a \"top-level\" cache mode, whereas something like `fetchCache` is more\n            // fine-grained. Top-level modes are responsible for setting reasonable defaults for the\n            // other configurations.\n            const noFetchConfigAndForceDynamic = !pageFetchCacheMode && !currentFetchCacheConfig && !currentFetchRevalidate && workStore.forceDynamic;\n            if (// force-cache was specified without a revalidate value. We set the revalidate value to false\n            // which will signal the cache to not revalidate\n            currentFetchCacheConfig === 'force-cache' && typeof currentFetchRevalidate === 'undefined') {\n                currentFetchRevalidate = false;\n            } else if (// if we are inside of \"use cache\"/\"unstable_cache\"\n            // we shouldn't set the revalidate to 0 as it's overridden\n            // by the cache context\n            (workUnitStore == null ? void 0 : workUnitStore.type) !== 'cache' && (hasExplicitFetchCacheOptOut || noFetchConfigAndForceDynamic)) {\n                currentFetchRevalidate = 0;\n            }\n            if (currentFetchCacheConfig === 'no-cache' || currentFetchCacheConfig === 'no-store') {\n                cacheReason = `cache: ${currentFetchCacheConfig}`;\n            }\n            finalRevalidate = validateRevalidate(currentFetchRevalidate, workStore.route);\n            const _headers = getRequestMeta('headers');\n            const initHeaders = typeof (_headers == null ? void 0 : _headers.get) === 'function' ? _headers : new Headers(_headers || {});\n            const hasUnCacheableHeader = initHeaders.get('authorization') || initHeaders.get('cookie');\n            const isUnCacheableMethod = ![\n                'get',\n                'head'\n            ].includes(((_getRequestMeta = getRequestMeta('method')) == null ? void 0 : _getRequestMeta.toLowerCase()) || 'get');\n            /**\n         * We automatically disable fetch caching under the following conditions:\n         * - Fetch cache configs are not set. Specifically:\n         *    - A page fetch cache mode is not set (export const fetchCache=...)\n         *    - A fetch cache mode is not set in the fetch call (fetch(url, { cache: ... }))\n         *      or the fetch cache mode is set to 'default'\n         *    - A fetch revalidate value is not set in the fetch call (fetch(url, { revalidate: ... }))\n         * - OR the fetch comes after a configuration that triggered dynamic rendering (e.g., reading cookies())\n         *   and the fetch was considered uncacheable (e.g., POST method or has authorization headers)\n         */ const hasNoExplicitCacheConfig = // eslint-disable-next-line eqeqeq\n            pageFetchCacheMode == undefined && // eslint-disable-next-line eqeqeq\n            (currentFetchCacheConfig == undefined || // when considering whether to opt into the default \"no-cache\" fetch semantics,\n            // a \"default\" cache config should be treated the same as no cache config\n            currentFetchCacheConfig === 'default') && // eslint-disable-next-line eqeqeq\n            currentFetchRevalidate == undefined;\n            const autoNoCache = // this condition is hit for null/undefined\n            // eslint-disable-next-line eqeqeq\n            hasNoExplicitCacheConfig && // we disable automatic no caching behavior during build time SSG so that we can still\n            // leverage the fetch cache between SSG workers\n            !workStore.isPrerendering || (hasUnCacheableHeader || isUnCacheableMethod) && revalidateStore && revalidateStore.revalidate === 0;\n            if (hasNoExplicitCacheConfig && workUnitStore !== undefined && workUnitStore.type === 'prerender') {\n                // If we have no cache config, and we're in Dynamic I/O prerendering, it'll be a dynamic call.\n                // We don't have to issue that dynamic call.\n                if (cacheSignal) {\n                    cacheSignal.endRead();\n                    cacheSignal = null;\n                }\n                return (0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, 'fetch()');\n            }\n            switch(pageFetchCacheMode){\n                case 'force-no-store':\n                    {\n                        cacheReason = 'fetchCache = force-no-store';\n                        break;\n                    }\n                case 'only-no-store':\n                    {\n                        if (currentFetchCacheConfig === 'force-cache' || typeof finalRevalidate !== 'undefined' && finalRevalidate > 0) {\n                            throw Object.defineProperty(new Error(`cache: 'force-cache' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-no-store'`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E448\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                        cacheReason = 'fetchCache = only-no-store';\n                        break;\n                    }\n                case 'only-cache':\n                    {\n                        if (currentFetchCacheConfig === 'no-store') {\n                            throw Object.defineProperty(new Error(`cache: 'no-store' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-cache'`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E521\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                        break;\n                    }\n                case 'force-cache':\n                    {\n                        if (typeof currentFetchRevalidate === 'undefined' || currentFetchRevalidate === 0) {\n                            cacheReason = 'fetchCache = force-cache';\n                            finalRevalidate = _constants1.INFINITE_CACHE;\n                        }\n                        break;\n                    }\n                default:\n            }\n            if (typeof finalRevalidate === 'undefined') {\n                if (pageFetchCacheMode === 'default-cache' && !isUsingNoStore) {\n                    finalRevalidate = _constants1.INFINITE_CACHE;\n                    cacheReason = 'fetchCache = default-cache';\n                } else if (pageFetchCacheMode === 'default-no-store') {\n                    finalRevalidate = 0;\n                    cacheReason = 'fetchCache = default-no-store';\n                } else if (isUsingNoStore) {\n                    finalRevalidate = 0;\n                    cacheReason = 'noStore call';\n                } else if (autoNoCache) {\n                    finalRevalidate = 0;\n                    cacheReason = 'auto no cache';\n                } else {\n                    // TODO: should we consider this case an invariant?\n                    cacheReason = 'auto cache';\n                    finalRevalidate = revalidateStore ? revalidateStore.revalidate : _constants1.INFINITE_CACHE;\n                }\n            } else if (!cacheReason) {\n                cacheReason = `revalidate: ${finalRevalidate}`;\n            }\n            if (// when force static is configured we don't bail from\n            // `revalidate: 0` values\n            !(workStore.forceStatic && finalRevalidate === 0) && // we don't consider autoNoCache to switch to dynamic for ISR\n            !autoNoCache && // If the revalidate value isn't currently set or the value is less\n            // than the current revalidate value, we should update the revalidate\n            // value.\n            revalidateStore && finalRevalidate < revalidateStore.revalidate) {\n                // If we were setting the revalidate value to 0, we should try to\n                // postpone instead first.\n                if (finalRevalidate === 0) {\n                    if (workUnitStore && workUnitStore.type === 'prerender') {\n                        if (cacheSignal) {\n                            cacheSignal.endRead();\n                            cacheSignal = null;\n                        }\n                        return (0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, 'fetch()');\n                    } else {\n                        (0, _dynamicrendering.markCurrentScopeAsDynamic)(workStore, workUnitStore, `revalidate: 0 fetch ${input} ${workStore.route}`);\n                    }\n                }\n                // We only want to set the revalidate store's revalidate time if it\n                // was explicitly set for the fetch call, i.e. currentFetchRevalidate.\n                if (revalidateStore && currentFetchRevalidate === finalRevalidate) {\n                    revalidateStore.revalidate = finalRevalidate;\n                }\n            }\n            const isCacheableRevalidate = typeof finalRevalidate === 'number' && finalRevalidate > 0;\n            let cacheKey;\n            const { incrementalCache } = workStore;\n            const useCacheOrRequestStore = (workUnitStore == null ? void 0 : workUnitStore.type) === 'request' || (workUnitStore == null ? void 0 : workUnitStore.type) === 'cache' ? workUnitStore : undefined;\n            if (incrementalCache && (isCacheableRevalidate || (useCacheOrRequestStore == null ? void 0 : useCacheOrRequestStore.serverComponentsHmrCache))) {\n                try {\n                    cacheKey = await incrementalCache.generateCacheKey(fetchUrl, isRequestInput ? input : init);\n                } catch (err) {\n                    console.error(`Failed to generate cache key for`, input);\n                }\n            }\n            const fetchIdx = workStore.nextFetchId ?? 1;\n            workStore.nextFetchId = fetchIdx + 1;\n            let handleUnlock = ()=>Promise.resolve();\n            const doOriginalFetch = async (isStale, cacheReasonOverride)=>{\n                const requestInputFields = [\n                    'cache',\n                    'credentials',\n                    'headers',\n                    'integrity',\n                    'keepalive',\n                    'method',\n                    'mode',\n                    'redirect',\n                    'referrer',\n                    'referrerPolicy',\n                    'window',\n                    'duplex',\n                    // don't pass through signal when revalidating\n                    ...isStale ? [] : [\n                        'signal'\n                    ]\n                ];\n                if (isRequestInput) {\n                    const reqInput = input;\n                    const reqOptions = {\n                        body: reqInput._ogBody || reqInput.body\n                    };\n                    for (const field of requestInputFields){\n                        // @ts-expect-error custom fields\n                        reqOptions[field] = reqInput[field];\n                    }\n                    input = new Request(reqInput.url, reqOptions);\n                } else if (init) {\n                    const { _ogBody, body, signal, ...otherInput } = init;\n                    init = {\n                        ...otherInput,\n                        body: _ogBody || body,\n                        signal: isStale ? undefined : signal\n                    };\n                }\n                // add metadata to init without editing the original\n                const clonedInit = {\n                    ...init,\n                    next: {\n                        ...init == null ? void 0 : init.next,\n                        fetchType: 'origin',\n                        fetchIdx\n                    }\n                };\n                return originFetch(input, clonedInit).then(async (res)=>{\n                    if (!isStale && fetchStart) {\n                        trackFetchMetric(workStore, {\n                            start: fetchStart,\n                            url: fetchUrl,\n                            cacheReason: cacheReasonOverride || cacheReason,\n                            cacheStatus: finalRevalidate === 0 || cacheReasonOverride ? 'skip' : 'miss',\n                            cacheWarning,\n                            status: res.status,\n                            method: clonedInit.method || 'GET'\n                        });\n                    }\n                    if (res.status === 200 && incrementalCache && cacheKey && (isCacheableRevalidate || (useCacheOrRequestStore == null ? void 0 : useCacheOrRequestStore.serverComponentsHmrCache))) {\n                        const normalizedRevalidate = finalRevalidate >= _constants1.INFINITE_CACHE ? _constants1.CACHE_ONE_YEAR : finalRevalidate;\n                        if (workUnitStore && workUnitStore.type === 'prerender') {\n                            // We are prerendering at build time or revalidate time with dynamicIO so we need to\n                            // buffer the response so we can guarantee it can be read in a microtask\n                            const bodyBuffer = await res.arrayBuffer();\n                            const fetchedData = {\n                                headers: Object.fromEntries(res.headers.entries()),\n                                body: Buffer.from(bodyBuffer).toString('base64'),\n                                status: res.status,\n                                url: res.url\n                            };\n                            // We can skip checking the serverComponentsHmrCache because we aren't in\n                            // dev mode.\n                            await incrementalCache.set(cacheKey, {\n                                kind: _responsecache.CachedRouteKind.FETCH,\n                                data: fetchedData,\n                                revalidate: normalizedRevalidate\n                            }, {\n                                fetchCache: true,\n                                fetchUrl,\n                                fetchIdx,\n                                tags\n                            });\n                            await handleUnlock();\n                            // We return a new Response to the caller.\n                            return new Response(bodyBuffer, {\n                                headers: res.headers,\n                                status: res.status,\n                                statusText: res.statusText\n                            });\n                        } else {\n                            // We're cloning the response using this utility because there\n                            // exists a bug in the undici library around response cloning.\n                            // See the following pull request for more details:\n                            // https://github.com/vercel/next.js/pull/73274\n                            const [cloned1, cloned2] = (0, _cloneresponse.cloneResponse)(res);\n                            // We are dynamically rendering including dev mode. We want to return\n                            // the response to the caller as soon as possible because it might stream\n                            // over a very long time.\n                            cloned1.arrayBuffer().then(async (arrayBuffer)=>{\n                                var _useCacheOrRequestStore_serverComponentsHmrCache;\n                                const bodyBuffer = Buffer.from(arrayBuffer);\n                                const fetchedData = {\n                                    headers: Object.fromEntries(cloned1.headers.entries()),\n                                    body: bodyBuffer.toString('base64'),\n                                    status: cloned1.status,\n                                    url: cloned1.url\n                                };\n                                useCacheOrRequestStore == null ? void 0 : (_useCacheOrRequestStore_serverComponentsHmrCache = useCacheOrRequestStore.serverComponentsHmrCache) == null ? void 0 : _useCacheOrRequestStore_serverComponentsHmrCache.set(cacheKey, fetchedData);\n                                if (isCacheableRevalidate) {\n                                    await incrementalCache.set(cacheKey, {\n                                        kind: _responsecache.CachedRouteKind.FETCH,\n                                        data: fetchedData,\n                                        revalidate: normalizedRevalidate\n                                    }, {\n                                        fetchCache: true,\n                                        fetchUrl,\n                                        fetchIdx,\n                                        tags\n                                    });\n                                }\n                            }).catch((error)=>console.warn(`Failed to set fetch cache`, input, error)).finally(handleUnlock);\n                            return cloned2;\n                        }\n                    }\n                    // we had response that we determined shouldn't be cached so we return it\n                    // and don't cache it. This also needs to unlock the cache lock we acquired.\n                    await handleUnlock();\n                    return res;\n                }).catch((error)=>{\n                    handleUnlock();\n                    throw error;\n                });\n            };\n            let cacheReasonOverride;\n            let isForegroundRevalidate = false;\n            let isHmrRefreshCache = false;\n            if (cacheKey && incrementalCache) {\n                let cachedFetchData;\n                if ((useCacheOrRequestStore == null ? void 0 : useCacheOrRequestStore.isHmrRefresh) && useCacheOrRequestStore.serverComponentsHmrCache) {\n                    cachedFetchData = useCacheOrRequestStore.serverComponentsHmrCache.get(cacheKey);\n                    isHmrRefreshCache = true;\n                }\n                if (isCacheableRevalidate && !cachedFetchData) {\n                    handleUnlock = await incrementalCache.lock(cacheKey);\n                    const entry = workStore.isOnDemandRevalidate ? null : await incrementalCache.get(cacheKey, {\n                        kind: _responsecache.IncrementalCacheKind.FETCH,\n                        revalidate: finalRevalidate,\n                        fetchUrl,\n                        fetchIdx,\n                        tags,\n                        softTags: implicitTags\n                    });\n                    if (hasNoExplicitCacheConfig) {\n                        // We sometimes use the cache to dedupe fetches that do not specify a cache configuration\n                        // In these cases we want to make sure we still exclude them from prerenders if dynamicIO is on\n                        // so we introduce an artificial Task boundary here.\n                        if (workUnitStore && workUnitStore.type === 'prerender') {\n                            await (0, _scheduler.waitAtLeastOneReactRenderTask)();\n                        }\n                    }\n                    if (entry) {\n                        await handleUnlock();\n                    } else {\n                        // in dev, incremental cache response will be null in case the browser adds `cache-control: no-cache` in the request headers\n                        cacheReasonOverride = 'cache-control: no-cache (hard refresh)';\n                    }\n                    if ((entry == null ? void 0 : entry.value) && entry.value.kind === _responsecache.CachedRouteKind.FETCH) {\n                        // when stale and is revalidating we wait for fresh data\n                        // so the revalidated entry has the updated data\n                        if (workStore.isRevalidate && entry.isStale) {\n                            isForegroundRevalidate = true;\n                        } else {\n                            if (entry.isStale) {\n                                workStore.pendingRevalidates ??= {};\n                                if (!workStore.pendingRevalidates[cacheKey]) {\n                                    const pendingRevalidate = doOriginalFetch(true).then(async (response)=>({\n                                            body: await response.arrayBuffer(),\n                                            headers: response.headers,\n                                            status: response.status,\n                                            statusText: response.statusText\n                                        })).finally(()=>{\n                                        workStore.pendingRevalidates ??= {};\n                                        delete workStore.pendingRevalidates[cacheKey || ''];\n                                    });\n                                    // Attach the empty catch here so we don't get a \"unhandled\n                                    // promise rejection\" warning.\n                                    pendingRevalidate.catch(console.error);\n                                    workStore.pendingRevalidates[cacheKey] = pendingRevalidate;\n                                }\n                            }\n                            cachedFetchData = entry.value.data;\n                        }\n                    }\n                }\n                if (cachedFetchData) {\n                    if (fetchStart) {\n                        trackFetchMetric(workStore, {\n                            start: fetchStart,\n                            url: fetchUrl,\n                            cacheReason,\n                            cacheStatus: isHmrRefreshCache ? 'hmr' : 'hit',\n                            cacheWarning,\n                            status: cachedFetchData.status || 200,\n                            method: (init == null ? void 0 : init.method) || 'GET'\n                        });\n                    }\n                    const response = new Response(Buffer.from(cachedFetchData.body, 'base64'), {\n                        headers: cachedFetchData.headers,\n                        status: cachedFetchData.status\n                    });\n                    Object.defineProperty(response, 'url', {\n                        value: cachedFetchData.url\n                    });\n                    return response;\n                }\n            }\n            if (workStore.isStaticGeneration && init && typeof init === 'object') {\n                const { cache } = init;\n                // Delete `cache` property as Cloudflare Workers will throw an error\n                if (isEdgeRuntime) delete init.cache;\n                if (cache === 'no-store') {\n                    // If enabled, we should bail out of static generation.\n                    if (workUnitStore && workUnitStore.type === 'prerender') {\n                        if (cacheSignal) {\n                            cacheSignal.endRead();\n                            cacheSignal = null;\n                        }\n                        return (0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, 'fetch()');\n                    } else {\n                        (0, _dynamicrendering.markCurrentScopeAsDynamic)(workStore, workUnitStore, `no-store fetch ${input} ${workStore.route}`);\n                    }\n                }\n                const hasNextConfig = 'next' in init;\n                const { next = {} } = init;\n                if (typeof next.revalidate === 'number' && revalidateStore && next.revalidate < revalidateStore.revalidate) {\n                    if (next.revalidate === 0) {\n                        // If enabled, we should bail out of static generation.\n                        if (workUnitStore && workUnitStore.type === 'prerender') {\n                            return (0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, 'fetch()');\n                        } else {\n                            (0, _dynamicrendering.markCurrentScopeAsDynamic)(workStore, workUnitStore, `revalidate: 0 fetch ${input} ${workStore.route}`);\n                        }\n                    }\n                    if (!workStore.forceStatic || next.revalidate !== 0) {\n                        revalidateStore.revalidate = next.revalidate;\n                    }\n                }\n                if (hasNextConfig) delete init.next;\n            }\n            // if we are revalidating the whole page via time or on-demand and\n            // the fetch cache entry is stale we should still de-dupe the\n            // origin hit if it's a cache-able entry\n            if (cacheKey && isForegroundRevalidate) {\n                const pendingRevalidateKey = cacheKey;\n                workStore.pendingRevalidates ??= {};\n                let pendingRevalidate = workStore.pendingRevalidates[pendingRevalidateKey];\n                if (pendingRevalidate) {\n                    const revalidatedResult = await pendingRevalidate;\n                    return new Response(revalidatedResult.body, {\n                        headers: revalidatedResult.headers,\n                        status: revalidatedResult.status,\n                        statusText: revalidatedResult.statusText\n                    });\n                }\n                // We used to just resolve the Response and clone it however for\n                // static generation with dynamicIO we need the response to be able to\n                // be resolved in a microtask and cloning the response will never have\n                // a body that can resolve in a microtask in node (as observed through\n                // experimentation) So instead we await the body and then when it is\n                // available we construct manually cloned Response objects with the\n                // body as an ArrayBuffer. This will be resolvable in a microtask\n                // making it compatible with dynamicIO.\n                const pendingResponse = doOriginalFetch(true, cacheReasonOverride)// We're cloning the response using this utility because there\n                // exists a bug in the undici library around response cloning.\n                // See the following pull request for more details:\n                // https://github.com/vercel/next.js/pull/73274\n                .then(_cloneresponse.cloneResponse);\n                pendingRevalidate = pendingResponse.then(async (responses)=>{\n                    const response = responses[0];\n                    return {\n                        body: await response.arrayBuffer(),\n                        headers: response.headers,\n                        status: response.status,\n                        statusText: response.statusText\n                    };\n                }).finally(()=>{\n                    var _workStore_pendingRevalidates;\n                    // If the pending revalidate is not present in the store, then\n                    // we have nothing to delete.\n                    if (!((_workStore_pendingRevalidates = workStore.pendingRevalidates) == null ? void 0 : _workStore_pendingRevalidates[pendingRevalidateKey])) {\n                        return;\n                    }\n                    delete workStore.pendingRevalidates[pendingRevalidateKey];\n                });\n                // Attach the empty catch here so we don't get a \"unhandled promise\n                // rejection\" warning\n                pendingRevalidate.catch(()=>{});\n                workStore.pendingRevalidates[pendingRevalidateKey] = pendingRevalidate;\n                return pendingResponse.then((responses)=>responses[1]);\n            } else {\n                return doOriginalFetch(false, cacheReasonOverride);\n            }\n        });\n        if (cacheSignal) {\n            try {\n                return await result;\n            } finally{\n                if (cacheSignal) {\n                    cacheSignal.endRead();\n                }\n            }\n        }\n        return result;\n    };\n    // Attach the necessary properties to the patched fetch function.\n    // We don't use this to determine if the fetch function has been patched,\n    // but for external consumers to determine if the fetch function has been\n    // patched.\n    patched.__nextPatched = true;\n    patched.__nextGetStaticStore = ()=>workAsyncStorage;\n    patched._nextOriginalFetch = originFetch;\n    globalThis[NEXT_PATCH_SYMBOL] = true;\n    return patched;\n}\nfunction patchFetch(options) {\n    // If we've already patched fetch, we should not patch it again.\n    if (isFetchPatched()) return;\n    // Grab the original fetch function. We'll attach this so we can use it in\n    // the patched fetch function.\n    const original = (0, _dedupefetch.createDedupeFetch)(globalThis.fetch);\n    // Set the global fetch to the patched fetch.\n    globalThis.fetch = createPatchedFetcher(original, options);\n}\n\n//# sourceMappingURL=patch-fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixNQUFNLENBTUw7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsdUZBQW1CO0FBQzlDLGdCQUFnQixtQkFBTyxDQUFDLGlGQUFnQjtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBcUI7QUFDakQsMEJBQTBCLG1CQUFPLENBQUMsOEdBQWlDO0FBQ25FLCtCQUErQixtQkFBTyxDQUFDLG9HQUE0QjtBQUNuRSxxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBZ0I7QUFDN0MsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQW1CO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLDRFQUFxQjtBQUNoRCx1QkFBdUIsbUJBQU8sQ0FBQyxxRkFBa0I7QUFDakQsc0JBQXNCLFFBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDViwrRUFBK0UsY0FBYyxRQUFRLE1BQU07QUFDM0c7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxrREFBa0Qsc0NBQXNDO0FBQ3hGLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFlBQVk7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsWUFBWTtBQUNwRSxxQkFBcUIsY0FBYztBQUNuQyxpQ0FBaUMsSUFBSSxJQUFJLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2Q0FBNkMsd0NBQXdDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxpQkFBaUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx3QkFBd0IscUJBQXFCLHVCQUF1QjtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdCQUF3QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0k7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLFlBQVk7QUFDMUY7QUFDQSxvRkFBb0YsaUJBQWlCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLFVBQVU7QUFDdEg7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLFVBQVU7QUFDbkg7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDBIQUEwSCxPQUFPLEVBQUUsZ0JBQWdCO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLDRCQUE0Qix1Q0FBdUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIscUhBQXFILE9BQU8sRUFBRSxnQkFBZ0I7QUFDOUk7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiw4SEFBOEgsT0FBTyxFQUFFLGdCQUFnQjtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxzZXJ2ZXJcXGxpYlxccGF0Y2gtZmV0Y2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBORVhUX1BBVENIX1NZTUJPTDogbnVsbCxcbiAgICBjcmVhdGVQYXRjaGVkRmV0Y2hlcjogbnVsbCxcbiAgICBwYXRjaEZldGNoOiBudWxsLFxuICAgIHZhbGlkYXRlUmV2YWxpZGF0ZTogbnVsbCxcbiAgICB2YWxpZGF0ZVRhZ3M6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgTkVYVF9QQVRDSF9TWU1CT0w6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9QQVRDSF9TWU1CT0w7XG4gICAgfSxcbiAgICBjcmVhdGVQYXRjaGVkRmV0Y2hlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQYXRjaGVkRmV0Y2hlcjtcbiAgICB9LFxuICAgIHBhdGNoRmV0Y2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGF0Y2hGZXRjaDtcbiAgICB9LFxuICAgIHZhbGlkYXRlUmV2YWxpZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVJldmFsaWRhdGU7XG4gICAgfSxcbiAgICB2YWxpZGF0ZVRhZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVUYWdzO1xuICAgIH1cbn0pO1xuY29uc3QgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuL3RyYWNlL2NvbnN0YW50c1wiKTtcbmNvbnN0IF90cmFjZXIgPSByZXF1aXJlKFwiLi90cmFjZS90cmFjZXJcIik7XG5jb25zdCBfY29uc3RhbnRzMSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvY29uc3RhbnRzXCIpO1xuY29uc3QgX2R5bmFtaWNyZW5kZXJpbmcgPSByZXF1aXJlKFwiLi4vYXBwLXJlbmRlci9keW5hbWljLXJlbmRlcmluZ1wiKTtcbmNvbnN0IF9keW5hbWljcmVuZGVyaW5ndXRpbHMgPSByZXF1aXJlKFwiLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHNcIik7XG5jb25zdCBfZGVkdXBlZmV0Y2ggPSByZXF1aXJlKFwiLi9kZWR1cGUtZmV0Y2hcIik7XG5jb25zdCBfcmVzcG9uc2VjYWNoZSA9IHJlcXVpcmUoXCIuLi9yZXNwb25zZS1jYWNoZVwiKTtcbmNvbnN0IF9zY2hlZHVsZXIgPSByZXF1aXJlKFwiLi4vLi4vbGliL3NjaGVkdWxlclwiKTtcbmNvbnN0IF9jbG9uZXJlc3BvbnNlID0gcmVxdWlyZShcIi4vY2xvbmUtcmVzcG9uc2VcIik7XG5jb25zdCBpc0VkZ2VSdW50aW1lID0gcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnZWRnZSc7XG5jb25zdCBORVhUX1BBVENIX1NZTUJPTCA9IFN5bWJvbC5mb3IoJ25leHQtcGF0Y2gnKTtcbmZ1bmN0aW9uIGlzRmV0Y2hQYXRjaGVkKCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzW05FWFRfUEFUQ0hfU1lNQk9MXSA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmV2YWxpZGF0ZShyZXZhbGlkYXRlVmFsLCByb3V0ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBub3JtYWxpemVkUmV2YWxpZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHJldmFsaWRhdGVWYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkUmV2YWxpZGF0ZSA9IF9jb25zdGFudHMxLklORklOSVRFX0NBQ0hFO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXZhbGlkYXRlVmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4ocmV2YWxpZGF0ZVZhbCkgJiYgcmV2YWxpZGF0ZVZhbCA+IC0xKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkUmV2YWxpZGF0ZSA9IHJldmFsaWRhdGVWYWw7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJldmFsaWRhdGVWYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBJbnZhbGlkIHJldmFsaWRhdGUgdmFsdWUgXCIke3JldmFsaWRhdGVWYWx9XCIgb24gXCIke3JvdXRlfVwiLCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlciBvciBmYWxzZWApLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJFMTc5XCIsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZFJldmFsaWRhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGhhbmRsZSBjbGllbnQgY29tcG9uZW50IGVycm9yIGZyb20gYXR0ZW1wdGluZyB0byBjaGVjayByZXZhbGlkYXRlIHZhbHVlXG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnSW52YWxpZCByZXZhbGlkYXRlJykpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVGFncyh0YWdzLCBkZXNjcmlwdGlvbikge1xuICAgIGNvbnN0IHZhbGlkVGFncyA9IFtdO1xuICAgIGNvbnN0IGludmFsaWRUYWdzID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHRhZ3MubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCB0YWcgPSB0YWdzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHRhZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGludmFsaWRUYWdzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICByZWFzb246ICdpbnZhbGlkIHR5cGUsIG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWcubGVuZ3RoID4gX2NvbnN0YW50czEuTkVYVF9DQUNIRV9UQUdfTUFYX0xFTkdUSCkge1xuICAgICAgICAgICAgaW52YWxpZFRhZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogYGV4Y2VlZGVkIG1heCBsZW5ndGggb2YgJHtfY29uc3RhbnRzMS5ORVhUX0NBQ0hFX1RBR19NQVhfTEVOR1RIfWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRUYWdzLnB1c2godGFnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWRUYWdzLmxlbmd0aCA+IF9jb25zdGFudHMxLk5FWFRfQ0FDSEVfVEFHX01BWF9JVEVNUykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBXYXJuaW5nOiBleGNlZWRlZCBtYXggdGFnIGNvdW50IGZvciAke2Rlc2NyaXB0aW9ufSwgZHJvcHBlZCB0YWdzOmAsIHRhZ3Muc2xpY2UoaSkuam9pbignLCAnKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW52YWxpZFRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6IGludmFsaWQgdGFncyBwYXNzZWQgdG8gJHtkZXNjcmlwdGlvbn06IGApO1xuICAgICAgICBmb3IgKGNvbnN0IHsgdGFnLCByZWFzb24gfSBvZiBpbnZhbGlkVGFncyl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgdGFnOiBcIiR7dGFnfVwiICR7cmVhc29ufWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWxpZFRhZ3M7XG59XG5mdW5jdGlvbiB0cmFja0ZldGNoTWV0cmljKHdvcmtTdG9yZSwgY3R4KSB7XG4gICAgdmFyIF93b3JrU3RvcmVfcmVxdWVzdEVuZGVkU3RhdGU7XG4gICAgLy8gSWYgdGhlIHN0YXRpYyBnZW5lcmF0aW9uIHN0b3JlIGlzIG5vdCBhdmFpbGFibGUsIHdlIGNhbid0IHRyYWNrIHRoZSBmZXRjaFxuICAgIGlmICghd29ya1N0b3JlKSByZXR1cm47XG4gICAgaWYgKChfd29ya1N0b3JlX3JlcXVlc3RFbmRlZFN0YXRlID0gd29ya1N0b3JlLnJlcXVlc3RFbmRlZFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3dvcmtTdG9yZV9yZXF1ZXN0RW5kZWRTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICAgIGNvbnN0IGlzRGVidWdCdWlsZCA9ICghIXByb2Nlc3MuZW52Lk5FWFRfREVCVUdfQlVJTEQgfHwgcHJvY2Vzcy5lbnYuTkVYVF9TU0dfRkVUQ0hfTUVUUklDUyA9PT0gJzEnKSAmJiB3b3JrU3RvcmUuaXNTdGF0aWNHZW5lcmF0aW9uO1xuICAgIGNvbnN0IGlzRGV2ZWxvcG1lbnQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JztcbiAgICBpZiAoLy8gVGhlIG9ubHkgdGltZSB3ZSB3YW50IHRvIHRyYWNrIGZldGNoIG1ldHJpY3Mgb3V0c2lkZSBvZiBkZXZlbG9wbWVudCBpcyB3aGVuXG4gICAgLy8gd2UgYXJlIHBlcmZvcm1pbmcgYSBzdGF0aWMgZ2VuZXJhdGlvbiAmIHdlIGFyZSBpbiBkZWJ1ZyBtb2RlLlxuICAgICFpc0RlYnVnQnVpbGQgJiYgIWlzRGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3b3JrU3RvcmUuZmV0Y2hNZXRyaWNzID8/PSBbXTtcbiAgICB3b3JrU3RvcmUuZmV0Y2hNZXRyaWNzLnB1c2goe1xuICAgICAgICAuLi5jdHgsXG4gICAgICAgIGVuZDogcGVyZm9ybWFuY2UudGltZU9yaWdpbiArIHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICBpZHg6IHdvcmtTdG9yZS5uZXh0RmV0Y2hJZCB8fCAwXG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRjaGVkRmV0Y2hlcihvcmlnaW5GZXRjaCwgeyB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSB9KSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBwYXRjaGVkIGZldGNoIGZ1bmN0aW9uLiBXZSBkb24ndCBzZXQgdGhlIHR5cGUgaGVyZSwgYXMgaXQnc1xuICAgIC8vIHZlcmlmaWVkIGFzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICBjb25zdCBwYXRjaGVkID0gYXN5bmMgKGlucHV0LCBpbml0KT0+e1xuICAgICAgICB2YXIgX2luaXRfbWV0aG9kLCBfaW5pdF9uZXh0O1xuICAgICAgICBsZXQgdXJsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdXJsID0gbmV3IFVSTChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QgPyBpbnB1dC51cmwgOiBpbnB1dCk7XG4gICAgICAgICAgICB1cmwudXNlcm5hbWUgPSAnJztcbiAgICAgICAgICAgIHVybC5wYXNzd29yZCA9ICcnO1xuICAgICAgICB9IGNhdGNoICB7XG4gICAgICAgICAgICAvLyBFcnJvciBjYXVzZWQgYnkgbWFsZm9ybWVkIFVSTCBzaG91bGQgYmUgaGFuZGxlZCBieSBuYXRpdmUgZmV0Y2hcbiAgICAgICAgICAgIHVybCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZXRjaFVybCA9ICh1cmwgPT0gbnVsbCA/IHZvaWQgMCA6IHVybC5ocmVmKSA/PyAnJztcbiAgICAgICAgY29uc3QgbWV0aG9kID0gKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IChfaW5pdF9tZXRob2QgPSBpbml0Lm1ldGhvZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbml0X21ldGhvZC50b1VwcGVyQ2FzZSgpKSB8fCAnR0VUJztcbiAgICAgICAgLy8gRG8gY3JlYXRlIGEgbmV3IHNwYW4gdHJhY2UgZm9yIGludGVybmFsIGZldGNoZXMgaW4gdGhlXG4gICAgICAgIC8vIG5vbi12ZXJib3NlIG1vZGUuXG4gICAgICAgIGNvbnN0IGlzSW50ZXJuYWwgPSAoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogKF9pbml0X25leHQgPSBpbml0Lm5leHQpID09IG51bGwgPyB2b2lkIDAgOiBfaW5pdF9uZXh0LmludGVybmFsKSA9PT0gdHJ1ZTtcbiAgICAgICAgY29uc3QgaGlkZVNwYW4gPSBwcm9jZXNzLmVudi5ORVhUX09URUxfRkVUQ0hfRElTQUJMRUQgPT09ICcxJztcbiAgICAgICAgLy8gV2UgZG9uJ3QgdHJhY2sgZmV0Y2ggbWV0cmljcyBmb3IgaW50ZXJuYWwgZmV0Y2hlc1xuICAgICAgICAvLyBzbyBpdCdzIG5vdCBjcml0aWNhbCB0aGF0IHdlIGhhdmUgYSBzdGFydCB0aW1lLCBhcyBpdCB3b24ndCBiZSByZWNvcmRlZC5cbiAgICAgICAgLy8gVGhpcyBpcyB0byB3b3JrYXJvdW5kIGEgZmxha3kgaXNzdWUgd2hlcmUgcGVyZm9ybWFuY2UgQVBJcyBtaWdodFxuICAgICAgICAvLyBub3QgYmUgYXZhaWxhYmxlIGFuZCB3aWxsIHJlcXVpcmUgZm9sbG93LXVwIGludmVzdGlnYXRpb24uXG4gICAgICAgIGNvbnN0IGZldGNoU3RhcnQgPSBpc0ludGVybmFsID8gdW5kZWZpbmVkIDogcGVyZm9ybWFuY2UudGltZU9yaWdpbiArIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCB3b3JrU3RvcmUgPSB3b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgICAgIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgICAgICAvLyBEdXJpbmcgc3RhdGljIGdlbmVyYXRpb24gd2UgdHJhY2sgY2FjaGUgcmVhZHMgc28gd2UgY2FuIHJlYXNvbiBhYm91dCB3aGVuIHRoZXkgZmlsbFxuICAgICAgICBsZXQgY2FjaGVTaWduYWwgPSB3b3JrVW5pdFN0b3JlICYmIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicgPyB3b3JrVW5pdFN0b3JlLmNhY2hlU2lnbmFsIDogbnVsbDtcbiAgICAgICAgaWYgKGNhY2hlU2lnbmFsKSB7XG4gICAgICAgICAgICBjYWNoZVNpZ25hbC5iZWdpblJlYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgX3RyYWNlci5nZXRUcmFjZXIpKCkudHJhY2UoaXNJbnRlcm5hbCA/IF9jb25zdGFudHMuTmV4dE5vZGVTZXJ2ZXJTcGFuLmludGVybmFsRmV0Y2ggOiBfY29uc3RhbnRzLkFwcFJlbmRlclNwYW4uZmV0Y2gsIHtcbiAgICAgICAgICAgIGhpZGVTcGFuLFxuICAgICAgICAgICAga2luZDogX3RyYWNlci5TcGFuS2luZC5DTElFTlQsXG4gICAgICAgICAgICBzcGFuTmFtZTogW1xuICAgICAgICAgICAgICAgICdmZXRjaCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgIGZldGNoVXJsXG4gICAgICAgICAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJyksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgJ2h0dHAudXJsJzogZmV0Y2hVcmwsXG4gICAgICAgICAgICAgICAgJ2h0dHAubWV0aG9kJzogbWV0aG9kLFxuICAgICAgICAgICAgICAgICduZXQucGVlci5uYW1lJzogdXJsID09IG51bGwgPyB2b2lkIDAgOiB1cmwuaG9zdG5hbWUsXG4gICAgICAgICAgICAgICAgJ25ldC5wZWVyLnBvcnQnOiAodXJsID09IG51bGwgPyB2b2lkIDAgOiB1cmwucG9ydCkgfHwgdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGFzeW5jICgpPT57XG4gICAgICAgICAgICB2YXIgX2dldFJlcXVlc3RNZXRhO1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBpbnRlcm5hbCBmZXRjaCwgd2Ugc2hvdWxkIG5vdCBkbyBhbnkgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICAgICAgICBpZiAoaXNJbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5GZXRjaChpbnB1dCwgaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgd29ya1N0b3JlIGlzIG5vdCBhdmFpbGFibGUsIHdlIGNhbid0IGRvIGFueVxuICAgICAgICAgICAgLy8gc3BlY2lhbCB0cmVhdG1lbnQgb2YgZmV0Y2gsIHRoZXJlZm9yZSBmYWxsYmFjayB0byB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIGZldGNoIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgaWYgKCF3b3JrU3RvcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luRmV0Y2goaW5wdXQsIGluaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGFsc28gZmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIGZldGNoIGltcGxlbWVudGF0aW9uIGlmIHdlXG4gICAgICAgICAgICAvLyBhcmUgaW4gZHJhZnQgbW9kZSwgaXQgZG9lcyBub3QgY29uc3RpdHV0ZSBhIHN0YXRpYyBnZW5lcmF0aW9uLlxuICAgICAgICAgICAgaWYgKHdvcmtTdG9yZS5pc0RyYWZ0TW9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5GZXRjaChpbnB1dCwgaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc1JlcXVlc3RJbnB1dCA9IGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGlucHV0Lm1ldGhvZCA9PT0gJ3N0cmluZyc7XG4gICAgICAgICAgICBjb25zdCBnZXRSZXF1ZXN0TWV0YSA9IChmaWVsZCk9PntcbiAgICAgICAgICAgICAgICAvLyBJZiByZXF1ZXN0IGlucHV0IGlzIHByZXNlbnQgYnV0IGluaXQgaXMgbm90LCByZXRyaWV2ZSBmcm9tIGlucHV0IGZpcnN0LlxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdFtmaWVsZF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIHx8IChpc1JlcXVlc3RJbnB1dCA/IGlucHV0W2ZpZWxkXSA6IG51bGwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBmaW5hbFJldmFsaWRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBnZXROZXh0RmllbGQgPSAoZmllbGQpPT57XG4gICAgICAgICAgICAgICAgdmFyIF9pbml0X25leHQsIF9pbml0X25leHQxLCBfaW5wdXRfbmV4dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIChpbml0ID09IG51bGwgPyB2b2lkIDAgOiAoX2luaXRfbmV4dCA9IGluaXQubmV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbml0X25leHRbZmllbGRdKSAhPT0gJ3VuZGVmaW5lZCcgPyBpbml0ID09IG51bGwgPyB2b2lkIDAgOiAoX2luaXRfbmV4dDEgPSBpbml0Lm5leHQpID09IG51bGwgPyB2b2lkIDAgOiBfaW5pdF9uZXh0MVtmaWVsZF0gOiBpc1JlcXVlc3RJbnB1dCA/IChfaW5wdXRfbmV4dCA9IGlucHV0Lm5leHQpID09IG51bGwgPyB2b2lkIDAgOiBfaW5wdXRfbmV4dFtmaWVsZF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gUmVxdWVzdEluaXQgZG9lc24ndCBrZWVwIGV4dHJhIGZpZWxkcyBlLmcuIG5leHQgc28gaXQnc1xuICAgICAgICAgICAgLy8gb25seSBhdmFpbGFibGUgaWYgaW5pdCBpcyB1c2VkIHNlcGFyYXRlXG4gICAgICAgICAgICBsZXQgY3VycmVudEZldGNoUmV2YWxpZGF0ZSA9IGdldE5leHRGaWVsZCgncmV2YWxpZGF0ZScpO1xuICAgICAgICAgICAgY29uc3QgdGFncyA9IHZhbGlkYXRlVGFncyhnZXROZXh0RmllbGQoJ3RhZ3MnKSB8fCBbXSwgYGZldGNoICR7aW5wdXQudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIGNvbnN0IHJldmFsaWRhdGVTdG9yZSA9IHdvcmtVbml0U3RvcmUgJiYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ2NhY2hlJyB8fCB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXInIHx8IHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInIHx8IHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1sZWdhY3knKSA/IHdvcmtVbml0U3RvcmUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAocmV2YWxpZGF0ZVN0b3JlKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFncykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdCB0YWdzIG9udG8gcGFyZW50IGNhY2hlcyBvciBwYXJlbnQgcHJlcmVuZGVycy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGVkVGFncyA9IHJldmFsaWRhdGVTdG9yZS50YWdzID8/IChyZXZhbGlkYXRlU3RvcmUudGFncyA9IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgdGFncyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbGxlY3RlZFRhZ3MuaW5jbHVkZXModGFnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFRhZ3MucHVzaCh0YWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW1wbGljaXRUYWdzID0gIXdvcmtVbml0U3RvcmUgfHwgd29ya1VuaXRTdG9yZS50eXBlID09PSAndW5zdGFibGUtY2FjaGUnID8gW10gOiB3b3JrVW5pdFN0b3JlLmltcGxpY2l0VGFncztcbiAgICAgICAgICAgIC8vIEluc2lkZSB1bnN0YWJsZS1jYWNoZSB3ZSB0cmVhdCBpdCB0aGUgc2FtZSBhcyBmb3JjZS1uby1zdG9yZSBvbiB0aGVcbiAgICAgICAgICAgIC8vIHBhZ2UuXG4gICAgICAgICAgICBjb25zdCBwYWdlRmV0Y2hDYWNoZU1vZGUgPSB3b3JrVW5pdFN0b3JlICYmIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3Vuc3RhYmxlLWNhY2hlJyA/ICdmb3JjZS1uby1zdG9yZScgOiB3b3JrU3RvcmUuZmV0Y2hDYWNoZTtcbiAgICAgICAgICAgIGNvbnN0IGlzVXNpbmdOb1N0b3JlID0gISF3b3JrU3RvcmUuaXNVbnN0YWJsZU5vU3RvcmU7XG4gICAgICAgICAgICBsZXQgY3VycmVudEZldGNoQ2FjaGVDb25maWcgPSBnZXRSZXF1ZXN0TWV0YSgnY2FjaGUnKTtcbiAgICAgICAgICAgIGxldCBjYWNoZVJlYXNvbiA9ICcnO1xuICAgICAgICAgICAgbGV0IGNhY2hlV2FybmluZztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudEZldGNoQ2FjaGVDb25maWcgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBjdXJyZW50RmV0Y2hSZXZhbGlkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXZhbGlkYXRlIHZhbHVlIGNvbmZsaWN0cyB3aXRoIHRoZSBjYWNoZSB2YWx1ZSwgd2Ugc2hvdWxkIHdhcm4gdGhlIHVzZXIgYW5kIHVuc2V0IHRoZSBjb25mbGljdGluZyB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgY29uc3QgaXNDb25mbGljdGluZ1JldmFsaWRhdGUgPSAvLyByZXZhbGlkYXRlOiAwIGFuZCBjYWNoZTogZm9yY2UtY2FjaGVcbiAgICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hDYWNoZUNvbmZpZyA9PT0gJ2ZvcmNlLWNhY2hlJyAmJiBjdXJyZW50RmV0Y2hSZXZhbGlkYXRlID09PSAwIHx8IC8vIHJldmFsaWRhdGU6ID4wIG9yIHJldmFsaWRhdGU6IGZhbHNlIGFuZCBjYWNoZTogbm8tc3RvcmVcbiAgICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hDYWNoZUNvbmZpZyA9PT0gJ25vLXN0b3JlJyAmJiAoY3VycmVudEZldGNoUmV2YWxpZGF0ZSA+IDAgfHwgY3VycmVudEZldGNoUmV2YWxpZGF0ZSA9PT0gZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChpc0NvbmZsaWN0aW5nUmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVdhcm5pbmcgPSBgU3BlY2lmaWVkIFwiY2FjaGU6ICR7Y3VycmVudEZldGNoQ2FjaGVDb25maWd9XCIgYW5kIFwicmV2YWxpZGF0ZTogJHtjdXJyZW50RmV0Y2hSZXZhbGlkYXRlfVwiLCBvbmx5IG9uZSBzaG91bGQgYmUgc3BlY2lmaWVkLmA7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGZXRjaENhY2hlQ29uZmlnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hSZXZhbGlkYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhc0V4cGxpY2l0RmV0Y2hDYWNoZU9wdE91dCA9IC8vIGZldGNoIGNvbmZpZyBpdHNlbGYgc2lnbmFscyBub3QgdG8gY2FjaGVcbiAgICAgICAgICAgIGN1cnJlbnRGZXRjaENhY2hlQ29uZmlnID09PSAnbm8tY2FjaGUnIHx8IGN1cnJlbnRGZXRjaENhY2hlQ29uZmlnID09PSAnbm8tc3RvcmUnIHx8IC8vIHRoZSBmZXRjaCBpc24ndCBleHBsaWNpdGx5IGNhY2hpbmcgYW5kIHRoZSBzZWdtZW50IGxldmVsIGNhY2hlIGNvbmZpZyBzaWduYWxzIG5vdCB0byBjYWNoZVxuICAgICAgICAgICAgLy8gbm90ZTogYHBhZ2VGZXRjaENhY2hlTW9kZWAgaXMgYWxzbyBzZXQgYnkgYmVpbmcgaW4gYW4gdW5zdGFibGVfY2FjaGUgY29udGV4dC5cbiAgICAgICAgICAgIHBhZ2VGZXRjaENhY2hlTW9kZSA9PT0gJ2ZvcmNlLW5vLXN0b3JlJyB8fCBwYWdlRmV0Y2hDYWNoZU1vZGUgPT09ICdvbmx5LW5vLXN0b3JlJztcbiAgICAgICAgICAgIC8vIElmIG5vIGV4cGxpY2l0IGZldGNoIGNhY2hlIG1vZGUgaXMgc2V0LCBidXQgZHluYW1pYyA9IGBmb3JjZS1keW5hbWljYCBpcyBzZXQsXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGRuJ3QgY29uc2lkZXIgY2FjaGluZyB0aGUgZmV0Y2guIFRoaXMgaXMgYmVjYXVzZSB0aGUgYGR5bmFtaWNgIGNhY2hlXG4gICAgICAgICAgICAvLyBpcyBjb25zaWRlcmVkIGEgXCJ0b3AtbGV2ZWxcIiBjYWNoZSBtb2RlLCB3aGVyZWFzIHNvbWV0aGluZyBsaWtlIGBmZXRjaENhY2hlYCBpcyBtb3JlXG4gICAgICAgICAgICAvLyBmaW5lLWdyYWluZWQuIFRvcC1sZXZlbCBtb2RlcyBhcmUgcmVzcG9uc2libGUgZm9yIHNldHRpbmcgcmVhc29uYWJsZSBkZWZhdWx0cyBmb3IgdGhlXG4gICAgICAgICAgICAvLyBvdGhlciBjb25maWd1cmF0aW9ucy5cbiAgICAgICAgICAgIGNvbnN0IG5vRmV0Y2hDb25maWdBbmRGb3JjZUR5bmFtaWMgPSAhcGFnZUZldGNoQ2FjaGVNb2RlICYmICFjdXJyZW50RmV0Y2hDYWNoZUNvbmZpZyAmJiAhY3VycmVudEZldGNoUmV2YWxpZGF0ZSAmJiB3b3JrU3RvcmUuZm9yY2VEeW5hbWljO1xuICAgICAgICAgICAgaWYgKC8vIGZvcmNlLWNhY2hlIHdhcyBzcGVjaWZpZWQgd2l0aG91dCBhIHJldmFsaWRhdGUgdmFsdWUuIFdlIHNldCB0aGUgcmV2YWxpZGF0ZSB2YWx1ZSB0byBmYWxzZVxuICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBzaWduYWwgdGhlIGNhY2hlIHRvIG5vdCByZXZhbGlkYXRlXG4gICAgICAgICAgICBjdXJyZW50RmV0Y2hDYWNoZUNvbmZpZyA9PT0gJ2ZvcmNlLWNhY2hlJyAmJiB0eXBlb2YgY3VycmVudEZldGNoUmV2YWxpZGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hSZXZhbGlkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC8vIGlmIHdlIGFyZSBpbnNpZGUgb2YgXCJ1c2UgY2FjaGVcIi9cInVuc3RhYmxlX2NhY2hlXCJcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZG4ndCBzZXQgdGhlIHJldmFsaWRhdGUgdG8gMCBhcyBpdCdzIG92ZXJyaWRkZW5cbiAgICAgICAgICAgIC8vIGJ5IHRoZSBjYWNoZSBjb250ZXh0XG4gICAgICAgICAgICAod29ya1VuaXRTdG9yZSA9PSBudWxsID8gdm9pZCAwIDogd29ya1VuaXRTdG9yZS50eXBlKSAhPT0gJ2NhY2hlJyAmJiAoaGFzRXhwbGljaXRGZXRjaENhY2hlT3B0T3V0IHx8IG5vRmV0Y2hDb25maWdBbmRGb3JjZUR5bmFtaWMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEZldGNoUmV2YWxpZGF0ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudEZldGNoQ2FjaGVDb25maWcgPT09ICduby1jYWNoZScgfHwgY3VycmVudEZldGNoQ2FjaGVDb25maWcgPT09ICduby1zdG9yZScpIHtcbiAgICAgICAgICAgICAgICBjYWNoZVJlYXNvbiA9IGBjYWNoZTogJHtjdXJyZW50RmV0Y2hDYWNoZUNvbmZpZ31gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxSZXZhbGlkYXRlID0gdmFsaWRhdGVSZXZhbGlkYXRlKGN1cnJlbnRGZXRjaFJldmFsaWRhdGUsIHdvcmtTdG9yZS5yb3V0ZSk7XG4gICAgICAgICAgICBjb25zdCBfaGVhZGVycyA9IGdldFJlcXVlc3RNZXRhKCdoZWFkZXJzJyk7XG4gICAgICAgICAgICBjb25zdCBpbml0SGVhZGVycyA9IHR5cGVvZiAoX2hlYWRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IF9oZWFkZXJzLmdldCkgPT09ICdmdW5jdGlvbicgPyBfaGVhZGVycyA6IG5ldyBIZWFkZXJzKF9oZWFkZXJzIHx8IHt9KTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1VuQ2FjaGVhYmxlSGVhZGVyID0gaW5pdEhlYWRlcnMuZ2V0KCdhdXRob3JpemF0aW9uJykgfHwgaW5pdEhlYWRlcnMuZ2V0KCdjb29raWUnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzVW5DYWNoZWFibGVNZXRob2QgPSAhW1xuICAgICAgICAgICAgICAgICdnZXQnLFxuICAgICAgICAgICAgICAgICdoZWFkJ1xuICAgICAgICAgICAgXS5pbmNsdWRlcygoKF9nZXRSZXF1ZXN0TWV0YSA9IGdldFJlcXVlc3RNZXRhKCdtZXRob2QnKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXRSZXF1ZXN0TWV0YS50b0xvd2VyQ2FzZSgpKSB8fCAnZ2V0Jyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICogV2UgYXV0b21hdGljYWxseSBkaXNhYmxlIGZldGNoIGNhY2hpbmcgdW5kZXIgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAgICAgKiAtIEZldGNoIGNhY2hlIGNvbmZpZ3MgYXJlIG5vdCBzZXQuIFNwZWNpZmljYWxseTpcbiAgICAgICAgICogICAgLSBBIHBhZ2UgZmV0Y2ggY2FjaGUgbW9kZSBpcyBub3Qgc2V0IChleHBvcnQgY29uc3QgZmV0Y2hDYWNoZT0uLi4pXG4gICAgICAgICAqICAgIC0gQSBmZXRjaCBjYWNoZSBtb2RlIGlzIG5vdCBzZXQgaW4gdGhlIGZldGNoIGNhbGwgKGZldGNoKHVybCwgeyBjYWNoZTogLi4uIH0pKVxuICAgICAgICAgKiAgICAgIG9yIHRoZSBmZXRjaCBjYWNoZSBtb2RlIGlzIHNldCB0byAnZGVmYXVsdCdcbiAgICAgICAgICogICAgLSBBIGZldGNoIHJldmFsaWRhdGUgdmFsdWUgaXMgbm90IHNldCBpbiB0aGUgZmV0Y2ggY2FsbCAoZmV0Y2godXJsLCB7IHJldmFsaWRhdGU6IC4uLiB9KSlcbiAgICAgICAgICogLSBPUiB0aGUgZmV0Y2ggY29tZXMgYWZ0ZXIgYSBjb25maWd1cmF0aW9uIHRoYXQgdHJpZ2dlcmVkIGR5bmFtaWMgcmVuZGVyaW5nIChlLmcuLCByZWFkaW5nIGNvb2tpZXMoKSlcbiAgICAgICAgICogICBhbmQgdGhlIGZldGNoIHdhcyBjb25zaWRlcmVkIHVuY2FjaGVhYmxlIChlLmcuLCBQT1NUIG1ldGhvZCBvciBoYXMgYXV0aG9yaXphdGlvbiBoZWFkZXJzKVxuICAgICAgICAgKi8gY29uc3QgaGFzTm9FeHBsaWNpdENhY2hlQ29uZmlnID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgcGFnZUZldGNoQ2FjaGVNb2RlID09IHVuZGVmaW5lZCAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgICAoY3VycmVudEZldGNoQ2FjaGVDb25maWcgPT0gdW5kZWZpbmVkIHx8IC8vIHdoZW4gY29uc2lkZXJpbmcgd2hldGhlciB0byBvcHQgaW50byB0aGUgZGVmYXVsdCBcIm5vLWNhY2hlXCIgZmV0Y2ggc2VtYW50aWNzLFxuICAgICAgICAgICAgLy8gYSBcImRlZmF1bHRcIiBjYWNoZSBjb25maWcgc2hvdWxkIGJlIHRyZWF0ZWQgdGhlIHNhbWUgYXMgbm8gY2FjaGUgY29uZmlnXG4gICAgICAgICAgICBjdXJyZW50RmV0Y2hDYWNoZUNvbmZpZyA9PT0gJ2RlZmF1bHQnKSAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgICBjdXJyZW50RmV0Y2hSZXZhbGlkYXRlID09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGF1dG9Ob0NhY2hlID0gLy8gdGhpcyBjb25kaXRpb24gaXMgaGl0IGZvciBudWxsL3VuZGVmaW5lZFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgaGFzTm9FeHBsaWNpdENhY2hlQ29uZmlnICYmIC8vIHdlIGRpc2FibGUgYXV0b21hdGljIG5vIGNhY2hpbmcgYmVoYXZpb3IgZHVyaW5nIGJ1aWxkIHRpbWUgU1NHIHNvIHRoYXQgd2UgY2FuIHN0aWxsXG4gICAgICAgICAgICAvLyBsZXZlcmFnZSB0aGUgZmV0Y2ggY2FjaGUgYmV0d2VlbiBTU0cgd29ya2Vyc1xuICAgICAgICAgICAgIXdvcmtTdG9yZS5pc1ByZXJlbmRlcmluZyB8fCAoaGFzVW5DYWNoZWFibGVIZWFkZXIgfHwgaXNVbkNhY2hlYWJsZU1ldGhvZCkgJiYgcmV2YWxpZGF0ZVN0b3JlICYmIHJldmFsaWRhdGVTdG9yZS5yZXZhbGlkYXRlID09PSAwO1xuICAgICAgICAgICAgaWYgKGhhc05vRXhwbGljaXRDYWNoZUNvbmZpZyAmJiB3b3JrVW5pdFN0b3JlICE9PSB1bmRlZmluZWQgJiYgd29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbm8gY2FjaGUgY29uZmlnLCBhbmQgd2UncmUgaW4gRHluYW1pYyBJL08gcHJlcmVuZGVyaW5nLCBpdCdsbCBiZSBhIGR5bmFtaWMgY2FsbC5cbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIHRvIGlzc3VlIHRoYXQgZHluYW1pYyBjYWxsLlxuICAgICAgICAgICAgICAgIGlmIChjYWNoZVNpZ25hbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVNpZ25hbC5lbmRSZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlU2lnbmFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfZHluYW1pY3JlbmRlcmluZ3V0aWxzLm1ha2VIYW5naW5nUHJvbWlzZSkod29ya1VuaXRTdG9yZS5yZW5kZXJTaWduYWwsICdmZXRjaCgpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2gocGFnZUZldGNoQ2FjaGVNb2RlKXtcbiAgICAgICAgICAgICAgICBjYXNlICdmb3JjZS1uby1zdG9yZSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlUmVhc29uID0gJ2ZldGNoQ2FjaGUgPSBmb3JjZS1uby1zdG9yZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ29ubHktbm8tc3RvcmUnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZldGNoQ2FjaGVDb25maWcgPT09ICdmb3JjZS1jYWNoZScgfHwgdHlwZW9mIGZpbmFsUmV2YWxpZGF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZmluYWxSZXZhbGlkYXRlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgRXJyb3IoYGNhY2hlOiAnZm9yY2UtY2FjaGUnIHVzZWQgb24gZmV0Y2ggZm9yICR7ZmV0Y2hVcmx9IHdpdGggJ2V4cG9ydCBjb25zdCBmZXRjaENhY2hlID0gJ29ubHktbm8tc3RvcmUnYCksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJFNDQ4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlUmVhc29uID0gJ2ZldGNoQ2FjaGUgPSBvbmx5LW5vLXN0b3JlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnb25seS1jYWNoZSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmV0Y2hDYWNoZUNvbmZpZyA9PT0gJ25vLXN0b3JlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgRXJyb3IoYGNhY2hlOiAnbm8tc3RvcmUnIHVzZWQgb24gZmV0Y2ggZm9yICR7ZmV0Y2hVcmx9IHdpdGggJ2V4cG9ydCBjb25zdCBmZXRjaENhY2hlID0gJ29ubHktY2FjaGUnYCksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJFNTIxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZm9yY2UtY2FjaGUnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRGZXRjaFJldmFsaWRhdGUgPT09ICd1bmRlZmluZWQnIHx8IGN1cnJlbnRGZXRjaFJldmFsaWRhdGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVJlYXNvbiA9ICdmZXRjaENhY2hlID0gZm9yY2UtY2FjaGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsUmV2YWxpZGF0ZSA9IF9jb25zdGFudHMxLklORklOSVRFX0NBQ0hFO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaW5hbFJldmFsaWRhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhZ2VGZXRjaENhY2hlTW9kZSA9PT0gJ2RlZmF1bHQtY2FjaGUnICYmICFpc1VzaW5nTm9TdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbFJldmFsaWRhdGUgPSBfY29uc3RhbnRzMS5JTkZJTklURV9DQUNIRTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVSZWFzb24gPSAnZmV0Y2hDYWNoZSA9IGRlZmF1bHQtY2FjaGUnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFnZUZldGNoQ2FjaGVNb2RlID09PSAnZGVmYXVsdC1uby1zdG9yZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxSZXZhbGlkYXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVSZWFzb24gPSAnZmV0Y2hDYWNoZSA9IGRlZmF1bHQtbm8tc3RvcmUnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNVc2luZ05vU3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxSZXZhbGlkYXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVSZWFzb24gPSAnbm9TdG9yZSBjYWxsJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF1dG9Ob0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsUmV2YWxpZGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlUmVhc29uID0gJ2F1dG8gbm8gY2FjaGUnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHNob3VsZCB3ZSBjb25zaWRlciB0aGlzIGNhc2UgYW4gaW52YXJpYW50P1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVJlYXNvbiA9ICdhdXRvIGNhY2hlJztcbiAgICAgICAgICAgICAgICAgICAgZmluYWxSZXZhbGlkYXRlID0gcmV2YWxpZGF0ZVN0b3JlID8gcmV2YWxpZGF0ZVN0b3JlLnJldmFsaWRhdGUgOiBfY29uc3RhbnRzMS5JTkZJTklURV9DQUNIRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjYWNoZVJlYXNvbikge1xuICAgICAgICAgICAgICAgIGNhY2hlUmVhc29uID0gYHJldmFsaWRhdGU6ICR7ZmluYWxSZXZhbGlkYXRlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoLy8gd2hlbiBmb3JjZSBzdGF0aWMgaXMgY29uZmlndXJlZCB3ZSBkb24ndCBiYWlsIGZyb21cbiAgICAgICAgICAgIC8vIGByZXZhbGlkYXRlOiAwYCB2YWx1ZXNcbiAgICAgICAgICAgICEod29ya1N0b3JlLmZvcmNlU3RhdGljICYmIGZpbmFsUmV2YWxpZGF0ZSA9PT0gMCkgJiYgLy8gd2UgZG9uJ3QgY29uc2lkZXIgYXV0b05vQ2FjaGUgdG8gc3dpdGNoIHRvIGR5bmFtaWMgZm9yIElTUlxuICAgICAgICAgICAgIWF1dG9Ob0NhY2hlICYmIC8vIElmIHRoZSByZXZhbGlkYXRlIHZhbHVlIGlzbid0IGN1cnJlbnRseSBzZXQgb3IgdGhlIHZhbHVlIGlzIGxlc3NcbiAgICAgICAgICAgIC8vIHRoYW4gdGhlIGN1cnJlbnQgcmV2YWxpZGF0ZSB2YWx1ZSwgd2Ugc2hvdWxkIHVwZGF0ZSB0aGUgcmV2YWxpZGF0ZVxuICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICByZXZhbGlkYXRlU3RvcmUgJiYgZmluYWxSZXZhbGlkYXRlIDwgcmV2YWxpZGF0ZVN0b3JlLnJldmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIHNldHRpbmcgdGhlIHJldmFsaWRhdGUgdmFsdWUgdG8gMCwgd2Ugc2hvdWxkIHRyeSB0b1xuICAgICAgICAgICAgICAgIC8vIHBvc3Rwb25lIGluc3RlYWQgZmlyc3QuXG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsUmV2YWxpZGF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod29ya1VuaXRTdG9yZSAmJiB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVTaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVNpZ25hbC5lbmRSZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVTaWduYWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfZHluYW1pY3JlbmRlcmluZ3V0aWxzLm1ha2VIYW5naW5nUHJvbWlzZSkod29ya1VuaXRTdG9yZS5yZW5kZXJTaWduYWwsICdmZXRjaCgpJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcubWFya0N1cnJlbnRTY29wZUFzRHluYW1pYykod29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlLCBgcmV2YWxpZGF0ZTogMCBmZXRjaCAke2lucHV0fSAke3dvcmtTdG9yZS5yb3V0ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gc2V0IHRoZSByZXZhbGlkYXRlIHN0b3JlJ3MgcmV2YWxpZGF0ZSB0aW1lIGlmIGl0XG4gICAgICAgICAgICAgICAgLy8gd2FzIGV4cGxpY2l0bHkgc2V0IGZvciB0aGUgZmV0Y2ggY2FsbCwgaS5lLiBjdXJyZW50RmV0Y2hSZXZhbGlkYXRlLlxuICAgICAgICAgICAgICAgIGlmIChyZXZhbGlkYXRlU3RvcmUgJiYgY3VycmVudEZldGNoUmV2YWxpZGF0ZSA9PT0gZmluYWxSZXZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGVTdG9yZS5yZXZhbGlkYXRlID0gZmluYWxSZXZhbGlkYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzQ2FjaGVhYmxlUmV2YWxpZGF0ZSA9IHR5cGVvZiBmaW5hbFJldmFsaWRhdGUgPT09ICdudW1iZXInICYmIGZpbmFsUmV2YWxpZGF0ZSA+IDA7XG4gICAgICAgICAgICBsZXQgY2FjaGVLZXk7XG4gICAgICAgICAgICBjb25zdCB7IGluY3JlbWVudGFsQ2FjaGUgfSA9IHdvcmtTdG9yZTtcbiAgICAgICAgICAgIGNvbnN0IHVzZUNhY2hlT3JSZXF1ZXN0U3RvcmUgPSAod29ya1VuaXRTdG9yZSA9PSBudWxsID8gdm9pZCAwIDogd29ya1VuaXRTdG9yZS50eXBlKSA9PT0gJ3JlcXVlc3QnIHx8ICh3b3JrVW5pdFN0b3JlID09IG51bGwgPyB2b2lkIDAgOiB3b3JrVW5pdFN0b3JlLnR5cGUpID09PSAnY2FjaGUnID8gd29ya1VuaXRTdG9yZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnRhbENhY2hlICYmIChpc0NhY2hlYWJsZVJldmFsaWRhdGUgfHwgKHVzZUNhY2hlT3JSZXF1ZXN0U3RvcmUgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZUNhY2hlT3JSZXF1ZXN0U3RvcmUuc2VydmVyQ29tcG9uZW50c0htckNhY2hlKSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleSA9IGF3YWl0IGluY3JlbWVudGFsQ2FjaGUuZ2VuZXJhdGVDYWNoZUtleShmZXRjaFVybCwgaXNSZXF1ZXN0SW5wdXQgPyBpbnB1dCA6IGluaXQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUgY2FjaGUga2V5IGZvcmAsIGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmZXRjaElkeCA9IHdvcmtTdG9yZS5uZXh0RmV0Y2hJZCA/PyAxO1xuICAgICAgICAgICAgd29ya1N0b3JlLm5leHRGZXRjaElkID0gZmV0Y2hJZHggKyAxO1xuICAgICAgICAgICAgbGV0IGhhbmRsZVVubG9jayA9ICgpPT5Qcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGRvT3JpZ2luYWxGZXRjaCA9IGFzeW5jIChpc1N0YWxlLCBjYWNoZVJlYXNvbk92ZXJyaWRlKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJbnB1dEZpZWxkcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ2NhY2hlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NyZWRlbnRpYWxzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2hlYWRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAnaW50ZWdyaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgJ2tlZXBhbGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICdtZXRob2QnLFxuICAgICAgICAgICAgICAgICAgICAnbW9kZScsXG4gICAgICAgICAgICAgICAgICAgICdyZWRpcmVjdCcsXG4gICAgICAgICAgICAgICAgICAgICdyZWZlcnJlcicsXG4gICAgICAgICAgICAgICAgICAgICdyZWZlcnJlclBvbGljeScsXG4gICAgICAgICAgICAgICAgICAgICd3aW5kb3cnLFxuICAgICAgICAgICAgICAgICAgICAnZHVwbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgcGFzcyB0aHJvdWdoIHNpZ25hbCB3aGVuIHJldmFsaWRhdGluZ1xuICAgICAgICAgICAgICAgICAgICAuLi5pc1N0YWxlID8gW10gOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2lnbmFsJ1xuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXF1ZXN0SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxSW5wdXQgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHJlcUlucHV0Ll9vZ0JvZHkgfHwgcmVxSW5wdXQuYm9keVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHJlcXVlc3RJbnB1dEZpZWxkcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGN1c3RvbSBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcU9wdGlvbnNbZmllbGRdID0gcmVxSW5wdXRbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gbmV3IFJlcXVlc3QocmVxSW5wdXQudXJsLCByZXFPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBfb2dCb2R5LCBib2R5LCBzaWduYWwsIC4uLm90aGVySW5wdXQgfSA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vdGhlcklucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogX29nQm9keSB8fCBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBpc1N0YWxlID8gdW5kZWZpbmVkIDogc2lnbmFsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFkZCBtZXRhZGF0YSB0byBpbml0IHdpdGhvdXQgZWRpdGluZyB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9uZWRJbml0ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5pbml0LFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0Lm5leHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFR5cGU6ICdvcmlnaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hJZHhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbkZldGNoKGlucHV0LCBjbG9uZWRJbml0KS50aGVuKGFzeW5jIChyZXMpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTdGFsZSAmJiBmZXRjaFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja0ZldGNoTWV0cmljKHdvcmtTdG9yZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmZXRjaFN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZmV0Y2hVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVSZWFzb246IGNhY2hlUmVhc29uT3ZlcnJpZGUgfHwgY2FjaGVSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVTdGF0dXM6IGZpbmFsUmV2YWxpZGF0ZSA9PT0gMCB8fCBjYWNoZVJlYXNvbk92ZXJyaWRlID8gJ3NraXAnIDogJ21pc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlV2FybmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBjbG9uZWRJbml0Lm1ldGhvZCB8fCAnR0VUJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDIwMCAmJiBpbmNyZW1lbnRhbENhY2hlICYmIGNhY2hlS2V5ICYmIChpc0NhY2hlYWJsZVJldmFsaWRhdGUgfHwgKHVzZUNhY2hlT3JSZXF1ZXN0U3RvcmUgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZUNhY2hlT3JSZXF1ZXN0U3RvcmUuc2VydmVyQ29tcG9uZW50c0htckNhY2hlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRSZXZhbGlkYXRlID0gZmluYWxSZXZhbGlkYXRlID49IF9jb25zdGFudHMxLklORklOSVRFX0NBQ0hFID8gX2NvbnN0YW50czEuQ0FDSEVfT05FX1lFQVIgOiBmaW5hbFJldmFsaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya1VuaXRTdG9yZSAmJiB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIHByZXJlbmRlcmluZyBhdCBidWlsZCB0aW1lIG9yIHJldmFsaWRhdGUgdGltZSB3aXRoIGR5bmFtaWNJTyBzbyB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnVmZmVyIHRoZSByZXNwb25zZSBzbyB3ZSBjYW4gZ3VhcmFudGVlIGl0IGNhbiBiZSByZWFkIGluIGEgbWljcm90YXNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keUJ1ZmZlciA9IGF3YWl0IHJlcy5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoZWREYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMocmVzLmhlYWRlcnMuZW50cmllcygpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogQnVmZmVyLmZyb20oYm9keUJ1ZmZlcikudG9TdHJpbmcoJ2Jhc2U2NCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogcmVzLnVybFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHNraXAgY2hlY2tpbmcgdGhlIHNlcnZlckNvbXBvbmVudHNIbXJDYWNoZSBiZWNhdXNlIHdlIGFyZW4ndCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRldiBtb2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGluY3JlbWVudGFsQ2FjaGUuc2V0KGNhY2hlS2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IF9yZXNwb25zZWNhY2hlLkNhY2hlZFJvdXRlS2luZC5GRVRDSCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZmV0Y2hlZERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGU6IG5vcm1hbGl6ZWRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaENhY2hlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVVbmxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSByZXR1cm4gYSBuZXcgUmVzcG9uc2UgdG8gdGhlIGNhbGxlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHlCdWZmZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzLnN0YXR1c1RleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgY2xvbmluZyB0aGUgcmVzcG9uc2UgdXNpbmcgdGhpcyB1dGlsaXR5IGJlY2F1c2UgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleGlzdHMgYSBidWcgaW4gdGhlIHVuZGljaSBsaWJyYXJ5IGFyb3VuZCByZXNwb25zZSBjbG9uaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZSB0aGUgZm9sbG93aW5nIHB1bGwgcmVxdWVzdCBmb3IgbW9yZSBkZXRhaWxzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9wdWxsLzczMjc0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2Nsb25lZDEsIGNsb25lZDJdID0gKDAsIF9jbG9uZXJlc3BvbnNlLmNsb25lUmVzcG9uc2UpKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIGR5bmFtaWNhbGx5IHJlbmRlcmluZyBpbmNsdWRpbmcgZGV2IG1vZGUuIFdlIHdhbnQgdG8gcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlc3BvbnNlIHRvIHRoZSBjYWxsZXIgYXMgc29vbiBhcyBwb3NzaWJsZSBiZWNhdXNlIGl0IG1pZ2h0IHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG92ZXIgYSB2ZXJ5IGxvbmcgdGltZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWQxLmFycmF5QnVmZmVyKCkudGhlbihhc3luYyAoYXJyYXlCdWZmZXIpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdXNlQ2FjaGVPclJlcXVlc3RTdG9yZV9zZXJ2ZXJDb21wb25lbnRzSG1yQ2FjaGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlCdWZmZXIgPSBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoZWREYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKGNsb25lZDEuaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keUJ1ZmZlci50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGNsb25lZDEuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBjbG9uZWQxLnVybFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VDYWNoZU9yUmVxdWVzdFN0b3JlID09IG51bGwgPyB2b2lkIDAgOiAoX3VzZUNhY2hlT3JSZXF1ZXN0U3RvcmVfc2VydmVyQ29tcG9uZW50c0htckNhY2hlID0gdXNlQ2FjaGVPclJlcXVlc3RTdG9yZS5zZXJ2ZXJDb21wb25lbnRzSG1yQ2FjaGUpID09IG51bGwgPyB2b2lkIDAgOiBfdXNlQ2FjaGVPclJlcXVlc3RTdG9yZV9zZXJ2ZXJDb21wb25lbnRzSG1yQ2FjaGUuc2V0KGNhY2hlS2V5LCBmZXRjaGVkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NhY2hlYWJsZVJldmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGluY3JlbWVudGFsQ2FjaGUuc2V0KGNhY2hlS2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogX3Jlc3BvbnNlY2FjaGUuQ2FjaGVkUm91dGVLaW5kLkZFVENILFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGZldGNoZWREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGU6IG5vcm1hbGl6ZWRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hDYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaElkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcik9PmNvbnNvbGUud2FybihgRmFpbGVkIHRvIHNldCBmZXRjaCBjYWNoZWAsIGlucHV0LCBlcnJvcikpLmZpbmFsbHkoaGFuZGxlVW5sb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoYWQgcmVzcG9uc2UgdGhhdCB3ZSBkZXRlcm1pbmVkIHNob3VsZG4ndCBiZSBjYWNoZWQgc28gd2UgcmV0dXJuIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBkb24ndCBjYWNoZSBpdC4gVGhpcyBhbHNvIG5lZWRzIHRvIHVubG9jayB0aGUgY2FjaGUgbG9jayB3ZSBhY3F1aXJlZC5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlVW5sb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKT0+e1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVVbmxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGNhY2hlUmVhc29uT3ZlcnJpZGU7XG4gICAgICAgICAgICBsZXQgaXNGb3JlZ3JvdW5kUmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGlzSG1yUmVmcmVzaENhY2hlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2FjaGVLZXkgJiYgaW5jcmVtZW50YWxDYWNoZSkge1xuICAgICAgICAgICAgICAgIGxldCBjYWNoZWRGZXRjaERhdGE7XG4gICAgICAgICAgICAgICAgaWYgKCh1c2VDYWNoZU9yUmVxdWVzdFN0b3JlID09IG51bGwgPyB2b2lkIDAgOiB1c2VDYWNoZU9yUmVxdWVzdFN0b3JlLmlzSG1yUmVmcmVzaCkgJiYgdXNlQ2FjaGVPclJlcXVlc3RTdG9yZS5zZXJ2ZXJDb21wb25lbnRzSG1yQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkRmV0Y2hEYXRhID0gdXNlQ2FjaGVPclJlcXVlc3RTdG9yZS5zZXJ2ZXJDb21wb25lbnRzSG1yQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaXNIbXJSZWZyZXNoQ2FjaGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNDYWNoZWFibGVSZXZhbGlkYXRlICYmICFjYWNoZWRGZXRjaERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlVW5sb2NrID0gYXdhaXQgaW5jcmVtZW50YWxDYWNoZS5sb2NrKGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSB3b3JrU3RvcmUuaXNPbkRlbWFuZFJldmFsaWRhdGUgPyBudWxsIDogYXdhaXQgaW5jcmVtZW50YWxDYWNoZS5nZXQoY2FjaGVLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IF9yZXNwb25zZWNhY2hlLkluY3JlbWVudGFsQ2FjaGVLaW5kLkZFVENILFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZTogZmluYWxSZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaElkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2Z0VGFnczogaW1wbGljaXRUYWdzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTm9FeHBsaWNpdENhY2hlQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzb21ldGltZXMgdXNlIHRoZSBjYWNoZSB0byBkZWR1cGUgZmV0Y2hlcyB0aGF0IGRvIG5vdCBzcGVjaWZ5IGEgY2FjaGUgY29uZmlndXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlc2UgY2FzZXMgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2Ugc3RpbGwgZXhjbHVkZSB0aGVtIGZyb20gcHJlcmVuZGVycyBpZiBkeW5hbWljSU8gaXMgb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIGludHJvZHVjZSBhbiBhcnRpZmljaWFsIFRhc2sgYm91bmRhcnkgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JrVW5pdFN0b3JlICYmIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCAoMCwgX3NjaGVkdWxlci53YWl0QXRMZWFzdE9uZVJlYWN0UmVuZGVyVGFzaykoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZVVubG9jaygpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gZGV2LCBpbmNyZW1lbnRhbCBjYWNoZSByZXNwb25zZSB3aWxsIGJlIG51bGwgaW4gY2FzZSB0aGUgYnJvd3NlciBhZGRzIGBjYWNoZS1jb250cm9sOiBuby1jYWNoZWAgaW4gdGhlIHJlcXVlc3QgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVSZWFzb25PdmVycmlkZSA9ICdjYWNoZS1jb250cm9sOiBuby1jYWNoZSAoaGFyZCByZWZyZXNoKSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkudmFsdWUpICYmIGVudHJ5LnZhbHVlLmtpbmQgPT09IF9yZXNwb25zZWNhY2hlLkNhY2hlZFJvdXRlS2luZC5GRVRDSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBzdGFsZSBhbmQgaXMgcmV2YWxpZGF0aW5nIHdlIHdhaXQgZm9yIGZyZXNoIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHRoZSByZXZhbGlkYXRlZCBlbnRyeSBoYXMgdGhlIHVwZGF0ZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtTdG9yZS5pc1JldmFsaWRhdGUgJiYgZW50cnkuaXNTdGFsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRm9yZWdyb3VuZFJldmFsaWRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNTdGFsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrU3RvcmUucGVuZGluZ1JldmFsaWRhdGVzID8/PSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3b3JrU3RvcmUucGVuZGluZ1JldmFsaWRhdGVzW2NhY2hlS2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ1JldmFsaWRhdGUgPSBkb09yaWdpbmFsRmV0Y2godHJ1ZSkudGhlbihhc3luYyAocmVzcG9uc2UpPT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya1N0b3JlLnBlbmRpbmdSZXZhbGlkYXRlcyA/Pz0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdvcmtTdG9yZS5wZW5kaW5nUmV2YWxpZGF0ZXNbY2FjaGVLZXkgfHwgJyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRhY2ggdGhlIGVtcHR5IGNhdGNoIGhlcmUgc28gd2UgZG9uJ3QgZ2V0IGEgXCJ1bmhhbmRsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb21pc2UgcmVqZWN0aW9uXCIgd2FybmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdSZXZhbGlkYXRlLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya1N0b3JlLnBlbmRpbmdSZXZhbGlkYXRlc1tjYWNoZUtleV0gPSBwZW5kaW5nUmV2YWxpZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRGZXRjaERhdGEgPSBlbnRyeS52YWx1ZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRGZXRjaERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZldGNoU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrRmV0Y2hNZXRyaWMod29ya1N0b3JlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZldGNoU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBmZXRjaFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVN0YXR1czogaXNIbXJSZWZyZXNoQ2FjaGUgPyAnaG1yJyA6ICdoaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlV2FybmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGNhY2hlZEZldGNoRGF0YS5zdGF0dXMgfHwgMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQubWV0aG9kKSB8fCAnR0VUJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoQnVmZmVyLmZyb20oY2FjaGVkRmV0Y2hEYXRhLmJvZHksICdiYXNlNjQnKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogY2FjaGVkRmV0Y2hEYXRhLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGNhY2hlZEZldGNoRGF0YS5zdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ3VybCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjYWNoZWRGZXRjaERhdGEudXJsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdvcmtTdG9yZS5pc1N0YXRpY0dlbmVyYXRpb24gJiYgaW5pdCAmJiB0eXBlb2YgaW5pdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSBpbml0O1xuICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBgY2FjaGVgIHByb3BlcnR5IGFzIENsb3VkZmxhcmUgV29ya2VycyB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKGlzRWRnZVJ1bnRpbWUpIGRlbGV0ZSBpbml0LmNhY2hlO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZSA9PT0gJ25vLXN0b3JlJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBlbmFibGVkLCB3ZSBzaG91bGQgYmFpbCBvdXQgb2Ygc3RhdGljIGdlbmVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmICh3b3JrVW5pdFN0b3JlICYmIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZVNpZ25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlU2lnbmFsLmVuZFJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVNpZ25hbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9keW5hbWljcmVuZGVyaW5ndXRpbHMubWFrZUhhbmdpbmdQcm9taXNlKSh3b3JrVW5pdFN0b3JlLnJlbmRlclNpZ25hbCwgJ2ZldGNoKCknKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5tYXJrQ3VycmVudFNjb3BlQXNEeW5hbWljKSh3b3JrU3RvcmUsIHdvcmtVbml0U3RvcmUsIGBuby1zdG9yZSBmZXRjaCAke2lucHV0fSAke3dvcmtTdG9yZS5yb3V0ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBoYXNOZXh0Q29uZmlnID0gJ25leHQnIGluIGluaXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBuZXh0ID0ge30gfSA9IGluaXQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXh0LnJldmFsaWRhdGUgPT09ICdudW1iZXInICYmIHJldmFsaWRhdGVTdG9yZSAmJiBuZXh0LnJldmFsaWRhdGUgPCByZXZhbGlkYXRlU3RvcmUucmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5yZXZhbGlkYXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBlbmFibGVkLCB3ZSBzaG91bGQgYmFpbCBvdXQgb2Ygc3RhdGljIGdlbmVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya1VuaXRTdG9yZSAmJiB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfZHluYW1pY3JlbmRlcmluZ3V0aWxzLm1ha2VIYW5naW5nUHJvbWlzZSkod29ya1VuaXRTdG9yZS5yZW5kZXJTaWduYWwsICdmZXRjaCgpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5tYXJrQ3VycmVudFNjb3BlQXNEeW5hbWljKSh3b3JrU3RvcmUsIHdvcmtVbml0U3RvcmUsIGByZXZhbGlkYXRlOiAwIGZldGNoICR7aW5wdXR9ICR7d29ya1N0b3JlLnJvdXRlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghd29ya1N0b3JlLmZvcmNlU3RhdGljIHx8IG5leHQucmV2YWxpZGF0ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZVN0b3JlLnJldmFsaWRhdGUgPSBuZXh0LnJldmFsaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc05leHRDb25maWcpIGRlbGV0ZSBpbml0Lm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgcmV2YWxpZGF0aW5nIHRoZSB3aG9sZSBwYWdlIHZpYSB0aW1lIG9yIG9uLWRlbWFuZCBhbmRcbiAgICAgICAgICAgIC8vIHRoZSBmZXRjaCBjYWNoZSBlbnRyeSBpcyBzdGFsZSB3ZSBzaG91bGQgc3RpbGwgZGUtZHVwZSB0aGVcbiAgICAgICAgICAgIC8vIG9yaWdpbiBoaXQgaWYgaXQncyBhIGNhY2hlLWFibGUgZW50cnlcbiAgICAgICAgICAgIGlmIChjYWNoZUtleSAmJiBpc0ZvcmVncm91bmRSZXZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ1JldmFsaWRhdGVLZXkgPSBjYWNoZUtleTtcbiAgICAgICAgICAgICAgICB3b3JrU3RvcmUucGVuZGluZ1JldmFsaWRhdGVzID8/PSB7fTtcbiAgICAgICAgICAgICAgICBsZXQgcGVuZGluZ1JldmFsaWRhdGUgPSB3b3JrU3RvcmUucGVuZGluZ1JldmFsaWRhdGVzW3BlbmRpbmdSZXZhbGlkYXRlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ1JldmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV2YWxpZGF0ZWRSZXN1bHQgPSBhd2FpdCBwZW5kaW5nUmV2YWxpZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXZhbGlkYXRlZFJlc3VsdC5ib2R5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXZhbGlkYXRlZFJlc3VsdC5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXZhbGlkYXRlZFJlc3VsdC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXZhbGlkYXRlZFJlc3VsdC5zdGF0dXNUZXh0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSB1c2VkIHRvIGp1c3QgcmVzb2x2ZSB0aGUgUmVzcG9uc2UgYW5kIGNsb25lIGl0IGhvd2V2ZXIgZm9yXG4gICAgICAgICAgICAgICAgLy8gc3RhdGljIGdlbmVyYXRpb24gd2l0aCBkeW5hbWljSU8gd2UgbmVlZCB0aGUgcmVzcG9uc2UgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgICAgICAgIC8vIGJlIHJlc29sdmVkIGluIGEgbWljcm90YXNrIGFuZCBjbG9uaW5nIHRoZSByZXNwb25zZSB3aWxsIG5ldmVyIGhhdmVcbiAgICAgICAgICAgICAgICAvLyBhIGJvZHkgdGhhdCBjYW4gcmVzb2x2ZSBpbiBhIG1pY3JvdGFzayBpbiBub2RlIChhcyBvYnNlcnZlZCB0aHJvdWdoXG4gICAgICAgICAgICAgICAgLy8gZXhwZXJpbWVudGF0aW9uKSBTbyBpbnN0ZWFkIHdlIGF3YWl0IHRoZSBib2R5IGFuZCB0aGVuIHdoZW4gaXQgaXNcbiAgICAgICAgICAgICAgICAvLyBhdmFpbGFibGUgd2UgY29uc3RydWN0IG1hbnVhbGx5IGNsb25lZCBSZXNwb25zZSBvYmplY3RzIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gYm9keSBhcyBhbiBBcnJheUJ1ZmZlci4gVGhpcyB3aWxsIGJlIHJlc29sdmFibGUgaW4gYSBtaWNyb3Rhc2tcbiAgICAgICAgICAgICAgICAvLyBtYWtpbmcgaXQgY29tcGF0aWJsZSB3aXRoIGR5bmFtaWNJTy5cbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nUmVzcG9uc2UgPSBkb09yaWdpbmFsRmV0Y2godHJ1ZSwgY2FjaGVSZWFzb25PdmVycmlkZSkvLyBXZSdyZSBjbG9uaW5nIHRoZSByZXNwb25zZSB1c2luZyB0aGlzIHV0aWxpdHkgYmVjYXVzZSB0aGVyZVxuICAgICAgICAgICAgICAgIC8vIGV4aXN0cyBhIGJ1ZyBpbiB0aGUgdW5kaWNpIGxpYnJhcnkgYXJvdW5kIHJlc3BvbnNlIGNsb25pbmcuXG4gICAgICAgICAgICAgICAgLy8gU2VlIHRoZSBmb2xsb3dpbmcgcHVsbCByZXF1ZXN0IGZvciBtb3JlIGRldGFpbHM6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL3B1bGwvNzMyNzRcbiAgICAgICAgICAgICAgICAudGhlbihfY2xvbmVyZXNwb25zZS5jbG9uZVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmV2YWxpZGF0ZSA9IHBlbmRpbmdSZXNwb25zZS50aGVuKGFzeW5jIChyZXNwb25zZXMpPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcmVzcG9uc2VzWzBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgICAgIHZhciBfd29ya1N0b3JlX3BlbmRpbmdSZXZhbGlkYXRlcztcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBlbmRpbmcgcmV2YWxpZGF0ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgc3RvcmUsIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBub3RoaW5nIHRvIGRlbGV0ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoKF93b3JrU3RvcmVfcGVuZGluZ1JldmFsaWRhdGVzID0gd29ya1N0b3JlLnBlbmRpbmdSZXZhbGlkYXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF93b3JrU3RvcmVfcGVuZGluZ1JldmFsaWRhdGVzW3BlbmRpbmdSZXZhbGlkYXRlS2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgd29ya1N0b3JlLnBlbmRpbmdSZXZhbGlkYXRlc1twZW5kaW5nUmV2YWxpZGF0ZUtleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSBlbXB0eSBjYXRjaCBoZXJlIHNvIHdlIGRvbid0IGdldCBhIFwidW5oYW5kbGVkIHByb21pc2VcbiAgICAgICAgICAgICAgICAvLyByZWplY3Rpb25cIiB3YXJuaW5nXG4gICAgICAgICAgICAgICAgcGVuZGluZ1JldmFsaWRhdGUuY2F0Y2goKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICB3b3JrU3RvcmUucGVuZGluZ1JldmFsaWRhdGVzW3BlbmRpbmdSZXZhbGlkYXRlS2V5XSA9IHBlbmRpbmdSZXZhbGlkYXRlO1xuICAgICAgICAgICAgICAgIHJldHVybiBwZW5kaW5nUmVzcG9uc2UudGhlbigocmVzcG9uc2VzKT0+cmVzcG9uc2VzWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvT3JpZ2luYWxGZXRjaChmYWxzZSwgY2FjaGVSZWFzb25PdmVycmlkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FjaGVTaWduYWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVTaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVTaWduYWwuZW5kUmVhZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLy8gQXR0YWNoIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllcyB0byB0aGUgcGF0Y2hlZCBmZXRjaCBmdW5jdGlvbi5cbiAgICAvLyBXZSBkb24ndCB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaWYgdGhlIGZldGNoIGZ1bmN0aW9uIGhhcyBiZWVuIHBhdGNoZWQsXG4gICAgLy8gYnV0IGZvciBleHRlcm5hbCBjb25zdW1lcnMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmZXRjaCBmdW5jdGlvbiBoYXMgYmVlblxuICAgIC8vIHBhdGNoZWQuXG4gICAgcGF0Y2hlZC5fX25leHRQYXRjaGVkID0gdHJ1ZTtcbiAgICBwYXRjaGVkLl9fbmV4dEdldFN0YXRpY1N0b3JlID0gKCk9PndvcmtBc3luY1N0b3JhZ2U7XG4gICAgcGF0Y2hlZC5fbmV4dE9yaWdpbmFsRmV0Y2ggPSBvcmlnaW5GZXRjaDtcbiAgICBnbG9iYWxUaGlzW05FWFRfUEFUQ0hfU1lNQk9MXSA9IHRydWU7XG4gICAgcmV0dXJuIHBhdGNoZWQ7XG59XG5mdW5jdGlvbiBwYXRjaEZldGNoKG9wdGlvbnMpIHtcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHBhdGNoZWQgZmV0Y2gsIHdlIHNob3VsZCBub3QgcGF0Y2ggaXQgYWdhaW4uXG4gICAgaWYgKGlzRmV0Y2hQYXRjaGVkKCkpIHJldHVybjtcbiAgICAvLyBHcmFiIHRoZSBvcmlnaW5hbCBmZXRjaCBmdW5jdGlvbi4gV2UnbGwgYXR0YWNoIHRoaXMgc28gd2UgY2FuIHVzZSBpdCBpblxuICAgIC8vIHRoZSBwYXRjaGVkIGZldGNoIGZ1bmN0aW9uLlxuICAgIGNvbnN0IG9yaWdpbmFsID0gKDAsIF9kZWR1cGVmZXRjaC5jcmVhdGVEZWR1cGVGZXRjaCkoZ2xvYmFsVGhpcy5mZXRjaCk7XG4gICAgLy8gU2V0IHRoZSBnbG9iYWwgZmV0Y2ggdG8gdGhlIHBhdGNoZWQgZmV0Y2guXG4gICAgZ2xvYmFsVGhpcy5mZXRjaCA9IGNyZWF0ZVBhdGNoZWRGZXRjaGVyKG9yaWdpbmFsLCBvcHRpb25zKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0Y2gtZmV0Y2guanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/lib/trace/constants.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/server/lib/trace/constants.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * Contains predefined constants for the trace span name in next/server.\n *\n * Currently, next/server/tracer is internal implementation only for tracking\n * next.js's implementation only with known span names defined here.\n **/ // eslint typescript has a bug with TS enums\n/* eslint-disable no-shadow */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    AppRenderSpan: function() {\n        return AppRenderSpan;\n    },\n    AppRouteRouteHandlersSpan: function() {\n        return AppRouteRouteHandlersSpan;\n    },\n    BaseServerSpan: function() {\n        return BaseServerSpan;\n    },\n    LoadComponentsSpan: function() {\n        return LoadComponentsSpan;\n    },\n    LogSpanAllowList: function() {\n        return LogSpanAllowList;\n    },\n    MiddlewareSpan: function() {\n        return MiddlewareSpan;\n    },\n    NextNodeServerSpan: function() {\n        return NextNodeServerSpan;\n    },\n    NextServerSpan: function() {\n        return NextServerSpan;\n    },\n    NextVanillaSpanAllowlist: function() {\n        return NextVanillaSpanAllowlist;\n    },\n    NodeSpan: function() {\n        return NodeSpan;\n    },\n    RenderSpan: function() {\n        return RenderSpan;\n    },\n    ResolveMetadataSpan: function() {\n        return ResolveMetadataSpan;\n    },\n    RouterSpan: function() {\n        return RouterSpan;\n    },\n    StartServerSpan: function() {\n        return StartServerSpan;\n    }\n});\nvar BaseServerSpan = /*#__PURE__*/ function(BaseServerSpan) {\n    BaseServerSpan[\"handleRequest\"] = \"BaseServer.handleRequest\";\n    BaseServerSpan[\"run\"] = \"BaseServer.run\";\n    BaseServerSpan[\"pipe\"] = \"BaseServer.pipe\";\n    BaseServerSpan[\"getStaticHTML\"] = \"BaseServer.getStaticHTML\";\n    BaseServerSpan[\"render\"] = \"BaseServer.render\";\n    BaseServerSpan[\"renderToResponseWithComponents\"] = \"BaseServer.renderToResponseWithComponents\";\n    BaseServerSpan[\"renderToResponse\"] = \"BaseServer.renderToResponse\";\n    BaseServerSpan[\"renderToHTML\"] = \"BaseServer.renderToHTML\";\n    BaseServerSpan[\"renderError\"] = \"BaseServer.renderError\";\n    BaseServerSpan[\"renderErrorToResponse\"] = \"BaseServer.renderErrorToResponse\";\n    BaseServerSpan[\"renderErrorToHTML\"] = \"BaseServer.renderErrorToHTML\";\n    BaseServerSpan[\"render404\"] = \"BaseServer.render404\";\n    return BaseServerSpan;\n}(BaseServerSpan || {});\nvar LoadComponentsSpan = /*#__PURE__*/ function(LoadComponentsSpan) {\n    LoadComponentsSpan[\"loadDefaultErrorComponents\"] = \"LoadComponents.loadDefaultErrorComponents\";\n    LoadComponentsSpan[\"loadComponents\"] = \"LoadComponents.loadComponents\";\n    return LoadComponentsSpan;\n}(LoadComponentsSpan || {});\nvar NextServerSpan = /*#__PURE__*/ function(NextServerSpan) {\n    NextServerSpan[\"getRequestHandler\"] = \"NextServer.getRequestHandler\";\n    NextServerSpan[\"getServer\"] = \"NextServer.getServer\";\n    NextServerSpan[\"getServerRequestHandler\"] = \"NextServer.getServerRequestHandler\";\n    NextServerSpan[\"createServer\"] = \"createServer.createServer\";\n    return NextServerSpan;\n}(NextServerSpan || {});\nvar NextNodeServerSpan = /*#__PURE__*/ function(NextNodeServerSpan) {\n    NextNodeServerSpan[\"compression\"] = \"NextNodeServer.compression\";\n    NextNodeServerSpan[\"getBuildId\"] = \"NextNodeServer.getBuildId\";\n    NextNodeServerSpan[\"createComponentTree\"] = \"NextNodeServer.createComponentTree\";\n    NextNodeServerSpan[\"clientComponentLoading\"] = \"NextNodeServer.clientComponentLoading\";\n    NextNodeServerSpan[\"getLayoutOrPageModule\"] = \"NextNodeServer.getLayoutOrPageModule\";\n    NextNodeServerSpan[\"generateStaticRoutes\"] = \"NextNodeServer.generateStaticRoutes\";\n    NextNodeServerSpan[\"generateFsStaticRoutes\"] = \"NextNodeServer.generateFsStaticRoutes\";\n    NextNodeServerSpan[\"generatePublicRoutes\"] = \"NextNodeServer.generatePublicRoutes\";\n    NextNodeServerSpan[\"generateImageRoutes\"] = \"NextNodeServer.generateImageRoutes.route\";\n    NextNodeServerSpan[\"sendRenderResult\"] = \"NextNodeServer.sendRenderResult\";\n    NextNodeServerSpan[\"proxyRequest\"] = \"NextNodeServer.proxyRequest\";\n    NextNodeServerSpan[\"runApi\"] = \"NextNodeServer.runApi\";\n    NextNodeServerSpan[\"render\"] = \"NextNodeServer.render\";\n    NextNodeServerSpan[\"renderHTML\"] = \"NextNodeServer.renderHTML\";\n    NextNodeServerSpan[\"imageOptimizer\"] = \"NextNodeServer.imageOptimizer\";\n    NextNodeServerSpan[\"getPagePath\"] = \"NextNodeServer.getPagePath\";\n    NextNodeServerSpan[\"getRoutesManifest\"] = \"NextNodeServer.getRoutesManifest\";\n    NextNodeServerSpan[\"findPageComponents\"] = \"NextNodeServer.findPageComponents\";\n    NextNodeServerSpan[\"getFontManifest\"] = \"NextNodeServer.getFontManifest\";\n    NextNodeServerSpan[\"getServerComponentManifest\"] = \"NextNodeServer.getServerComponentManifest\";\n    NextNodeServerSpan[\"getRequestHandler\"] = \"NextNodeServer.getRequestHandler\";\n    NextNodeServerSpan[\"renderToHTML\"] = \"NextNodeServer.renderToHTML\";\n    NextNodeServerSpan[\"renderError\"] = \"NextNodeServer.renderError\";\n    NextNodeServerSpan[\"renderErrorToHTML\"] = \"NextNodeServer.renderErrorToHTML\";\n    NextNodeServerSpan[\"render404\"] = \"NextNodeServer.render404\";\n    NextNodeServerSpan[\"startResponse\"] = \"NextNodeServer.startResponse\";\n    // nested inner span, does not require parent scope name\n    NextNodeServerSpan[\"route\"] = \"route\";\n    NextNodeServerSpan[\"onProxyReq\"] = \"onProxyReq\";\n    NextNodeServerSpan[\"apiResolver\"] = \"apiResolver\";\n    NextNodeServerSpan[\"internalFetch\"] = \"internalFetch\";\n    return NextNodeServerSpan;\n}(NextNodeServerSpan || {});\nvar StartServerSpan = /*#__PURE__*/ function(StartServerSpan) {\n    StartServerSpan[\"startServer\"] = \"startServer.startServer\";\n    return StartServerSpan;\n}(StartServerSpan || {});\nvar RenderSpan = /*#__PURE__*/ function(RenderSpan) {\n    RenderSpan[\"getServerSideProps\"] = \"Render.getServerSideProps\";\n    RenderSpan[\"getStaticProps\"] = \"Render.getStaticProps\";\n    RenderSpan[\"renderToString\"] = \"Render.renderToString\";\n    RenderSpan[\"renderDocument\"] = \"Render.renderDocument\";\n    RenderSpan[\"createBodyResult\"] = \"Render.createBodyResult\";\n    return RenderSpan;\n}(RenderSpan || {});\nvar AppRenderSpan = /*#__PURE__*/ function(AppRenderSpan) {\n    AppRenderSpan[\"renderToString\"] = \"AppRender.renderToString\";\n    AppRenderSpan[\"renderToReadableStream\"] = \"AppRender.renderToReadableStream\";\n    AppRenderSpan[\"getBodyResult\"] = \"AppRender.getBodyResult\";\n    AppRenderSpan[\"fetch\"] = \"AppRender.fetch\";\n    return AppRenderSpan;\n}(AppRenderSpan || {});\nvar RouterSpan = /*#__PURE__*/ function(RouterSpan) {\n    RouterSpan[\"executeRoute\"] = \"Router.executeRoute\";\n    return RouterSpan;\n}(RouterSpan || {});\nvar NodeSpan = /*#__PURE__*/ function(NodeSpan) {\n    NodeSpan[\"runHandler\"] = \"Node.runHandler\";\n    return NodeSpan;\n}(NodeSpan || {});\nvar AppRouteRouteHandlersSpan = /*#__PURE__*/ function(AppRouteRouteHandlersSpan) {\n    AppRouteRouteHandlersSpan[\"runHandler\"] = \"AppRouteRouteHandlers.runHandler\";\n    return AppRouteRouteHandlersSpan;\n}(AppRouteRouteHandlersSpan || {});\nvar ResolveMetadataSpan = /*#__PURE__*/ function(ResolveMetadataSpan) {\n    ResolveMetadataSpan[\"generateMetadata\"] = \"ResolveMetadata.generateMetadata\";\n    ResolveMetadataSpan[\"generateViewport\"] = \"ResolveMetadata.generateViewport\";\n    return ResolveMetadataSpan;\n}(ResolveMetadataSpan || {});\nvar MiddlewareSpan = /*#__PURE__*/ function(MiddlewareSpan) {\n    MiddlewareSpan[\"execute\"] = \"Middleware.execute\";\n    return MiddlewareSpan;\n}(MiddlewareSpan || {});\nconst NextVanillaSpanAllowlist = [\n    \"Middleware.execute\",\n    \"BaseServer.handleRequest\",\n    \"Render.getServerSideProps\",\n    \"Render.getStaticProps\",\n    \"AppRender.fetch\",\n    \"AppRender.getBodyResult\",\n    \"Render.renderDocument\",\n    \"Node.runHandler\",\n    \"AppRouteRouteHandlers.runHandler\",\n    \"ResolveMetadata.generateMetadata\",\n    \"ResolveMetadata.generateViewport\",\n    \"NextNodeServer.createComponentTree\",\n    \"NextNodeServer.findPageComponents\",\n    \"NextNodeServer.getLayoutOrPageModule\",\n    \"NextNodeServer.startResponse\",\n    \"NextNodeServer.clientComponentLoading\"\n];\nconst LogSpanAllowList = [\n    \"NextNodeServer.findPageComponents\",\n    \"NextNodeServer.createComponentTree\",\n    \"NextNodeServer.clientComponentLoading\"\n];\n\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE0QztBQUM1Qyw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixNQUFNLENBZUw7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx5QkFBeUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUI7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx5QkFBeUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxDQUFDLGVBQWU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFxsaWJcXHRyYWNlXFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWlucyBwcmVkZWZpbmVkIGNvbnN0YW50cyBmb3IgdGhlIHRyYWNlIHNwYW4gbmFtZSBpbiBuZXh0L3NlcnZlci5cbiAqXG4gKiBDdXJyZW50bHksIG5leHQvc2VydmVyL3RyYWNlciBpcyBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvbmx5IGZvciB0cmFja2luZ1xuICogbmV4dC5qcydzIGltcGxlbWVudGF0aW9uIG9ubHkgd2l0aCBrbm93biBzcGFuIG5hbWVzIGRlZmluZWQgaGVyZS5cbiAqKi8gLy8gZXNsaW50IHR5cGVzY3JpcHQgaGFzIGEgYnVnIHdpdGggVFMgZW51bXNcbi8qIGVzbGludC1kaXNhYmxlIG5vLXNoYWRvdyAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIEFwcFJlbmRlclNwYW46IG51bGwsXG4gICAgQXBwUm91dGVSb3V0ZUhhbmRsZXJzU3BhbjogbnVsbCxcbiAgICBCYXNlU2VydmVyU3BhbjogbnVsbCxcbiAgICBMb2FkQ29tcG9uZW50c1NwYW46IG51bGwsXG4gICAgTG9nU3BhbkFsbG93TGlzdDogbnVsbCxcbiAgICBNaWRkbGV3YXJlU3BhbjogbnVsbCxcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW46IG51bGwsXG4gICAgTmV4dFNlcnZlclNwYW46IG51bGwsXG4gICAgTmV4dFZhbmlsbGFTcGFuQWxsb3dsaXN0OiBudWxsLFxuICAgIE5vZGVTcGFuOiBudWxsLFxuICAgIFJlbmRlclNwYW46IG51bGwsXG4gICAgUmVzb2x2ZU1ldGFkYXRhU3BhbjogbnVsbCxcbiAgICBSb3V0ZXJTcGFuOiBudWxsLFxuICAgIFN0YXJ0U2VydmVyU3BhbjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBBcHBSZW5kZXJTcGFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFwcFJlbmRlclNwYW47XG4gICAgfSxcbiAgICBBcHBSb3V0ZVJvdXRlSGFuZGxlcnNTcGFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFwcFJvdXRlUm91dGVIYW5kbGVyc1NwYW47XG4gICAgfSxcbiAgICBCYXNlU2VydmVyU3BhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBCYXNlU2VydmVyU3BhbjtcbiAgICB9LFxuICAgIExvYWRDb21wb25lbnRzU3BhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBMb2FkQ29tcG9uZW50c1NwYW47XG4gICAgfSxcbiAgICBMb2dTcGFuQWxsb3dMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIExvZ1NwYW5BbGxvd0xpc3Q7XG4gICAgfSxcbiAgICBNaWRkbGV3YXJlU3BhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNaWRkbGV3YXJlU3BhbjtcbiAgICB9LFxuICAgIE5leHROb2RlU2VydmVyU3BhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBOZXh0Tm9kZVNlcnZlclNwYW47XG4gICAgfSxcbiAgICBOZXh0U2VydmVyU3BhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBOZXh0U2VydmVyU3BhbjtcbiAgICB9LFxuICAgIE5leHRWYW5pbGxhU3BhbkFsbG93bGlzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBOZXh0VmFuaWxsYVNwYW5BbGxvd2xpc3Q7XG4gICAgfSxcbiAgICBOb2RlU3BhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBOb2RlU3BhbjtcbiAgICB9LFxuICAgIFJlbmRlclNwYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVuZGVyU3BhbjtcbiAgICB9LFxuICAgIFJlc29sdmVNZXRhZGF0YVNwYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVzb2x2ZU1ldGFkYXRhU3BhbjtcbiAgICB9LFxuICAgIFJvdXRlclNwYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUm91dGVyU3BhbjtcbiAgICB9LFxuICAgIFN0YXJ0U2VydmVyU3BhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTdGFydFNlcnZlclNwYW47XG4gICAgfVxufSk7XG52YXIgQmFzZVNlcnZlclNwYW4gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKEJhc2VTZXJ2ZXJTcGFuKSB7XG4gICAgQmFzZVNlcnZlclNwYW5bXCJoYW5kbGVSZXF1ZXN0XCJdID0gXCJCYXNlU2VydmVyLmhhbmRsZVJlcXVlc3RcIjtcbiAgICBCYXNlU2VydmVyU3BhbltcInJ1blwiXSA9IFwiQmFzZVNlcnZlci5ydW5cIjtcbiAgICBCYXNlU2VydmVyU3BhbltcInBpcGVcIl0gPSBcIkJhc2VTZXJ2ZXIucGlwZVwiO1xuICAgIEJhc2VTZXJ2ZXJTcGFuW1wiZ2V0U3RhdGljSFRNTFwiXSA9IFwiQmFzZVNlcnZlci5nZXRTdGF0aWNIVE1MXCI7XG4gICAgQmFzZVNlcnZlclNwYW5bXCJyZW5kZXJcIl0gPSBcIkJhc2VTZXJ2ZXIucmVuZGVyXCI7XG4gICAgQmFzZVNlcnZlclNwYW5bXCJyZW5kZXJUb1Jlc3BvbnNlV2l0aENvbXBvbmVudHNcIl0gPSBcIkJhc2VTZXJ2ZXIucmVuZGVyVG9SZXNwb25zZVdpdGhDb21wb25lbnRzXCI7XG4gICAgQmFzZVNlcnZlclNwYW5bXCJyZW5kZXJUb1Jlc3BvbnNlXCJdID0gXCJCYXNlU2VydmVyLnJlbmRlclRvUmVzcG9uc2VcIjtcbiAgICBCYXNlU2VydmVyU3BhbltcInJlbmRlclRvSFRNTFwiXSA9IFwiQmFzZVNlcnZlci5yZW5kZXJUb0hUTUxcIjtcbiAgICBCYXNlU2VydmVyU3BhbltcInJlbmRlckVycm9yXCJdID0gXCJCYXNlU2VydmVyLnJlbmRlckVycm9yXCI7XG4gICAgQmFzZVNlcnZlclNwYW5bXCJyZW5kZXJFcnJvclRvUmVzcG9uc2VcIl0gPSBcIkJhc2VTZXJ2ZXIucmVuZGVyRXJyb3JUb1Jlc3BvbnNlXCI7XG4gICAgQmFzZVNlcnZlclNwYW5bXCJyZW5kZXJFcnJvclRvSFRNTFwiXSA9IFwiQmFzZVNlcnZlci5yZW5kZXJFcnJvclRvSFRNTFwiO1xuICAgIEJhc2VTZXJ2ZXJTcGFuW1wicmVuZGVyNDA0XCJdID0gXCJCYXNlU2VydmVyLnJlbmRlcjQwNFwiO1xuICAgIHJldHVybiBCYXNlU2VydmVyU3Bhbjtcbn0oQmFzZVNlcnZlclNwYW4gfHwge30pO1xudmFyIExvYWRDb21wb25lbnRzU3BhbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTG9hZENvbXBvbmVudHNTcGFuKSB7XG4gICAgTG9hZENvbXBvbmVudHNTcGFuW1wibG9hZERlZmF1bHRFcnJvckNvbXBvbmVudHNcIl0gPSBcIkxvYWRDb21wb25lbnRzLmxvYWREZWZhdWx0RXJyb3JDb21wb25lbnRzXCI7XG4gICAgTG9hZENvbXBvbmVudHNTcGFuW1wibG9hZENvbXBvbmVudHNcIl0gPSBcIkxvYWRDb21wb25lbnRzLmxvYWRDb21wb25lbnRzXCI7XG4gICAgcmV0dXJuIExvYWRDb21wb25lbnRzU3Bhbjtcbn0oTG9hZENvbXBvbmVudHNTcGFuIHx8IHt9KTtcbnZhciBOZXh0U2VydmVyU3BhbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTmV4dFNlcnZlclNwYW4pIHtcbiAgICBOZXh0U2VydmVyU3BhbltcImdldFJlcXVlc3RIYW5kbGVyXCJdID0gXCJOZXh0U2VydmVyLmdldFJlcXVlc3RIYW5kbGVyXCI7XG4gICAgTmV4dFNlcnZlclNwYW5bXCJnZXRTZXJ2ZXJcIl0gPSBcIk5leHRTZXJ2ZXIuZ2V0U2VydmVyXCI7XG4gICAgTmV4dFNlcnZlclNwYW5bXCJnZXRTZXJ2ZXJSZXF1ZXN0SGFuZGxlclwiXSA9IFwiTmV4dFNlcnZlci5nZXRTZXJ2ZXJSZXF1ZXN0SGFuZGxlclwiO1xuICAgIE5leHRTZXJ2ZXJTcGFuW1wiY3JlYXRlU2VydmVyXCJdID0gXCJjcmVhdGVTZXJ2ZXIuY3JlYXRlU2VydmVyXCI7XG4gICAgcmV0dXJuIE5leHRTZXJ2ZXJTcGFuO1xufShOZXh0U2VydmVyU3BhbiB8fCB7fSk7XG52YXIgTmV4dE5vZGVTZXJ2ZXJTcGFuID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihOZXh0Tm9kZVNlcnZlclNwYW4pIHtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJjb21wcmVzc2lvblwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuY29tcHJlc3Npb25cIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJnZXRCdWlsZElkXCJdID0gXCJOZXh0Tm9kZVNlcnZlci5nZXRCdWlsZElkXCI7XG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuW1wiY3JlYXRlQ29tcG9uZW50VHJlZVwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuY3JlYXRlQ29tcG9uZW50VHJlZVwiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcImNsaWVudENvbXBvbmVudExvYWRpbmdcIl0gPSBcIk5leHROb2RlU2VydmVyLmNsaWVudENvbXBvbmVudExvYWRpbmdcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJnZXRMYXlvdXRPclBhZ2VNb2R1bGVcIl0gPSBcIk5leHROb2RlU2VydmVyLmdldExheW91dE9yUGFnZU1vZHVsZVwiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcImdlbmVyYXRlU3RhdGljUm91dGVzXCJdID0gXCJOZXh0Tm9kZVNlcnZlci5nZW5lcmF0ZVN0YXRpY1JvdXRlc1wiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcImdlbmVyYXRlRnNTdGF0aWNSb3V0ZXNcIl0gPSBcIk5leHROb2RlU2VydmVyLmdlbmVyYXRlRnNTdGF0aWNSb3V0ZXNcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJnZW5lcmF0ZVB1YmxpY1JvdXRlc1wiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuZ2VuZXJhdGVQdWJsaWNSb3V0ZXNcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJnZW5lcmF0ZUltYWdlUm91dGVzXCJdID0gXCJOZXh0Tm9kZVNlcnZlci5nZW5lcmF0ZUltYWdlUm91dGVzLnJvdXRlXCI7XG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuW1wic2VuZFJlbmRlclJlc3VsdFwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuc2VuZFJlbmRlclJlc3VsdFwiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcInByb3h5UmVxdWVzdFwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIucHJveHlSZXF1ZXN0XCI7XG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuW1wicnVuQXBpXCJdID0gXCJOZXh0Tm9kZVNlcnZlci5ydW5BcGlcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJyZW5kZXJcIl0gPSBcIk5leHROb2RlU2VydmVyLnJlbmRlclwiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcInJlbmRlckhUTUxcIl0gPSBcIk5leHROb2RlU2VydmVyLnJlbmRlckhUTUxcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJpbWFnZU9wdGltaXplclwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuaW1hZ2VPcHRpbWl6ZXJcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJnZXRQYWdlUGF0aFwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuZ2V0UGFnZVBhdGhcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJnZXRSb3V0ZXNNYW5pZmVzdFwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuZ2V0Um91dGVzTWFuaWZlc3RcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJmaW5kUGFnZUNvbXBvbmVudHNcIl0gPSBcIk5leHROb2RlU2VydmVyLmZpbmRQYWdlQ29tcG9uZW50c1wiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcImdldEZvbnRNYW5pZmVzdFwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIuZ2V0Rm9udE1hbmlmZXN0XCI7XG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuW1wiZ2V0U2VydmVyQ29tcG9uZW50TWFuaWZlc3RcIl0gPSBcIk5leHROb2RlU2VydmVyLmdldFNlcnZlckNvbXBvbmVudE1hbmlmZXN0XCI7XG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuW1wiZ2V0UmVxdWVzdEhhbmRsZXJcIl0gPSBcIk5leHROb2RlU2VydmVyLmdldFJlcXVlc3RIYW5kbGVyXCI7XG4gICAgTmV4dE5vZGVTZXJ2ZXJTcGFuW1wicmVuZGVyVG9IVE1MXCJdID0gXCJOZXh0Tm9kZVNlcnZlci5yZW5kZXJUb0hUTUxcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJyZW5kZXJFcnJvclwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIucmVuZGVyRXJyb3JcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJyZW5kZXJFcnJvclRvSFRNTFwiXSA9IFwiTmV4dE5vZGVTZXJ2ZXIucmVuZGVyRXJyb3JUb0hUTUxcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJyZW5kZXI0MDRcIl0gPSBcIk5leHROb2RlU2VydmVyLnJlbmRlcjQwNFwiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcInN0YXJ0UmVzcG9uc2VcIl0gPSBcIk5leHROb2RlU2VydmVyLnN0YXJ0UmVzcG9uc2VcIjtcbiAgICAvLyBuZXN0ZWQgaW5uZXIgc3BhbiwgZG9lcyBub3QgcmVxdWlyZSBwYXJlbnQgc2NvcGUgbmFtZVxuICAgIE5leHROb2RlU2VydmVyU3BhbltcInJvdXRlXCJdID0gXCJyb3V0ZVwiO1xuICAgIE5leHROb2RlU2VydmVyU3BhbltcIm9uUHJveHlSZXFcIl0gPSBcIm9uUHJveHlSZXFcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJhcGlSZXNvbHZlclwiXSA9IFwiYXBpUmVzb2x2ZXJcIjtcbiAgICBOZXh0Tm9kZVNlcnZlclNwYW5bXCJpbnRlcm5hbEZldGNoXCJdID0gXCJpbnRlcm5hbEZldGNoXCI7XG4gICAgcmV0dXJuIE5leHROb2RlU2VydmVyU3Bhbjtcbn0oTmV4dE5vZGVTZXJ2ZXJTcGFuIHx8IHt9KTtcbnZhciBTdGFydFNlcnZlclNwYW4gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFN0YXJ0U2VydmVyU3Bhbikge1xuICAgIFN0YXJ0U2VydmVyU3BhbltcInN0YXJ0U2VydmVyXCJdID0gXCJzdGFydFNlcnZlci5zdGFydFNlcnZlclwiO1xuICAgIHJldHVybiBTdGFydFNlcnZlclNwYW47XG59KFN0YXJ0U2VydmVyU3BhbiB8fCB7fSk7XG52YXIgUmVuZGVyU3BhbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUmVuZGVyU3Bhbikge1xuICAgIFJlbmRlclNwYW5bXCJnZXRTZXJ2ZXJTaWRlUHJvcHNcIl0gPSBcIlJlbmRlci5nZXRTZXJ2ZXJTaWRlUHJvcHNcIjtcbiAgICBSZW5kZXJTcGFuW1wiZ2V0U3RhdGljUHJvcHNcIl0gPSBcIlJlbmRlci5nZXRTdGF0aWNQcm9wc1wiO1xuICAgIFJlbmRlclNwYW5bXCJyZW5kZXJUb1N0cmluZ1wiXSA9IFwiUmVuZGVyLnJlbmRlclRvU3RyaW5nXCI7XG4gICAgUmVuZGVyU3BhbltcInJlbmRlckRvY3VtZW50XCJdID0gXCJSZW5kZXIucmVuZGVyRG9jdW1lbnRcIjtcbiAgICBSZW5kZXJTcGFuW1wiY3JlYXRlQm9keVJlc3VsdFwiXSA9IFwiUmVuZGVyLmNyZWF0ZUJvZHlSZXN1bHRcIjtcbiAgICByZXR1cm4gUmVuZGVyU3Bhbjtcbn0oUmVuZGVyU3BhbiB8fCB7fSk7XG52YXIgQXBwUmVuZGVyU3BhbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQXBwUmVuZGVyU3Bhbikge1xuICAgIEFwcFJlbmRlclNwYW5bXCJyZW5kZXJUb1N0cmluZ1wiXSA9IFwiQXBwUmVuZGVyLnJlbmRlclRvU3RyaW5nXCI7XG4gICAgQXBwUmVuZGVyU3BhbltcInJlbmRlclRvUmVhZGFibGVTdHJlYW1cIl0gPSBcIkFwcFJlbmRlci5yZW5kZXJUb1JlYWRhYmxlU3RyZWFtXCI7XG4gICAgQXBwUmVuZGVyU3BhbltcImdldEJvZHlSZXN1bHRcIl0gPSBcIkFwcFJlbmRlci5nZXRCb2R5UmVzdWx0XCI7XG4gICAgQXBwUmVuZGVyU3BhbltcImZldGNoXCJdID0gXCJBcHBSZW5kZXIuZmV0Y2hcIjtcbiAgICByZXR1cm4gQXBwUmVuZGVyU3Bhbjtcbn0oQXBwUmVuZGVyU3BhbiB8fCB7fSk7XG52YXIgUm91dGVyU3BhbiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oUm91dGVyU3Bhbikge1xuICAgIFJvdXRlclNwYW5bXCJleGVjdXRlUm91dGVcIl0gPSBcIlJvdXRlci5leGVjdXRlUm91dGVcIjtcbiAgICByZXR1cm4gUm91dGVyU3Bhbjtcbn0oUm91dGVyU3BhbiB8fCB7fSk7XG52YXIgTm9kZVNwYW4gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vZGVTcGFuKSB7XG4gICAgTm9kZVNwYW5bXCJydW5IYW5kbGVyXCJdID0gXCJOb2RlLnJ1bkhhbmRsZXJcIjtcbiAgICByZXR1cm4gTm9kZVNwYW47XG59KE5vZGVTcGFuIHx8IHt9KTtcbnZhciBBcHBSb3V0ZVJvdXRlSGFuZGxlcnNTcGFuID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihBcHBSb3V0ZVJvdXRlSGFuZGxlcnNTcGFuKSB7XG4gICAgQXBwUm91dGVSb3V0ZUhhbmRsZXJzU3BhbltcInJ1bkhhbmRsZXJcIl0gPSBcIkFwcFJvdXRlUm91dGVIYW5kbGVycy5ydW5IYW5kbGVyXCI7XG4gICAgcmV0dXJuIEFwcFJvdXRlUm91dGVIYW5kbGVyc1NwYW47XG59KEFwcFJvdXRlUm91dGVIYW5kbGVyc1NwYW4gfHwge30pO1xudmFyIFJlc29sdmVNZXRhZGF0YVNwYW4gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKFJlc29sdmVNZXRhZGF0YVNwYW4pIHtcbiAgICBSZXNvbHZlTWV0YWRhdGFTcGFuW1wiZ2VuZXJhdGVNZXRhZGF0YVwiXSA9IFwiUmVzb2x2ZU1ldGFkYXRhLmdlbmVyYXRlTWV0YWRhdGFcIjtcbiAgICBSZXNvbHZlTWV0YWRhdGFTcGFuW1wiZ2VuZXJhdGVWaWV3cG9ydFwiXSA9IFwiUmVzb2x2ZU1ldGFkYXRhLmdlbmVyYXRlVmlld3BvcnRcIjtcbiAgICByZXR1cm4gUmVzb2x2ZU1ldGFkYXRhU3Bhbjtcbn0oUmVzb2x2ZU1ldGFkYXRhU3BhbiB8fCB7fSk7XG52YXIgTWlkZGxld2FyZVNwYW4gPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE1pZGRsZXdhcmVTcGFuKSB7XG4gICAgTWlkZGxld2FyZVNwYW5bXCJleGVjdXRlXCJdID0gXCJNaWRkbGV3YXJlLmV4ZWN1dGVcIjtcbiAgICByZXR1cm4gTWlkZGxld2FyZVNwYW47XG59KE1pZGRsZXdhcmVTcGFuIHx8IHt9KTtcbmNvbnN0IE5leHRWYW5pbGxhU3BhbkFsbG93bGlzdCA9IFtcbiAgICBcIk1pZGRsZXdhcmUuZXhlY3V0ZVwiLFxuICAgIFwiQmFzZVNlcnZlci5oYW5kbGVSZXF1ZXN0XCIsXG4gICAgXCJSZW5kZXIuZ2V0U2VydmVyU2lkZVByb3BzXCIsXG4gICAgXCJSZW5kZXIuZ2V0U3RhdGljUHJvcHNcIixcbiAgICBcIkFwcFJlbmRlci5mZXRjaFwiLFxuICAgIFwiQXBwUmVuZGVyLmdldEJvZHlSZXN1bHRcIixcbiAgICBcIlJlbmRlci5yZW5kZXJEb2N1bWVudFwiLFxuICAgIFwiTm9kZS5ydW5IYW5kbGVyXCIsXG4gICAgXCJBcHBSb3V0ZVJvdXRlSGFuZGxlcnMucnVuSGFuZGxlclwiLFxuICAgIFwiUmVzb2x2ZU1ldGFkYXRhLmdlbmVyYXRlTWV0YWRhdGFcIixcbiAgICBcIlJlc29sdmVNZXRhZGF0YS5nZW5lcmF0ZVZpZXdwb3J0XCIsXG4gICAgXCJOZXh0Tm9kZVNlcnZlci5jcmVhdGVDb21wb25lbnRUcmVlXCIsXG4gICAgXCJOZXh0Tm9kZVNlcnZlci5maW5kUGFnZUNvbXBvbmVudHNcIixcbiAgICBcIk5leHROb2RlU2VydmVyLmdldExheW91dE9yUGFnZU1vZHVsZVwiLFxuICAgIFwiTmV4dE5vZGVTZXJ2ZXIuc3RhcnRSZXNwb25zZVwiLFxuICAgIFwiTmV4dE5vZGVTZXJ2ZXIuY2xpZW50Q29tcG9uZW50TG9hZGluZ1wiXG5dO1xuY29uc3QgTG9nU3BhbkFsbG93TGlzdCA9IFtcbiAgICBcIk5leHROb2RlU2VydmVyLmZpbmRQYWdlQ29tcG9uZW50c1wiLFxuICAgIFwiTmV4dE5vZGVTZXJ2ZXIuY3JlYXRlQ29tcG9uZW50VHJlZVwiLFxuICAgIFwiTmV4dE5vZGVTZXJ2ZXIuY2xpZW50Q29tcG9uZW50TG9hZGluZ1wiXG5dO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/lib/trace/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/lib/trace/tracer.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/server/lib/trace/tracer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    BubbledError: function() {\n        return BubbledError;\n    },\n    SpanKind: function() {\n        return SpanKind;\n    },\n    SpanStatusCode: function() {\n        return SpanStatusCode;\n    },\n    getTracer: function() {\n        return getTracer;\n    },\n    isBubbledError: function() {\n        return isBubbledError;\n    }\n});\nconst _constants = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/next/dist/server/lib/trace/constants.js\");\nconst _isthenable = __webpack_require__(/*! ../../../shared/lib/is-thenable */ \"(rsc)/./node_modules/next/dist/shared/lib/is-thenable.js\");\nlet api;\n// we want to allow users to use their own version of @opentelemetry/api if they\n// want to, so we try to require it first, and if it fails we fall back to the\n// version that is bundled with Next.js\n// this is because @opentelemetry/api has to be synced with the version of\n// @opentelemetry/tracing that is used, and we don't want to force users to use\n// the version that is bundled with Next.js.\n// the API is ~stable, so this should be fine\nif (false) {} else {\n    try {\n        api = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/next/dist/compiled/@opentelemetry/api/index.js\");\n    } catch (err) {\n        api = __webpack_require__(/*! next/dist/compiled/@opentelemetry/api */ \"(rsc)/./node_modules/next/dist/compiled/@opentelemetry/api/index.js\");\n    }\n}\nconst { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } = api;\nclass BubbledError extends Error {\n    constructor(bubble, result){\n        super(), this.bubble = bubble, this.result = result;\n    }\n}\nfunction isBubbledError(error) {\n    if (typeof error !== 'object' || error === null) return false;\n    return error instanceof BubbledError;\n}\nconst closeSpanWithError = (span, error)=>{\n    if (isBubbledError(error) && error.bubble) {\n        span.setAttribute('next.bubble', true);\n    } else {\n        if (error) {\n            span.recordException(error);\n        }\n        span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: error == null ? void 0 : error.message\n        });\n    }\n    span.end();\n};\n/** we use this map to propagate attributes from nested spans to the top span */ const rootSpanAttributesStore = new Map();\nconst rootSpanIdKey = api.createContextKey('next.rootSpanId');\nlet lastSpanId = 0;\nconst getSpanId = ()=>lastSpanId++;\nconst clientTraceDataSetter = {\n    set (carrier, key, value) {\n        carrier.push({\n            key,\n            value\n        });\n    }\n};\nclass NextTracerImpl {\n    /**\n   * Returns an instance to the trace with configured name.\n   * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,\n   * This should be lazily evaluated.\n   */ getTracerInstance() {\n        return trace.getTracer('next.js', '0.0.1');\n    }\n    getContext() {\n        return context;\n    }\n    getTracePropagationData() {\n        const activeContext = context.active();\n        const entries = [];\n        propagation.inject(activeContext, entries, clientTraceDataSetter);\n        return entries;\n    }\n    getActiveScopeSpan() {\n        return trace.getSpan(context == null ? void 0 : context.active());\n    }\n    withPropagatedContext(carrier, fn, getter) {\n        const activeContext = context.active();\n        if (trace.getSpanContext(activeContext)) {\n            // Active span is already set, too late to propagate.\n            return fn();\n        }\n        const remoteContext = propagation.extract(activeContext, carrier, getter);\n        return context.with(remoteContext, fn);\n    }\n    trace(...args) {\n        var _trace_getSpanContext;\n        const [type, fnOrOptions, fnOrEmpty] = args;\n        // coerce options form overload\n        const { fn, options } = typeof fnOrOptions === 'function' ? {\n            fn: fnOrOptions,\n            options: {}\n        } : {\n            fn: fnOrEmpty,\n            options: {\n                ...fnOrOptions\n            }\n        };\n        const spanName = options.spanName ?? type;\n        if (!_constants.NextVanillaSpanAllowlist.includes(type) && process.env.NEXT_OTEL_VERBOSE !== '1' || options.hideSpan) {\n            return fn();\n        }\n        // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.\n        let spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());\n        let isRootSpan = false;\n        if (!spanContext) {\n            spanContext = (context == null ? void 0 : context.active()) ?? ROOT_CONTEXT;\n            isRootSpan = true;\n        } else if ((_trace_getSpanContext = trace.getSpanContext(spanContext)) == null ? void 0 : _trace_getSpanContext.isRemote) {\n            isRootSpan = true;\n        }\n        const spanId = getSpanId();\n        options.attributes = {\n            'next.span_name': spanName,\n            'next.span_type': type,\n            ...options.attributes\n        };\n        return context.with(spanContext.setValue(rootSpanIdKey, spanId), ()=>this.getTracerInstance().startActiveSpan(spanName, options, (span)=>{\n                const startTime = 'performance' in globalThis && 'measure' in performance ? globalThis.performance.now() : undefined;\n                const onCleanup = ()=>{\n                    rootSpanAttributesStore.delete(spanId);\n                    if (startTime && process.env.NEXT_OTEL_PERFORMANCE_PREFIX && _constants.LogSpanAllowList.includes(type || '')) {\n                        performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(type.split('.').pop() || '').replace(/[A-Z]/g, (match)=>'-' + match.toLowerCase())}`, {\n                            start: startTime,\n                            end: performance.now()\n                        });\n                    }\n                };\n                if (isRootSpan) {\n                    rootSpanAttributesStore.set(spanId, new Map(Object.entries(options.attributes ?? {})));\n                }\n                try {\n                    if (fn.length > 1) {\n                        return fn(span, (err)=>closeSpanWithError(span, err));\n                    }\n                    const result = fn(span);\n                    if ((0, _isthenable.isThenable)(result)) {\n                        // If there's error make sure it throws\n                        return result.then((res)=>{\n                            span.end();\n                            // Need to pass down the promise result,\n                            // it could be react stream response with error { error, stream }\n                            return res;\n                        }).catch((err)=>{\n                            closeSpanWithError(span, err);\n                            throw err;\n                        }).finally(onCleanup);\n                    } else {\n                        span.end();\n                        onCleanup();\n                    }\n                    return result;\n                } catch (err) {\n                    closeSpanWithError(span, err);\n                    onCleanup();\n                    throw err;\n                }\n            }));\n    }\n    wrap(...args) {\n        const tracer = this;\n        const [name, options, fn] = args.length === 3 ? args : [\n            args[0],\n            {},\n            args[1]\n        ];\n        if (!_constants.NextVanillaSpanAllowlist.includes(name) && process.env.NEXT_OTEL_VERBOSE !== '1') {\n            return fn;\n        }\n        return function() {\n            let optionsObj = options;\n            if (typeof optionsObj === 'function' && typeof fn === 'function') {\n                optionsObj = optionsObj.apply(this, arguments);\n            }\n            const lastArgId = arguments.length - 1;\n            const cb = arguments[lastArgId];\n            if (typeof cb === 'function') {\n                const scopeBoundCb = tracer.getContext().bind(context.active(), cb);\n                return tracer.trace(name, optionsObj, (_span, done)=>{\n                    arguments[lastArgId] = function(err) {\n                        done == null ? void 0 : done(err);\n                        return scopeBoundCb.apply(this, arguments);\n                    };\n                    return fn.apply(this, arguments);\n                });\n            } else {\n                return tracer.trace(name, optionsObj, ()=>fn.apply(this, arguments));\n            }\n        };\n    }\n    startSpan(...args) {\n        const [type, options] = args;\n        const spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());\n        return this.getTracerInstance().startSpan(type, options, spanContext);\n    }\n    getSpanContext(parentSpan) {\n        const spanContext = parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined;\n        return spanContext;\n    }\n    getRootSpanAttributes() {\n        const spanId = context.active().getValue(rootSpanIdKey);\n        return rootSpanAttributesStore.get(spanId);\n    }\n    setRootSpanAttribute(key, value) {\n        const spanId = context.active().getValue(rootSpanIdKey);\n        const attributes = rootSpanAttributesStore.get(spanId);\n        if (attributes) {\n            attributes.set(key, value);\n        }\n    }\n}\nconst getTracer = (()=>{\n    const tracer = new NextTracerImpl();\n    return ()=>tracer;\n})();\n\n//# sourceMappingURL=tracer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvdHJhY2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsTUFBTSxDQU1MO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQixtQkFBTyxDQUFDLGlGQUFhO0FBQ3hDLG9CQUFvQixtQkFBTyxDQUFDLGlHQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFtQyxFQUFFLEVBRXhDLENBQUM7QUFDRjtBQUNBLGNBQWMsbUJBQU8sQ0FBQywrRkFBb0I7QUFDMUMsTUFBTTtBQUNOLGNBQWMsbUJBQU8sQ0FBQyxrSEFBdUM7QUFDN0Q7QUFDQTtBQUNBLFFBQVEsc0VBQXNFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx5Q0FBeUMsUUFBUSxvRkFBb0Y7QUFDcEw7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxcbGliXFx0cmFjZVxcdHJhY2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQnViYmxlZEVycm9yOiBudWxsLFxuICAgIFNwYW5LaW5kOiBudWxsLFxuICAgIFNwYW5TdGF0dXNDb2RlOiBudWxsLFxuICAgIGdldFRyYWNlcjogbnVsbCxcbiAgICBpc0J1YmJsZWRFcnJvcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBCdWJibGVkRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQnViYmxlZEVycm9yO1xuICAgIH0sXG4gICAgU3BhbktpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU3BhbktpbmQ7XG4gICAgfSxcbiAgICBTcGFuU3RhdHVzQ29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTcGFuU3RhdHVzQ29kZTtcbiAgICB9LFxuICAgIGdldFRyYWNlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRUcmFjZXI7XG4gICAgfSxcbiAgICBpc0J1YmJsZWRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc0J1YmJsZWRFcnJvcjtcbiAgICB9XG59KTtcbmNvbnN0IF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBfaXN0aGVuYWJsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zaGFyZWQvbGliL2lzLXRoZW5hYmxlXCIpO1xubGV0IGFwaTtcbi8vIHdlIHdhbnQgdG8gYWxsb3cgdXNlcnMgdG8gdXNlIHRoZWlyIG93biB2ZXJzaW9uIG9mIEBvcGVudGVsZW1ldHJ5L2FwaSBpZiB0aGV5XG4vLyB3YW50IHRvLCBzbyB3ZSB0cnkgdG8gcmVxdWlyZSBpdCBmaXJzdCwgYW5kIGlmIGl0IGZhaWxzIHdlIGZhbGwgYmFjayB0byB0aGVcbi8vIHZlcnNpb24gdGhhdCBpcyBidW5kbGVkIHdpdGggTmV4dC5qc1xuLy8gdGhpcyBpcyBiZWNhdXNlIEBvcGVudGVsZW1ldHJ5L2FwaSBoYXMgdG8gYmUgc3luY2VkIHdpdGggdGhlIHZlcnNpb24gb2Zcbi8vIEBvcGVudGVsZW1ldHJ5L3RyYWNpbmcgdGhhdCBpcyB1c2VkLCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSB1c2VycyB0byB1c2Vcbi8vIHRoZSB2ZXJzaW9uIHRoYXQgaXMgYnVuZGxlZCB3aXRoIE5leHQuanMuXG4vLyB0aGUgQVBJIGlzIH5zdGFibGUsIHNvIHRoaXMgc2hvdWxkIGJlIGZpbmVcbmlmIChwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdlZGdlJykge1xuICAgIGFwaSA9IHJlcXVpcmUoJ0BvcGVudGVsZW1ldHJ5L2FwaScpO1xufSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgICBhcGkgPSByZXF1aXJlKCdAb3BlbnRlbGVtZXRyeS9hcGknKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgYXBpID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL0BvcGVudGVsZW1ldHJ5L2FwaScpO1xuICAgIH1cbn1cbmNvbnN0IHsgY29udGV4dCwgcHJvcGFnYXRpb24sIHRyYWNlLCBTcGFuU3RhdHVzQ29kZSwgU3BhbktpbmQsIFJPT1RfQ09OVEVYVCB9ID0gYXBpO1xuY2xhc3MgQnViYmxlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ1YmJsZSwgcmVzdWx0KXtcbiAgICAgICAgc3VwZXIoKSwgdGhpcy5idWJibGUgPSBidWJibGUsIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQnViYmxlZEVycm9yKGVycm9yKSB7XG4gICAgaWYgKHR5cGVvZiBlcnJvciAhPT0gJ29iamVjdCcgfHwgZXJyb3IgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBCdWJibGVkRXJyb3I7XG59XG5jb25zdCBjbG9zZVNwYW5XaXRoRXJyb3IgPSAoc3BhbiwgZXJyb3IpPT57XG4gICAgaWYgKGlzQnViYmxlZEVycm9yKGVycm9yKSAmJiBlcnJvci5idWJibGUpIHtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoJ25leHQuYnViYmxlJywgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Bhbi5lbmQoKTtcbn07XG4vKiogd2UgdXNlIHRoaXMgbWFwIHRvIHByb3BhZ2F0ZSBhdHRyaWJ1dGVzIGZyb20gbmVzdGVkIHNwYW5zIHRvIHRoZSB0b3Agc3BhbiAqLyBjb25zdCByb290U3BhbkF0dHJpYnV0ZXNTdG9yZSA9IG5ldyBNYXAoKTtcbmNvbnN0IHJvb3RTcGFuSWRLZXkgPSBhcGkuY3JlYXRlQ29udGV4dEtleSgnbmV4dC5yb290U3BhbklkJyk7XG5sZXQgbGFzdFNwYW5JZCA9IDA7XG5jb25zdCBnZXRTcGFuSWQgPSAoKT0+bGFzdFNwYW5JZCsrO1xuY29uc3QgY2xpZW50VHJhY2VEYXRhU2V0dGVyID0ge1xuICAgIHNldCAoY2Fycmllciwga2V5LCB2YWx1ZSkge1xuICAgICAgICBjYXJyaWVyLnB1c2goe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNsYXNzIE5leHRUcmFjZXJJbXBsIHtcbiAgICAvKipcbiAgICogUmV0dXJucyBhbiBpbnN0YW5jZSB0byB0aGUgdHJhY2Ugd2l0aCBjb25maWd1cmVkIG5hbWUuXG4gICAqIFNpbmNlIHdyYXAgLyB0cmFjZSBjYW4gYmUgZGVmaW5lZCBpbiBhbnkgcGxhY2UgcHJpb3IgdG8gYWN0dWFsIHRyYWNlIHN1YnNjcmliZXIgaW5pdGlhbGl6YXRpb24sXG4gICAqIFRoaXMgc2hvdWxkIGJlIGxhemlseSBldmFsdWF0ZWQuXG4gICAqLyBnZXRUcmFjZXJJbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlLmdldFRyYWNlcignbmV4dC5qcycsICcwLjAuMScpO1xuICAgIH1cbiAgICBnZXRDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgZ2V0VHJhY2VQcm9wYWdhdGlvbkRhdGEoKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUNvbnRleHQgPSBjb250ZXh0LmFjdGl2ZSgpO1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgICAgIHByb3BhZ2F0aW9uLmluamVjdChhY3RpdmVDb250ZXh0LCBlbnRyaWVzLCBjbGllbnRUcmFjZURhdGFTZXR0ZXIpO1xuICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICB9XG4gICAgZ2V0QWN0aXZlU2NvcGVTcGFuKCkge1xuICAgICAgICByZXR1cm4gdHJhY2UuZ2V0U3Bhbihjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0LmFjdGl2ZSgpKTtcbiAgICB9XG4gICAgd2l0aFByb3BhZ2F0ZWRDb250ZXh0KGNhcnJpZXIsIGZuLCBnZXR0ZXIpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlQ29udGV4dCA9IGNvbnRleHQuYWN0aXZlKCk7XG4gICAgICAgIGlmICh0cmFjZS5nZXRTcGFuQ29udGV4dChhY3RpdmVDb250ZXh0KSkge1xuICAgICAgICAgICAgLy8gQWN0aXZlIHNwYW4gaXMgYWxyZWFkeSBzZXQsIHRvbyBsYXRlIHRvIHByb3BhZ2F0ZS5cbiAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbW90ZUNvbnRleHQgPSBwcm9wYWdhdGlvbi5leHRyYWN0KGFjdGl2ZUNvbnRleHQsIGNhcnJpZXIsIGdldHRlcik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LndpdGgocmVtb3RlQ29udGV4dCwgZm4pO1xuICAgIH1cbiAgICB0cmFjZSguLi5hcmdzKSB7XG4gICAgICAgIHZhciBfdHJhY2VfZ2V0U3BhbkNvbnRleHQ7XG4gICAgICAgIGNvbnN0IFt0eXBlLCBmbk9yT3B0aW9ucywgZm5PckVtcHR5XSA9IGFyZ3M7XG4gICAgICAgIC8vIGNvZXJjZSBvcHRpb25zIGZvcm0gb3ZlcmxvYWRcbiAgICAgICAgY29uc3QgeyBmbiwgb3B0aW9ucyB9ID0gdHlwZW9mIGZuT3JPcHRpb25zID09PSAnZnVuY3Rpb24nID8ge1xuICAgICAgICAgICAgZm46IGZuT3JPcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9uczoge31cbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGZuOiBmbk9yRW1wdHksXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgLi4uZm5Pck9wdGlvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3Bhbk5hbWUgPSBvcHRpb25zLnNwYW5OYW1lID8/IHR5cGU7XG4gICAgICAgIGlmICghX2NvbnN0YW50cy5OZXh0VmFuaWxsYVNwYW5BbGxvd2xpc3QuaW5jbHVkZXModHlwZSkgJiYgcHJvY2Vzcy5lbnYuTkVYVF9PVEVMX1ZFUkJPU0UgIT09ICcxJyB8fCBvcHRpb25zLmhpZGVTcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnlpbmcgdG8gZ2V0IGFjdGl2ZSBzY29wZWQgc3BhbiB0byBhc3NpZ24gcGFyZW50LiBJZiBvcHRpb24gc3BlY2lmaWVzIHBhcmVudCBzcGFuIG1hbnVhbGx5LCB3aWxsIHRyeSB0byB1c2UgaXQuXG4gICAgICAgIGxldCBzcGFuQ29udGV4dCA9IHRoaXMuZ2V0U3BhbkNvbnRleHQoKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyZW50U3BhbikgPz8gdGhpcy5nZXRBY3RpdmVTY29wZVNwYW4oKSk7XG4gICAgICAgIGxldCBpc1Jvb3RTcGFuID0gZmFsc2U7XG4gICAgICAgIGlmICghc3BhbkNvbnRleHQpIHtcbiAgICAgICAgICAgIHNwYW5Db250ZXh0ID0gKGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQuYWN0aXZlKCkpID8/IFJPT1RfQ09OVEVYVDtcbiAgICAgICAgICAgIGlzUm9vdFNwYW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKChfdHJhY2VfZ2V0U3BhbkNvbnRleHQgPSB0cmFjZS5nZXRTcGFuQ29udGV4dChzcGFuQ29udGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfdHJhY2VfZ2V0U3BhbkNvbnRleHQuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgIGlzUm9vdFNwYW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwYW5JZCA9IGdldFNwYW5JZCgpO1xuICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICAnbmV4dC5zcGFuX25hbWUnOiBzcGFuTmFtZSxcbiAgICAgICAgICAgICduZXh0LnNwYW5fdHlwZSc6IHR5cGUsXG4gICAgICAgICAgICAuLi5vcHRpb25zLmF0dHJpYnV0ZXNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQud2l0aChzcGFuQ29udGV4dC5zZXRWYWx1ZShyb290U3BhbklkS2V5LCBzcGFuSWQpLCAoKT0+dGhpcy5nZXRUcmFjZXJJbnN0YW5jZSgpLnN0YXJ0QWN0aXZlU3BhbihzcGFuTmFtZSwgb3B0aW9ucywgKHNwYW4pPT57XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gJ3BlcmZvcm1hbmNlJyBpbiBnbG9iYWxUaGlzICYmICdtZWFzdXJlJyBpbiBwZXJmb3JtYW5jZSA/IGdsb2JhbFRoaXMucGVyZm9ybWFuY2Uubm93KCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25DbGVhbnVwID0gKCk9PntcbiAgICAgICAgICAgICAgICAgICAgcm9vdFNwYW5BdHRyaWJ1dGVzU3RvcmUuZGVsZXRlKHNwYW5JZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydFRpbWUgJiYgcHJvY2Vzcy5lbnYuTkVYVF9PVEVMX1BFUkZPUk1BTkNFX1BSRUZJWCAmJiBfY29uc3RhbnRzLkxvZ1NwYW5BbGxvd0xpc3QuaW5jbHVkZXModHlwZSB8fCAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoYCR7cHJvY2Vzcy5lbnYuTkVYVF9PVEVMX1BFUkZPUk1BTkNFX1BSRUZJWH06bmV4dC0keyh0eXBlLnNwbGl0KCcuJykucG9wKCkgfHwgJycpLnJlcGxhY2UoL1tBLVpdL2csIChtYXRjaCk9PictJyArIG1hdGNoLnRvTG93ZXJDYXNlKCkpfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSb290U3Bhbikge1xuICAgICAgICAgICAgICAgICAgICByb290U3BhbkF0dHJpYnV0ZXNTdG9yZS5zZXQoc3BhbklkLCBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuYXR0cmlidXRlcyA/PyB7fSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihzcGFuLCAoZXJyKT0+Y2xvc2VTcGFuV2l0aEVycm9yKHNwYW4sIGVycikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc3RoZW5hYmxlLmlzVGhlbmFibGUpKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgZXJyb3IgbWFrZSBzdXJlIGl0IHRocm93c1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXMpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHBhc3MgZG93biB0aGUgcHJvbWlzZSByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgY291bGQgYmUgcmVhY3Qgc3RyZWFtIHJlc3BvbnNlIHdpdGggZXJyb3IgeyBlcnJvciwgc3RyZWFtIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZVNwYW5XaXRoRXJyb3Ioc3BhbiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5maW5hbGx5KG9uQ2xlYW51cCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VTcGFuV2l0aEVycm9yKHNwYW4sIGVycik7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgIH1cbiAgICB3cmFwKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgdHJhY2VyID0gdGhpcztcbiAgICAgICAgY29uc3QgW25hbWUsIG9wdGlvbnMsIGZuXSA9IGFyZ3MubGVuZ3RoID09PSAzID8gYXJncyA6IFtcbiAgICAgICAgICAgIGFyZ3NbMF0sXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGFyZ3NbMV1cbiAgICAgICAgXTtcbiAgICAgICAgaWYgKCFfY29uc3RhbnRzLk5leHRWYW5pbGxhU3BhbkFsbG93bGlzdC5pbmNsdWRlcyhuYW1lKSAmJiBwcm9jZXNzLmVudi5ORVhUX09URUxfVkVSQk9TRSAhPT0gJzEnKSB7XG4gICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGV0IG9wdGlvbnNPYmogPSBvcHRpb25zO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zT2JqID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNPYmogPSBvcHRpb25zT2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsYXN0QXJnSWQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGNiID0gYXJndW1lbnRzW2xhc3RBcmdJZF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVCb3VuZENiID0gdHJhY2VyLmdldENvbnRleHQoKS5iaW5kKGNvbnRleHQuYWN0aXZlKCksIGNiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2VyLnRyYWNlKG5hbWUsIG9wdGlvbnNPYmosIChfc3BhbiwgZG9uZSk9PntcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzW2xhc3RBcmdJZF0gPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPT0gbnVsbCA/IHZvaWQgMCA6IGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZUJvdW5kQ2IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZXIudHJhY2UobmFtZSwgb3B0aW9uc09iaiwgKCk9PmZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGFydFNwYW4oLi4uYXJncykge1xuICAgICAgICBjb25zdCBbdHlwZSwgb3B0aW9uc10gPSBhcmdzO1xuICAgICAgICBjb25zdCBzcGFuQ29udGV4dCA9IHRoaXMuZ2V0U3BhbkNvbnRleHQoKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyZW50U3BhbikgPz8gdGhpcy5nZXRBY3RpdmVTY29wZVNwYW4oKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRyYWNlckluc3RhbmNlKCkuc3RhcnRTcGFuKHR5cGUsIG9wdGlvbnMsIHNwYW5Db250ZXh0KTtcbiAgICB9XG4gICAgZ2V0U3BhbkNvbnRleHQocGFyZW50U3Bhbikge1xuICAgICAgICBjb25zdCBzcGFuQ29udGV4dCA9IHBhcmVudFNwYW4gPyB0cmFjZS5zZXRTcGFuKGNvbnRleHQuYWN0aXZlKCksIHBhcmVudFNwYW4pIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3BhbkNvbnRleHQ7XG4gICAgfVxuICAgIGdldFJvb3RTcGFuQXR0cmlidXRlcygpIHtcbiAgICAgICAgY29uc3Qgc3BhbklkID0gY29udGV4dC5hY3RpdmUoKS5nZXRWYWx1ZShyb290U3BhbklkS2V5KTtcbiAgICAgICAgcmV0dXJuIHJvb3RTcGFuQXR0cmlidXRlc1N0b3JlLmdldChzcGFuSWQpO1xuICAgIH1cbiAgICBzZXRSb290U3BhbkF0dHJpYnV0ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNwYW5JZCA9IGNvbnRleHQuYWN0aXZlKCkuZ2V0VmFsdWUocm9vdFNwYW5JZEtleSk7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSByb290U3BhbkF0dHJpYnV0ZXNTdG9yZS5nZXQoc3BhbklkKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZ2V0VHJhY2VyID0gKCgpPT57XG4gICAgY29uc3QgdHJhY2VyID0gbmV3IE5leHRUcmFjZXJJbXBsKCk7XG4gICAgcmV0dXJuICgpPT50cmFjZXI7XG59KSgpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/lib/trace/tracer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/pipe-readable.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/server/pipe-readable.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isAbortError: function() {\n        return isAbortError;\n    },\n    pipeToNodeResponse: function() {\n        return pipeToNodeResponse;\n    }\n});\nconst _nextrequest = __webpack_require__(/*! ./web/spec-extension/adapters/next-request */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/adapters/next-request.js\");\nconst _detachedpromise = __webpack_require__(/*! ../lib/detached-promise */ \"(rsc)/./node_modules/next/dist/lib/detached-promise.js\");\nconst _tracer = __webpack_require__(/*! ./lib/trace/tracer */ \"(rsc)/./node_modules/next/dist/server/lib/trace/tracer.js\");\nconst _constants = __webpack_require__(/*! ./lib/trace/constants */ \"(rsc)/./node_modules/next/dist/server/lib/trace/constants.js\");\nconst _clientcomponentrendererlogger = __webpack_require__(/*! ./client-component-renderer-logger */ \"(rsc)/./node_modules/next/dist/server/client-component-renderer-logger.js\");\nfunction isAbortError(e) {\n    return (e == null ? void 0 : e.name) === 'AbortError' || (e == null ? void 0 : e.name) === _nextrequest.ResponseAbortedName;\n}\nfunction createWriterFromResponse(res, waitUntilForEnd) {\n    let started = false;\n    // Create a promise that will resolve once the response has drained. See\n    // https://nodejs.org/api/stream.html#stream_event_drain\n    let drained = new _detachedpromise.DetachedPromise();\n    function onDrain() {\n        drained.resolve();\n    }\n    res.on('drain', onDrain);\n    // If the finish event fires, it means we shouldn't block and wait for the\n    // drain event.\n    res.once('close', ()=>{\n        res.off('drain', onDrain);\n        drained.resolve();\n    });\n    // Create a promise that will resolve once the response has finished. See\n    // https://nodejs.org/api/http.html#event-finish_1\n    const finished = new _detachedpromise.DetachedPromise();\n    res.once('finish', ()=>{\n        finished.resolve();\n    });\n    // Create a writable stream that will write to the response.\n    return new WritableStream({\n        write: async (chunk)=>{\n            // You'd think we'd want to use `start` instead of placing this in `write`\n            // but this ensures that we don't actually flush the headers until we've\n            // started writing chunks.\n            if (!started) {\n                started = true;\n                if ('performance' in globalThis && process.env.NEXT_OTEL_PERFORMANCE_PREFIX) {\n                    const metrics = (0, _clientcomponentrendererlogger.getClientComponentLoaderMetrics)();\n                    if (metrics) {\n                        performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`, {\n                            start: metrics.clientComponentLoadStart,\n                            end: metrics.clientComponentLoadStart + metrics.clientComponentLoadTimes\n                        });\n                    }\n                }\n                res.flushHeaders();\n                (0, _tracer.getTracer)().trace(_constants.NextNodeServerSpan.startResponse, {\n                    spanName: 'start response'\n                }, ()=>undefined);\n            }\n            try {\n                const ok = res.write(chunk);\n                // Added by the `compression` middleware, this is a function that will\n                // flush the partially-compressed response to the client.\n                if ('flush' in res && typeof res.flush === 'function') {\n                    res.flush();\n                }\n                // If the write returns false, it means there's some backpressure, so\n                // wait until it's streamed before continuing.\n                if (!ok) {\n                    await drained.promise;\n                    // Reset the drained promise so that we can wait for the next drain event.\n                    drained = new _detachedpromise.DetachedPromise();\n                }\n            } catch (err) {\n                res.end();\n                throw Object.defineProperty(new Error('failed to write chunk to response', {\n                    cause: err\n                }), \"__NEXT_ERROR_CODE\", {\n                    value: \"E321\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        },\n        abort: (err)=>{\n            if (res.writableFinished) return;\n            res.destroy(err);\n        },\n        close: async ()=>{\n            // if a waitUntil promise was passed, wait for it to resolve before\n            // ending the response.\n            if (waitUntilForEnd) {\n                await waitUntilForEnd;\n            }\n            if (res.writableFinished) return;\n            res.end();\n            return finished.promise;\n        }\n    });\n}\nasync function pipeToNodeResponse(readable, res, waitUntilForEnd) {\n    try {\n        // If the response has already errored, then just return now.\n        const { errored, destroyed } = res;\n        if (errored || destroyed) return;\n        // Create a new AbortController so that we can abort the readable if the\n        // client disconnects.\n        const controller = (0, _nextrequest.createAbortController)(res);\n        const writer = createWriterFromResponse(res, waitUntilForEnd);\n        await readable.pipeTo(writer, {\n            signal: controller.signal\n        });\n    } catch (err) {\n        // If this isn't related to an abort error, re-throw it.\n        if (isAbortError(err)) return;\n        throw Object.defineProperty(new Error('failed to pipe response', {\n            cause: err\n        }), \"__NEXT_ERROR_CODE\", {\n            value: \"E180\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\n\n//# sourceMappingURL=pipe-readable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9waXBlLXJlYWRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsTUFBTSxDQUdMO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFCQUFxQixtQkFBTyxDQUFDLHFJQUE0QztBQUN6RSx5QkFBeUIsbUJBQU8sQ0FBQyx1RkFBeUI7QUFDMUQsZ0JBQWdCLG1CQUFPLENBQUMscUZBQW9CO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCx1Q0FBdUMsbUJBQU8sQ0FBQyxxSEFBb0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MseUNBQXlDO0FBQ3hGO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxccGlwZS1yZWFkYWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlzQWJvcnRFcnJvcjogbnVsbCxcbiAgICBwaXBlVG9Ob2RlUmVzcG9uc2U6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgaXNBYm9ydEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzQWJvcnRFcnJvcjtcbiAgICB9LFxuICAgIHBpcGVUb05vZGVSZXNwb25zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwaXBlVG9Ob2RlUmVzcG9uc2U7XG4gICAgfVxufSk7XG5jb25zdCBfbmV4dHJlcXVlc3QgPSByZXF1aXJlKFwiLi93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvbmV4dC1yZXF1ZXN0XCIpO1xuY29uc3QgX2RldGFjaGVkcHJvbWlzZSA9IHJlcXVpcmUoXCIuLi9saWIvZGV0YWNoZWQtcHJvbWlzZVwiKTtcbmNvbnN0IF90cmFjZXIgPSByZXF1aXJlKFwiLi9saWIvdHJhY2UvdHJhY2VyXCIpO1xuY29uc3QgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2xpYi90cmFjZS9jb25zdGFudHNcIik7XG5jb25zdCBfY2xpZW50Y29tcG9uZW50cmVuZGVyZXJsb2dnZXIgPSByZXF1aXJlKFwiLi9jbGllbnQtY29tcG9uZW50LXJlbmRlcmVyLWxvZ2dlclwiKTtcbmZ1bmN0aW9uIGlzQWJvcnRFcnJvcihlKSB7XG4gICAgcmV0dXJuIChlID09IG51bGwgPyB2b2lkIDAgOiBlLm5hbWUpID09PSAnQWJvcnRFcnJvcicgfHwgKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUubmFtZSkgPT09IF9uZXh0cmVxdWVzdC5SZXNwb25zZUFib3J0ZWROYW1lO1xufVxuZnVuY3Rpb24gY3JlYXRlV3JpdGVyRnJvbVJlc3BvbnNlKHJlcywgd2FpdFVudGlsRm9yRW5kKSB7XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAvLyBDcmVhdGUgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgdGhlIHJlc3BvbnNlIGhhcyBkcmFpbmVkLiBTZWVcbiAgICAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9ldmVudF9kcmFpblxuICAgIGxldCBkcmFpbmVkID0gbmV3IF9kZXRhY2hlZHByb21pc2UuRGV0YWNoZWRQcm9taXNlKCk7XG4gICAgZnVuY3Rpb24gb25EcmFpbigpIHtcbiAgICAgICAgZHJhaW5lZC5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlcy5vbignZHJhaW4nLCBvbkRyYWluKTtcbiAgICAvLyBJZiB0aGUgZmluaXNoIGV2ZW50IGZpcmVzLCBpdCBtZWFucyB3ZSBzaG91bGRuJ3QgYmxvY2sgYW5kIHdhaXQgZm9yIHRoZVxuICAgIC8vIGRyYWluIGV2ZW50LlxuICAgIHJlcy5vbmNlKCdjbG9zZScsICgpPT57XG4gICAgICAgIHJlcy5vZmYoJ2RyYWluJywgb25EcmFpbik7XG4gICAgICAgIGRyYWluZWQucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIC8vIENyZWF0ZSBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgb25jZSB0aGUgcmVzcG9uc2UgaGFzIGZpbmlzaGVkLiBTZWVcbiAgICAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNldmVudC1maW5pc2hfMVxuICAgIGNvbnN0IGZpbmlzaGVkID0gbmV3IF9kZXRhY2hlZHByb21pc2UuRGV0YWNoZWRQcm9taXNlKCk7XG4gICAgcmVzLm9uY2UoJ2ZpbmlzaCcsICgpPT57XG4gICAgICAgIGZpbmlzaGVkLnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICAvLyBDcmVhdGUgYSB3cml0YWJsZSBzdHJlYW0gdGhhdCB3aWxsIHdyaXRlIHRvIHRoZSByZXNwb25zZS5cbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgd3JpdGU6IGFzeW5jIChjaHVuayk9PntcbiAgICAgICAgICAgIC8vIFlvdSdkIHRoaW5rIHdlJ2Qgd2FudCB0byB1c2UgYHN0YXJ0YCBpbnN0ZWFkIG9mIHBsYWNpbmcgdGhpcyBpbiBgd3JpdGVgXG4gICAgICAgICAgICAvLyBidXQgdGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3QgYWN0dWFsbHkgZmx1c2ggdGhlIGhlYWRlcnMgdW50aWwgd2UndmVcbiAgICAgICAgICAgIC8vIHN0YXJ0ZWQgd3JpdGluZyBjaHVua3MuXG4gICAgICAgICAgICBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoJ3BlcmZvcm1hbmNlJyBpbiBnbG9iYWxUaGlzICYmIHByb2Nlc3MuZW52Lk5FWFRfT1RFTF9QRVJGT1JNQU5DRV9QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0cmljcyA9ICgwLCBfY2xpZW50Y29tcG9uZW50cmVuZGVyZXJsb2dnZXIuZ2V0Q2xpZW50Q29tcG9uZW50TG9hZGVyTWV0cmljcykoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldHJpY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoYCR7cHJvY2Vzcy5lbnYuTkVYVF9PVEVMX1BFUkZPUk1BTkNFX1BSRUZJWH06bmV4dC1jbGllbnQtY29tcG9uZW50LWxvYWRpbmdgLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG1ldHJpY3MuY2xpZW50Q29tcG9uZW50TG9hZFN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbWV0cmljcy5jbGllbnRDb21wb25lbnRMb2FkU3RhcnQgKyBtZXRyaWNzLmNsaWVudENvbXBvbmVudExvYWRUaW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzLmZsdXNoSGVhZGVycygpO1xuICAgICAgICAgICAgICAgICgwLCBfdHJhY2VyLmdldFRyYWNlcikoKS50cmFjZShfY29uc3RhbnRzLk5leHROb2RlU2VydmVyU3Bhbi5zdGFydFJlc3BvbnNlLCB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW5OYW1lOiAnc3RhcnQgcmVzcG9uc2UnXG4gICAgICAgICAgICAgICAgfSwgKCk9PnVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9rID0gcmVzLndyaXRlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAvLyBBZGRlZCBieSB0aGUgYGNvbXByZXNzaW9uYCBtaWRkbGV3YXJlLCB0aGlzIGlzIGEgZnVuY3Rpb24gdGhhdCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gZmx1c2ggdGhlIHBhcnRpYWxseS1jb21wcmVzc2VkIHJlc3BvbnNlIHRvIHRoZSBjbGllbnQuXG4gICAgICAgICAgICAgICAgaWYgKCdmbHVzaCcgaW4gcmVzICYmIHR5cGVvZiByZXMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB3cml0ZSByZXR1cm5zIGZhbHNlLCBpdCBtZWFucyB0aGVyZSdzIHNvbWUgYmFja3ByZXNzdXJlLCBzb1xuICAgICAgICAgICAgICAgIC8vIHdhaXQgdW50aWwgaXQncyBzdHJlYW1lZCBiZWZvcmUgY29udGludWluZy5cbiAgICAgICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGRyYWluZWQucHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGRyYWluZWQgcHJvbWlzZSBzbyB0aGF0IHdlIGNhbiB3YWl0IGZvciB0aGUgbmV4dCBkcmFpbiBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgZHJhaW5lZCA9IG5ldyBfZGV0YWNoZWRwcm9taXNlLkRldGFjaGVkUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKCdmYWlsZWQgdG8gd3JpdGUgY2h1bmsgdG8gcmVzcG9uc2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJcbiAgICAgICAgICAgICAgICB9KSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkUzMjFcIixcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhYm9ydDogKGVycik9PntcbiAgICAgICAgICAgIGlmIChyZXMud3JpdGFibGVGaW5pc2hlZCkgcmV0dXJuO1xuICAgICAgICAgICAgcmVzLmRlc3Ryb3koZXJyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2U6IGFzeW5jICgpPT57XG4gICAgICAgICAgICAvLyBpZiBhIHdhaXRVbnRpbCBwcm9taXNlIHdhcyBwYXNzZWQsIHdhaXQgZm9yIGl0IHRvIHJlc29sdmUgYmVmb3JlXG4gICAgICAgICAgICAvLyBlbmRpbmcgdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgaWYgKHdhaXRVbnRpbEZvckVuZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHdhaXRVbnRpbEZvckVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXMud3JpdGFibGVGaW5pc2hlZCkgcmV0dXJuO1xuICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaGVkLnByb21pc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBpcGVUb05vZGVSZXNwb25zZShyZWFkYWJsZSwgcmVzLCB3YWl0VW50aWxGb3JFbmQpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBJZiB0aGUgcmVzcG9uc2UgaGFzIGFscmVhZHkgZXJyb3JlZCwgdGhlbiBqdXN0IHJldHVybiBub3cuXG4gICAgICAgIGNvbnN0IHsgZXJyb3JlZCwgZGVzdHJveWVkIH0gPSByZXM7XG4gICAgICAgIGlmIChlcnJvcmVkIHx8IGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgQWJvcnRDb250cm9sbGVyIHNvIHRoYXQgd2UgY2FuIGFib3J0IHRoZSByZWFkYWJsZSBpZiB0aGVcbiAgICAgICAgLy8gY2xpZW50IGRpc2Nvbm5lY3RzLlxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gKDAsIF9uZXh0cmVxdWVzdC5jcmVhdGVBYm9ydENvbnRyb2xsZXIpKHJlcyk7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IGNyZWF0ZVdyaXRlckZyb21SZXNwb25zZShyZXMsIHdhaXRVbnRpbEZvckVuZCk7XG4gICAgICAgIGF3YWl0IHJlYWRhYmxlLnBpcGVUbyh3cml0ZXIsIHtcbiAgICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXNuJ3QgcmVsYXRlZCB0byBhbiBhYm9ydCBlcnJvciwgcmUtdGhyb3cgaXQuXG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyKSkgcmV0dXJuO1xuICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKCdmYWlsZWQgdG8gcGlwZSByZXNwb25zZScsIHtcbiAgICAgICAgICAgIGNhdXNlOiBlcnJcbiAgICAgICAgfSksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IFwiRTE4MFwiLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1waXBlLXJlYWRhYmxlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/pipe-readable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/render-result.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/server/render-result.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return RenderResult;\n    }\n}));\nconst _nodewebstreamshelper = __webpack_require__(/*! ./stream-utils/node-web-streams-helper */ \"(rsc)/./node_modules/next/dist/server/stream-utils/node-web-streams-helper.js\");\nconst _pipereadable = __webpack_require__(/*! ./pipe-readable */ \"(rsc)/./node_modules/next/dist/server/pipe-readable.js\");\nclass RenderResult {\n    /**\n   * Creates a new RenderResult instance from a static response.\n   *\n   * @param value the static response value\n   * @returns a new RenderResult instance\n   */ static fromStatic(value) {\n        return new RenderResult(value, {\n            metadata: {}\n        });\n    }\n    constructor(response, { contentType, waitUntil, metadata }){\n        this.response = response;\n        this.contentType = contentType;\n        this.metadata = metadata;\n        this.waitUntil = waitUntil;\n    }\n    assignMetadata(metadata) {\n        Object.assign(this.metadata, metadata);\n    }\n    /**\n   * Returns true if the response is null. It can be null if the response was\n   * not found or was already sent.\n   */ get isNull() {\n        return this.response === null;\n    }\n    /**\n   * Returns false if the response is a string. It can be a string if the page\n   * was prerendered. If it's not, then it was generated dynamically.\n   */ get isDynamic() {\n        return typeof this.response !== 'string';\n    }\n    toUnchunkedBuffer(stream = false) {\n        if (this.response === null) {\n            throw Object.defineProperty(new Error('Invariant: null responses cannot be unchunked'), \"__NEXT_ERROR_CODE\", {\n                value: \"E274\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (typeof this.response !== 'string') {\n            if (!stream) {\n                throw Object.defineProperty(new Error('Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E81\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            return (0, _nodewebstreamshelper.streamToBuffer)(this.readable);\n        }\n        return Buffer.from(this.response);\n    }\n    toUnchunkedString(stream = false) {\n        if (this.response === null) {\n            throw Object.defineProperty(new Error('Invariant: null responses cannot be unchunked'), \"__NEXT_ERROR_CODE\", {\n                value: \"E274\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (typeof this.response !== 'string') {\n            if (!stream) {\n                throw Object.defineProperty(new Error('Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E81\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            return (0, _nodewebstreamshelper.streamToString)(this.readable);\n        }\n        return this.response;\n    }\n    /**\n   * Returns the response if it is a stream, or throws an error if it is a\n   * string.\n   */ get readable() {\n        if (this.response === null) {\n            throw Object.defineProperty(new Error('Invariant: null responses cannot be streamed'), \"__NEXT_ERROR_CODE\", {\n                value: \"E14\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (typeof this.response === 'string') {\n            throw Object.defineProperty(new Error('Invariant: static responses cannot be streamed'), \"__NEXT_ERROR_CODE\", {\n                value: \"E151\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (Buffer.isBuffer(this.response)) {\n            return (0, _nodewebstreamshelper.streamFromBuffer)(this.response);\n        }\n        // If the response is an array of streams, then chain them together.\n        if (Array.isArray(this.response)) {\n            return (0, _nodewebstreamshelper.chainStreams)(...this.response);\n        }\n        return this.response;\n    }\n    /**\n   * Chains a new stream to the response. This will convert the response to an\n   * array of streams if it is not already one and will add the new stream to\n   * the end. When this response is piped, all of the streams will be piped\n   * one after the other.\n   *\n   * @param readable The new stream to chain\n   */ chain(readable) {\n        if (this.response === null) {\n            throw Object.defineProperty(new Error('Invariant: response is null. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\n                value: \"E258\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        // If the response is not an array of streams already, make it one.\n        let responses;\n        if (typeof this.response === 'string') {\n            responses = [\n                (0, _nodewebstreamshelper.streamFromString)(this.response)\n            ];\n        } else if (Array.isArray(this.response)) {\n            responses = this.response;\n        } else if (Buffer.isBuffer(this.response)) {\n            responses = [\n                (0, _nodewebstreamshelper.streamFromBuffer)(this.response)\n            ];\n        } else {\n            responses = [\n                this.response\n            ];\n        }\n        // Add the new stream to the array.\n        responses.push(readable);\n        // Update the response.\n        this.response = responses;\n    }\n    /**\n   * Pipes the response to a writable stream. This will close/cancel the\n   * writable stream if an error is encountered. If this doesn't throw, then\n   * the writable stream will be closed or aborted.\n   *\n   * @param writable Writable stream to pipe the response to\n   */ async pipeTo(writable) {\n        try {\n            await this.readable.pipeTo(writable, {\n                // We want to close the writable stream ourselves so that we can wait\n                // for the waitUntil promise to resolve before closing it. If an error\n                // is encountered, we'll abort the writable stream if we swallowed the\n                // error.\n                preventClose: true\n            });\n            // If there is a waitUntil promise, wait for it to resolve before\n            // closing the writable stream.\n            if (this.waitUntil) await this.waitUntil;\n            // Close the writable stream.\n            await writable.close();\n        } catch (err) {\n            // If this is an abort error, we should abort the writable stream (as we\n            // took ownership of it when we started piping). We don't need to re-throw\n            // because we handled the error.\n            if ((0, _pipereadable.isAbortError)(err)) {\n                // Abort the writable stream if an error is encountered.\n                await writable.abort(err);\n                return;\n            }\n            // We're not aborting the writer here as when this method throws it's not\n            // clear as to how so the caller should assume it's their responsibility\n            // to clean up the writer.\n            throw err;\n        }\n    }\n    /**\n   * Pipes the response to a node response. This will close/cancel the node\n   * response if an error is encountered.\n   *\n   * @param res\n   */ async pipeToNodeResponse(res) {\n        await (0, _pipereadable.pipeToNodeResponse)(this.readable, res, this.waitUntil);\n    }\n}\n\n//# sourceMappingURL=render-result.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yZW5kZXItcmVzdWx0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkNBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOEJBQThCLG1CQUFPLENBQUMsNkhBQXdDO0FBQzlFLHNCQUFzQixtQkFBTyxDQUFDLCtFQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxccmVuZGVyLXJlc3VsdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJlbmRlclJlc3VsdDtcbiAgICB9XG59KTtcbmNvbnN0IF9ub2Rld2Vic3RyZWFtc2hlbHBlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS11dGlscy9ub2RlLXdlYi1zdHJlYW1zLWhlbHBlclwiKTtcbmNvbnN0IF9waXBlcmVhZGFibGUgPSByZXF1aXJlKFwiLi9waXBlLXJlYWRhYmxlXCIpO1xuY2xhc3MgUmVuZGVyUmVzdWx0IHtcbiAgICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBSZW5kZXJSZXN1bHQgaW5zdGFuY2UgZnJvbSBhIHN0YXRpYyByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIHRoZSBzdGF0aWMgcmVzcG9uc2UgdmFsdWVcbiAgICogQHJldHVybnMgYSBuZXcgUmVuZGVyUmVzdWx0IGluc3RhbmNlXG4gICAqLyBzdGF0aWMgZnJvbVN0YXRpYyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlbmRlclJlc3VsdCh2YWx1ZSwge1xuICAgICAgICAgICAgbWV0YWRhdGE6IHt9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSwgeyBjb250ZW50VHlwZSwgd2FpdFVudGlsLCBtZXRhZGF0YSB9KXtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gY29udGVudFR5cGU7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy53YWl0VW50aWwgPSB3YWl0VW50aWw7XG4gICAgfVxuICAgIGFzc2lnbk1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5tZXRhZGF0YSwgbWV0YWRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSByZXNwb25zZSBpcyBudWxsLiBJdCBjYW4gYmUgbnVsbCBpZiB0aGUgcmVzcG9uc2Ugd2FzXG4gICAqIG5vdCBmb3VuZCBvciB3YXMgYWxyZWFkeSBzZW50LlxuICAgKi8gZ2V0IGlzTnVsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2UgPT09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGZhbHNlIGlmIHRoZSByZXNwb25zZSBpcyBhIHN0cmluZy4gSXQgY2FuIGJlIGEgc3RyaW5nIGlmIHRoZSBwYWdlXG4gICAqIHdhcyBwcmVyZW5kZXJlZC4gSWYgaXQncyBub3QsIHRoZW4gaXQgd2FzIGdlbmVyYXRlZCBkeW5hbWljYWxseS5cbiAgICovIGdldCBpc0R5bmFtaWMoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5yZXNwb25zZSAhPT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIHRvVW5jaHVua2VkQnVmZmVyKHN0cmVhbSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKCdJbnZhcmlhbnQ6IG51bGwgcmVzcG9uc2VzIGNhbm5vdCBiZSB1bmNodW5rZWQnKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiRTI3NFwiLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJlc3BvbnNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKCdJbnZhcmlhbnQ6IGR5bmFtaWMgcmVzcG9uc2VzIGNhbm5vdCBiZSB1bmNodW5rZWQuIFRoaXMgaXMgYSBidWcgaW4gTmV4dC5qcycpLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiRTgxXCIsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgX25vZGV3ZWJzdHJlYW1zaGVscGVyLnN0cmVhbVRvQnVmZmVyKSh0aGlzLnJlYWRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5yZXNwb25zZSk7XG4gICAgfVxuICAgIHRvVW5jaHVua2VkU3RyaW5nKHN0cmVhbSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKCdJbnZhcmlhbnQ6IG51bGwgcmVzcG9uc2VzIGNhbm5vdCBiZSB1bmNodW5rZWQnKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiRTI3NFwiLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJlc3BvbnNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKCdJbnZhcmlhbnQ6IGR5bmFtaWMgcmVzcG9uc2VzIGNhbm5vdCBiZSB1bmNodW5rZWQuIFRoaXMgaXMgYSBidWcgaW4gTmV4dC5qcycpLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiRTgxXCIsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgX25vZGV3ZWJzdHJlYW1zaGVscGVyLnN0cmVhbVRvU3RyaW5nKSh0aGlzLnJlYWRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIGEgc3RyZWFtLCBvciB0aHJvd3MgYW4gZXJyb3IgaWYgaXQgaXMgYVxuICAgKiBzdHJpbmcuXG4gICAqLyBnZXQgcmVhZGFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKCdJbnZhcmlhbnQ6IG51bGwgcmVzcG9uc2VzIGNhbm5vdCBiZSBzdHJlYW1lZCcpLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJFMTRcIixcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5yZXNwb25zZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgRXJyb3IoJ0ludmFyaWFudDogc3RhdGljIHJlc3BvbnNlcyBjYW5ub3QgYmUgc3RyZWFtZWQnKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiRTE1MVwiLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0aGlzLnJlc3BvbnNlKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfbm9kZXdlYnN0cmVhbXNoZWxwZXIuc3RyZWFtRnJvbUJ1ZmZlcikodGhpcy5yZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHJlc3BvbnNlIGlzIGFuIGFycmF5IG9mIHN0cmVhbXMsIHRoZW4gY2hhaW4gdGhlbSB0b2dldGhlci5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5yZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX25vZGV3ZWJzdHJlYW1zaGVscGVyLmNoYWluU3RyZWFtcykoLi4udGhpcy5yZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDaGFpbnMgYSBuZXcgc3RyZWFtIHRvIHRoZSByZXNwb25zZS4gVGhpcyB3aWxsIGNvbnZlcnQgdGhlIHJlc3BvbnNlIHRvIGFuXG4gICAqIGFycmF5IG9mIHN0cmVhbXMgaWYgaXQgaXMgbm90IGFscmVhZHkgb25lIGFuZCB3aWxsIGFkZCB0aGUgbmV3IHN0cmVhbSB0b1xuICAgKiB0aGUgZW5kLiBXaGVuIHRoaXMgcmVzcG9uc2UgaXMgcGlwZWQsIGFsbCBvZiB0aGUgc3RyZWFtcyB3aWxsIGJlIHBpcGVkXG4gICAqIG9uZSBhZnRlciB0aGUgb3RoZXIuXG4gICAqXG4gICAqIEBwYXJhbSByZWFkYWJsZSBUaGUgbmV3IHN0cmVhbSB0byBjaGFpblxuICAgKi8gY2hhaW4ocmVhZGFibGUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgRXJyb3IoJ0ludmFyaWFudDogcmVzcG9uc2UgaXMgbnVsbC4gVGhpcyBpcyBhIGJ1ZyBpbiBOZXh0LmpzJyksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIkUyNThcIixcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSByZXNwb25zZSBpcyBub3QgYW4gYXJyYXkgb2Ygc3RyZWFtcyBhbHJlYWR5LCBtYWtlIGl0IG9uZS5cbiAgICAgICAgbGV0IHJlc3BvbnNlcztcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJlc3BvbnNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzcG9uc2VzID0gW1xuICAgICAgICAgICAgICAgICgwLCBfbm9kZXdlYnN0cmVhbXNoZWxwZXIuc3RyZWFtRnJvbVN0cmluZykodGhpcy5yZXNwb25zZSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnJlc3BvbnNlKSkge1xuICAgICAgICAgICAgcmVzcG9uc2VzID0gdGhpcy5yZXNwb25zZTtcbiAgICAgICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodGhpcy5yZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlcyA9IFtcbiAgICAgICAgICAgICAgICAoMCwgX25vZGV3ZWJzdHJlYW1zaGVscGVyLnN0cmVhbUZyb21CdWZmZXIpKHRoaXMucmVzcG9uc2UpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2VzID0gW1xuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2VcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBuZXcgc3RyZWFtIHRvIHRoZSBhcnJheS5cbiAgICAgICAgcmVzcG9uc2VzLnB1c2gocmVhZGFibGUpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlc3BvbnNlLlxuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2VzO1xuICAgIH1cbiAgICAvKipcbiAgICogUGlwZXMgdGhlIHJlc3BvbnNlIHRvIGEgd3JpdGFibGUgc3RyZWFtLiBUaGlzIHdpbGwgY2xvc2UvY2FuY2VsIHRoZVxuICAgKiB3cml0YWJsZSBzdHJlYW0gaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuIElmIHRoaXMgZG9lc24ndCB0aHJvdywgdGhlblxuICAgKiB0aGUgd3JpdGFibGUgc3RyZWFtIHdpbGwgYmUgY2xvc2VkIG9yIGFib3J0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB3cml0YWJsZSBXcml0YWJsZSBzdHJlYW0gdG8gcGlwZSB0aGUgcmVzcG9uc2UgdG9cbiAgICovIGFzeW5jIHBpcGVUbyh3cml0YWJsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWFkYWJsZS5waXBlVG8od3JpdGFibGUsIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRvIGNsb3NlIHRoZSB3cml0YWJsZSBzdHJlYW0gb3Vyc2VsdmVzIHNvIHRoYXQgd2UgY2FuIHdhaXRcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIHdhaXRVbnRpbCBwcm9taXNlIHRvIHJlc29sdmUgYmVmb3JlIGNsb3NpbmcgaXQuIElmIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gaXMgZW5jb3VudGVyZWQsIHdlJ2xsIGFib3J0IHRoZSB3cml0YWJsZSBzdHJlYW0gaWYgd2Ugc3dhbGxvd2VkIHRoZVxuICAgICAgICAgICAgICAgIC8vIGVycm9yLlxuICAgICAgICAgICAgICAgIHByZXZlbnRDbG9zZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHdhaXRVbnRpbCBwcm9taXNlLCB3YWl0IGZvciBpdCB0byByZXNvbHZlIGJlZm9yZVxuICAgICAgICAgICAgLy8gY2xvc2luZyB0aGUgd3JpdGFibGUgc3RyZWFtLlxuICAgICAgICAgICAgaWYgKHRoaXMud2FpdFVudGlsKSBhd2FpdCB0aGlzLndhaXRVbnRpbDtcbiAgICAgICAgICAgIC8vIENsb3NlIHRoZSB3cml0YWJsZSBzdHJlYW0uXG4gICAgICAgICAgICBhd2FpdCB3cml0YWJsZS5jbG9zZSgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYW4gYWJvcnQgZXJyb3IsIHdlIHNob3VsZCBhYm9ydCB0aGUgd3JpdGFibGUgc3RyZWFtIChhcyB3ZVxuICAgICAgICAgICAgLy8gdG9vayBvd25lcnNoaXAgb2YgaXQgd2hlbiB3ZSBzdGFydGVkIHBpcGluZykuIFdlIGRvbid0IG5lZWQgdG8gcmUtdGhyb3dcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgaGFuZGxlZCB0aGUgZXJyb3IuXG4gICAgICAgICAgICBpZiAoKDAsIF9waXBlcmVhZGFibGUuaXNBYm9ydEVycm9yKShlcnIpKSB7XG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgdGhlIHdyaXRhYmxlIHN0cmVhbSBpZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgICAgICBhd2FpdCB3cml0YWJsZS5hYm9ydChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBhYm9ydGluZyB0aGUgd3JpdGVyIGhlcmUgYXMgd2hlbiB0aGlzIG1ldGhvZCB0aHJvd3MgaXQncyBub3RcbiAgICAgICAgICAgIC8vIGNsZWFyIGFzIHRvIGhvdyBzbyB0aGUgY2FsbGVyIHNob3VsZCBhc3N1bWUgaXQncyB0aGVpciByZXNwb25zaWJpbGl0eVxuICAgICAgICAgICAgLy8gdG8gY2xlYW4gdXAgdGhlIHdyaXRlci5cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICogUGlwZXMgdGhlIHJlc3BvbnNlIHRvIGEgbm9kZSByZXNwb25zZS4gVGhpcyB3aWxsIGNsb3NlL2NhbmNlbCB0aGUgbm9kZVxuICAgKiByZXNwb25zZSBpZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHJlc1xuICAgKi8gYXN5bmMgcGlwZVRvTm9kZVJlc3BvbnNlKHJlcykge1xuICAgICAgICBhd2FpdCAoMCwgX3BpcGVyZWFkYWJsZS5waXBlVG9Ob2RlUmVzcG9uc2UpKHRoaXMucmVhZGFibGUsIHJlcywgdGhpcy53YWl0VW50aWwpO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyLXJlc3VsdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/render-result.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/request-meta.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/server/request-meta.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/* eslint-disable no-redeclare */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    NEXT_REQUEST_META: function() {\n        return NEXT_REQUEST_META;\n    },\n    addRequestMeta: function() {\n        return addRequestMeta;\n    },\n    getRequestMeta: function() {\n        return getRequestMeta;\n    },\n    removeRequestMeta: function() {\n        return removeRequestMeta;\n    },\n    setRequestMeta: function() {\n        return setRequestMeta;\n    }\n});\nconst NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta');\nfunction getRequestMeta(req, key) {\n    const meta = req[NEXT_REQUEST_META] || {};\n    return typeof key === 'string' ? meta[key] : meta;\n}\nfunction setRequestMeta(req, meta) {\n    req[NEXT_REQUEST_META] = meta;\n    return meta;\n}\nfunction addRequestMeta(request, key, value) {\n    const meta = getRequestMeta(request);\n    meta[key] = value;\n    return setRequestMeta(request, meta);\n}\nfunction removeRequestMeta(request, key) {\n    const meta = getRequestMeta(request);\n    delete meta[key];\n    return setRequestMeta(request, meta);\n}\n\n//# sourceMappingURL=request-meta.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yZXF1ZXN0LW1ldGEuanMiLCJtYXBwaW5ncyI6IkFBQUEsa0NBQStDO0FBQy9DLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLE1BQU0sQ0FNTDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxccmVxdWVzdC1tZXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIE5FWFRfUkVRVUVTVF9NRVRBOiBudWxsLFxuICAgIGFkZFJlcXVlc3RNZXRhOiBudWxsLFxuICAgIGdldFJlcXVlc3RNZXRhOiBudWxsLFxuICAgIHJlbW92ZVJlcXVlc3RNZXRhOiBudWxsLFxuICAgIHNldFJlcXVlc3RNZXRhOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIE5FWFRfUkVRVUVTVF9NRVRBOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfUkVRVUVTVF9NRVRBO1xuICAgIH0sXG4gICAgYWRkUmVxdWVzdE1ldGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWRkUmVxdWVzdE1ldGE7XG4gICAgfSxcbiAgICBnZXRSZXF1ZXN0TWV0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRSZXF1ZXN0TWV0YTtcbiAgICB9LFxuICAgIHJlbW92ZVJlcXVlc3RNZXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVJlcXVlc3RNZXRhO1xuICAgIH0sXG4gICAgc2V0UmVxdWVzdE1ldGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2V0UmVxdWVzdE1ldGE7XG4gICAgfVxufSk7XG5jb25zdCBORVhUX1JFUVVFU1RfTUVUQSA9IFN5bWJvbC5mb3IoJ05leHRJbnRlcm5hbFJlcXVlc3RNZXRhJyk7XG5mdW5jdGlvbiBnZXRSZXF1ZXN0TWV0YShyZXEsIGtleSkge1xuICAgIGNvbnN0IG1ldGEgPSByZXFbTkVYVF9SRVFVRVNUX01FVEFdIHx8IHt9O1xuICAgIHJldHVybiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IG1ldGFba2V5XSA6IG1ldGE7XG59XG5mdW5jdGlvbiBzZXRSZXF1ZXN0TWV0YShyZXEsIG1ldGEpIHtcbiAgICByZXFbTkVYVF9SRVFVRVNUX01FVEFdID0gbWV0YTtcbiAgICByZXR1cm4gbWV0YTtcbn1cbmZ1bmN0aW9uIGFkZFJlcXVlc3RNZXRhKHJlcXVlc3QsIGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBtZXRhID0gZ2V0UmVxdWVzdE1ldGEocmVxdWVzdCk7XG4gICAgbWV0YVtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIHNldFJlcXVlc3RNZXRhKHJlcXVlc3QsIG1ldGEpO1xufVxuZnVuY3Rpb24gcmVtb3ZlUmVxdWVzdE1ldGEocmVxdWVzdCwga2V5KSB7XG4gICAgY29uc3QgbWV0YSA9IGdldFJlcXVlc3RNZXRhKHJlcXVlc3QpO1xuICAgIGRlbGV0ZSBtZXRhW2tleV07XG4gICAgcmV0dXJuIHNldFJlcXVlc3RNZXRhKHJlcXVlc3QsIG1ldGEpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0LW1ldGEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/request-meta.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/request/connection.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/server/request/connection.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"connection\", ({\n    enumerable: true,\n    get: function() {\n        return connection;\n    }\n}));\nconst _workasyncstorageexternal = __webpack_require__(/*! ../app-render/work-async-storage.external */ \"../app-render/work-async-storage.external\");\nconst _workunitasyncstorageexternal = __webpack_require__(/*! ../app-render/work-unit-async-storage.external */ \"./work-unit-async-storage.external\");\nconst _dynamicrendering = __webpack_require__(/*! ../app-render/dynamic-rendering */ \"(rsc)/./node_modules/next/dist/server/app-render/dynamic-rendering.js\");\nconst _staticgenerationbailout = __webpack_require__(/*! ../../client/components/static-generation-bailout */ \"(rsc)/./node_modules/next/dist/client/components/static-generation-bailout.js\");\nconst _dynamicrenderingutils = __webpack_require__(/*! ../dynamic-rendering-utils */ \"(rsc)/./node_modules/next/dist/server/dynamic-rendering-utils.js\");\nconst _utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/next/dist/server/request/utils.js\");\nfunction connection() {\n    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (workStore) {\n        if (workUnitStore && workUnitStore.phase === 'after' && !(0, _utils.isRequestAPICallableInsideAfter)()) {\n            throw Object.defineProperty(new Error(`Route ${workStore.route} used \"connection\" inside \"after(...)\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but \"after(...)\" executes after the request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`), \"__NEXT_ERROR_CODE\", {\n                value: \"E186\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workStore.forceStatic) {\n            // When using forceStatic we override all other logic and always just return an empty\n            // headers object without tracking\n            return Promise.resolve(undefined);\n        }\n        if (workUnitStore) {\n            if (workUnitStore.type === 'cache') {\n                throw Object.defineProperty(new Error(`Route ${workStore.route} used \"connection\" inside \"use cache\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E111\",\n                    enumerable: false,\n                    configurable: true\n                });\n            } else if (workUnitStore.type === 'unstable-cache') {\n                throw Object.defineProperty(new Error(`Route ${workStore.route} used \"connection\" inside a function cached with \"unstable_cache(...)\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E1\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n        if (workStore.dynamicShouldError) {\n            throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`connection\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n                value: \"E562\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workUnitStore) {\n            if (workUnitStore.type === 'prerender') {\n                // dynamicIO Prerender\n                // We return a promise that never resolves to allow the prender to stall at this point\n                return (0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, '`connection()`');\n            } else if (workUnitStore.type === 'prerender-ppr') {\n                // PPR Prerender (no dynamicIO)\n                // We use React's postpone API to interrupt rendering here to create a dynamic hole\n                (0, _dynamicrendering.postponeWithTracking)(workStore.route, 'connection', workUnitStore.dynamicTracking);\n            } else if (workUnitStore.type === 'prerender-legacy') {\n                // Legacy Prerender\n                // We throw an error here to interrupt prerendering to mark the route as dynamic\n                (0, _dynamicrendering.throwToInterruptStaticGeneration)('connection', workStore, workUnitStore);\n            }\n        }\n        // We fall through to the dynamic context below but we still track dynamic access\n        // because in dev we can still error for things like using headers inside a cache context\n        (0, _dynamicrendering.trackDynamicDataInDynamicRender)(workStore, workUnitStore);\n    }\n    return Promise.resolve(undefined);\n}\n\n//# sourceMappingURL=connection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yZXF1ZXN0L2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiw4Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixrQ0FBa0MsbUJBQU8sQ0FBQyw0RkFBMkM7QUFDckYsc0NBQXNDLG1CQUFPLENBQUMsMEZBQWdEO0FBQzlGLDBCQUEwQixtQkFBTyxDQUFDLDhHQUFpQztBQUNuRSxpQ0FBaUMsbUJBQU8sQ0FBQyx3SUFBbUQ7QUFDNUYsK0JBQStCLG1CQUFPLENBQUMsb0dBQTRCO0FBQ25FLGVBQWUsbUJBQU8sQ0FBQyx1RUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZCwrREFBK0QsaUJBQWlCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csaUJBQWlCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxzZXJ2ZXJcXHJlcXVlc3RcXGNvbm5lY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25uZWN0aW9uXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH1cbn0pO1xuY29uc3QgX3dvcmthc3luY3N0b3JhZ2VleHRlcm5hbCA9IHJlcXVpcmUoXCIuLi9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbFwiKTtcbmNvbnN0IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsID0gcmVxdWlyZShcIi4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWxcIik7XG5jb25zdCBfZHluYW1pY3JlbmRlcmluZyA9IHJlcXVpcmUoXCIuLi9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nXCIpO1xuY29uc3QgX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0ID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXRcIik7XG5jb25zdCBfZHluYW1pY3JlbmRlcmluZ3V0aWxzID0gcmVxdWlyZShcIi4uL2R5bmFtaWMtcmVuZGVyaW5nLXV0aWxzXCIpO1xuY29uc3QgX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5mdW5jdGlvbiBjb25uZWN0aW9uKCkge1xuICAgIGNvbnN0IHdvcmtTdG9yZSA9IF93b3JrYXN5bmNzdG9yYWdlZXh0ZXJuYWwud29ya0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGNvbnN0IHdvcmtVbml0U3RvcmUgPSBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbC53b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmICh3b3JrU3RvcmUpIHtcbiAgICAgICAgaWYgKHdvcmtVbml0U3RvcmUgJiYgd29ya1VuaXRTdG9yZS5waGFzZSA9PT0gJ2FmdGVyJyAmJiAhKDAsIF91dGlscy5pc1JlcXVlc3RBUElDYWxsYWJsZUluc2lkZUFmdGVyKSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gdXNlZCBcImNvbm5lY3Rpb25cIiBpbnNpZGUgXCJhZnRlciguLi4pXCIuIFRoZSBcXGBjb25uZWN0aW9uKClcXGAgZnVuY3Rpb24gaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGUgc3Vic2VxdWVudCBjb2RlIG11c3Qgb25seSBydW4gd2hlbiB0aGVyZSBpcyBhbiBhY3R1YWwgUmVxdWVzdCwgYnV0IFwiYWZ0ZXIoLi4uKVwiIGV4ZWN1dGVzIGFmdGVyIHRoZSByZXF1ZXN0LCBzbyB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgc2NvcGUuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvY2FuYXJ5L2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9hZnRlcmApLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJFMTg2XCIsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya1N0b3JlLmZvcmNlU3RhdGljKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHVzaW5nIGZvcmNlU3RhdGljIHdlIG92ZXJyaWRlIGFsbCBvdGhlciBsb2dpYyBhbmQgYWx3YXlzIGp1c3QgcmV0dXJuIGFuIGVtcHR5XG4gICAgICAgICAgICAvLyBoZWFkZXJzIG9iamVjdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgICAgIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdjYWNoZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gdXNlZCBcImNvbm5lY3Rpb25cIiBpbnNpZGUgXCJ1c2UgY2FjaGVcIi4gVGhlIFxcYGNvbm5lY3Rpb24oKVxcYCBmdW5jdGlvbiBpcyB1c2VkIHRvIGluZGljYXRlIHRoZSBzdWJzZXF1ZW50IGNvZGUgbXVzdCBvbmx5IHJ1biB3aGVuIHRoZXJlIGlzIGFuIGFjdHVhbCBSZXF1ZXN0LCBidXQgY2FjaGVzIG11c3QgYmUgYWJsZSB0byBiZSBwcm9kdWNlZCBiZWZvcmUgYSBSZXF1ZXN0IHNvIHRoaXMgZnVuY3Rpb24gaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBzY29wZS4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXJlcXVlc3QtaW4tdXNlLWNhY2hlYCksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJFMTExXCIsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod29ya1VuaXRTdG9yZS50eXBlID09PSAndW5zdGFibGUtY2FjaGUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcihgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHVzZWQgXCJjb25uZWN0aW9uXCIgaW5zaWRlIGEgZnVuY3Rpb24gY2FjaGVkIHdpdGggXCJ1bnN0YWJsZV9jYWNoZSguLi4pXCIuIFRoZSBcXGBjb25uZWN0aW9uKClcXGAgZnVuY3Rpb24gaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGUgc3Vic2VxdWVudCBjb2RlIG11c3Qgb25seSBydW4gd2hlbiB0aGVyZSBpcyBhbiBhY3R1YWwgUmVxdWVzdCwgYnV0IGNhY2hlcyBtdXN0IGJlIGFibGUgdG8gYmUgcHJvZHVjZWQgYmVmb3JlIGEgUmVxdWVzdCBzbyB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgc2NvcGUuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3Vuc3RhYmxlX2NhY2hlYCksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJFMVwiLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0LlN0YXRpY0dlbkJhaWxvdXRFcnJvcihgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHdpdGggXFxgZHluYW1pYyA9IFwiZXJyb3JcIlxcYCBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCBcXGBjb25uZWN0aW9uXFxgLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zdGF0aWMtYW5kLWR5bmFtaWMjZHluYW1pYy1yZW5kZXJpbmdgKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiRTU2MlwiLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgICAgIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gZHluYW1pY0lPIFByZXJlbmRlclxuICAgICAgICAgICAgICAgIC8vIFdlIHJldHVybiBhIHByb21pc2UgdGhhdCBuZXZlciByZXNvbHZlcyB0byBhbGxvdyB0aGUgcHJlbmRlciB0byBzdGFsbCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfZHluYW1pY3JlbmRlcmluZ3V0aWxzLm1ha2VIYW5naW5nUHJvbWlzZSkod29ya1VuaXRTdG9yZS5yZW5kZXJTaWduYWwsICdgY29ubmVjdGlvbigpYCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJykge1xuICAgICAgICAgICAgICAgIC8vIFBQUiBQcmVyZW5kZXIgKG5vIGR5bmFtaWNJTylcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgUmVhY3QncyBwb3N0cG9uZSBBUEkgdG8gaW50ZXJydXB0IHJlbmRlcmluZyBoZXJlIHRvIGNyZWF0ZSBhIGR5bmFtaWMgaG9sZVxuICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5wb3N0cG9uZVdpdGhUcmFja2luZykod29ya1N0b3JlLnJvdXRlLCAnY29ubmVjdGlvbicsIHdvcmtVbml0U3RvcmUuZHluYW1pY1RyYWNraW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLWxlZ2FjeScpIHtcbiAgICAgICAgICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgICAgICAgLy8gV2UgdGhyb3cgYW4gZXJyb3IgaGVyZSB0byBpbnRlcnJ1cHQgcHJlcmVuZGVyaW5nIHRvIG1hcmsgdGhlIHJvdXRlIGFzIGR5bmFtaWNcbiAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24pKCdjb25uZWN0aW9uJywgd29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBmYWxsIHRocm91Z2ggdG8gdGhlIGR5bmFtaWMgY29udGV4dCBiZWxvdyBidXQgd2Ugc3RpbGwgdHJhY2sgZHluYW1pYyBhY2Nlc3NcbiAgICAgICAgLy8gYmVjYXVzZSBpbiBkZXYgd2UgY2FuIHN0aWxsIGVycm9yIGZvciB0aGluZ3MgbGlrZSB1c2luZyBoZWFkZXJzIGluc2lkZSBhIGNhY2hlIGNvbnRleHRcbiAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIpKHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/request/connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/request/root-params.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/server/request/root-params.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"unstable_rootParams\", ({\n    enumerable: true,\n    get: function() {\n        return unstable_rootParams;\n    }\n}));\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(rsc)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nconst _dynamicrendering = __webpack_require__(/*! ../app-render/dynamic-rendering */ \"(rsc)/./node_modules/next/dist/server/app-render/dynamic-rendering.js\");\nconst _workasyncstorageexternal = __webpack_require__(/*! ../app-render/work-async-storage.external */ \"../app-render/work-async-storage.external\");\nconst _workunitasyncstorageexternal = __webpack_require__(/*! ../app-render/work-unit-async-storage.external */ \"./work-unit-async-storage.external\");\nconst _dynamicrenderingutils = __webpack_require__(/*! ../dynamic-rendering-utils */ \"(rsc)/./node_modules/next/dist/server/dynamic-rendering-utils.js\");\nconst _reflectutils = __webpack_require__(/*! ../../shared/lib/utils/reflect-utils */ \"(rsc)/./node_modules/next/dist/shared/lib/utils/reflect-utils.js\");\nconst CachedParams = new WeakMap();\nasync function unstable_rootParams() {\n    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();\n    if (!workStore) {\n        throw Object.defineProperty(new _invarianterror.InvariantError('Missing workStore in unstable_rootParams'), \"__NEXT_ERROR_CODE\", {\n            value: \"E615\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (!workUnitStore) {\n        throw Object.defineProperty(new Error(`Route ${workStore.route} used \\`unstable_rootParams()\\` in Pages Router. This API is only available within App Router.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E641\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    switch(workUnitStore.type){\n        case 'unstable-cache':\n        case 'cache':\n            {\n                throw Object.defineProperty(new Error(`Route ${workStore.route} used \\`unstable_rootParams()\\` inside \\`\"use cache\"\\` or \\`unstable_cache\\`. Support for this API inside cache scopes is planned for a future version of Next.js.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E642\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        case 'prerender':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n            return createPrerenderRootParams(workUnitStore.rootParams, workStore, workUnitStore);\n        default:\n            return Promise.resolve(workUnitStore.rootParams);\n    }\n}\nfunction createPrerenderRootParams(underlyingParams, workStore, prerenderStore) {\n    const fallbackParams = workStore.fallbackRouteParams;\n    if (fallbackParams) {\n        let hasSomeFallbackParams = false;\n        for(const key in underlyingParams){\n            if (fallbackParams.has(key)) {\n                hasSomeFallbackParams = true;\n                break;\n            }\n        }\n        if (hasSomeFallbackParams) {\n            // params need to be treated as dynamic because we have at least one fallback param\n            if (prerenderStore.type === 'prerender') {\n                // We are in a dynamicIO (PPR or otherwise) prerender\n                const cachedParams = CachedParams.get(underlyingParams);\n                if (cachedParams) {\n                    return cachedParams;\n                }\n                const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`unstable_rootParams`');\n                CachedParams.set(underlyingParams, promise);\n                return promise;\n            }\n            // remaining cases are prerender-ppr and prerender-legacy\n            // We aren't in a dynamicIO prerender but we do have fallback params at this\n            // level so we need to make an erroring params object which will postpone\n            // if you access the fallback params\n            return makeErroringRootParams(underlyingParams, fallbackParams, workStore, prerenderStore);\n        }\n    }\n    // We don't have any fallback params so we have an entirely static safe params object\n    return Promise.resolve(underlyingParams);\n}\nfunction makeErroringRootParams(underlyingParams, fallbackParams, workStore, prerenderStore) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    const augmentedUnderlying = {\n        ...underlyingParams\n    };\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = Promise.resolve(augmentedUnderlying);\n    CachedParams.set(underlyingParams, promise);\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (_reflectutils.wellKnownProperties.has(prop)) {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        } else {\n            if (fallbackParams.has(prop)) {\n                Object.defineProperty(augmentedUnderlying, prop, {\n                    get () {\n                        const expression = (0, _reflectutils.describeStringPropertyAccess)('unstable_rootParams', prop);\n                        // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n                        // for params is only dynamic when we're generating a fallback shell\n                        // and even when `dynamic = \"error\"` we still support generating dynamic\n                        // fallback shells\n                        // TODO remove this comment when dynamicIO is the default since there\n                        // will be no `dynamic = \"error\"`\n                        if (prerenderStore.type === 'prerender-ppr') {\n                            // PPR Prerender (no dynamicIO)\n                            (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n                        } else {\n                            // Legacy Prerender\n                            (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n                        }\n                    },\n                    enumerable: true\n                });\n            } else {\n                ;\n                promise[prop] = underlyingParams[prop];\n            }\n        }\n    });\n    return promise;\n}\n\n//# sourceMappingURL=root-params.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yZXF1ZXN0L3Jvb3QtcGFyYW1zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0JBQXdCLG1CQUFPLENBQUMsc0dBQWtDO0FBQ2xFLDBCQUEwQixtQkFBTyxDQUFDLDhHQUFpQztBQUNuRSxrQ0FBa0MsbUJBQU8sQ0FBQyw0RkFBMkM7QUFDckYsc0NBQXNDLG1CQUFPLENBQUMsMEZBQWdEO0FBQzlGLCtCQUErQixtQkFBTyxDQUFDLG9HQUE0QjtBQUNuRSxzQkFBc0IsbUJBQU8sQ0FBQyw4R0FBc0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsaUJBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGlCQUFpQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFxyZXF1ZXN0XFxyb290LXBhcmFtcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVuc3RhYmxlX3Jvb3RQYXJhbXNcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVuc3RhYmxlX3Jvb3RQYXJhbXM7XG4gICAgfVxufSk7XG5jb25zdCBfaW52YXJpYW50ZXJyb3IgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3JcIik7XG5jb25zdCBfZHluYW1pY3JlbmRlcmluZyA9IHJlcXVpcmUoXCIuLi9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nXCIpO1xuY29uc3QgX3dvcmthc3luY3N0b3JhZ2VleHRlcm5hbCA9IHJlcXVpcmUoXCIuLi9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbFwiKTtcbmNvbnN0IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsID0gcmVxdWlyZShcIi4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWxcIik7XG5jb25zdCBfZHluYW1pY3JlbmRlcmluZ3V0aWxzID0gcmVxdWlyZShcIi4uL2R5bmFtaWMtcmVuZGVyaW5nLXV0aWxzXCIpO1xuY29uc3QgX3JlZmxlY3R1dGlscyA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL3V0aWxzL3JlZmxlY3QtdXRpbHNcIik7XG5jb25zdCBDYWNoZWRQYXJhbXMgPSBuZXcgV2Vha01hcCgpO1xuYXN5bmMgZnVuY3Rpb24gdW5zdGFibGVfcm9vdFBhcmFtcygpIHtcbiAgICBjb25zdCB3b3JrU3RvcmUgPSBfd29ya2FzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICBpZiAoIXdvcmtTdG9yZSkge1xuICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IF9pbnZhcmlhbnRlcnJvci5JbnZhcmlhbnRFcnJvcignTWlzc2luZyB3b3JrU3RvcmUgaW4gdW5zdGFibGVfcm9vdFBhcmFtcycpLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBcIkU2MTVcIixcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB3b3JrVW5pdFN0b3JlID0gX3dvcmt1bml0YXN5bmNzdG9yYWdlZXh0ZXJuYWwud29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICBpZiAoIXdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcihgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHVzZWQgXFxgdW5zdGFibGVfcm9vdFBhcmFtcygpXFxgIGluIFBhZ2VzIFJvdXRlci4gVGhpcyBBUEkgaXMgb25seSBhdmFpbGFibGUgd2l0aGluIEFwcCBSb3V0ZXIuYCksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IFwiRTY0MVwiLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN3aXRjaCh3b3JrVW5pdFN0b3JlLnR5cGUpe1xuICAgICAgICBjYXNlICd1bnN0YWJsZS1jYWNoZSc6XG4gICAgICAgIGNhc2UgJ2NhY2hlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gdXNlZCBcXGB1bnN0YWJsZV9yb290UGFyYW1zKClcXGAgaW5zaWRlIFxcYFwidXNlIGNhY2hlXCJcXGAgb3IgXFxgdW5zdGFibGVfY2FjaGVcXGAuIFN1cHBvcnQgZm9yIHRoaXMgQVBJIGluc2lkZSBjYWNoZSBzY29wZXMgaXMgcGxhbm5lZCBmb3IgYSBmdXR1cmUgdmVyc2lvbiBvZiBOZXh0LmpzLmApLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiRTY0MlwiLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJSb290UGFyYW1zKHdvcmtVbml0U3RvcmUucm9vdFBhcmFtcywgd29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUod29ya1VuaXRTdG9yZS5yb290UGFyYW1zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQcmVyZW5kZXJSb290UGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpIHtcbiAgICBjb25zdCBmYWxsYmFja1BhcmFtcyA9IHdvcmtTdG9yZS5mYWxsYmFja1JvdXRlUGFyYW1zO1xuICAgIGlmIChmYWxsYmFja1BhcmFtcykge1xuICAgICAgICBsZXQgaGFzU29tZUZhbGxiYWNrUGFyYW1zID0gZmFsc2U7XG4gICAgICAgIGZvcihjb25zdCBrZXkgaW4gdW5kZXJseWluZ1BhcmFtcyl7XG4gICAgICAgICAgICBpZiAoZmFsbGJhY2tQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBoYXNTb21lRmFsbGJhY2tQYXJhbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTb21lRmFsbGJhY2tQYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIHBhcmFtcyBuZWVkIHRvIGJlIHRyZWF0ZWQgYXMgZHluYW1pYyBiZWNhdXNlIHdlIGhhdmUgYXQgbGVhc3Qgb25lIGZhbGxiYWNrIHBhcmFtXG4gICAgICAgICAgICBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgaW4gYSBkeW5hbWljSU8gKFBQUiBvciBvdGhlcndpc2UpIHByZXJlbmRlclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gKDAsIF9keW5hbWljcmVuZGVyaW5ndXRpbHMubWFrZUhhbmdpbmdQcm9taXNlKShwcmVyZW5kZXJTdG9yZS5yZW5kZXJTaWduYWwsICdgdW5zdGFibGVfcm9vdFBhcmFtc2AnKTtcbiAgICAgICAgICAgICAgICBDYWNoZWRQYXJhbXMuc2V0KHVuZGVybHlpbmdQYXJhbXMsIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtYWluaW5nIGNhc2VzIGFyZSBwcmVyZW5kZXItcHByIGFuZCBwcmVyZW5kZXItbGVnYWN5XG4gICAgICAgICAgICAvLyBXZSBhcmVuJ3QgaW4gYSBkeW5hbWljSU8gcHJlcmVuZGVyIGJ1dCB3ZSBkbyBoYXZlIGZhbGxiYWNrIHBhcmFtcyBhdCB0aGlzXG4gICAgICAgICAgICAvLyBsZXZlbCBzbyB3ZSBuZWVkIHRvIG1ha2UgYW4gZXJyb3JpbmcgcGFyYW1zIG9iamVjdCB3aGljaCB3aWxsIHBvc3Rwb25lXG4gICAgICAgICAgICAvLyBpZiB5b3UgYWNjZXNzIHRoZSBmYWxsYmFjayBwYXJhbXNcbiAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3JpbmdSb290UGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIGZhbGxiYWNrUGFyYW1zLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBkb24ndCBoYXZlIGFueSBmYWxsYmFjayBwYXJhbXMgc28gd2UgaGF2ZSBhbiBlbnRpcmVseSBzdGF0aWMgc2FmZSBwYXJhbXMgb2JqZWN0XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nUGFyYW1zKTtcbn1cbmZ1bmN0aW9uIG1ha2VFcnJvcmluZ1Jvb3RQYXJhbXModW5kZXJseWluZ1BhcmFtcywgZmFsbGJhY2tQYXJhbXMsIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpIHtcbiAgICBjb25zdCBjYWNoZWRQYXJhbXMgPSBDYWNoZWRQYXJhbXMuZ2V0KHVuZGVybHlpbmdQYXJhbXMpO1xuICAgIGlmIChjYWNoZWRQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFBhcmFtcztcbiAgICB9XG4gICAgY29uc3QgYXVnbWVudGVkVW5kZXJseWluZyA9IHtcbiAgICAgICAgLi4udW5kZXJseWluZ1BhcmFtc1xuICAgIH07XG4gICAgLy8gV2UgZG9uJ3QgdXNlIG1ha2VSZXNvbHZlZFJlYWN0UHJvbWlzZSBoZXJlIGJlY2F1c2UgcGFyYW1zXG4gICAgLy8gc3VwcG9ydHMgY29weWluZyB3aXRoIHNwcmVhZCBhbmQgd2UgZG9uJ3Qgd2FudCB0byB1bm5lY2Vzc2FyaWx5XG4gICAgLy8gaW5zdHJ1bWVudCB0aGUgcHJvbWlzZSB3aXRoIHNwcmVhZGFibGUgcHJvcGVydGllcyBvZiBSZWFjdFByb21pc2UuXG4gICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShhdWdtZW50ZWRVbmRlcmx5aW5nKTtcbiAgICBDYWNoZWRQYXJhbXMuc2V0KHVuZGVybHlpbmdQYXJhbXMsIHByb21pc2UpO1xuICAgIE9iamVjdC5rZXlzKHVuZGVybHlpbmdQYXJhbXMpLmZvckVhY2goKHByb3ApPT57XG4gICAgICAgIGlmIChfcmVmbGVjdHV0aWxzLndlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmYWxsYmFja1BhcmFtcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXVnbWVudGVkVW5kZXJseWluZywgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfcmVmbGVjdHV0aWxzLmRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MpKCd1bnN0YWJsZV9yb290UGFyYW1zJywgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBtb3N0IGR5bmFtaWMgQVBJcyB3ZSBhbHNvIHRocm93IGlmIGBkeW5hbWljID0gXCJlcnJvclwiYCBob3dldmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcGFyYW1zIGlzIG9ubHkgZHluYW1pYyB3aGVuIHdlJ3JlIGdlbmVyYXRpbmcgYSBmYWxsYmFjayBzaGVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGV2ZW4gd2hlbiBgZHluYW1pYyA9IFwiZXJyb3JcImAgd2Ugc3RpbGwgc3VwcG9ydCBnZW5lcmF0aW5nIGR5bmFtaWNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrIHNoZWxsc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhpcyBjb21tZW50IHdoZW4gZHluYW1pY0lPIGlzIHRoZSBkZWZhdWx0IHNpbmNlIHRoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIG5vIGBkeW5hbWljID0gXCJlcnJvclwiYFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBQUiBQcmVyZW5kZXIgKG5vIGR5bmFtaWNJTylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcucG9zdHBvbmVXaXRoVHJhY2tpbmcpKHdvcmtTdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbiwgcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVnYWN5IFByZXJlbmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy50aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbikoZXhwcmVzc2lvbiwgd29ya1N0b3JlLCBwcmVyZW5kZXJTdG9yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIHByb21pc2VbcHJvcF0gPSB1bmRlcmx5aW5nUGFyYW1zW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvb3QtcGFyYW1zLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/request/root-params.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/request/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/server/request/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isRequestAPICallableInsideAfter: function() {\n        return isRequestAPICallableInsideAfter;\n    },\n    throwForSearchParamsAccessInUseCache: function() {\n        return throwForSearchParamsAccessInUseCache;\n    },\n    throwWithStaticGenerationBailoutError: function() {\n        return throwWithStaticGenerationBailoutError;\n    },\n    throwWithStaticGenerationBailoutErrorWithDynamicError: function() {\n        return throwWithStaticGenerationBailoutErrorWithDynamicError;\n    }\n});\nconst _staticgenerationbailout = __webpack_require__(/*! ../../client/components/static-generation-bailout */ \"(rsc)/./node_modules/next/dist/client/components/static-generation-bailout.js\");\nconst _aftertaskasyncstorageexternal = __webpack_require__(/*! ../app-render/after-task-async-storage.external */ \"../app-render/after-task-async-storage.external\");\nfunction throwWithStaticGenerationBailoutError(route, expression) {\n    throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n        value: \"E576\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {\n    throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError(`Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n        value: \"E543\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction throwForSearchParamsAccessInUseCache(route) {\n    throw Object.defineProperty(new Error(`Route ${route} used \"searchParams\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"searchParams\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n        value: \"E634\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction isRequestAPICallableInsideAfter() {\n    const afterTaskStore = _aftertaskasyncstorageexternal.afterTaskAsyncStorage.getStore();\n    return (afterTaskStore == null ? void 0 : afterTaskStore.rootTaskSpawnPhase) === 'action';\n}\n\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yZXF1ZXN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsTUFBTSxDQUtMO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQ0FBaUMsbUJBQU8sQ0FBQyx3SUFBbUQ7QUFDNUYsdUNBQXVDLG1CQUFPLENBQUMsd0dBQWlEO0FBQ2hHO0FBQ0EsNEZBQTRGLE9BQU8sa0RBQWtELFdBQVc7QUFDaEs7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0RkFBNEYsT0FBTyw2RUFBNkUsV0FBVztBQUMzTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFxyZXF1ZXN0XFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXI6IG51bGwsXG4gICAgdGhyb3dGb3JTZWFyY2hQYXJhbXNBY2Nlc3NJblVzZUNhY2hlOiBudWxsLFxuICAgIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3I6IG51bGwsXG4gICAgdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3I6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgaXNSZXF1ZXN0QVBJQ2FsbGFibGVJbnNpZGVBZnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc1JlcXVlc3RBUElDYWxsYWJsZUluc2lkZUFmdGVyO1xuICAgIH0sXG4gICAgdGhyb3dGb3JTZWFyY2hQYXJhbXNBY2Nlc3NJblVzZUNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRocm93Rm9yU2VhcmNoUGFyYW1zQWNjZXNzSW5Vc2VDYWNoZTtcbiAgICB9LFxuICAgIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcjtcbiAgICB9LFxuICAgIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yO1xuICAgIH1cbn0pO1xuY29uc3QgX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0ID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXRcIik7XG5jb25zdCBfYWZ0ZXJ0YXNrYXN5bmNzdG9yYWdlZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi4vYXBwLXJlbmRlci9hZnRlci10YXNrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWxcIik7XG5mdW5jdGlvbiB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yKHJvdXRlLCBleHByZXNzaW9uKSB7XG4gICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBfc3RhdGljZ2VuZXJhdGlvbmJhaWxvdXQuU3RhdGljR2VuQmFpbG91dEVycm9yKGBSb3V0ZSAke3JvdXRlfSBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCAke2V4cHJlc3Npb259LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zdGF0aWMtYW5kLWR5bmFtaWMjZHluYW1pYy1yZW5kZXJpbmdgKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgIHZhbHVlOiBcIkU1NzZcIixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xufVxuZnVuY3Rpb24gdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3Iocm91dGUsIGV4cHJlc3Npb24pIHtcbiAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IF9zdGF0aWNnZW5lcmF0aW9uYmFpbG91dC5TdGF0aWNHZW5CYWlsb3V0RXJyb3IoYFJvdXRlICR7cm91dGV9IHdpdGggXFxgZHluYW1pYyA9IFwiZXJyb3JcIlxcYCBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCAke2V4cHJlc3Npb259LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zdGF0aWMtYW5kLWR5bmFtaWMjZHluYW1pYy1yZW5kZXJpbmdgKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgIHZhbHVlOiBcIkU1NDNcIixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xufVxuZnVuY3Rpb24gdGhyb3dGb3JTZWFyY2hQYXJhbXNBY2Nlc3NJblVzZUNhY2hlKHJvdXRlKSB7XG4gICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcihgUm91dGUgJHtyb3V0ZX0gdXNlZCBcInNlYXJjaFBhcmFtc1wiIGluc2lkZSBcInVzZSBjYWNoZVwiLiBBY2Nlc3NpbmcgRHluYW1pYyBkYXRhIHNvdXJjZXMgaW5zaWRlIGEgY2FjaGUgc2NvcGUgaXMgbm90IHN1cHBvcnRlZC4gSWYgeW91IG5lZWQgdGhpcyBkYXRhIGluc2lkZSBhIGNhY2hlZCBmdW5jdGlvbiB1c2UgXCJzZWFyY2hQYXJhbXNcIiBvdXRzaWRlIG9mIHRoZSBjYWNoZWQgZnVuY3Rpb24gYW5kIHBhc3MgdGhlIHJlcXVpcmVkIGR5bmFtaWMgZGF0YSBpbiBhcyBhbiBhcmd1bWVudC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXJlcXVlc3QtaW4tdXNlLWNhY2hlYCksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICB2YWx1ZTogXCJFNjM0XCIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIoKSB7XG4gICAgY29uc3QgYWZ0ZXJUYXNrU3RvcmUgPSBfYWZ0ZXJ0YXNrYXN5bmNzdG9yYWdlZXh0ZXJuYWwuYWZ0ZXJUYXNrQXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgcmV0dXJuIChhZnRlclRhc2tTdG9yZSA9PSBudWxsID8gdm9pZCAwIDogYWZ0ZXJUYXNrU3RvcmUucm9vdFRhc2tTcGF3blBoYXNlKSA9PT0gJ2FjdGlvbic7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/request/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/response-cache/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/server/response-cache/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return ResponseCache;\n    }\n}));\n0 && 0;\nconst _batcher = __webpack_require__(/*! ../../lib/batcher */ \"(rsc)/./node_modules/next/dist/lib/batcher.js\");\nconst _scheduler = __webpack_require__(/*! ../../lib/scheduler */ \"(rsc)/./node_modules/next/dist/lib/scheduler.js\");\nconst _utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/next/dist/server/response-cache/utils.js\");\n_export_star(__webpack_require__(/*! ./types */ \"(rsc)/./node_modules/next/dist/server/response-cache/types.js\"), exports);\nfunction _export_star(from, to) {\n    Object.keys(from).forEach(function(k) {\n        if (k !== \"default\" && !Object.prototype.hasOwnProperty.call(to, k)) {\n            Object.defineProperty(to, k, {\n                enumerable: true,\n                get: function() {\n                    return from[k];\n                }\n            });\n        }\n    });\n    return from;\n}\nclass ResponseCache {\n    constructor(minimalMode){\n        this.batcher = _batcher.Batcher.create({\n            // Ensure on-demand revalidate doesn't block normal requests, it should be\n            // safe to run an on-demand revalidate for the same key as a normal request.\n            cacheKeyFn: ({ key, isOnDemandRevalidate })=>`${key}-${isOnDemandRevalidate ? '1' : '0'}`,\n            // We wait to do any async work until after we've added our promise to\n            // `pendingResponses` to ensure that any any other calls will reuse the\n            // same promise until we've fully finished our work.\n            schedulerFn: _scheduler.scheduleOnNextTick\n        });\n        // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n        // because we replace this.minimalMode to true in production bundles.\n        const minimalModeKey = 'minimalMode';\n        this[minimalModeKey] = minimalMode;\n    }\n    async get(key, responseGenerator, context) {\n        // If there is no key for the cache, we can't possibly look this up in the\n        // cache so just return the result of the response generator.\n        if (!key) {\n            return responseGenerator({\n                hasResolved: false,\n                previousCacheEntry: null\n            });\n        }\n        const { incrementalCache, isOnDemandRevalidate = false, isFallback = false, isRoutePPREnabled = false } = context;\n        const response = await this.batcher.batch({\n            key,\n            isOnDemandRevalidate\n        }, async (cacheKey, resolve)=>{\n            var _this_previousCacheItem;\n            // We keep the previous cache entry around to leverage when the\n            // incremental cache is disabled in minimal mode.\n            if (this.minimalMode && ((_this_previousCacheItem = this.previousCacheItem) == null ? void 0 : _this_previousCacheItem.key) === cacheKey && this.previousCacheItem.expiresAt > Date.now()) {\n                return this.previousCacheItem.entry;\n            }\n            // Coerce the kindHint into a given kind for the incremental cache.\n            const kind = (0, _utils.routeKindToIncrementalCacheKind)(context.routeKind);\n            let resolved = false;\n            let cachedResponse = null;\n            try {\n                cachedResponse = !this.minimalMode ? await incrementalCache.get(key, {\n                    kind,\n                    isRoutePPREnabled: context.isRoutePPREnabled,\n                    isFallback\n                }) : null;\n                if (cachedResponse && !isOnDemandRevalidate) {\n                    resolve(cachedResponse);\n                    resolved = true;\n                    if (!cachedResponse.isStale || context.isPrefetch) {\n                        // The cached value is still valid, so we don't need\n                        // to update it yet.\n                        return null;\n                    }\n                }\n                const cacheEntry = await responseGenerator({\n                    hasResolved: resolved,\n                    previousCacheEntry: cachedResponse,\n                    isRevalidating: true\n                });\n                // If the cache entry couldn't be generated, we don't want to cache\n                // the result.\n                if (!cacheEntry) {\n                    // Unset the previous cache item if it was set.\n                    if (this.minimalMode) this.previousCacheItem = undefined;\n                    return null;\n                }\n                const resolveValue = await (0, _utils.fromResponseCacheEntry)({\n                    ...cacheEntry,\n                    isMiss: !cachedResponse\n                });\n                if (!resolveValue) {\n                    // Unset the previous cache item if it was set.\n                    if (this.minimalMode) this.previousCacheItem = undefined;\n                    return null;\n                }\n                // For on-demand revalidate wait to resolve until cache is set.\n                // Otherwise resolve now.\n                if (!isOnDemandRevalidate && !resolved) {\n                    resolve(resolveValue);\n                    resolved = true;\n                }\n                // We want to persist the result only if it has a cache control value\n                // defined.\n                if (resolveValue.cacheControl) {\n                    if (this.minimalMode) {\n                        this.previousCacheItem = {\n                            key: cacheKey,\n                            entry: resolveValue,\n                            expiresAt: Date.now() + 1000\n                        };\n                    } else {\n                        await incrementalCache.set(key, resolveValue.value, {\n                            cacheControl: resolveValue.cacheControl,\n                            isRoutePPREnabled,\n                            isFallback\n                        });\n                    }\n                }\n                return resolveValue;\n            } catch (err) {\n                // When a path is erroring we automatically re-set the existing cache\n                // with new revalidate and expire times to prevent non-stop retrying.\n                if (cachedResponse == null ? void 0 : cachedResponse.cacheControl) {\n                    const newRevalidate = Math.min(Math.max(cachedResponse.cacheControl.revalidate || 3, 3), 30);\n                    const newExpire = cachedResponse.cacheControl.expire === undefined ? undefined : Math.max(newRevalidate + 3, cachedResponse.cacheControl.expire);\n                    await incrementalCache.set(key, cachedResponse.value, {\n                        cacheControl: {\n                            revalidate: newRevalidate,\n                            expire: newExpire\n                        },\n                        isRoutePPREnabled,\n                        isFallback\n                    });\n                }\n                // While revalidating in the background we can't reject as we already\n                // resolved the cache entry so log the error here.\n                if (resolved) {\n                    console.error(err);\n                    return null;\n                }\n                // We haven't resolved yet, so let's throw to indicate an error.\n                throw err;\n            }\n        });\n        return (0, _utils.toResponseCacheEntry)(response);\n    }\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yZXNwb25zZS1jYWNoZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLDJDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLEtBQUssQ0FBNEI7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQW1CO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFxQjtBQUNoRCxlQUFlLG1CQUFPLENBQUMsOEVBQVM7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLDhFQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCLE1BQU0sSUFBSSxHQUFHLGlDQUFpQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0IsZ0dBQWdHO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFxyZXNwb25zZS1jYWNoZVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZXNwb25zZUNhY2hlO1xuICAgIH1cbn0pO1xuMCAmJiBfX2V4cG9ydChyZXF1aXJlKFwiLi90eXBlc1wiKSk7XG5jb25zdCBfYmF0Y2hlciA9IHJlcXVpcmUoXCIuLi8uLi9saWIvYmF0Y2hlclwiKTtcbmNvbnN0IF9zY2hlZHVsZXIgPSByZXF1aXJlKFwiLi4vLi4vbGliL3NjaGVkdWxlclwiKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuX2V4cG9ydF9zdGFyKHJlcXVpcmUoXCIuL3R5cGVzXCIpLCBleHBvcnRzKTtcbmZ1bmN0aW9uIF9leHBvcnRfc3Rhcihmcm9tLCB0bykge1xuICAgIE9iamVjdC5rZXlzKGZyb20pLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0bywgaykpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0bywgaywge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb21ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZnJvbTtcbn1cbmNsYXNzIFJlc3BvbnNlQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKG1pbmltYWxNb2RlKXtcbiAgICAgICAgdGhpcy5iYXRjaGVyID0gX2JhdGNoZXIuQmF0Y2hlci5jcmVhdGUoe1xuICAgICAgICAgICAgLy8gRW5zdXJlIG9uLWRlbWFuZCByZXZhbGlkYXRlIGRvZXNuJ3QgYmxvY2sgbm9ybWFsIHJlcXVlc3RzLCBpdCBzaG91bGQgYmVcbiAgICAgICAgICAgIC8vIHNhZmUgdG8gcnVuIGFuIG9uLWRlbWFuZCByZXZhbGlkYXRlIGZvciB0aGUgc2FtZSBrZXkgYXMgYSBub3JtYWwgcmVxdWVzdC5cbiAgICAgICAgICAgIGNhY2hlS2V5Rm46ICh7IGtleSwgaXNPbkRlbWFuZFJldmFsaWRhdGUgfSk9PmAke2tleX0tJHtpc09uRGVtYW5kUmV2YWxpZGF0ZSA/ICcxJyA6ICcwJ31gLFxuICAgICAgICAgICAgLy8gV2Ugd2FpdCB0byBkbyBhbnkgYXN5bmMgd29yayB1bnRpbCBhZnRlciB3ZSd2ZSBhZGRlZCBvdXIgcHJvbWlzZSB0b1xuICAgICAgICAgICAgLy8gYHBlbmRpbmdSZXNwb25zZXNgIHRvIGVuc3VyZSB0aGF0IGFueSBhbnkgb3RoZXIgY2FsbHMgd2lsbCByZXVzZSB0aGVcbiAgICAgICAgICAgIC8vIHNhbWUgcHJvbWlzZSB1bnRpbCB3ZSd2ZSBmdWxseSBmaW5pc2hlZCBvdXIgd29yay5cbiAgICAgICAgICAgIHNjaGVkdWxlckZuOiBfc2NoZWR1bGVyLnNjaGVkdWxlT25OZXh0VGlja1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhpcyBpcyBhIGhhY2sgdG8gYXZvaWQgV2VicGFjayBrbm93aW5nIHRoaXMgaXMgZXF1YWwgdG8gdGhpcy5taW5pbWFsTW9kZVxuICAgICAgICAvLyBiZWNhdXNlIHdlIHJlcGxhY2UgdGhpcy5taW5pbWFsTW9kZSB0byB0cnVlIGluIHByb2R1Y3Rpb24gYnVuZGxlcy5cbiAgICAgICAgY29uc3QgbWluaW1hbE1vZGVLZXkgPSAnbWluaW1hbE1vZGUnO1xuICAgICAgICB0aGlzW21pbmltYWxNb2RlS2V5XSA9IG1pbmltYWxNb2RlO1xuICAgIH1cbiAgICBhc3luYyBnZXQoa2V5LCByZXNwb25zZUdlbmVyYXRvciwgY29udGV4dCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBrZXkgZm9yIHRoZSBjYWNoZSwgd2UgY2FuJ3QgcG9zc2libHkgbG9vayB0aGlzIHVwIGluIHRoZVxuICAgICAgICAvLyBjYWNoZSBzbyBqdXN0IHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSByZXNwb25zZSBnZW5lcmF0b3IuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VHZW5lcmF0b3Ioe1xuICAgICAgICAgICAgICAgIGhhc1Jlc29sdmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c0NhY2hlRW50cnk6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaW5jcmVtZW50YWxDYWNoZSwgaXNPbkRlbWFuZFJldmFsaWRhdGUgPSBmYWxzZSwgaXNGYWxsYmFjayA9IGZhbHNlLCBpc1JvdXRlUFBSRW5hYmxlZCA9IGZhbHNlIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYmF0Y2hlci5iYXRjaCh7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBpc09uRGVtYW5kUmV2YWxpZGF0ZVxuICAgICAgICB9LCBhc3luYyAoY2FjaGVLZXksIHJlc29sdmUpPT57XG4gICAgICAgICAgICB2YXIgX3RoaXNfcHJldmlvdXNDYWNoZUl0ZW07XG4gICAgICAgICAgICAvLyBXZSBrZWVwIHRoZSBwcmV2aW91cyBjYWNoZSBlbnRyeSBhcm91bmQgdG8gbGV2ZXJhZ2Ugd2hlbiB0aGVcbiAgICAgICAgICAgIC8vIGluY3JlbWVudGFsIGNhY2hlIGlzIGRpc2FibGVkIGluIG1pbmltYWwgbW9kZS5cbiAgICAgICAgICAgIGlmICh0aGlzLm1pbmltYWxNb2RlICYmICgoX3RoaXNfcHJldmlvdXNDYWNoZUl0ZW0gPSB0aGlzLnByZXZpb3VzQ2FjaGVJdGVtKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfcHJldmlvdXNDYWNoZUl0ZW0ua2V5KSA9PT0gY2FjaGVLZXkgJiYgdGhpcy5wcmV2aW91c0NhY2hlSXRlbS5leHBpcmVzQXQgPiBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNDYWNoZUl0ZW0uZW50cnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb2VyY2UgdGhlIGtpbmRIaW50IGludG8gYSBnaXZlbiBraW5kIGZvciB0aGUgaW5jcmVtZW50YWwgY2FjaGUuXG4gICAgICAgICAgICBjb25zdCBraW5kID0gKDAsIF91dGlscy5yb3V0ZUtpbmRUb0luY3JlbWVudGFsQ2FjaGVLaW5kKShjb250ZXh0LnJvdXRlS2luZCk7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjYWNoZWRSZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhY2hlZFJlc3BvbnNlID0gIXRoaXMubWluaW1hbE1vZGUgPyBhd2FpdCBpbmNyZW1lbnRhbENhY2hlLmdldChrZXksIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQ6IGNvbnRleHQuaXNSb3V0ZVBQUkVuYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIGlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgICB9KSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3BvbnNlICYmICFpc09uRGVtYW5kUmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNhY2hlZFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZFJlc3BvbnNlLmlzU3RhbGUgfHwgY29udGV4dC5pc1ByZWZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY2FjaGVkIHZhbHVlIGlzIHN0aWxsIHZhbGlkLCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byB1cGRhdGUgaXQgeWV0LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IGF3YWl0IHJlc3BvbnNlR2VuZXJhdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgaGFzUmVzb2x2ZWQ6IHJlc29sdmVkLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0NhY2hlRW50cnk6IGNhY2hlZFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGluZzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjYWNoZSBlbnRyeSBjb3VsZG4ndCBiZSBnZW5lcmF0ZWQsIHdlIGRvbid0IHdhbnQgdG8gY2FjaGVcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgICAgIGlmICghY2FjaGVFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbnNldCB0aGUgcHJldmlvdXMgY2FjaGUgaXRlbSBpZiBpdCB3YXMgc2V0LlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5taW5pbWFsTW9kZSkgdGhpcy5wcmV2aW91c0NhY2hlSXRlbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVWYWx1ZSA9IGF3YWl0ICgwLCBfdXRpbHMuZnJvbVJlc3BvbnNlQ2FjaGVFbnRyeSkoe1xuICAgICAgICAgICAgICAgICAgICAuLi5jYWNoZUVudHJ5LFxuICAgICAgICAgICAgICAgICAgICBpc01pc3M6ICFjYWNoZWRSZXNwb25zZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuc2V0IHRoZSBwcmV2aW91cyBjYWNoZSBpdGVtIGlmIGl0IHdhcyBzZXQuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pbmltYWxNb2RlKSB0aGlzLnByZXZpb3VzQ2FjaGVJdGVtID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRm9yIG9uLWRlbWFuZCByZXZhbGlkYXRlIHdhaXQgdG8gcmVzb2x2ZSB1bnRpbCBjYWNoZSBpcyBzZXQuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc29sdmUgbm93LlxuICAgICAgICAgICAgICAgIGlmICghaXNPbkRlbWFuZFJldmFsaWRhdGUgJiYgIXJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRvIHBlcnNpc3QgdGhlIHJlc3VsdCBvbmx5IGlmIGl0IGhhcyBhIGNhY2hlIGNvbnRyb2wgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmVkLlxuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlVmFsdWUuY2FjaGVDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pbmltYWxNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQ2FjaGVJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnk6IHJlc29sdmVWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVzQXQ6IERhdGUubm93KCkgKyAxMDAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgaW5jcmVtZW50YWxDYWNoZS5zZXQoa2V5LCByZXNvbHZlVmFsdWUudmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2w6IHJlc29sdmVWYWx1ZS5jYWNoZUNvbnRyb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVWYWx1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gYSBwYXRoIGlzIGVycm9yaW5nIHdlIGF1dG9tYXRpY2FsbHkgcmUtc2V0IHRoZSBleGlzdGluZyBjYWNoZVxuICAgICAgICAgICAgICAgIC8vIHdpdGggbmV3IHJldmFsaWRhdGUgYW5kIGV4cGlyZSB0aW1lcyB0byBwcmV2ZW50IG5vbi1zdG9wIHJldHJ5aW5nLlxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogY2FjaGVkUmVzcG9uc2UuY2FjaGVDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JldmFsaWRhdGUgPSBNYXRoLm1pbihNYXRoLm1heChjYWNoZWRSZXNwb25zZS5jYWNoZUNvbnRyb2wucmV2YWxpZGF0ZSB8fCAzLCAzKSwgMzApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdFeHBpcmUgPSBjYWNoZWRSZXNwb25zZS5jYWNoZUNvbnRyb2wuZXhwaXJlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBNYXRoLm1heChuZXdSZXZhbGlkYXRlICsgMywgY2FjaGVkUmVzcG9uc2UuY2FjaGVDb250cm9sLmV4cGlyZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGluY3JlbWVudGFsQ2FjaGUuc2V0KGtleSwgY2FjaGVkUmVzcG9uc2UudmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlQ29udHJvbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGU6IG5ld1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlOiBuZXdFeHBpcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1JvdXRlUFBSRW5hYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdoaWxlIHJldmFsaWRhdGluZyBpbiB0aGUgYmFja2dyb3VuZCB3ZSBjYW4ndCByZWplY3QgYXMgd2UgYWxyZWFkeVxuICAgICAgICAgICAgICAgIC8vIHJlc29sdmVkIHRoZSBjYWNoZSBlbnRyeSBzbyBsb2cgdGhlIGVycm9yIGhlcmUuXG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmVuJ3QgcmVzb2x2ZWQgeWV0LCBzbyBsZXQncyB0aHJvdyB0byBpbmRpY2F0ZSBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKDAsIF91dGlscy50b1Jlc3BvbnNlQ2FjaGVFbnRyeSkocmVzcG9uc2UpO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/response-cache/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/response-cache/types.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/server/response-cache/types.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    CachedRouteKind: function() {\n        return CachedRouteKind;\n    },\n    IncrementalCacheKind: function() {\n        return IncrementalCacheKind;\n    }\n});\nvar CachedRouteKind = /*#__PURE__*/ function(CachedRouteKind) {\n    CachedRouteKind[\"APP_PAGE\"] = \"APP_PAGE\";\n    CachedRouteKind[\"APP_ROUTE\"] = \"APP_ROUTE\";\n    CachedRouteKind[\"PAGES\"] = \"PAGES\";\n    CachedRouteKind[\"FETCH\"] = \"FETCH\";\n    CachedRouteKind[\"REDIRECT\"] = \"REDIRECT\";\n    CachedRouteKind[\"IMAGE\"] = \"IMAGE\";\n    return CachedRouteKind;\n}({});\nvar IncrementalCacheKind = /*#__PURE__*/ function(IncrementalCacheKind) {\n    IncrementalCacheKind[\"APP_PAGE\"] = \"APP_PAGE\";\n    IncrementalCacheKind[\"APP_ROUTE\"] = \"APP_ROUTE\";\n    IncrementalCacheKind[\"PAGES\"] = \"PAGES\";\n    IncrementalCacheKind[\"FETCH\"] = \"FETCH\";\n    IncrementalCacheKind[\"IMAGE\"] = \"IMAGE\";\n    return IncrementalCacheKind;\n}({});\n\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yZXNwb25zZS1jYWNoZS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLE1BQU0sQ0FHTDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUoiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxzZXJ2ZXJcXHJlc3BvbnNlLWNhY2hlXFx0eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIENhY2hlZFJvdXRlS2luZDogbnVsbCxcbiAgICBJbmNyZW1lbnRhbENhY2hlS2luZDogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBDYWNoZWRSb3V0ZUtpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQ2FjaGVkUm91dGVLaW5kO1xuICAgIH0sXG4gICAgSW5jcmVtZW50YWxDYWNoZUtpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSW5jcmVtZW50YWxDYWNoZUtpbmQ7XG4gICAgfVxufSk7XG52YXIgQ2FjaGVkUm91dGVLaW5kID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihDYWNoZWRSb3V0ZUtpbmQpIHtcbiAgICBDYWNoZWRSb3V0ZUtpbmRbXCJBUFBfUEFHRVwiXSA9IFwiQVBQX1BBR0VcIjtcbiAgICBDYWNoZWRSb3V0ZUtpbmRbXCJBUFBfUk9VVEVcIl0gPSBcIkFQUF9ST1VURVwiO1xuICAgIENhY2hlZFJvdXRlS2luZFtcIlBBR0VTXCJdID0gXCJQQUdFU1wiO1xuICAgIENhY2hlZFJvdXRlS2luZFtcIkZFVENIXCJdID0gXCJGRVRDSFwiO1xuICAgIENhY2hlZFJvdXRlS2luZFtcIlJFRElSRUNUXCJdID0gXCJSRURJUkVDVFwiO1xuICAgIENhY2hlZFJvdXRlS2luZFtcIklNQUdFXCJdID0gXCJJTUFHRVwiO1xuICAgIHJldHVybiBDYWNoZWRSb3V0ZUtpbmQ7XG59KHt9KTtcbnZhciBJbmNyZW1lbnRhbENhY2hlS2luZCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oSW5jcmVtZW50YWxDYWNoZUtpbmQpIHtcbiAgICBJbmNyZW1lbnRhbENhY2hlS2luZFtcIkFQUF9QQUdFXCJdID0gXCJBUFBfUEFHRVwiO1xuICAgIEluY3JlbWVudGFsQ2FjaGVLaW5kW1wiQVBQX1JPVVRFXCJdID0gXCJBUFBfUk9VVEVcIjtcbiAgICBJbmNyZW1lbnRhbENhY2hlS2luZFtcIlBBR0VTXCJdID0gXCJQQUdFU1wiO1xuICAgIEluY3JlbWVudGFsQ2FjaGVLaW5kW1wiRkVUQ0hcIl0gPSBcIkZFVENIXCI7XG4gICAgSW5jcmVtZW50YWxDYWNoZUtpbmRbXCJJTUFHRVwiXSA9IFwiSU1BR0VcIjtcbiAgICByZXR1cm4gSW5jcmVtZW50YWxDYWNoZUtpbmQ7XG59KHt9KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/response-cache/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/response-cache/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/server/response-cache/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    fromResponseCacheEntry: function() {\n        return fromResponseCacheEntry;\n    },\n    routeKindToIncrementalCacheKind: function() {\n        return routeKindToIncrementalCacheKind;\n    },\n    toResponseCacheEntry: function() {\n        return toResponseCacheEntry;\n    }\n});\nconst _types = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/next/dist/server/response-cache/types.js\");\nconst _renderresult = /*#__PURE__*/ _interop_require_default(__webpack_require__(/*! ../render-result */ \"(rsc)/./node_modules/next/dist/server/render-result.js\"));\nconst _routekind = __webpack_require__(/*! ../route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nasync function fromResponseCacheEntry(cacheEntry) {\n    var _cacheEntry_value, _cacheEntry_value1;\n    return {\n        ...cacheEntry,\n        value: ((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) === _types.CachedRouteKind.PAGES ? {\n            kind: _types.CachedRouteKind.PAGES,\n            html: await cacheEntry.value.html.toUnchunkedString(true),\n            pageData: cacheEntry.value.pageData,\n            headers: cacheEntry.value.headers,\n            status: cacheEntry.value.status\n        } : ((_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind) === _types.CachedRouteKind.APP_PAGE ? {\n            kind: _types.CachedRouteKind.APP_PAGE,\n            html: await cacheEntry.value.html.toUnchunkedString(true),\n            postponed: cacheEntry.value.postponed,\n            rscData: cacheEntry.value.rscData,\n            headers: cacheEntry.value.headers,\n            status: cacheEntry.value.status,\n            segmentData: cacheEntry.value.segmentData\n        } : cacheEntry.value\n    };\n}\nasync function toResponseCacheEntry(response) {\n    var _response_value, _response_value1;\n    if (!response) return null;\n    return {\n        isMiss: response.isMiss,\n        isStale: response.isStale,\n        cacheControl: response.cacheControl,\n        isFallback: response.isFallback,\n        value: ((_response_value = response.value) == null ? void 0 : _response_value.kind) === _types.CachedRouteKind.PAGES ? {\n            kind: _types.CachedRouteKind.PAGES,\n            html: _renderresult.default.fromStatic(response.value.html),\n            pageData: response.value.pageData,\n            headers: response.value.headers,\n            status: response.value.status\n        } : ((_response_value1 = response.value) == null ? void 0 : _response_value1.kind) === _types.CachedRouteKind.APP_PAGE ? {\n            kind: _types.CachedRouteKind.APP_PAGE,\n            html: _renderresult.default.fromStatic(response.value.html),\n            rscData: response.value.rscData,\n            headers: response.value.headers,\n            status: response.value.status,\n            postponed: response.value.postponed,\n            segmentData: response.value.segmentData\n        } : response.value\n    };\n}\nfunction routeKindToIncrementalCacheKind(routeKind) {\n    switch(routeKind){\n        case _routekind.RouteKind.PAGES:\n            return _types.IncrementalCacheKind.PAGES;\n        case _routekind.RouteKind.APP_PAGE:\n            return _types.IncrementalCacheKind.APP_PAGE;\n        case _routekind.RouteKind.IMAGE:\n            return _types.IncrementalCacheKind.IMAGE;\n        case _routekind.RouteKind.APP_ROUTE:\n            return _types.IncrementalCacheKind.APP_ROUTE;\n        default:\n            throw Object.defineProperty(new Error(`Unexpected route kind ${routeKind}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E64\",\n                enumerable: false,\n                configurable: true\n            });\n    }\n}\n\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yZXNwb25zZS1jYWNoZS91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLE1BQU0sQ0FJTDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGVBQWUsbUJBQU8sQ0FBQyw4RUFBUztBQUNoQyw2REFBNkQsbUJBQU8sQ0FBQyxnRkFBa0I7QUFDdkYsbUJBQW1CLG1CQUFPLENBQUMsMEVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLFVBQVU7QUFDckY7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxzZXJ2ZXJcXHJlc3BvbnNlLWNhY2hlXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZyb21SZXNwb25zZUNhY2hlRW50cnk6IG51bGwsXG4gICAgcm91dGVLaW5kVG9JbmNyZW1lbnRhbENhY2hlS2luZDogbnVsbCxcbiAgICB0b1Jlc3BvbnNlQ2FjaGVFbnRyeTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBmcm9tUmVzcG9uc2VDYWNoZUVudHJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZyb21SZXNwb25zZUNhY2hlRW50cnk7XG4gICAgfSxcbiAgICByb3V0ZUtpbmRUb0luY3JlbWVudGFsQ2FjaGVLaW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlS2luZFRvSW5jcmVtZW50YWxDYWNoZUtpbmQ7XG4gICAgfSxcbiAgICB0b1Jlc3BvbnNlQ2FjaGVFbnRyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0b1Jlc3BvbnNlQ2FjaGVFbnRyeTtcbiAgICB9XG59KTtcbmNvbnN0IF90eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgX3JlbmRlcnJlc3VsdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuLi9yZW5kZXItcmVzdWx0XCIpKTtcbmNvbnN0IF9yb3V0ZWtpbmQgPSByZXF1aXJlKFwiLi4vcm91dGUta2luZFwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZnJvbVJlc3BvbnNlQ2FjaGVFbnRyeShjYWNoZUVudHJ5KSB7XG4gICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlLCBfY2FjaGVFbnRyeV92YWx1ZTE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY2FjaGVFbnRyeSxcbiAgICAgICAgdmFsdWU6ICgoX2NhY2hlRW50cnlfdmFsdWUgPSBjYWNoZUVudHJ5LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2NhY2hlRW50cnlfdmFsdWUua2luZCkgPT09IF90eXBlcy5DYWNoZWRSb3V0ZUtpbmQuUEFHRVMgPyB7XG4gICAgICAgICAgICBraW5kOiBfdHlwZXMuQ2FjaGVkUm91dGVLaW5kLlBBR0VTLFxuICAgICAgICAgICAgaHRtbDogYXdhaXQgY2FjaGVFbnRyeS52YWx1ZS5odG1sLnRvVW5jaHVua2VkU3RyaW5nKHRydWUpLFxuICAgICAgICAgICAgcGFnZURhdGE6IGNhY2hlRW50cnkudmFsdWUucGFnZURhdGEsXG4gICAgICAgICAgICBoZWFkZXJzOiBjYWNoZUVudHJ5LnZhbHVlLmhlYWRlcnMsXG4gICAgICAgICAgICBzdGF0dXM6IGNhY2hlRW50cnkudmFsdWUuc3RhdHVzXG4gICAgICAgIH0gOiAoKF9jYWNoZUVudHJ5X3ZhbHVlMSA9IGNhY2hlRW50cnkudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfY2FjaGVFbnRyeV92YWx1ZTEua2luZCkgPT09IF90eXBlcy5DYWNoZWRSb3V0ZUtpbmQuQVBQX1BBR0UgPyB7XG4gICAgICAgICAgICBraW5kOiBfdHlwZXMuQ2FjaGVkUm91dGVLaW5kLkFQUF9QQUdFLFxuICAgICAgICAgICAgaHRtbDogYXdhaXQgY2FjaGVFbnRyeS52YWx1ZS5odG1sLnRvVW5jaHVua2VkU3RyaW5nKHRydWUpLFxuICAgICAgICAgICAgcG9zdHBvbmVkOiBjYWNoZUVudHJ5LnZhbHVlLnBvc3Rwb25lZCxcbiAgICAgICAgICAgIHJzY0RhdGE6IGNhY2hlRW50cnkudmFsdWUucnNjRGF0YSxcbiAgICAgICAgICAgIGhlYWRlcnM6IGNhY2hlRW50cnkudmFsdWUuaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1czogY2FjaGVFbnRyeS52YWx1ZS5zdGF0dXMsXG4gICAgICAgICAgICBzZWdtZW50RGF0YTogY2FjaGVFbnRyeS52YWx1ZS5zZWdtZW50RGF0YVxuICAgICAgICB9IDogY2FjaGVFbnRyeS52YWx1ZVxuICAgIH07XG59XG5hc3luYyBmdW5jdGlvbiB0b1Jlc3BvbnNlQ2FjaGVFbnRyeShyZXNwb25zZSkge1xuICAgIHZhciBfcmVzcG9uc2VfdmFsdWUsIF9yZXNwb25zZV92YWx1ZTE7XG4gICAgaWYgKCFyZXNwb25zZSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNNaXNzOiByZXNwb25zZS5pc01pc3MsXG4gICAgICAgIGlzU3RhbGU6IHJlc3BvbnNlLmlzU3RhbGUsXG4gICAgICAgIGNhY2hlQ29udHJvbDogcmVzcG9uc2UuY2FjaGVDb250cm9sLFxuICAgICAgICBpc0ZhbGxiYWNrOiByZXNwb25zZS5pc0ZhbGxiYWNrLFxuICAgICAgICB2YWx1ZTogKChfcmVzcG9uc2VfdmFsdWUgPSByZXNwb25zZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXNwb25zZV92YWx1ZS5raW5kKSA9PT0gX3R5cGVzLkNhY2hlZFJvdXRlS2luZC5QQUdFUyA/IHtcbiAgICAgICAgICAgIGtpbmQ6IF90eXBlcy5DYWNoZWRSb3V0ZUtpbmQuUEFHRVMsXG4gICAgICAgICAgICBodG1sOiBfcmVuZGVycmVzdWx0LmRlZmF1bHQuZnJvbVN0YXRpYyhyZXNwb25zZS52YWx1ZS5odG1sKSxcbiAgICAgICAgICAgIHBhZ2VEYXRhOiByZXNwb25zZS52YWx1ZS5wYWdlRGF0YSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLnZhbHVlLmhlYWRlcnMsXG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnZhbHVlLnN0YXR1c1xuICAgICAgICB9IDogKChfcmVzcG9uc2VfdmFsdWUxID0gcmVzcG9uc2UudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzcG9uc2VfdmFsdWUxLmtpbmQpID09PSBfdHlwZXMuQ2FjaGVkUm91dGVLaW5kLkFQUF9QQUdFID8ge1xuICAgICAgICAgICAga2luZDogX3R5cGVzLkNhY2hlZFJvdXRlS2luZC5BUFBfUEFHRSxcbiAgICAgICAgICAgIGh0bWw6IF9yZW5kZXJyZXN1bHQuZGVmYXVsdC5mcm9tU3RhdGljKHJlc3BvbnNlLnZhbHVlLmh0bWwpLFxuICAgICAgICAgICAgcnNjRGF0YTogcmVzcG9uc2UudmFsdWUucnNjRGF0YSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLnZhbHVlLmhlYWRlcnMsXG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnZhbHVlLnN0YXR1cyxcbiAgICAgICAgICAgIHBvc3Rwb25lZDogcmVzcG9uc2UudmFsdWUucG9zdHBvbmVkLFxuICAgICAgICAgICAgc2VnbWVudERhdGE6IHJlc3BvbnNlLnZhbHVlLnNlZ21lbnREYXRhXG4gICAgICAgIH0gOiByZXNwb25zZS52YWx1ZVxuICAgIH07XG59XG5mdW5jdGlvbiByb3V0ZUtpbmRUb0luY3JlbWVudGFsQ2FjaGVLaW5kKHJvdXRlS2luZCkge1xuICAgIHN3aXRjaChyb3V0ZUtpbmQpe1xuICAgICAgICBjYXNlIF9yb3V0ZWtpbmQuUm91dGVLaW5kLlBBR0VTOlxuICAgICAgICAgICAgcmV0dXJuIF90eXBlcy5JbmNyZW1lbnRhbENhY2hlS2luZC5QQUdFUztcbiAgICAgICAgY2FzZSBfcm91dGVraW5kLlJvdXRlS2luZC5BUFBfUEFHRTpcbiAgICAgICAgICAgIHJldHVybiBfdHlwZXMuSW5jcmVtZW50YWxDYWNoZUtpbmQuQVBQX1BBR0U7XG4gICAgICAgIGNhc2UgX3JvdXRla2luZC5Sb3V0ZUtpbmQuSU1BR0U6XG4gICAgICAgICAgICByZXR1cm4gX3R5cGVzLkluY3JlbWVudGFsQ2FjaGVLaW5kLklNQUdFO1xuICAgICAgICBjYXNlIF9yb3V0ZWtpbmQuUm91dGVLaW5kLkFQUF9ST1VURTpcbiAgICAgICAgICAgIHJldHVybiBfdHlwZXMuSW5jcmVtZW50YWxDYWNoZUtpbmQuQVBQX1JPVVRFO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcihgVW5leHBlY3RlZCByb3V0ZSBraW5kICR7cm91dGVLaW5kfWApLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJFNjRcIixcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/response-cache/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/route-kind.js":
/*!*****************************************************!*\
  !*** ./node_modules/next/dist/server/route-kind.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouteKind\", ({\n    enumerable: true,\n    get: function() {\n        return RouteKind;\n    }\n}));\nvar RouteKind = /*#__PURE__*/ function(RouteKind) {\n    /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */ RouteKind[\"PAGES\"] = \"PAGES\";\n    /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */ RouteKind[\"PAGES_API\"] = \"PAGES_API\";\n    /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */ RouteKind[\"APP_PAGE\"] = \"APP_PAGE\";\n    /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */ RouteKind[\"APP_ROUTE\"] = \"APP_ROUTE\";\n    /**\n   * `IMAGE` represents all the images that are generated by `next/image`.\n   */ RouteKind[\"IMAGE\"] = \"IMAGE\";\n    return RouteKind;\n}({});\n\n//# sourceMappingURL=route-kind.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1raW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLElBQUksRUFBRSxHQUFHO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJLEVBQUUsR0FBRztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFxyb3V0ZS1raW5kLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUm91dGVLaW5kXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSb3V0ZUtpbmQ7XG4gICAgfVxufSk7XG52YXIgUm91dGVLaW5kID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihSb3V0ZUtpbmQpIHtcbiAgICAvKipcbiAgICogYFBBR0VTYCByZXByZXNlbnRzIGFsbCB0aGUgUmVhY3QgcGFnZXMgdGhhdCBhcmUgdW5kZXIgYHBhZ2VzL2AuXG4gICAqLyBSb3V0ZUtpbmRbXCJQQUdFU1wiXSA9IFwiUEFHRVNcIjtcbiAgICAvKipcbiAgICogYFBBR0VTX0FQSWAgcmVwcmVzZW50cyBhbGwgdGhlIEFQSSByb3V0ZXMgdW5kZXIgYHBhZ2VzL2FwaS9gLlxuICAgKi8gUm91dGVLaW5kW1wiUEFHRVNfQVBJXCJdID0gXCJQQUdFU19BUElcIjtcbiAgICAvKipcbiAgICogYEFQUF9QQUdFYCByZXByZXNlbnRzIGFsbCB0aGUgUmVhY3QgcGFnZXMgdGhhdCBhcmUgdW5kZXIgYGFwcC9gIHdpdGggdGhlXG4gICAqIGZpbGVuYW1lIG9mIGBwYWdlLntqLHR9c3sseH1gLlxuICAgKi8gUm91dGVLaW5kW1wiQVBQX1BBR0VcIl0gPSBcIkFQUF9QQUdFXCI7XG4gICAgLyoqXG4gICAqIGBBUFBfUk9VVEVgIHJlcHJlc2VudHMgYWxsIHRoZSBBUEkgcm91dGVzIGFuZCBtZXRhZGF0YSByb3V0ZXMgdGhhdCBhcmUgdW5kZXIgYGFwcC9gIHdpdGggdGhlXG4gICAqIGZpbGVuYW1lIG9mIGByb3V0ZS57aix0fXN7LHh9YC5cbiAgICovIFJvdXRlS2luZFtcIkFQUF9ST1VURVwiXSA9IFwiQVBQX1JPVVRFXCI7XG4gICAgLyoqXG4gICAqIGBJTUFHRWAgcmVwcmVzZW50cyBhbGwgdGhlIGltYWdlcyB0aGF0IGFyZSBnZW5lcmF0ZWQgYnkgYG5leHQvaW1hZ2VgLlxuICAgKi8gUm91dGVLaW5kW1wiSU1BR0VcIl0gPSBcIklNQUdFXCI7XG4gICAgcmV0dXJuIFJvdXRlS2luZDtcbn0oe30pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZS1raW5kLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/route-kind.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-dev-runtime.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-dev-runtime.js ***!
  \****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ../../module.compiled */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/module.compiled.js\").vendored[\"react-rsc\"].ReactJsxDevRuntime;\n\n//# sourceMappingURL=react-jsx-dev-runtime.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1wYWdlL3ZlbmRvcmVkL3JzYy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw2TEFBMEY7O0FBRTFGIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFxyb3V0ZS1tb2R1bGVzXFxhcHAtcGFnZVxcdmVuZG9yZWRcXHJzY1xccmVhY3QtanN4LWRldi1ydW50aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGUuY29tcGlsZWQnKS52ZW5kb3JlZFsncmVhY3QtcnNjJ10uUmVhY3RKc3hEZXZSdW50aW1lO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-dev-runtime.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ../../module.compiled */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/module.compiled.js\").vendored[\"react-rsc\"].ReactJsxRuntime;\n\n//# sourceMappingURL=react-jsx-runtime.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1wYWdlL3ZlbmRvcmVkL3JzYy9yZWFjdC1qc3gtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDBMQUF1Rjs7QUFFdkYiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxzZXJ2ZXJcXHJvdXRlLW1vZHVsZXNcXGFwcC1wYWdlXFx2ZW5kb3JlZFxccnNjXFxyZWFjdC1qc3gtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlLmNvbXBpbGVkJykudmVuZG9yZWRbJ3JlYWN0LXJzYyddLlJlYWN0SnN4UnVudGltZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtanN4LXJ1bnRpbWUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ../../module.compiled */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/module.compiled.js\").vendored[\"react-rsc\"].React;\n\n//# sourceMappingURL=react.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1wYWdlL3ZlbmRvcmVkL3JzYy9yZWFjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGdMQUE2RTs7QUFFN0UiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxzZXJ2ZXJcXHJvdXRlLW1vZHVsZXNcXGFwcC1wYWdlXFx2ZW5kb3JlZFxccnNjXFxyZWFjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlLmNvbXBpbGVkJykudmVuZG9yZWRbJ3JlYWN0LXJzYyddLlJlYWN0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/server/route-modules/app-route/module.compiled.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nif (false) {} else {\n    if (false) {} else {\n        if (true) {\n            module.exports = __webpack_require__(/*! next/dist/compiled/next-server/app-route.runtime.dev.js */ \"next/dist/compiled/next-server/app-route.runtime.dev.js\");\n        } else {}\n    }\n}\n\n//# sourceMappingURL=module.compiled.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJLEtBQW1DLEVBQUUsRUFFeEMsQ0FBQztBQUNGLFFBQVEsS0FBcUMsRUFBRSxFQVExQyxDQUFDO0FBQ04sWUFBWSxJQUFzQztBQUNsRCxZQUFZLDhKQUFtRjtBQUMvRixVQUFVLEtBQUssRUFJTjtBQUNUO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxzZXJ2ZXJcXHJvdXRlLW1vZHVsZXNcXGFwcC1yb3V0ZVxcbW9kdWxlLmNvbXBpbGVkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaWYgKHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCduZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5qcycpO1xufSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0VYUEVSSU1FTlRBTF9SRUFDVCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL25leHQtc2VydmVyL2FwcC1yb3V0ZS1leHBlcmltZW50YWwucnVudGltZS5kZXYuanMnKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL25leHQtc2VydmVyL2FwcC1yb3V0ZS10dXJiby1leHBlcmltZW50YWwucnVudGltZS5wcm9kLmpzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LXNlcnZlci9hcHAtcm91dGUtZXhwZXJpbWVudGFsLnJ1bnRpbWUucHJvZC5qcycpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LXNlcnZlci9hcHAtcm91dGUucnVudGltZS5kZXYuanMnKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL25leHQtc2VydmVyL2FwcC1yb3V0ZS10dXJiby5ydW50aW1lLnByb2QuanMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL25leHQtc2VydmVyL2FwcC1yb3V0ZS5ydW50aW1lLnByb2QuanMnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmNvbXBpbGVkLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/stream-utils/encodedTags.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/server/stream-utils/encodedTags.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ENCODED_TAGS\", ({\n    enumerable: true,\n    get: function() {\n        return ENCODED_TAGS;\n    }\n}));\nconst ENCODED_TAGS = {\n    // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`\n    OPENING: {\n        // <html\n        HTML: new Uint8Array([\n            60,\n            104,\n            116,\n            109,\n            108\n        ]),\n        // <body\n        BODY: new Uint8Array([\n            60,\n            98,\n            111,\n            100,\n            121\n        ])\n    },\n    CLOSED: {\n        // </head>\n        HEAD: new Uint8Array([\n            60,\n            47,\n            104,\n            101,\n            97,\n            100,\n            62\n        ]),\n        // </body>\n        BODY: new Uint8Array([\n            60,\n            47,\n            98,\n            111,\n            100,\n            121,\n            62\n        ]),\n        // </html>\n        HTML: new Uint8Array([\n            60,\n            47,\n            104,\n            116,\n            109,\n            108,\n            62\n        ]),\n        // </body></html>\n        BODY_AND_HTML: new Uint8Array([\n            60,\n            47,\n            98,\n            111,\n            100,\n            121,\n            62,\n            60,\n            47,\n            104,\n            116,\n            109,\n            108,\n            62\n        ])\n    }\n};\n\n//# sourceMappingURL=encodedTags.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9zdHJlYW0tdXRpbHMvZW5jb2RlZFRhZ3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFxzdHJlYW0tdXRpbHNcXGVuY29kZWRUYWdzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRU5DT0RFRF9UQUdTXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBFTkNPREVEX1RBR1M7XG4gICAgfVxufSk7XG5jb25zdCBFTkNPREVEX1RBR1MgPSB7XG4gICAgLy8gb3BlbmluZyB0YWdzIGRvIG5vdCBoYXZlIHRoZSBjbG9zaW5nIGA+YCBzaW5jZSB0aGV5IGNhbiBjb250YWluIG90aGVyIGF0dHJpYnV0ZXMgc3VjaCBhcyBgPGJvZHkgY2xhc3NOYW1lPScnPmBcbiAgICBPUEVOSU5HOiB7XG4gICAgICAgIC8vIDxodG1sXG4gICAgICAgIEhUTUw6IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDYwLFxuICAgICAgICAgICAgMTA0LFxuICAgICAgICAgICAgMTE2LFxuICAgICAgICAgICAgMTA5LFxuICAgICAgICAgICAgMTA4XG4gICAgICAgIF0pLFxuICAgICAgICAvLyA8Ym9keVxuICAgICAgICBCT0RZOiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICA2MCxcbiAgICAgICAgICAgIDk4LFxuICAgICAgICAgICAgMTExLFxuICAgICAgICAgICAgMTAwLFxuICAgICAgICAgICAgMTIxXG4gICAgICAgIF0pXG4gICAgfSxcbiAgICBDTE9TRUQ6IHtcbiAgICAgICAgLy8gPC9oZWFkPlxuICAgICAgICBIRUFEOiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICA2MCxcbiAgICAgICAgICAgIDQ3LFxuICAgICAgICAgICAgMTA0LFxuICAgICAgICAgICAgMTAxLFxuICAgICAgICAgICAgOTcsXG4gICAgICAgICAgICAxMDAsXG4gICAgICAgICAgICA2MlxuICAgICAgICBdKSxcbiAgICAgICAgLy8gPC9ib2R5PlxuICAgICAgICBCT0RZOiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICA2MCxcbiAgICAgICAgICAgIDQ3LFxuICAgICAgICAgICAgOTgsXG4gICAgICAgICAgICAxMTEsXG4gICAgICAgICAgICAxMDAsXG4gICAgICAgICAgICAxMjEsXG4gICAgICAgICAgICA2MlxuICAgICAgICBdKSxcbiAgICAgICAgLy8gPC9odG1sPlxuICAgICAgICBIVE1MOiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICA2MCxcbiAgICAgICAgICAgIDQ3LFxuICAgICAgICAgICAgMTA0LFxuICAgICAgICAgICAgMTE2LFxuICAgICAgICAgICAgMTA5LFxuICAgICAgICAgICAgMTA4LFxuICAgICAgICAgICAgNjJcbiAgICAgICAgXSksXG4gICAgICAgIC8vIDwvYm9keT48L2h0bWw+XG4gICAgICAgIEJPRFlfQU5EX0hUTUw6IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDYwLFxuICAgICAgICAgICAgNDcsXG4gICAgICAgICAgICA5OCxcbiAgICAgICAgICAgIDExMSxcbiAgICAgICAgICAgIDEwMCxcbiAgICAgICAgICAgIDEyMSxcbiAgICAgICAgICAgIDYyLFxuICAgICAgICAgICAgNjAsXG4gICAgICAgICAgICA0NyxcbiAgICAgICAgICAgIDEwNCxcbiAgICAgICAgICAgIDExNixcbiAgICAgICAgICAgIDEwOSxcbiAgICAgICAgICAgIDEwOCxcbiAgICAgICAgICAgIDYyXG4gICAgICAgIF0pXG4gICAgfVxufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jb2RlZFRhZ3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/stream-utils/encodedTags.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/stream-utils/node-web-streams-helper.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/server/stream-utils/node-web-streams-helper.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    chainStreams: function() {\n        return chainStreams;\n    },\n    continueDynamicHTMLResume: function() {\n        return continueDynamicHTMLResume;\n    },\n    continueDynamicPrerender: function() {\n        return continueDynamicPrerender;\n    },\n    continueFizzStream: function() {\n        return continueFizzStream;\n    },\n    continueStaticPrerender: function() {\n        return continueStaticPrerender;\n    },\n    createBufferedTransformStream: function() {\n        return createBufferedTransformStream;\n    },\n    createDocumentClosingStream: function() {\n        return createDocumentClosingStream;\n    },\n    createRootLayoutValidatorStream: function() {\n        return createRootLayoutValidatorStream;\n    },\n    renderToInitialFizzStream: function() {\n        return renderToInitialFizzStream;\n    },\n    streamFromBuffer: function() {\n        return streamFromBuffer;\n    },\n    streamFromString: function() {\n        return streamFromString;\n    },\n    streamToBuffer: function() {\n        return streamToBuffer;\n    },\n    streamToString: function() {\n        return streamToString;\n    }\n});\nconst _tracer = __webpack_require__(/*! ../lib/trace/tracer */ \"(rsc)/./node_modules/next/dist/server/lib/trace/tracer.js\");\nconst _constants = __webpack_require__(/*! ../lib/trace/constants */ \"(rsc)/./node_modules/next/dist/server/lib/trace/constants.js\");\nconst _detachedpromise = __webpack_require__(/*! ../../lib/detached-promise */ \"(rsc)/./node_modules/next/dist/lib/detached-promise.js\");\nconst _scheduler = __webpack_require__(/*! ../../lib/scheduler */ \"(rsc)/./node_modules/next/dist/lib/scheduler.js\");\nconst _encodedTags = __webpack_require__(/*! ./encodedTags */ \"(rsc)/./node_modules/next/dist/server/stream-utils/encodedTags.js\");\nconst _uint8arrayhelpers = __webpack_require__(/*! ./uint8array-helpers */ \"(rsc)/./node_modules/next/dist/server/stream-utils/uint8array-helpers.js\");\nfunction voidCatch() {\n// this catcher is designed to be used with pipeTo where we expect the underlying\n// pipe implementation to forward errors but we don't want the pipeTo promise to reject\n// and be unhandled\n}\n// We can share the same encoder instance everywhere\n// Notably we cannot do the same for TextDecoder because it is stateful\n// when handling streaming data\nconst encoder = new TextEncoder();\nfunction chainStreams(...streams) {\n    // We could encode this invariant in the arguments but current uses of this function pass\n    // use spread so it would be missed by\n    if (streams.length === 0) {\n        throw Object.defineProperty(new Error('Invariant: chainStreams requires at least one stream'), \"__NEXT_ERROR_CODE\", {\n            value: \"E437\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // If we only have 1 stream we fast path it by returning just this stream\n    if (streams.length === 1) {\n        return streams[0];\n    }\n    const { readable, writable } = new TransformStream();\n    // We always initiate pipeTo immediately. We know we have at least 2 streams\n    // so we need to avoid closing the writable when this one finishes.\n    let promise = streams[0].pipeTo(writable, {\n        preventClose: true\n    });\n    let i = 1;\n    for(; i < streams.length - 1; i++){\n        const nextStream = streams[i];\n        promise = promise.then(()=>nextStream.pipeTo(writable, {\n                preventClose: true\n            }));\n    }\n    // We can omit the length check because we halted before the last stream and there\n    // is at least two streams so the lastStream here will always be defined\n    const lastStream = streams[i];\n    promise = promise.then(()=>lastStream.pipeTo(writable));\n    // Catch any errors from the streams and ignore them, they will be handled\n    // by whatever is consuming the readable stream.\n    promise.catch(voidCatch);\n    return readable;\n}\nfunction streamFromString(str) {\n    return new ReadableStream({\n        start (controller) {\n            controller.enqueue(encoder.encode(str));\n            controller.close();\n        }\n    });\n}\nfunction streamFromBuffer(chunk) {\n    return new ReadableStream({\n        start (controller) {\n            controller.enqueue(chunk);\n            controller.close();\n        }\n    });\n}\nasync function streamToBuffer(stream) {\n    const reader = stream.getReader();\n    const chunks = [];\n    while(true){\n        const { done, value } = await reader.read();\n        if (done) {\n            break;\n        }\n        chunks.push(value);\n    }\n    return Buffer.concat(chunks);\n}\nasync function streamToString(stream, signal) {\n    const decoder = new TextDecoder('utf-8', {\n        fatal: true\n    });\n    let string = '';\n    for await (const chunk of stream){\n        if (signal == null ? void 0 : signal.aborted) {\n            return string;\n        }\n        string += decoder.decode(chunk, {\n            stream: true\n        });\n    }\n    string += decoder.decode();\n    return string;\n}\nfunction createBufferedTransformStream() {\n    let bufferedChunks = [];\n    let bufferByteLength = 0;\n    let pending;\n    const flush = (controller)=>{\n        // If we already have a pending flush, then return early.\n        if (pending) return;\n        const detached = new _detachedpromise.DetachedPromise();\n        pending = detached;\n        (0, _scheduler.scheduleImmediate)(()=>{\n            try {\n                const chunk = new Uint8Array(bufferByteLength);\n                let copiedBytes = 0;\n                for(let i = 0; i < bufferedChunks.length; i++){\n                    const bufferedChunk = bufferedChunks[i];\n                    chunk.set(bufferedChunk, copiedBytes);\n                    copiedBytes += bufferedChunk.byteLength;\n                }\n                // We just wrote all the buffered chunks so we need to reset the bufferedChunks array\n                // and our bufferByteLength to prepare for the next round of buffered chunks\n                bufferedChunks.length = 0;\n                bufferByteLength = 0;\n                controller.enqueue(chunk);\n            } catch  {\n            // If an error occurs while enqueuing it can't be due to this\n            // transformers fault. It's likely due to the controller being\n            // errored due to the stream being cancelled.\n            } finally{\n                pending = undefined;\n                detached.resolve();\n            }\n        });\n    };\n    return new TransformStream({\n        transform (chunk, controller) {\n            // Combine the previous buffer with the new chunk.\n            bufferedChunks.push(chunk);\n            bufferByteLength += chunk.byteLength;\n            // Flush the buffer to the controller.\n            flush(controller);\n        },\n        flush () {\n            if (!pending) return;\n            return pending.promise;\n        }\n    });\n}\nfunction renderToInitialFizzStream({ ReactDOMServer, element, streamOptions }) {\n    return (0, _tracer.getTracer)().trace(_constants.AppRenderSpan.renderToReadableStream, async ()=>ReactDOMServer.renderToReadableStream(element, streamOptions));\n}\nfunction createHeadInsertionTransformStream(insert) {\n    let inserted = false;\n    // We need to track if this transform saw any bytes because if it didn't\n    // we won't want to insert any server HTML at all\n    let hasBytes = false;\n    return new TransformStream({\n        async transform (chunk, controller) {\n            hasBytes = true;\n            const insertion = await insert();\n            if (inserted) {\n                if (insertion) {\n                    const encodedInsertion = encoder.encode(insertion);\n                    controller.enqueue(encodedInsertion);\n                }\n                controller.enqueue(chunk);\n            } else {\n                // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n                const index = (0, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedTags.ENCODED_TAGS.CLOSED.HEAD);\n                // In fully static rendering or non PPR rendering cases:\n                // `/head>` will always be found in the chunk in first chunk rendering.\n                if (index !== -1) {\n                    if (insertion) {\n                        const encodedInsertion = encoder.encode(insertion);\n                        // Get the total count of the bytes in the chunk and the insertion\n                        // e.g.\n                        // chunk = <head><meta charset=\"utf-8\"></head>\n                        // insertion = <script>...</script>\n                        // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n                        const insertedHeadContent = new Uint8Array(chunk.length + encodedInsertion.length);\n                        // Append the first part of the chunk, before the head tag\n                        insertedHeadContent.set(chunk.slice(0, index));\n                        // Append the server inserted content\n                        insertedHeadContent.set(encodedInsertion, index);\n                        // Append the rest of the chunk\n                        insertedHeadContent.set(chunk.slice(index), index + encodedInsertion.length);\n                        controller.enqueue(insertedHeadContent);\n                    } else {\n                        controller.enqueue(chunk);\n                    }\n                    inserted = true;\n                } else {\n                    // This will happens in PPR rendering during next start, when the page is partially rendered.\n                    // When the page resumes, the head tag will be found in the middle of the chunk.\n                    // Where we just need to append the insertion and chunk to the current stream.\n                    // e.g.\n                    // PPR-static: <head>...</head><body> [ resume content ] </body>\n                    // PPR-resume: [ insertion ] [ rest content ]\n                    if (insertion) {\n                        controller.enqueue(encoder.encode(insertion));\n                    }\n                    controller.enqueue(chunk);\n                    inserted = true;\n                }\n            }\n        },\n        async flush (controller) {\n            // Check before closing if there's anything remaining to insert.\n            if (hasBytes) {\n                const insertion = await insert();\n                if (insertion) {\n                    controller.enqueue(encoder.encode(insertion));\n                }\n            }\n        }\n    });\n}\n// Suffix after main body content - scripts before </body>,\n// but wait for the major chunks to be enqueued.\nfunction createDeferredSuffixStream(suffix) {\n    let flushed = false;\n    let pending;\n    const flush = (controller)=>{\n        const detached = new _detachedpromise.DetachedPromise();\n        pending = detached;\n        (0, _scheduler.scheduleImmediate)(()=>{\n            try {\n                controller.enqueue(encoder.encode(suffix));\n            } catch  {\n            // If an error occurs while enqueuing it can't be due to this\n            // transformers fault. It's likely due to the controller being\n            // errored due to the stream being cancelled.\n            } finally{\n                pending = undefined;\n                detached.resolve();\n            }\n        });\n    };\n    return new TransformStream({\n        transform (chunk, controller) {\n            controller.enqueue(chunk);\n            // If we've already flushed, we're done.\n            if (flushed) return;\n            // Schedule the flush to happen.\n            flushed = true;\n            flush(controller);\n        },\n        flush (controller) {\n            if (pending) return pending.promise;\n            if (flushed) return;\n            // Flush now.\n            controller.enqueue(encoder.encode(suffix));\n        }\n    });\n}\n// Merge two streams into one. Ensure the final transform stream is closed\n// when both are finished.\nfunction createMergedTransformStream(stream) {\n    let pull = null;\n    let donePulling = false;\n    async function startPulling(controller) {\n        if (pull) {\n            return;\n        }\n        const reader = stream.getReader();\n        // NOTE: streaming flush\n        // We are buffering here for the inlined data stream because the\n        // \"shell\" stream might be chunkenized again by the underlying stream\n        // implementation, e.g. with a specific high-water mark. To ensure it's\n        // the safe timing to pipe the data stream, this extra tick is\n        // necessary.\n        // We don't start reading until we've left the current Task to ensure\n        // that it's inserted after flushing the shell. Note that this implementation\n        // might get stale if impl details of Fizz change in the future.\n        await (0, _scheduler.atLeastOneTask)();\n        try {\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    donePulling = true;\n                    return;\n                }\n                controller.enqueue(value);\n            }\n        } catch (err) {\n            controller.error(err);\n        }\n    }\n    return new TransformStream({\n        transform (chunk, controller) {\n            controller.enqueue(chunk);\n            // Start the streaming if it hasn't already been started yet.\n            if (!pull) {\n                pull = startPulling(controller);\n            }\n        },\n        flush (controller) {\n            if (donePulling) {\n                return;\n            }\n            return pull || startPulling(controller);\n        }\n    });\n}\nconst CLOSE_TAG = '</body></html>';\n/**\n * This transform stream moves the suffix to the end of the stream, so results\n * like `</body></html><script>...</script>` will be transformed to\n * `<script>...</script></body></html>`.\n */ function createMoveSuffixStream() {\n    let foundSuffix = false;\n    return new TransformStream({\n        transform (chunk, controller) {\n            if (foundSuffix) {\n                return controller.enqueue(chunk);\n            }\n            const index = (0, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML);\n            if (index > -1) {\n                foundSuffix = true;\n                // If the whole chunk is the suffix, then don't write anything, it will\n                // be written in the flush.\n                if (chunk.length === _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {\n                    return;\n                }\n                // Write out the part before the suffix.\n                const before = chunk.slice(0, index);\n                controller.enqueue(before);\n                // In the case where the suffix is in the middle of the chunk, we need\n                // to split the chunk into two parts.\n                if (chunk.length > _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {\n                    // Write out the part after the suffix.\n                    const after = chunk.slice(index + _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length);\n                    controller.enqueue(after);\n                }\n            } else {\n                controller.enqueue(chunk);\n            }\n        },\n        flush (controller) {\n            // Even if we didn't find the suffix, the HTML is not valid if we don't\n            // add it, so insert it at the end.\n            controller.enqueue(_encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML);\n        }\n    });\n}\nfunction createStripDocumentClosingTagsTransform() {\n    return new TransformStream({\n        transform (chunk, controller) {\n            // We rely on the assumption that chunks will never break across a code unit.\n            // This is reasonable because we currently concat all of React's output from a single\n            // flush into one chunk before streaming it forward which means the chunk will represent\n            // a single coherent utf-8 string. This is not safe to use if we change our streaming to no\n            // longer do this large buffered chunk\n            if ((0, _uint8arrayhelpers.isEquivalentUint8Arrays)(chunk, _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML) || (0, _uint8arrayhelpers.isEquivalentUint8Arrays)(chunk, _encodedTags.ENCODED_TAGS.CLOSED.BODY) || (0, _uint8arrayhelpers.isEquivalentUint8Arrays)(chunk, _encodedTags.ENCODED_TAGS.CLOSED.HTML)) {\n                // the entire chunk is the closing tags; return without enqueueing anything.\n                return;\n            }\n            // We assume these tags will go at together at the end of the document and that\n            // they won't appear anywhere else in the document. This is not really a safe assumption\n            // but until we revamp our streaming infra this is a performant way to string the tags\n            chunk = (0, _uint8arrayhelpers.removeFromUint8Array)(chunk, _encodedTags.ENCODED_TAGS.CLOSED.BODY);\n            chunk = (0, _uint8arrayhelpers.removeFromUint8Array)(chunk, _encodedTags.ENCODED_TAGS.CLOSED.HTML);\n            controller.enqueue(chunk);\n        }\n    });\n}\nfunction createRootLayoutValidatorStream() {\n    let foundHtml = false;\n    let foundBody = false;\n    return new TransformStream({\n        async transform (chunk, controller) {\n            // Peek into the streamed chunk to see if the tags are present.\n            if (!foundHtml && (0, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedTags.ENCODED_TAGS.OPENING.HTML) > -1) {\n                foundHtml = true;\n            }\n            if (!foundBody && (0, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedTags.ENCODED_TAGS.OPENING.BODY) > -1) {\n                foundBody = true;\n            }\n            controller.enqueue(chunk);\n        },\n        flush (controller) {\n            const missingTags = [];\n            if (!foundHtml) missingTags.push('html');\n            if (!foundBody) missingTags.push('body');\n            if (!missingTags.length) return;\n            controller.enqueue(encoder.encode(`<script>self.__next_root_layout_missing_tags=${JSON.stringify(missingTags)}</script>`));\n        }\n    });\n}\nfunction chainTransformers(readable, transformers) {\n    let stream = readable;\n    for (const transformer of transformers){\n        if (!transformer) continue;\n        stream = stream.pipeThrough(transformer);\n    }\n    return stream;\n}\nasync function continueFizzStream(renderStream, { suffix, inlinedDataStream, isStaticGeneration, getServerInsertedHTML, getServerInsertedMetadata, validateRootLayout }) {\n    // Suffix itself might contain close tags at the end, so we need to split it.\n    const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null;\n    // If we're generating static HTML and there's an `allReady` promise on the\n    // stream, we need to wait for it to resolve before continuing.\n    if (isStaticGeneration && 'allReady' in renderStream) {\n        await renderStream.allReady;\n    }\n    return chainTransformers(renderStream, [\n        // Buffer everything to avoid flushing too frequently\n        createBufferedTransformStream(),\n        // Insert generated metadata\n        createHeadInsertionTransformStream(getServerInsertedMetadata),\n        // Insert suffix content\n        suffixUnclosed != null && suffixUnclosed.length > 0 ? createDeferredSuffixStream(suffixUnclosed) : null,\n        // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n        inlinedDataStream ? createMergedTransformStream(inlinedDataStream) : null,\n        // Validate the root layout for missing html or body tags\n        validateRootLayout ? createRootLayoutValidatorStream() : null,\n        // Close tags should always be deferred to the end\n        createMoveSuffixStream(),\n        // Special head insertions\n        // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid\n        // hydration errors. Remove this once it's ready to be handled by react itself.\n        createHeadInsertionTransformStream(getServerInsertedHTML)\n    ]);\n}\nasync function continueDynamicPrerender(prerenderStream, { getServerInsertedHTML, getServerInsertedMetadata }) {\n    return prerenderStream// Buffer everything to avoid flushing too frequently\n    .pipeThrough(createBufferedTransformStream()).pipeThrough(createStripDocumentClosingTagsTransform())// Insert generated tags to head\n    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))// Insert generated metadata\n    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedMetadata));\n}\nasync function continueStaticPrerender(prerenderStream, { inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata }) {\n    return prerenderStream// Buffer everything to avoid flushing too frequently\n    .pipeThrough(createBufferedTransformStream())// Insert generated tags to head\n    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))// Insert generated metadata to head\n    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedMetadata))// Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    .pipeThrough(createMergedTransformStream(inlinedDataStream))// Close tags should always be deferred to the end\n    .pipeThrough(createMoveSuffixStream());\n}\nasync function continueDynamicHTMLResume(renderStream, { inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata }) {\n    return renderStream// Buffer everything to avoid flushing too frequently\n    .pipeThrough(createBufferedTransformStream())// Insert generated tags to head\n    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))// Insert generated metadata to body\n    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedMetadata))// Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    .pipeThrough(createMergedTransformStream(inlinedDataStream))// Close tags should always be deferred to the end\n    .pipeThrough(createMoveSuffixStream());\n}\nfunction createDocumentClosingStream() {\n    return streamFromString(CLOSE_TAG);\n}\n\n//# sourceMappingURL=node-web-streams-helper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9zdHJlYW0tdXRpbHMvbm9kZS13ZWItc3RyZWFtcy1oZWxwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixNQUFNLENBY0w7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLHNGQUFxQjtBQUM3QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDbkQseUJBQXlCLG1CQUFPLENBQUMsMEZBQTRCO0FBQzdELG1CQUFtQixtQkFBTyxDQUFDLDRFQUFxQjtBQUNoRCxxQkFBcUIsbUJBQU8sQ0FBQyx3RkFBZTtBQUM1QywyQkFBMkIsbUJBQU8sQ0FBQyxzR0FBc0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkJBQTJCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsNEJBQTRCO0FBQzFIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxSEFBcUg7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxrREFBa0Q7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxxRUFBcUU7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscUVBQXFFO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFxzdHJlYW0tdXRpbHNcXG5vZGUtd2ViLXN0cmVhbXMtaGVscGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY2hhaW5TdHJlYW1zOiBudWxsLFxuICAgIGNvbnRpbnVlRHluYW1pY0hUTUxSZXN1bWU6IG51bGwsXG4gICAgY29udGludWVEeW5hbWljUHJlcmVuZGVyOiBudWxsLFxuICAgIGNvbnRpbnVlRml6elN0cmVhbTogbnVsbCxcbiAgICBjb250aW51ZVN0YXRpY1ByZXJlbmRlcjogbnVsbCxcbiAgICBjcmVhdGVCdWZmZXJlZFRyYW5zZm9ybVN0cmVhbTogbnVsbCxcbiAgICBjcmVhdGVEb2N1bWVudENsb3NpbmdTdHJlYW06IG51bGwsXG4gICAgY3JlYXRlUm9vdExheW91dFZhbGlkYXRvclN0cmVhbTogbnVsbCxcbiAgICByZW5kZXJUb0luaXRpYWxGaXp6U3RyZWFtOiBudWxsLFxuICAgIHN0cmVhbUZyb21CdWZmZXI6IG51bGwsXG4gICAgc3RyZWFtRnJvbVN0cmluZzogbnVsbCxcbiAgICBzdHJlYW1Ub0J1ZmZlcjogbnVsbCxcbiAgICBzdHJlYW1Ub1N0cmluZzogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBjaGFpblN0cmVhbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2hhaW5TdHJlYW1zO1xuICAgIH0sXG4gICAgY29udGludWVEeW5hbWljSFRNTFJlc3VtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb250aW51ZUR5bmFtaWNIVE1MUmVzdW1lO1xuICAgIH0sXG4gICAgY29udGludWVEeW5hbWljUHJlcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRpbnVlRHluYW1pY1ByZXJlbmRlcjtcbiAgICB9LFxuICAgIGNvbnRpbnVlRml6elN0cmVhbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb250aW51ZUZpenpTdHJlYW07XG4gICAgfSxcbiAgICBjb250aW51ZVN0YXRpY1ByZXJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb250aW51ZVN0YXRpY1ByZXJlbmRlcjtcbiAgICB9LFxuICAgIGNyZWF0ZUJ1ZmZlcmVkVHJhbnNmb3JtU3RyZWFtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcmVkVHJhbnNmb3JtU3RyZWFtO1xuICAgIH0sXG4gICAgY3JlYXRlRG9jdW1lbnRDbG9zaW5nU3RyZWFtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURvY3VtZW50Q2xvc2luZ1N0cmVhbTtcbiAgICB9LFxuICAgIGNyZWF0ZVJvb3RMYXlvdXRWYWxpZGF0b3JTdHJlYW06IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUm9vdExheW91dFZhbGlkYXRvclN0cmVhbTtcbiAgICB9LFxuICAgIHJlbmRlclRvSW5pdGlhbEZpenpTdHJlYW06IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmVuZGVyVG9Jbml0aWFsRml6elN0cmVhbTtcbiAgICB9LFxuICAgIHN0cmVhbUZyb21CdWZmZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtRnJvbUJ1ZmZlcjtcbiAgICB9LFxuICAgIHN0cmVhbUZyb21TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtRnJvbVN0cmluZztcbiAgICB9LFxuICAgIHN0cmVhbVRvQnVmZmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVRvQnVmZmVyO1xuICAgIH0sXG4gICAgc3RyZWFtVG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtVG9TdHJpbmc7XG4gICAgfVxufSk7XG5jb25zdCBfdHJhY2VyID0gcmVxdWlyZShcIi4uL2xpYi90cmFjZS90cmFjZXJcIik7XG5jb25zdCBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2xpYi90cmFjZS9jb25zdGFudHNcIik7XG5jb25zdCBfZGV0YWNoZWRwcm9taXNlID0gcmVxdWlyZShcIi4uLy4uL2xpYi9kZXRhY2hlZC1wcm9taXNlXCIpO1xuY29uc3QgX3NjaGVkdWxlciA9IHJlcXVpcmUoXCIuLi8uLi9saWIvc2NoZWR1bGVyXCIpO1xuY29uc3QgX2VuY29kZWRUYWdzID0gcmVxdWlyZShcIi4vZW5jb2RlZFRhZ3NcIik7XG5jb25zdCBfdWludDhhcnJheWhlbHBlcnMgPSByZXF1aXJlKFwiLi91aW50OGFycmF5LWhlbHBlcnNcIik7XG5mdW5jdGlvbiB2b2lkQ2F0Y2goKSB7XG4vLyB0aGlzIGNhdGNoZXIgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCB3aXRoIHBpcGVUbyB3aGVyZSB3ZSBleHBlY3QgdGhlIHVuZGVybHlpbmdcbi8vIHBpcGUgaW1wbGVtZW50YXRpb24gdG8gZm9yd2FyZCBlcnJvcnMgYnV0IHdlIGRvbid0IHdhbnQgdGhlIHBpcGVUbyBwcm9taXNlIHRvIHJlamVjdFxuLy8gYW5kIGJlIHVuaGFuZGxlZFxufVxuLy8gV2UgY2FuIHNoYXJlIHRoZSBzYW1lIGVuY29kZXIgaW5zdGFuY2UgZXZlcnl3aGVyZVxuLy8gTm90YWJseSB3ZSBjYW5ub3QgZG8gdGhlIHNhbWUgZm9yIFRleHREZWNvZGVyIGJlY2F1c2UgaXQgaXMgc3RhdGVmdWxcbi8vIHdoZW4gaGFuZGxpbmcgc3RyZWFtaW5nIGRhdGFcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIGNoYWluU3RyZWFtcyguLi5zdHJlYW1zKSB7XG4gICAgLy8gV2UgY291bGQgZW5jb2RlIHRoaXMgaW52YXJpYW50IGluIHRoZSBhcmd1bWVudHMgYnV0IGN1cnJlbnQgdXNlcyBvZiB0aGlzIGZ1bmN0aW9uIHBhc3NcbiAgICAvLyB1c2Ugc3ByZWFkIHNvIGl0IHdvdWxkIGJlIG1pc3NlZCBieVxuICAgIGlmIChzdHJlYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKCdJbnZhcmlhbnQ6IGNoYWluU3RyZWFtcyByZXF1aXJlcyBhdCBsZWFzdCBvbmUgc3RyZWFtJyksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IFwiRTQzN1wiLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIElmIHdlIG9ubHkgaGF2ZSAxIHN0cmVhbSB3ZSBmYXN0IHBhdGggaXQgYnkgcmV0dXJuaW5nIGp1c3QgdGhpcyBzdHJlYW1cbiAgICBpZiAoc3RyZWFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbXNbMF07XG4gICAgfVxuICAgIGNvbnN0IHsgcmVhZGFibGUsIHdyaXRhYmxlIH0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKCk7XG4gICAgLy8gV2UgYWx3YXlzIGluaXRpYXRlIHBpcGVUbyBpbW1lZGlhdGVseS4gV2Uga25vdyB3ZSBoYXZlIGF0IGxlYXN0IDIgc3RyZWFtc1xuICAgIC8vIHNvIHdlIG5lZWQgdG8gYXZvaWQgY2xvc2luZyB0aGUgd3JpdGFibGUgd2hlbiB0aGlzIG9uZSBmaW5pc2hlcy5cbiAgICBsZXQgcHJvbWlzZSA9IHN0cmVhbXNbMF0ucGlwZVRvKHdyaXRhYmxlLCB7XG4gICAgICAgIHByZXZlbnRDbG9zZTogdHJ1ZVxuICAgIH0pO1xuICAgIGxldCBpID0gMTtcbiAgICBmb3IoOyBpIDwgc3RyZWFtcy5sZW5ndGggLSAxOyBpKyspe1xuICAgICAgICBjb25zdCBuZXh0U3RyZWFtID0gc3RyZWFtc1tpXTtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbigoKT0+bmV4dFN0cmVhbS5waXBlVG8od3JpdGFibGUsIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50Q2xvc2U6IHRydWVcbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG4gICAgLy8gV2UgY2FuIG9taXQgdGhlIGxlbmd0aCBjaGVjayBiZWNhdXNlIHdlIGhhbHRlZCBiZWZvcmUgdGhlIGxhc3Qgc3RyZWFtIGFuZCB0aGVyZVxuICAgIC8vIGlzIGF0IGxlYXN0IHR3byBzdHJlYW1zIHNvIHRoZSBsYXN0U3RyZWFtIGhlcmUgd2lsbCBhbHdheXMgYmUgZGVmaW5lZFxuICAgIGNvbnN0IGxhc3RTdHJlYW0gPSBzdHJlYW1zW2ldO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKCk9Pmxhc3RTdHJlYW0ucGlwZVRvKHdyaXRhYmxlKSk7XG4gICAgLy8gQ2F0Y2ggYW55IGVycm9ycyBmcm9tIHRoZSBzdHJlYW1zIGFuZCBpZ25vcmUgdGhlbSwgdGhleSB3aWxsIGJlIGhhbmRsZWRcbiAgICAvLyBieSB3aGF0ZXZlciBpcyBjb25zdW1pbmcgdGhlIHJlYWRhYmxlIHN0cmVhbS5cbiAgICBwcm9taXNlLmNhdGNoKHZvaWRDYXRjaCk7XG4gICAgcmV0dXJuIHJlYWRhYmxlO1xufVxuZnVuY3Rpb24gc3RyZWFtRnJvbVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShzdHIpKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc3RyZWFtRnJvbUJ1ZmZlcihjaHVuaykge1xuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydCAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gc3RyZWFtVG9CdWZmZXIoc3RyZWFtKSB7XG4gICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIHdoaWxlKHRydWUpe1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChjaHVua3MpO1xufVxuYXN5bmMgZnVuY3Rpb24gc3RyZWFtVG9TdHJpbmcoc3RyZWFtLCBzaWduYWwpIHtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHtcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICB9KTtcbiAgICBsZXQgc3RyaW5nID0gJyc7XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pe1xuICAgICAgICBpZiAoc2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmcgKz0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHtcbiAgICAgICAgICAgIHN0cmVhbTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RyaW5nICs9IGRlY29kZXIuZGVjb2RlKCk7XG4gICAgcmV0dXJuIHN0cmluZztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlcmVkVHJhbnNmb3JtU3RyZWFtKCkge1xuICAgIGxldCBidWZmZXJlZENodW5rcyA9IFtdO1xuICAgIGxldCBidWZmZXJCeXRlTGVuZ3RoID0gMDtcbiAgICBsZXQgcGVuZGluZztcbiAgICBjb25zdCBmbHVzaCA9IChjb250cm9sbGVyKT0+e1xuICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYSBwZW5kaW5nIGZsdXNoLCB0aGVuIHJldHVybiBlYXJseS5cbiAgICAgICAgaWYgKHBlbmRpbmcpIHJldHVybjtcbiAgICAgICAgY29uc3QgZGV0YWNoZWQgPSBuZXcgX2RldGFjaGVkcHJvbWlzZS5EZXRhY2hlZFByb21pc2UoKTtcbiAgICAgICAgcGVuZGluZyA9IGRldGFjaGVkO1xuICAgICAgICAoMCwgX3NjaGVkdWxlci5zY2hlZHVsZUltbWVkaWF0ZSkoKCk9PntcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgVWludDhBcnJheShidWZmZXJCeXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsZXQgY29waWVkQnl0ZXMgPSAwO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBidWZmZXJlZENodW5rcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcmVkQ2h1bmsgPSBidWZmZXJlZENodW5rc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsuc2V0KGJ1ZmZlcmVkQ2h1bmssIGNvcGllZEJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29waWVkQnl0ZXMgKz0gYnVmZmVyZWRDaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBqdXN0IHdyb3RlIGFsbCB0aGUgYnVmZmVyZWQgY2h1bmtzIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIGJ1ZmZlcmVkQ2h1bmtzIGFycmF5XG4gICAgICAgICAgICAgICAgLy8gYW5kIG91ciBidWZmZXJCeXRlTGVuZ3RoIHRvIHByZXBhcmUgZm9yIHRoZSBuZXh0IHJvdW5kIG9mIGJ1ZmZlcmVkIGNodW5rc1xuICAgICAgICAgICAgICAgIGJ1ZmZlcmVkQ2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgYnVmZmVyQnl0ZUxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggIHtcbiAgICAgICAgICAgIC8vIElmIGFuIGVycm9yIG9jY3VycyB3aGlsZSBlbnF1ZXVpbmcgaXQgY2FuJ3QgYmUgZHVlIHRvIHRoaXNcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybWVycyBmYXVsdC4gSXQncyBsaWtlbHkgZHVlIHRvIHRoZSBjb250cm9sbGVyIGJlaW5nXG4gICAgICAgICAgICAvLyBlcnJvcmVkIGR1ZSB0byB0aGUgc3RyZWFtIGJlaW5nIGNhbmNlbGxlZC5cbiAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGRldGFjaGVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHRyYW5zZm9ybSAoY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIC8vIENvbWJpbmUgdGhlIHByZXZpb3VzIGJ1ZmZlciB3aXRoIHRoZSBuZXcgY2h1bmsuXG4gICAgICAgICAgICBidWZmZXJlZENodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIGJ1ZmZlckJ5dGVMZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIC8vIEZsdXNoIHRoZSBidWZmZXIgdG8gdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAgICBmbHVzaChjb250cm9sbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmx1c2ggKCkge1xuICAgICAgICAgICAgaWYgKCFwZW5kaW5nKSByZXR1cm47XG4gICAgICAgICAgICByZXR1cm4gcGVuZGluZy5wcm9taXNlO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZW5kZXJUb0luaXRpYWxGaXp6U3RyZWFtKHsgUmVhY3RET01TZXJ2ZXIsIGVsZW1lbnQsIHN0cmVhbU9wdGlvbnMgfSkge1xuICAgIHJldHVybiAoMCwgX3RyYWNlci5nZXRUcmFjZXIpKCkudHJhY2UoX2NvbnN0YW50cy5BcHBSZW5kZXJTcGFuLnJlbmRlclRvUmVhZGFibGVTdHJlYW0sIGFzeW5jICgpPT5SZWFjdERPTVNlcnZlci5yZW5kZXJUb1JlYWRhYmxlU3RyZWFtKGVsZW1lbnQsIHN0cmVhbU9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRJbnNlcnRpb25UcmFuc2Zvcm1TdHJlYW0oaW5zZXJ0KSB7XG4gICAgbGV0IGluc2VydGVkID0gZmFsc2U7XG4gICAgLy8gV2UgbmVlZCB0byB0cmFjayBpZiB0aGlzIHRyYW5zZm9ybSBzYXcgYW55IGJ5dGVzIGJlY2F1c2UgaWYgaXQgZGlkbid0XG4gICAgLy8gd2Ugd29uJ3Qgd2FudCB0byBpbnNlcnQgYW55IHNlcnZlciBIVE1MIGF0IGFsbFxuICAgIGxldCBoYXNCeXRlcyA9IGZhbHNlO1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgdHJhbnNmb3JtIChjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgaGFzQnl0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0aW9uID0gYXdhaXQgaW5zZXJ0KCk7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZWRJbnNlcnRpb24gPSBlbmNvZGVyLmVuY29kZShpbnNlcnRpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2RlZEluc2VydGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gKEBFdGhhbi1BcnJvd29vZCk6IFJlcGxhY2UgdGhlIGdlbmVyaWMgYGluZGV4T2ZVaW50OEFycmF5YCBtZXRob2Qgd2l0aCBzb21ldGhpbmcgZmluZWx5IHR1bmVkIGZvciB0aGUgc3Vic2V0IG9mIHRoaW5ncyBhY3R1YWxseSBiZWluZyBjaGVja2VkIGZvci5cbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9ICgwLCBfdWludDhhcnJheWhlbHBlcnMuaW5kZXhPZlVpbnQ4QXJyYXkpKGNodW5rLCBfZW5jb2RlZFRhZ3MuRU5DT0RFRF9UQUdTLkNMT1NFRC5IRUFEKTtcbiAgICAgICAgICAgICAgICAvLyBJbiBmdWxseSBzdGF0aWMgcmVuZGVyaW5nIG9yIG5vbiBQUFIgcmVuZGVyaW5nIGNhc2VzOlxuICAgICAgICAgICAgICAgIC8vIGAvaGVhZD5gIHdpbGwgYWx3YXlzIGJlIGZvdW5kIGluIHRoZSBjaHVuayBpbiBmaXJzdCBjaHVuayByZW5kZXJpbmcuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVkSW5zZXJ0aW9uID0gZW5jb2Rlci5lbmNvZGUoaW5zZXJ0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdG90YWwgY291bnQgb2YgdGhlIGJ5dGVzIGluIHRoZSBjaHVuayBhbmQgdGhlIGluc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2h1bmsgPSA8aGVhZD48bWV0YSBjaGFyc2V0PVwidXRmLThcIj48L2hlYWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnRpb24gPSA8c2NyaXB0Pi4uLjwvc2NyaXB0PlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3V0cHV0ID0gPGhlYWQ+PG1ldGEgY2hhcnNldD1cInV0Zi04XCI+IFsgPHNjcmlwdD4uLi48L3NjcmlwdD4gXSA8L2hlYWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRlZEhlYWRDb250ZW50ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsubGVuZ3RoICsgZW5jb2RlZEluc2VydGlvbi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSBjaHVuaywgYmVmb3JlIHRoZSBoZWFkIHRhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWRIZWFkQ29udGVudC5zZXQoY2h1bmsuc2xpY2UoMCwgaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc2VydmVyIGluc2VydGVkIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydGVkSGVhZENvbnRlbnQuc2V0KGVuY29kZWRJbnNlcnRpb24sIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcmVzdCBvZiB0aGUgY2h1bmtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydGVkSGVhZENvbnRlbnQuc2V0KGNodW5rLnNsaWNlKGluZGV4KSwgaW5kZXggKyBlbmNvZGVkSW5zZXJ0aW9uLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoaW5zZXJ0ZWRIZWFkQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgaGFwcGVucyBpbiBQUFIgcmVuZGVyaW5nIGR1cmluZyBuZXh0IHN0YXJ0LCB3aGVuIHRoZSBwYWdlIGlzIHBhcnRpYWxseSByZW5kZXJlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgcGFnZSByZXN1bWVzLCB0aGUgaGVhZCB0YWcgd2lsbCBiZSBmb3VuZCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBjaHVuay5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlcmUgd2UganVzdCBuZWVkIHRvIGFwcGVuZCB0aGUgaW5zZXJ0aW9uIGFuZCBjaHVuayB0byB0aGUgY3VycmVudCBzdHJlYW0uXG4gICAgICAgICAgICAgICAgICAgIC8vIGUuZy5cbiAgICAgICAgICAgICAgICAgICAgLy8gUFBSLXN0YXRpYzogPGhlYWQ+Li4uPC9oZWFkPjxib2R5PiBbIHJlc3VtZSBjb250ZW50IF0gPC9ib2R5PlxuICAgICAgICAgICAgICAgICAgICAvLyBQUFItcmVzdW1lOiBbIGluc2VydGlvbiBdIFsgcmVzdCBjb250ZW50IF1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKGluc2VydGlvbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGZsdXNoIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBiZWZvcmUgY2xvc2luZyBpZiB0aGVyZSdzIGFueXRoaW5nIHJlbWFpbmluZyB0byBpbnNlcnQuXG4gICAgICAgICAgICBpZiAoaGFzQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRpb24gPSBhd2FpdCBpbnNlcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShpbnNlcnRpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIFN1ZmZpeCBhZnRlciBtYWluIGJvZHkgY29udGVudCAtIHNjcmlwdHMgYmVmb3JlIDwvYm9keT4sXG4vLyBidXQgd2FpdCBmb3IgdGhlIG1ham9yIGNodW5rcyB0byBiZSBlbnF1ZXVlZC5cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkU3VmZml4U3RyZWFtKHN1ZmZpeCkge1xuICAgIGxldCBmbHVzaGVkID0gZmFsc2U7XG4gICAgbGV0IHBlbmRpbmc7XG4gICAgY29uc3QgZmx1c2ggPSAoY29udHJvbGxlcik9PntcbiAgICAgICAgY29uc3QgZGV0YWNoZWQgPSBuZXcgX2RldGFjaGVkcHJvbWlzZS5EZXRhY2hlZFByb21pc2UoKTtcbiAgICAgICAgcGVuZGluZyA9IGRldGFjaGVkO1xuICAgICAgICAoMCwgX3NjaGVkdWxlci5zY2hlZHVsZUltbWVkaWF0ZSkoKCk9PntcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKHN1ZmZpeCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAge1xuICAgICAgICAgICAgLy8gSWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIGVucXVldWluZyBpdCBjYW4ndCBiZSBkdWUgdG8gdGhpc1xuICAgICAgICAgICAgLy8gdHJhbnNmb3JtZXJzIGZhdWx0LiBJdCdzIGxpa2VseSBkdWUgdG8gdGhlIGNvbnRyb2xsZXIgYmVpbmdcbiAgICAgICAgICAgIC8vIGVycm9yZWQgZHVlIHRvIHRoZSBzdHJlYW0gYmVpbmcgY2FuY2VsbGVkLlxuICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZGV0YWNoZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtIChjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZmx1c2hlZCwgd2UncmUgZG9uZS5cbiAgICAgICAgICAgIGlmIChmbHVzaGVkKSByZXR1cm47XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSB0aGUgZmx1c2ggdG8gaGFwcGVuLlxuICAgICAgICAgICAgZmx1c2hlZCA9IHRydWU7XG4gICAgICAgICAgICBmbHVzaChjb250cm9sbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmx1c2ggKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSByZXR1cm4gcGVuZGluZy5wcm9taXNlO1xuICAgICAgICAgICAgaWYgKGZsdXNoZWQpIHJldHVybjtcbiAgICAgICAgICAgIC8vIEZsdXNoIG5vdy5cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShzdWZmaXgpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gTWVyZ2UgdHdvIHN0cmVhbXMgaW50byBvbmUuIEVuc3VyZSB0aGUgZmluYWwgdHJhbnNmb3JtIHN0cmVhbSBpcyBjbG9zZWRcbi8vIHdoZW4gYm90aCBhcmUgZmluaXNoZWQuXG5mdW5jdGlvbiBjcmVhdGVNZXJnZWRUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtKSB7XG4gICAgbGV0IHB1bGwgPSBudWxsO1xuICAgIGxldCBkb25lUHVsbGluZyA9IGZhbHNlO1xuICAgIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UHVsbGluZyhjb250cm9sbGVyKSB7XG4gICAgICAgIGlmIChwdWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICAvLyBOT1RFOiBzdHJlYW1pbmcgZmx1c2hcbiAgICAgICAgLy8gV2UgYXJlIGJ1ZmZlcmluZyBoZXJlIGZvciB0aGUgaW5saW5lZCBkYXRhIHN0cmVhbSBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBcInNoZWxsXCIgc3RyZWFtIG1pZ2h0IGJlIGNodW5rZW5pemVkIGFnYWluIGJ5IHRoZSB1bmRlcmx5aW5nIHN0cmVhbVxuICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiwgZS5nLiB3aXRoIGEgc3BlY2lmaWMgaGlnaC13YXRlciBtYXJrLiBUbyBlbnN1cmUgaXQnc1xuICAgICAgICAvLyB0aGUgc2FmZSB0aW1pbmcgdG8gcGlwZSB0aGUgZGF0YSBzdHJlYW0sIHRoaXMgZXh0cmEgdGljayBpc1xuICAgICAgICAvLyBuZWNlc3NhcnkuXG4gICAgICAgIC8vIFdlIGRvbid0IHN0YXJ0IHJlYWRpbmcgdW50aWwgd2UndmUgbGVmdCB0aGUgY3VycmVudCBUYXNrIHRvIGVuc3VyZVxuICAgICAgICAvLyB0aGF0IGl0J3MgaW5zZXJ0ZWQgYWZ0ZXIgZmx1c2hpbmcgdGhlIHNoZWxsLiBOb3RlIHRoYXQgdGhpcyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAvLyBtaWdodCBnZXQgc3RhbGUgaWYgaW1wbCBkZXRhaWxzIG9mIEZpenogY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gICAgICAgIGF3YWl0ICgwLCBfc2NoZWR1bGVyLmF0TGVhc3RPbmVUYXNrKSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBkb25lUHVsbGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0gKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHN0cmVhbWluZyBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQgeWV0LlxuICAgICAgICAgICAgaWYgKCFwdWxsKSB7XG4gICAgICAgICAgICAgICAgcHVsbCA9IHN0YXJ0UHVsbGluZyhjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmx1c2ggKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGlmIChkb25lUHVsbGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwdWxsIHx8IHN0YXJ0UHVsbGluZyhjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgQ0xPU0VfVEFHID0gJzwvYm9keT48L2h0bWw+Jztcbi8qKlxuICogVGhpcyB0cmFuc2Zvcm0gc3RyZWFtIG1vdmVzIHRoZSBzdWZmaXggdG8gdGhlIGVuZCBvZiB0aGUgc3RyZWFtLCBzbyByZXN1bHRzXG4gKiBsaWtlIGA8L2JvZHk+PC9odG1sPjxzY3JpcHQ+Li4uPC9zY3JpcHQ+YCB3aWxsIGJlIHRyYW5zZm9ybWVkIHRvXG4gKiBgPHNjcmlwdD4uLi48L3NjcmlwdD48L2JvZHk+PC9odG1sPmAuXG4gKi8gZnVuY3Rpb24gY3JlYXRlTW92ZVN1ZmZpeFN0cmVhbSgpIHtcbiAgICBsZXQgZm91bmRTdWZmaXggPSBmYWxzZTtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHRyYW5zZm9ybSAoY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGlmIChmb3VuZFN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSAoMCwgX3VpbnQ4YXJyYXloZWxwZXJzLmluZGV4T2ZVaW50OEFycmF5KShjaHVuaywgX2VuY29kZWRUYWdzLkVOQ09ERURfVEFHUy5DTE9TRUQuQk9EWV9BTkRfSFRNTCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGZvdW5kU3VmZml4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgd2hvbGUgY2h1bmsgaXMgdGhlIHN1ZmZpeCwgdGhlbiBkb24ndCB3cml0ZSBhbnl0aGluZywgaXQgd2lsbFxuICAgICAgICAgICAgICAgIC8vIGJlIHdyaXR0ZW4gaW4gdGhlIGZsdXNoLlxuICAgICAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPT09IF9lbmNvZGVkVGFncy5FTkNPREVEX1RBR1MuQ0xPU0VELkJPRFlfQU5EX0hUTUwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgb3V0IHRoZSBwYXJ0IGJlZm9yZSB0aGUgc3VmZml4LlxuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IGNodW5rLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYmVmb3JlKTtcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgc3VmZml4IGlzIGluIHRoZSBtaWRkbGUgb2YgdGhlIGNodW5rLCB3ZSBuZWVkXG4gICAgICAgICAgICAgICAgLy8gdG8gc3BsaXQgdGhlIGNodW5rIGludG8gdHdvIHBhcnRzLlxuICAgICAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPiBfZW5jb2RlZFRhZ3MuRU5DT0RFRF9UQUdTLkNMT1NFRC5CT0RZX0FORF9IVE1MLmxlbmd0aCArIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIG91dCB0aGUgcGFydCBhZnRlciB0aGUgc3VmZml4LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZnRlciA9IGNodW5rLnNsaWNlKGluZGV4ICsgX2VuY29kZWRUYWdzLkVOQ09ERURfVEFHUy5DTE9TRUQuQk9EWV9BTkRfSFRNTC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYWZ0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmx1c2ggKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgd2UgZGlkbid0IGZpbmQgdGhlIHN1ZmZpeCwgdGhlIEhUTUwgaXMgbm90IHZhbGlkIGlmIHdlIGRvbid0XG4gICAgICAgICAgICAvLyBhZGQgaXQsIHNvIGluc2VydCBpdCBhdCB0aGUgZW5kLlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKF9lbmNvZGVkVGFncy5FTkNPREVEX1RBR1MuQ0xPU0VELkJPRFlfQU5EX0hUTUwpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdHJpcERvY3VtZW50Q2xvc2luZ1RhZ3NUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0gKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAvLyBXZSByZWx5IG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgY2h1bmtzIHdpbGwgbmV2ZXIgYnJlYWsgYWNyb3NzIGEgY29kZSB1bml0LlxuICAgICAgICAgICAgLy8gVGhpcyBpcyByZWFzb25hYmxlIGJlY2F1c2Ugd2UgY3VycmVudGx5IGNvbmNhdCBhbGwgb2YgUmVhY3QncyBvdXRwdXQgZnJvbSBhIHNpbmdsZVxuICAgICAgICAgICAgLy8gZmx1c2ggaW50byBvbmUgY2h1bmsgYmVmb3JlIHN0cmVhbWluZyBpdCBmb3J3YXJkIHdoaWNoIG1lYW5zIHRoZSBjaHVuayB3aWxsIHJlcHJlc2VudFxuICAgICAgICAgICAgLy8gYSBzaW5nbGUgY29oZXJlbnQgdXRmLTggc3RyaW5nLiBUaGlzIGlzIG5vdCBzYWZlIHRvIHVzZSBpZiB3ZSBjaGFuZ2Ugb3VyIHN0cmVhbWluZyB0byBub1xuICAgICAgICAgICAgLy8gbG9uZ2VyIGRvIHRoaXMgbGFyZ2UgYnVmZmVyZWQgY2h1bmtcbiAgICAgICAgICAgIGlmICgoMCwgX3VpbnQ4YXJyYXloZWxwZXJzLmlzRXF1aXZhbGVudFVpbnQ4QXJyYXlzKShjaHVuaywgX2VuY29kZWRUYWdzLkVOQ09ERURfVEFHUy5DTE9TRUQuQk9EWV9BTkRfSFRNTCkgfHwgKDAsIF91aW50OGFycmF5aGVscGVycy5pc0VxdWl2YWxlbnRVaW50OEFycmF5cykoY2h1bmssIF9lbmNvZGVkVGFncy5FTkNPREVEX1RBR1MuQ0xPU0VELkJPRFkpIHx8ICgwLCBfdWludDhhcnJheWhlbHBlcnMuaXNFcXVpdmFsZW50VWludDhBcnJheXMpKGNodW5rLCBfZW5jb2RlZFRhZ3MuRU5DT0RFRF9UQUdTLkNMT1NFRC5IVE1MKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBlbnRpcmUgY2h1bmsgaXMgdGhlIGNsb3NpbmcgdGFnczsgcmV0dXJuIHdpdGhvdXQgZW5xdWV1ZWluZyBhbnl0aGluZy5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhlc2UgdGFncyB3aWxsIGdvIGF0IHRvZ2V0aGVyIGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50IGFuZCB0aGF0XG4gICAgICAgICAgICAvLyB0aGV5IHdvbid0IGFwcGVhciBhbnl3aGVyZSBlbHNlIGluIHRoZSBkb2N1bWVudC4gVGhpcyBpcyBub3QgcmVhbGx5IGEgc2FmZSBhc3N1bXB0aW9uXG4gICAgICAgICAgICAvLyBidXQgdW50aWwgd2UgcmV2YW1wIG91ciBzdHJlYW1pbmcgaW5mcmEgdGhpcyBpcyBhIHBlcmZvcm1hbnQgd2F5IHRvIHN0cmluZyB0aGUgdGFnc1xuICAgICAgICAgICAgY2h1bmsgPSAoMCwgX3VpbnQ4YXJyYXloZWxwZXJzLnJlbW92ZUZyb21VaW50OEFycmF5KShjaHVuaywgX2VuY29kZWRUYWdzLkVOQ09ERURfVEFHUy5DTE9TRUQuQk9EWSk7XG4gICAgICAgICAgICBjaHVuayA9ICgwLCBfdWludDhhcnJheWhlbHBlcnMucmVtb3ZlRnJvbVVpbnQ4QXJyYXkpKGNodW5rLCBfZW5jb2RlZFRhZ3MuRU5DT0RFRF9UQUdTLkNMT1NFRC5IVE1MKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RMYXlvdXRWYWxpZGF0b3JTdHJlYW0oKSB7XG4gICAgbGV0IGZvdW5kSHRtbCA9IGZhbHNlO1xuICAgIGxldCBmb3VuZEJvZHkgPSBmYWxzZTtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHRyYW5zZm9ybSAoY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIC8vIFBlZWsgaW50byB0aGUgc3RyZWFtZWQgY2h1bmsgdG8gc2VlIGlmIHRoZSB0YWdzIGFyZSBwcmVzZW50LlxuICAgICAgICAgICAgaWYgKCFmb3VuZEh0bWwgJiYgKDAsIF91aW50OGFycmF5aGVscGVycy5pbmRleE9mVWludDhBcnJheSkoY2h1bmssIF9lbmNvZGVkVGFncy5FTkNPREVEX1RBR1MuT1BFTklORy5IVE1MKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZm91bmRIdG1sID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmRCb2R5ICYmICgwLCBfdWludDhhcnJheWhlbHBlcnMuaW5kZXhPZlVpbnQ4QXJyYXkpKGNodW5rLCBfZW5jb2RlZFRhZ3MuRU5DT0RFRF9UQUdTLk9QRU5JTkcuQk9EWSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGZvdW5kQm9keSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICB9LFxuICAgICAgICBmbHVzaCAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3QgbWlzc2luZ1RhZ3MgPSBbXTtcbiAgICAgICAgICAgIGlmICghZm91bmRIdG1sKSBtaXNzaW5nVGFncy5wdXNoKCdodG1sJyk7XG4gICAgICAgICAgICBpZiAoIWZvdW5kQm9keSkgbWlzc2luZ1RhZ3MucHVzaCgnYm9keScpO1xuICAgICAgICAgICAgaWYgKCFtaXNzaW5nVGFncy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShgPHNjcmlwdD5zZWxmLl9fbmV4dF9yb290X2xheW91dF9taXNzaW5nX3RhZ3M9JHtKU09OLnN0cmluZ2lmeShtaXNzaW5nVGFncyl9PC9zY3JpcHQ+YCkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjaGFpblRyYW5zZm9ybWVycyhyZWFkYWJsZSwgdHJhbnNmb3JtZXJzKSB7XG4gICAgbGV0IHN0cmVhbSA9IHJlYWRhYmxlO1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKXtcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1lcikgY29udGludWU7XG4gICAgICAgIHN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaCh0cmFuc2Zvcm1lcik7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW07XG59XG5hc3luYyBmdW5jdGlvbiBjb250aW51ZUZpenpTdHJlYW0ocmVuZGVyU3RyZWFtLCB7IHN1ZmZpeCwgaW5saW5lZERhdGFTdHJlYW0sIGlzU3RhdGljR2VuZXJhdGlvbiwgZ2V0U2VydmVySW5zZXJ0ZWRIVE1MLCBnZXRTZXJ2ZXJJbnNlcnRlZE1ldGFkYXRhLCB2YWxpZGF0ZVJvb3RMYXlvdXQgfSkge1xuICAgIC8vIFN1ZmZpeCBpdHNlbGYgbWlnaHQgY29udGFpbiBjbG9zZSB0YWdzIGF0IHRoZSBlbmQsIHNvIHdlIG5lZWQgdG8gc3BsaXQgaXQuXG4gICAgY29uc3Qgc3VmZml4VW5jbG9zZWQgPSBzdWZmaXggPyBzdWZmaXguc3BsaXQoQ0xPU0VfVEFHLCAxKVswXSA6IG51bGw7XG4gICAgLy8gSWYgd2UncmUgZ2VuZXJhdGluZyBzdGF0aWMgSFRNTCBhbmQgdGhlcmUncyBhbiBgYWxsUmVhZHlgIHByb21pc2Ugb24gdGhlXG4gICAgLy8gc3RyZWFtLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0IHRvIHJlc29sdmUgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgaWYgKGlzU3RhdGljR2VuZXJhdGlvbiAmJiAnYWxsUmVhZHknIGluIHJlbmRlclN0cmVhbSkge1xuICAgICAgICBhd2FpdCByZW5kZXJTdHJlYW0uYWxsUmVhZHk7XG4gICAgfVxuICAgIHJldHVybiBjaGFpblRyYW5zZm9ybWVycyhyZW5kZXJTdHJlYW0sIFtcbiAgICAgICAgLy8gQnVmZmVyIGV2ZXJ5dGhpbmcgdG8gYXZvaWQgZmx1c2hpbmcgdG9vIGZyZXF1ZW50bHlcbiAgICAgICAgY3JlYXRlQnVmZmVyZWRUcmFuc2Zvcm1TdHJlYW0oKSxcbiAgICAgICAgLy8gSW5zZXJ0IGdlbmVyYXRlZCBtZXRhZGF0YVxuICAgICAgICBjcmVhdGVIZWFkSW5zZXJ0aW9uVHJhbnNmb3JtU3RyZWFtKGdldFNlcnZlckluc2VydGVkTWV0YWRhdGEpLFxuICAgICAgICAvLyBJbnNlcnQgc3VmZml4IGNvbnRlbnRcbiAgICAgICAgc3VmZml4VW5jbG9zZWQgIT0gbnVsbCAmJiBzdWZmaXhVbmNsb3NlZC5sZW5ndGggPiAwID8gY3JlYXRlRGVmZXJyZWRTdWZmaXhTdHJlYW0oc3VmZml4VW5jbG9zZWQpIDogbnVsbCxcbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBpbmxpbmVkIGRhdGEgKEZsaWdodCBkYXRhLCBmb3JtIHN0YXRlLCBldGMuKSBzdHJlYW0gaW50byB0aGUgSFRNTFxuICAgICAgICBpbmxpbmVkRGF0YVN0cmVhbSA/IGNyZWF0ZU1lcmdlZFRyYW5zZm9ybVN0cmVhbShpbmxpbmVkRGF0YVN0cmVhbSkgOiBudWxsLFxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgcm9vdCBsYXlvdXQgZm9yIG1pc3NpbmcgaHRtbCBvciBib2R5IHRhZ3NcbiAgICAgICAgdmFsaWRhdGVSb290TGF5b3V0ID8gY3JlYXRlUm9vdExheW91dFZhbGlkYXRvclN0cmVhbSgpIDogbnVsbCxcbiAgICAgICAgLy8gQ2xvc2UgdGFncyBzaG91bGQgYWx3YXlzIGJlIGRlZmVycmVkIHRvIHRoZSBlbmRcbiAgICAgICAgY3JlYXRlTW92ZVN1ZmZpeFN0cmVhbSgpLFxuICAgICAgICAvLyBTcGVjaWFsIGhlYWQgaW5zZXJ0aW9uc1xuICAgICAgICAvLyBUT0RPLUFQUDogSW5zZXJ0IHNlcnZlciBzaWRlIGh0bWwgdG8gZW5kIG9mIGhlYWQgaW4gYXBwIGxheW91dCByZW5kZXJpbmcsIHRvIGF2b2lkXG4gICAgICAgIC8vIGh5ZHJhdGlvbiBlcnJvcnMuIFJlbW92ZSB0aGlzIG9uY2UgaXQncyByZWFkeSB0byBiZSBoYW5kbGVkIGJ5IHJlYWN0IGl0c2VsZi5cbiAgICAgICAgY3JlYXRlSGVhZEluc2VydGlvblRyYW5zZm9ybVN0cmVhbShnZXRTZXJ2ZXJJbnNlcnRlZEhUTUwpXG4gICAgXSk7XG59XG5hc3luYyBmdW5jdGlvbiBjb250aW51ZUR5bmFtaWNQcmVyZW5kZXIocHJlcmVuZGVyU3RyZWFtLCB7IGdldFNlcnZlckluc2VydGVkSFRNTCwgZ2V0U2VydmVySW5zZXJ0ZWRNZXRhZGF0YSB9KSB7XG4gICAgcmV0dXJuIHByZXJlbmRlclN0cmVhbS8vIEJ1ZmZlciBldmVyeXRoaW5nIHRvIGF2b2lkIGZsdXNoaW5nIHRvbyBmcmVxdWVudGx5XG4gICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUJ1ZmZlcmVkVHJhbnNmb3JtU3RyZWFtKCkpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmlwRG9jdW1lbnRDbG9zaW5nVGFnc1RyYW5zZm9ybSgpKS8vIEluc2VydCBnZW5lcmF0ZWQgdGFncyB0byBoZWFkXG4gICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUhlYWRJbnNlcnRpb25UcmFuc2Zvcm1TdHJlYW0oZ2V0U2VydmVySW5zZXJ0ZWRIVE1MKSkvLyBJbnNlcnQgZ2VuZXJhdGVkIG1ldGFkYXRhXG4gICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUhlYWRJbnNlcnRpb25UcmFuc2Zvcm1TdHJlYW0oZ2V0U2VydmVySW5zZXJ0ZWRNZXRhZGF0YSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gY29udGludWVTdGF0aWNQcmVyZW5kZXIocHJlcmVuZGVyU3RyZWFtLCB7IGlubGluZWREYXRhU3RyZWFtLCBnZXRTZXJ2ZXJJbnNlcnRlZEhUTUwsIGdldFNlcnZlckluc2VydGVkTWV0YWRhdGEgfSkge1xuICAgIHJldHVybiBwcmVyZW5kZXJTdHJlYW0vLyBCdWZmZXIgZXZlcnl0aGluZyB0byBhdm9pZCBmbHVzaGluZyB0b28gZnJlcXVlbnRseVxuICAgIC5waXBlVGhyb3VnaChjcmVhdGVCdWZmZXJlZFRyYW5zZm9ybVN0cmVhbSgpKS8vIEluc2VydCBnZW5lcmF0ZWQgdGFncyB0byBoZWFkXG4gICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUhlYWRJbnNlcnRpb25UcmFuc2Zvcm1TdHJlYW0oZ2V0U2VydmVySW5zZXJ0ZWRIVE1MKSkvLyBJbnNlcnQgZ2VuZXJhdGVkIG1ldGFkYXRhIHRvIGhlYWRcbiAgICAucGlwZVRocm91Z2goY3JlYXRlSGVhZEluc2VydGlvblRyYW5zZm9ybVN0cmVhbShnZXRTZXJ2ZXJJbnNlcnRlZE1ldGFkYXRhKSkvLyBJbnNlcnQgdGhlIGlubGluZWQgZGF0YSAoRmxpZ2h0IGRhdGEsIGZvcm0gc3RhdGUsIGV0Yy4pIHN0cmVhbSBpbnRvIHRoZSBIVE1MXG4gICAgLnBpcGVUaHJvdWdoKGNyZWF0ZU1lcmdlZFRyYW5zZm9ybVN0cmVhbShpbmxpbmVkRGF0YVN0cmVhbSkpLy8gQ2xvc2UgdGFncyBzaG91bGQgYWx3YXlzIGJlIGRlZmVycmVkIHRvIHRoZSBlbmRcbiAgICAucGlwZVRocm91Z2goY3JlYXRlTW92ZVN1ZmZpeFN0cmVhbSgpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbnRpbnVlRHluYW1pY0hUTUxSZXN1bWUocmVuZGVyU3RyZWFtLCB7IGlubGluZWREYXRhU3RyZWFtLCBnZXRTZXJ2ZXJJbnNlcnRlZEhUTUwsIGdldFNlcnZlckluc2VydGVkTWV0YWRhdGEgfSkge1xuICAgIHJldHVybiByZW5kZXJTdHJlYW0vLyBCdWZmZXIgZXZlcnl0aGluZyB0byBhdm9pZCBmbHVzaGluZyB0b28gZnJlcXVlbnRseVxuICAgIC5waXBlVGhyb3VnaChjcmVhdGVCdWZmZXJlZFRyYW5zZm9ybVN0cmVhbSgpKS8vIEluc2VydCBnZW5lcmF0ZWQgdGFncyB0byBoZWFkXG4gICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUhlYWRJbnNlcnRpb25UcmFuc2Zvcm1TdHJlYW0oZ2V0U2VydmVySW5zZXJ0ZWRIVE1MKSkvLyBJbnNlcnQgZ2VuZXJhdGVkIG1ldGFkYXRhIHRvIGJvZHlcbiAgICAucGlwZVRocm91Z2goY3JlYXRlSGVhZEluc2VydGlvblRyYW5zZm9ybVN0cmVhbShnZXRTZXJ2ZXJJbnNlcnRlZE1ldGFkYXRhKSkvLyBJbnNlcnQgdGhlIGlubGluZWQgZGF0YSAoRmxpZ2h0IGRhdGEsIGZvcm0gc3RhdGUsIGV0Yy4pIHN0cmVhbSBpbnRvIHRoZSBIVE1MXG4gICAgLnBpcGVUaHJvdWdoKGNyZWF0ZU1lcmdlZFRyYW5zZm9ybVN0cmVhbShpbmxpbmVkRGF0YVN0cmVhbSkpLy8gQ2xvc2UgdGFncyBzaG91bGQgYWx3YXlzIGJlIGRlZmVycmVkIHRvIHRoZSBlbmRcbiAgICAucGlwZVRocm91Z2goY3JlYXRlTW92ZVN1ZmZpeFN0cmVhbSgpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50Q2xvc2luZ1N0cmVhbSgpIHtcbiAgICByZXR1cm4gc3RyZWFtRnJvbVN0cmluZyhDTE9TRV9UQUcpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlLXdlYi1zdHJlYW1zLWhlbHBlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/stream-utils/node-web-streams-helper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/stream-utils/uint8array-helpers.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/server/stream-utils/uint8array-helpers.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * Find the starting index of Uint8Array `b` within Uint8Array `a`.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    indexOfUint8Array: function() {\n        return indexOfUint8Array;\n    },\n    isEquivalentUint8Arrays: function() {\n        return isEquivalentUint8Arrays;\n    },\n    removeFromUint8Array: function() {\n        return removeFromUint8Array;\n    }\n});\nfunction indexOfUint8Array(a, b) {\n    if (b.length === 0) return 0;\n    if (a.length === 0 || b.length > a.length) return -1;\n    // start iterating through `a`\n    for(let i = 0; i <= a.length - b.length; i++){\n        let completeMatch = true;\n        // from index `i`, iterate through `b` and check for mismatch\n        for(let j = 0; j < b.length; j++){\n            // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.\n            if (a[i + j] !== b[j]) {\n                completeMatch = false;\n                break;\n            }\n        }\n        if (completeMatch) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction isEquivalentUint8Arrays(a, b) {\n    if (a.length !== b.length) return false;\n    for(let i = 0; i < a.length; i++){\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\nfunction removeFromUint8Array(a, b) {\n    const tagIndex = indexOfUint8Array(a, b);\n    if (tagIndex === 0) return a.subarray(b.length);\n    if (tagIndex > -1) {\n        const removed = new Uint8Array(a.length - b.length);\n        removed.set(a.slice(0, tagIndex));\n        removed.set(a.slice(tagIndex + b.length), tagIndex);\n        return removed;\n    } else {\n        return a;\n    }\n}\n\n//# sourceMappingURL=uint8array-helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9zdHJlYW0tdXRpbHMvdWludDhhcnJheS1oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxJQUFpQjtBQUNqQiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixNQUFNLENBSUw7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFxzdHJlYW0tdXRpbHNcXHVpbnQ4YXJyYXktaGVscGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZpbmQgdGhlIHN0YXJ0aW5nIGluZGV4IG9mIFVpbnQ4QXJyYXkgYGJgIHdpdGhpbiBVaW50OEFycmF5IGBhYC5cbiAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGluZGV4T2ZVaW50OEFycmF5OiBudWxsLFxuICAgIGlzRXF1aXZhbGVudFVpbnQ4QXJyYXlzOiBudWxsLFxuICAgIHJlbW92ZUZyb21VaW50OEFycmF5OiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGluZGV4T2ZVaW50OEFycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4T2ZVaW50OEFycmF5O1xuICAgIH0sXG4gICAgaXNFcXVpdmFsZW50VWludDhBcnJheXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNFcXVpdmFsZW50VWludDhBcnJheXM7XG4gICAgfSxcbiAgICByZW1vdmVGcm9tVWludDhBcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVGcm9tVWludDhBcnJheTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGluZGV4T2ZVaW50OEFycmF5KGEsIGIpIHtcbiAgICBpZiAoYi5sZW5ndGggPT09IDApIHJldHVybiAwO1xuICAgIGlmIChhLmxlbmd0aCA9PT0gMCB8fCBiLmxlbmd0aCA+IGEubGVuZ3RoKSByZXR1cm4gLTE7XG4gICAgLy8gc3RhcnQgaXRlcmF0aW5nIHRocm91Z2ggYGFgXG4gICAgZm9yKGxldCBpID0gMDsgaSA8PSBhLmxlbmd0aCAtIGIubGVuZ3RoOyBpKyspe1xuICAgICAgICBsZXQgY29tcGxldGVNYXRjaCA9IHRydWU7XG4gICAgICAgIC8vIGZyb20gaW5kZXggYGlgLCBpdGVyYXRlIHRocm91Z2ggYGJgIGFuZCBjaGVjayBmb3IgbWlzbWF0Y2hcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IGIubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgLy8gaWYgdGhlIHZhbHVlcyBkbyBub3QgbWF0Y2gsIHRoZW4gdGhpcyBpc24ndCBhIGNvbXBsZXRlIG1hdGNoLCBleGl0IGBiYCBpdGVyYXRpb24gZWFybHkgYW5kIGl0ZXJhdGUgdG8gbmV4dCBpbmRleCBvZiBgYWAuXG4gICAgICAgICAgICBpZiAoYVtpICsgal0gIT09IGJbal0pIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZU1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBsZXRlTWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGlzRXF1aXZhbGVudFVpbnQ4QXJyYXlzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUZyb21VaW50OEFycmF5KGEsIGIpIHtcbiAgICBjb25zdCB0YWdJbmRleCA9IGluZGV4T2ZVaW50OEFycmF5KGEsIGIpO1xuICAgIGlmICh0YWdJbmRleCA9PT0gMCkgcmV0dXJuIGEuc3ViYXJyYXkoYi5sZW5ndGgpO1xuICAgIGlmICh0YWdJbmRleCA+IC0xKSB7XG4gICAgICAgIGNvbnN0IHJlbW92ZWQgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCAtIGIubGVuZ3RoKTtcbiAgICAgICAgcmVtb3ZlZC5zZXQoYS5zbGljZSgwLCB0YWdJbmRleCkpO1xuICAgICAgICByZW1vdmVkLnNldChhLnNsaWNlKHRhZ0luZGV4ICsgYi5sZW5ndGgpLCB0YWdJbmRleCk7XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWludDhhcnJheS1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/stream-utils/uint8array-helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/web/error.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/server/web/error.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    PageSignatureError: function() {\n        return PageSignatureError;\n    },\n    RemovedPageError: function() {\n        return RemovedPageError;\n    },\n    RemovedUAError: function() {\n        return RemovedUAError;\n    }\n});\nclass PageSignatureError extends Error {\n    constructor({ page }){\n        super(`The middleware \"${page}\" accepts an async API directly with the form:\n  \n  export function middleware(request, event) {\n    return NextResponse.redirect('/new-location')\n  }\n  \n  Read more: https://nextjs.org/docs/messages/middleware-new-signature\n  `);\n    }\n}\nclass RemovedPageError extends Error {\n    constructor(){\n        super(`The request.page has been deprecated in favour of \\`URLPattern\\`.\n  Read more: https://nextjs.org/docs/messages/middleware-request-page\n  `);\n    }\n}\nclass RemovedUAError extends Error {\n    constructor(){\n        super(`The request.ua has been removed in favour of \\`userAgent\\` function.\n  Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent\n  `);\n    }\n}\n\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixNQUFNLENBSUw7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxzZXJ2ZXJcXHdlYlxcZXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQYWdlU2lnbmF0dXJlRXJyb3I6IG51bGwsXG4gICAgUmVtb3ZlZFBhZ2VFcnJvcjogbnVsbCxcbiAgICBSZW1vdmVkVUFFcnJvcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBQYWdlU2lnbmF0dXJlRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGFnZVNpZ25hdHVyZUVycm9yO1xuICAgIH0sXG4gICAgUmVtb3ZlZFBhZ2VFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZW1vdmVkUGFnZUVycm9yO1xuICAgIH0sXG4gICAgUmVtb3ZlZFVBRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVtb3ZlZFVBRXJyb3I7XG4gICAgfVxufSk7XG5jbGFzcyBQYWdlU2lnbmF0dXJlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBwYWdlIH0pe1xuICAgICAgICBzdXBlcihgVGhlIG1pZGRsZXdhcmUgXCIke3BhZ2V9XCIgYWNjZXB0cyBhbiBhc3luYyBBUEkgZGlyZWN0bHkgd2l0aCB0aGUgZm9ybTpcbiAgXG4gIGV4cG9ydCBmdW5jdGlvbiBtaWRkbGV3YXJlKHJlcXVlc3QsIGV2ZW50KSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5yZWRpcmVjdCgnL25ldy1sb2NhdGlvbicpXG4gIH1cbiAgXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1uZXctc2lnbmF0dXJlXG4gIGApO1xuICAgIH1cbn1cbmNsYXNzIFJlbW92ZWRQYWdlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoYFRoZSByZXF1ZXN0LnBhZ2UgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgXFxgVVJMUGF0dGVyblxcYC5cbiAgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9taWRkbGV3YXJlLXJlcXVlc3QtcGFnZVxuICBgKTtcbiAgICB9XG59XG5jbGFzcyBSZW1vdmVkVUFFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcihgVGhlIHJlcXVlc3QudWEgaGFzIGJlZW4gcmVtb3ZlZCBpbiBmYXZvdXIgb2YgXFxgdXNlckFnZW50XFxgIGZ1bmN0aW9uLlxuICBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL21pZGRsZXdhcmUtcGFyc2UtdXNlci1hZ2VudFxuICBgKTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/web/error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/web/exports/index.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/server/web/exports/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Alias index file of next/server for edge runtime for tree-shaking purpose\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ImageResponse: function() {\n        return _imageresponse.ImageResponse;\n    },\n    NextRequest: function() {\n        return _request.NextRequest;\n    },\n    NextResponse: function() {\n        return _response.NextResponse;\n    },\n    URLPattern: function() {\n        return _urlpattern.URLPattern;\n    },\n    after: function() {\n        return _after.after;\n    },\n    connection: function() {\n        return _connection.connection;\n    },\n    unstable_rootParams: function() {\n        return _rootparams.unstable_rootParams;\n    },\n    userAgent: function() {\n        return _useragent.userAgent;\n    },\n    userAgentFromString: function() {\n        return _useragent.userAgentFromString;\n    }\n});\nconst _imageresponse = __webpack_require__(/*! ../spec-extension/image-response */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/image-response.js\");\nconst _request = __webpack_require__(/*! ../spec-extension/request */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/request.js\");\nconst _response = __webpack_require__(/*! ../spec-extension/response */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/response.js\");\nconst _useragent = __webpack_require__(/*! ../spec-extension/user-agent */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/user-agent.js\");\nconst _urlpattern = __webpack_require__(/*! ../spec-extension/url-pattern */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/url-pattern.js\");\nconst _after = __webpack_require__(/*! ../../after */ \"(rsc)/./node_modules/next/dist/server/after/index.js\");\nconst _connection = __webpack_require__(/*! ../../request/connection */ \"(rsc)/./node_modules/next/dist/server/request/connection.js\");\nconst _rootparams = __webpack_require__(/*! ../../request/root-params */ \"(rsc)/./node_modules/next/dist/server/request/root-params.js\");\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvZXhwb3J0cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsTUFBTSxDQVVMO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCLG1CQUFPLENBQUMsb0hBQWtDO0FBQ2pFLGlCQUFpQixtQkFBTyxDQUFDLHNHQUEyQjtBQUNwRCxrQkFBa0IsbUJBQU8sQ0FBQyx3R0FBNEI7QUFDdEQsbUJBQW1CLG1CQUFPLENBQUMsNEdBQThCO0FBQ3pELG9CQUFvQixtQkFBTyxDQUFDLDhHQUErQjtBQUMzRCxlQUFlLG1CQUFPLENBQUMseUVBQWE7QUFDcEMsb0JBQW9CLG1CQUFPLENBQUMsNkZBQTBCO0FBQ3RELG9CQUFvQixtQkFBTyxDQUFDLCtGQUEyQjs7QUFFdkQiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxzZXJ2ZXJcXHdlYlxcZXhwb3J0c1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQWxpYXMgaW5kZXggZmlsZSBvZiBuZXh0L3NlcnZlciBmb3IgZWRnZSBydW50aW1lIGZvciB0cmVlLXNoYWtpbmcgcHVycG9zZVxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBJbWFnZVJlc3BvbnNlOiBudWxsLFxuICAgIE5leHRSZXF1ZXN0OiBudWxsLFxuICAgIE5leHRSZXNwb25zZTogbnVsbCxcbiAgICBVUkxQYXR0ZXJuOiBudWxsLFxuICAgIGFmdGVyOiBudWxsLFxuICAgIGNvbm5lY3Rpb246IG51bGwsXG4gICAgdW5zdGFibGVfcm9vdFBhcmFtczogbnVsbCxcbiAgICB1c2VyQWdlbnQ6IG51bGwsXG4gICAgdXNlckFnZW50RnJvbVN0cmluZzogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBJbWFnZVJlc3BvbnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9pbWFnZXJlc3BvbnNlLkltYWdlUmVzcG9uc2U7XG4gICAgfSxcbiAgICBOZXh0UmVxdWVzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcmVxdWVzdC5OZXh0UmVxdWVzdDtcbiAgICB9LFxuICAgIE5leHRSZXNwb25zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcmVzcG9uc2UuTmV4dFJlc3BvbnNlO1xuICAgIH0sXG4gICAgVVJMUGF0dGVybjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdXJscGF0dGVybi5VUkxQYXR0ZXJuO1xuICAgIH0sXG4gICAgYWZ0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2FmdGVyLmFmdGVyO1xuICAgIH0sXG4gICAgY29ubmVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfY29ubmVjdGlvbi5jb25uZWN0aW9uO1xuICAgIH0sXG4gICAgdW5zdGFibGVfcm9vdFBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcm9vdHBhcmFtcy51bnN0YWJsZV9yb290UGFyYW1zO1xuICAgIH0sXG4gICAgdXNlckFnZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF91c2VyYWdlbnQudXNlckFnZW50O1xuICAgIH0sXG4gICAgdXNlckFnZW50RnJvbVN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdXNlcmFnZW50LnVzZXJBZ2VudEZyb21TdHJpbmc7XG4gICAgfVxufSk7XG5jb25zdCBfaW1hZ2VyZXNwb25zZSA9IHJlcXVpcmUoXCIuLi9zcGVjLWV4dGVuc2lvbi9pbWFnZS1yZXNwb25zZVwiKTtcbmNvbnN0IF9yZXF1ZXN0ID0gcmVxdWlyZShcIi4uL3NwZWMtZXh0ZW5zaW9uL3JlcXVlc3RcIik7XG5jb25zdCBfcmVzcG9uc2UgPSByZXF1aXJlKFwiLi4vc3BlYy1leHRlbnNpb24vcmVzcG9uc2VcIik7XG5jb25zdCBfdXNlcmFnZW50ID0gcmVxdWlyZShcIi4uL3NwZWMtZXh0ZW5zaW9uL3VzZXItYWdlbnRcIik7XG5jb25zdCBfdXJscGF0dGVybiA9IHJlcXVpcmUoXCIuLi9zcGVjLWV4dGVuc2lvbi91cmwtcGF0dGVyblwiKTtcbmNvbnN0IF9hZnRlciA9IHJlcXVpcmUoXCIuLi8uLi9hZnRlclwiKTtcbmNvbnN0IF9jb25uZWN0aW9uID0gcmVxdWlyZShcIi4uLy4uL3JlcXVlc3QvY29ubmVjdGlvblwiKTtcbmNvbnN0IF9yb290cGFyYW1zID0gcmVxdWlyZShcIi4uLy4uL3JlcXVlc3Qvcm9vdC1wYXJhbXNcIik7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/web/exports/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/web/next-url.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/server/web/next-url.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"NextURL\", ({\n    enumerable: true,\n    get: function() {\n        return NextURL;\n    }\n}));\nconst _detectdomainlocale = __webpack_require__(/*! ../../shared/lib/i18n/detect-domain-locale */ \"(rsc)/./node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js\");\nconst _formatnextpathnameinfo = __webpack_require__(/*! ../../shared/lib/router/utils/format-next-pathname-info */ \"(rsc)/./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nconst _gethostname = __webpack_require__(/*! ../../shared/lib/get-hostname */ \"(rsc)/./node_modules/next/dist/shared/lib/get-hostname.js\");\nconst _getnextpathnameinfo = __webpack_require__(/*! ../../shared/lib/router/utils/get-next-pathname-info */ \"(rsc)/./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nconst REGEX_LOCALHOST_HOSTNAME = /(?!^https?:\\/\\/)(127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|\\[::1\\]|localhost)/;\nfunction parseURL(url, base) {\n    return new URL(String(url).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'), base && String(base).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'));\n}\nconst Internal = Symbol('NextURLInternal');\nclass NextURL {\n    constructor(input, baseOrOpts, opts){\n        let base;\n        let options;\n        if (typeof baseOrOpts === 'object' && 'pathname' in baseOrOpts || typeof baseOrOpts === 'string') {\n            base = baseOrOpts;\n            options = opts || {};\n        } else {\n            options = opts || baseOrOpts || {};\n        }\n        this[Internal] = {\n            url: parseURL(input, base ?? options.base),\n            options: options,\n            basePath: ''\n        };\n        this.analyze();\n    }\n    analyze() {\n        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig, _this_Internal_domainLocale, _this_Internal_options_nextConfig_i18n1, _this_Internal_options_nextConfig1;\n        const info = (0, _getnextpathnameinfo.getNextPathnameInfo)(this[Internal].url.pathname, {\n            nextConfig: this[Internal].options.nextConfig,\n            parseData: !undefined,\n            i18nProvider: this[Internal].options.i18nProvider\n        });\n        const hostname = (0, _gethostname.getHostname)(this[Internal].url, this[Internal].options.headers);\n        this[Internal].domainLocale = this[Internal].options.i18nProvider ? this[Internal].options.i18nProvider.detectDomainLocale(hostname) : (0, _detectdomainlocale.detectDomainLocale)((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.domains, hostname);\n        const defaultLocale = ((_this_Internal_domainLocale = this[Internal].domainLocale) == null ? void 0 : _this_Internal_domainLocale.defaultLocale) || ((_this_Internal_options_nextConfig1 = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n1 = _this_Internal_options_nextConfig1.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n1.defaultLocale);\n        this[Internal].url.pathname = info.pathname;\n        this[Internal].defaultLocale = defaultLocale;\n        this[Internal].basePath = info.basePath ?? '';\n        this[Internal].buildId = info.buildId;\n        this[Internal].locale = info.locale ?? defaultLocale;\n        this[Internal].trailingSlash = info.trailingSlash;\n    }\n    formatPathname() {\n        return (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n            basePath: this[Internal].basePath,\n            buildId: this[Internal].buildId,\n            defaultLocale: !this[Internal].options.forceLocale ? this[Internal].defaultLocale : undefined,\n            locale: this[Internal].locale,\n            pathname: this[Internal].url.pathname,\n            trailingSlash: this[Internal].trailingSlash\n        });\n    }\n    formatSearch() {\n        return this[Internal].url.search;\n    }\n    get buildId() {\n        return this[Internal].buildId;\n    }\n    set buildId(buildId) {\n        this[Internal].buildId = buildId;\n    }\n    get locale() {\n        return this[Internal].locale ?? '';\n    }\n    set locale(locale) {\n        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig;\n        if (!this[Internal].locale || !((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.locales.includes(locale))) {\n            throw Object.defineProperty(new TypeError(`The NextURL configuration includes no locale \"${locale}\"`), \"__NEXT_ERROR_CODE\", {\n                value: \"E597\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        this[Internal].locale = locale;\n    }\n    get defaultLocale() {\n        return this[Internal].defaultLocale;\n    }\n    get domainLocale() {\n        return this[Internal].domainLocale;\n    }\n    get searchParams() {\n        return this[Internal].url.searchParams;\n    }\n    get host() {\n        return this[Internal].url.host;\n    }\n    set host(value) {\n        this[Internal].url.host = value;\n    }\n    get hostname() {\n        return this[Internal].url.hostname;\n    }\n    set hostname(value) {\n        this[Internal].url.hostname = value;\n    }\n    get port() {\n        return this[Internal].url.port;\n    }\n    set port(value) {\n        this[Internal].url.port = value;\n    }\n    get protocol() {\n        return this[Internal].url.protocol;\n    }\n    set protocol(value) {\n        this[Internal].url.protocol = value;\n    }\n    get href() {\n        const pathname = this.formatPathname();\n        const search = this.formatSearch();\n        return `${this.protocol}//${this.host}${pathname}${search}${this.hash}`;\n    }\n    set href(url) {\n        this[Internal].url = parseURL(url);\n        this.analyze();\n    }\n    get origin() {\n        return this[Internal].url.origin;\n    }\n    get pathname() {\n        return this[Internal].url.pathname;\n    }\n    set pathname(value) {\n        this[Internal].url.pathname = value;\n    }\n    get hash() {\n        return this[Internal].url.hash;\n    }\n    set hash(value) {\n        this[Internal].url.hash = value;\n    }\n    get search() {\n        return this[Internal].url.search;\n    }\n    set search(value) {\n        this[Internal].url.search = value;\n    }\n    get password() {\n        return this[Internal].url.password;\n    }\n    set password(value) {\n        this[Internal].url.password = value;\n    }\n    get username() {\n        return this[Internal].url.username;\n    }\n    set username(value) {\n        this[Internal].url.username = value;\n    }\n    get basePath() {\n        return this[Internal].basePath;\n    }\n    set basePath(value) {\n        this[Internal].basePath = value.startsWith('/') ? value : `/${value}`;\n    }\n    toString() {\n        return this.href;\n    }\n    toJSON() {\n        return this.href;\n    }\n    [Symbol.for('edge-runtime.inspect.custom')]() {\n        return {\n            href: this.href,\n            origin: this.origin,\n            protocol: this.protocol,\n            username: this.username,\n            password: this.password,\n            host: this.host,\n            hostname: this.hostname,\n            port: this.port,\n            pathname: this.pathname,\n            search: this.search,\n            searchParams: this.searchParams,\n            hash: this.hash\n        };\n    }\n    clone() {\n        return new NextURL(String(this), this[Internal].options);\n    }\n}\n\n//# sourceMappingURL=next-url.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvbmV4dC11cmwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiw0QkFBNEIsbUJBQU8sQ0FBQywwSEFBNEM7QUFDaEYsZ0NBQWdDLG1CQUFPLENBQUMsb0pBQXlEO0FBQ2pHLHFCQUFxQixtQkFBTyxDQUFDLGdHQUErQjtBQUM1RCw2QkFBNkIsbUJBQU8sQ0FBQyw4SUFBc0Q7QUFDM0YscUdBQXFHLEVBQUU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUE4QztBQUN0RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsT0FBTztBQUM5RztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWMsSUFBSSxVQUFVLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxVQUFVO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxNQUFNO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxcd2ViXFxuZXh0LXVybC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5leHRVUkxcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5leHRVUkw7XG4gICAgfVxufSk7XG5jb25zdCBfZGV0ZWN0ZG9tYWlubG9jYWxlID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZVwiKTtcbmNvbnN0IF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG5jb25zdCBfZ2V0aG9zdG5hbWUgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9nZXQtaG9zdG5hbWVcIik7XG5jb25zdCBfZ2V0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9nZXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xuY29uc3QgUkVHRVhfTE9DQUxIT1NUX0hPU1ROQU1FID0gLyg/IV5odHRwcz86XFwvXFwvKSgxMjcoPzpcXC4oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pKXszfXxcXFs6OjFcXF18bG9jYWxob3N0KS87XG5mdW5jdGlvbiBwYXJzZVVSTCh1cmwsIGJhc2UpIHtcbiAgICByZXR1cm4gbmV3IFVSTChTdHJpbmcodXJsKS5yZXBsYWNlKFJFR0VYX0xPQ0FMSE9TVF9IT1NUTkFNRSwgJ2xvY2FsaG9zdCcpLCBiYXNlICYmIFN0cmluZyhiYXNlKS5yZXBsYWNlKFJFR0VYX0xPQ0FMSE9TVF9IT1NUTkFNRSwgJ2xvY2FsaG9zdCcpKTtcbn1cbmNvbnN0IEludGVybmFsID0gU3ltYm9sKCdOZXh0VVJMSW50ZXJuYWwnKTtcbmNsYXNzIE5leHRVUkwge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0LCBiYXNlT3JPcHRzLCBvcHRzKXtcbiAgICAgICAgbGV0IGJhc2U7XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2VPck9wdHMgPT09ICdvYmplY3QnICYmICdwYXRobmFtZScgaW4gYmFzZU9yT3B0cyB8fCB0eXBlb2YgYmFzZU9yT3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlT3JPcHRzO1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0cyB8fCBiYXNlT3JPcHRzIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdID0ge1xuICAgICAgICAgICAgdXJsOiBwYXJzZVVSTChpbnB1dCwgYmFzZSA/PyBvcHRpb25zLmJhc2UpLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIGJhc2VQYXRoOiAnJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFuYWx5emUoKTtcbiAgICB9XG4gICAgYW5hbHl6ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzX0ludGVybmFsX29wdGlvbnNfbmV4dENvbmZpZ19pMThuLCBfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWcsIF90aGlzX0ludGVybmFsX2RvbWFpbkxvY2FsZSwgX3RoaXNfSW50ZXJuYWxfb3B0aW9uc19uZXh0Q29uZmlnX2kxOG4xLCBfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWcxO1xuICAgICAgICBjb25zdCBpbmZvID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHRoaXNbSW50ZXJuYWxdLnVybC5wYXRobmFtZSwge1xuICAgICAgICAgICAgbmV4dENvbmZpZzogdGhpc1tJbnRlcm5hbF0ub3B0aW9ucy5uZXh0Q29uZmlnLFxuICAgICAgICAgICAgcGFyc2VEYXRhOiAhcHJvY2Vzcy5lbnYuX19ORVhUX05PX01JRERMRVdBUkVfVVJMX05PUk1BTElaRSxcbiAgICAgICAgICAgIGkxOG5Qcm92aWRlcjogdGhpc1tJbnRlcm5hbF0ub3B0aW9ucy5pMThuUHJvdmlkZXJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lID0gKDAsIF9nZXRob3N0bmFtZS5nZXRIb3N0bmFtZSkodGhpc1tJbnRlcm5hbF0udXJsLCB0aGlzW0ludGVybmFsXS5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICB0aGlzW0ludGVybmFsXS5kb21haW5Mb2NhbGUgPSB0aGlzW0ludGVybmFsXS5vcHRpb25zLmkxOG5Qcm92aWRlciA/IHRoaXNbSW50ZXJuYWxdLm9wdGlvbnMuaTE4blByb3ZpZGVyLmRldGVjdERvbWFpbkxvY2FsZShob3N0bmFtZSkgOiAoMCwgX2RldGVjdGRvbWFpbmxvY2FsZS5kZXRlY3REb21haW5Mb2NhbGUpKChfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWcgPSB0aGlzW0ludGVybmFsXS5vcHRpb25zLm5leHRDb25maWcpID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXNfSW50ZXJuYWxfb3B0aW9uc19uZXh0Q29uZmlnX2kxOG4gPSBfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWcuaTE4bikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX0ludGVybmFsX29wdGlvbnNfbmV4dENvbmZpZ19pMThuLmRvbWFpbnMsIGhvc3RuYW1lKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdExvY2FsZSA9ICgoX3RoaXNfSW50ZXJuYWxfZG9tYWluTG9jYWxlID0gdGhpc1tJbnRlcm5hbF0uZG9tYWluTG9jYWxlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfSW50ZXJuYWxfZG9tYWluTG9jYWxlLmRlZmF1bHRMb2NhbGUpIHx8ICgoX3RoaXNfSW50ZXJuYWxfb3B0aW9uc19uZXh0Q29uZmlnMSA9IHRoaXNbSW50ZXJuYWxdLm9wdGlvbnMubmV4dENvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWdfaTE4bjEgPSBfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWcxLmkxOG4pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWdfaTE4bjEuZGVmYXVsdExvY2FsZSk7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLnVybC5wYXRobmFtZSA9IGluZm8ucGF0aG5hbWU7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLmRlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuICAgICAgICB0aGlzW0ludGVybmFsXS5iYXNlUGF0aCA9IGluZm8uYmFzZVBhdGggPz8gJyc7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLmJ1aWxkSWQgPSBpbmZvLmJ1aWxkSWQ7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLmxvY2FsZSA9IGluZm8ubG9jYWxlID8/IGRlZmF1bHRMb2NhbGU7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLnRyYWlsaW5nU2xhc2ggPSBpbmZvLnRyYWlsaW5nU2xhc2g7XG4gICAgfVxuICAgIGZvcm1hdFBhdGhuYW1lKCkge1xuICAgICAgICByZXR1cm4gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcbiAgICAgICAgICAgIGJhc2VQYXRoOiB0aGlzW0ludGVybmFsXS5iYXNlUGF0aCxcbiAgICAgICAgICAgIGJ1aWxkSWQ6IHRoaXNbSW50ZXJuYWxdLmJ1aWxkSWQsXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiAhdGhpc1tJbnRlcm5hbF0ub3B0aW9ucy5mb3JjZUxvY2FsZSA/IHRoaXNbSW50ZXJuYWxdLmRlZmF1bHRMb2NhbGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXNbSW50ZXJuYWxdLmxvY2FsZSxcbiAgICAgICAgICAgIHBhdGhuYW1lOiB0aGlzW0ludGVybmFsXS51cmwucGF0aG5hbWUsXG4gICAgICAgICAgICB0cmFpbGluZ1NsYXNoOiB0aGlzW0ludGVybmFsXS50cmFpbGluZ1NsYXNoXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3JtYXRTZWFyY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwuc2VhcmNoO1xuICAgIH1cbiAgICBnZXQgYnVpbGRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLmJ1aWxkSWQ7XG4gICAgfVxuICAgIHNldCBidWlsZElkKGJ1aWxkSWQpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0uYnVpbGRJZCA9IGJ1aWxkSWQ7XG4gICAgfVxuICAgIGdldCBsb2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS5sb2NhbGUgPz8gJyc7XG4gICAgfVxuICAgIHNldCBsb2NhbGUobG9jYWxlKSB7XG4gICAgICAgIHZhciBfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWdfaTE4biwgX3RoaXNfSW50ZXJuYWxfb3B0aW9uc19uZXh0Q29uZmlnO1xuICAgICAgICBpZiAoIXRoaXNbSW50ZXJuYWxdLmxvY2FsZSB8fCAhKChfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWcgPSB0aGlzW0ludGVybmFsXS5vcHRpb25zLm5leHRDb25maWcpID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXNfSW50ZXJuYWxfb3B0aW9uc19uZXh0Q29uZmlnX2kxOG4gPSBfdGhpc19JbnRlcm5hbF9vcHRpb25zX25leHRDb25maWcuaTE4bikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX0ludGVybmFsX29wdGlvbnNfbmV4dENvbmZpZ19pMThuLmxvY2FsZXMuaW5jbHVkZXMobG9jYWxlKSkpIHtcbiAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgVHlwZUVycm9yKGBUaGUgTmV4dFVSTCBjb25maWd1cmF0aW9uIGluY2x1ZGVzIG5vIGxvY2FsZSBcIiR7bG9jYWxlfVwiYCksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIkU1OTdcIixcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB9XG4gICAgZ2V0IGRlZmF1bHRMb2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS5kZWZhdWx0TG9jYWxlO1xuICAgIH1cbiAgICBnZXQgZG9tYWluTG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0uZG9tYWluTG9jYWxlO1xuICAgIH1cbiAgICBnZXQgc2VhcmNoUGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLnNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgZ2V0IGhvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwuaG9zdDtcbiAgICB9XG4gICAgc2V0IGhvc3QodmFsdWUpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsLmhvc3QgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGhvc3RuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLmhvc3RuYW1lO1xuICAgIH1cbiAgICBzZXQgaG9zdG5hbWUodmFsdWUpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBwb3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLnBvcnQ7XG4gICAgfVxuICAgIHNldCBwb3J0KHZhbHVlKSB7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLnVybC5wb3J0ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBwcm90b2NvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5wcm90b2NvbDtcbiAgICB9XG4gICAgc2V0IHByb3RvY29sKHZhbHVlKSB7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLnVybC5wcm90b2NvbCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgaHJlZigpIHtcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSB0aGlzLmZvcm1hdFBhdGhuYW1lKCk7XG4gICAgICAgIGNvbnN0IHNlYXJjaCA9IHRoaXMuZm9ybWF0U2VhcmNoKCk7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sfS8vJHt0aGlzLmhvc3R9JHtwYXRobmFtZX0ke3NlYXJjaH0ke3RoaXMuaGFzaH1gO1xuICAgIH1cbiAgICBzZXQgaHJlZih1cmwpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsID0gcGFyc2VVUkwodXJsKTtcbiAgICAgICAgdGhpcy5hbmFseXplKCk7XG4gICAgfVxuICAgIGdldCBvcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwub3JpZ2luO1xuICAgIH1cbiAgICBnZXQgcGF0aG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwucGF0aG5hbWU7XG4gICAgfVxuICAgIHNldCBwYXRobmFtZSh2YWx1ZSkge1xuICAgICAgICB0aGlzW0ludGVybmFsXS51cmwucGF0aG5hbWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwuaGFzaDtcbiAgICB9XG4gICAgc2V0IGhhc2godmFsdWUpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsLmhhc2ggPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHNlYXJjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5zZWFyY2g7XG4gICAgfVxuICAgIHNldCBzZWFyY2godmFsdWUpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsLnNlYXJjaCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgcGFzc3dvcmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwucGFzc3dvcmQ7XG4gICAgfVxuICAgIHNldCBwYXNzd29yZCh2YWx1ZSkge1xuICAgICAgICB0aGlzW0ludGVybmFsXS51cmwucGFzc3dvcmQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHVzZXJuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLnVzZXJuYW1lO1xuICAgIH1cbiAgICBzZXQgdXNlcm5hbWUodmFsdWUpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsLnVzZXJuYW1lID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBiYXNlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLmJhc2VQYXRoO1xuICAgIH1cbiAgICBzZXQgYmFzZVBhdGgodmFsdWUpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0uYmFzZVBhdGggPSB2YWx1ZS5zdGFydHNXaXRoKCcvJykgPyB2YWx1ZSA6IGAvJHt2YWx1ZX1gO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHJlZjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ocmVmO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignZWRnZS1ydW50aW1lLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaHJlZjogdGhpcy5ocmVmLFxuICAgICAgICAgICAgb3JpZ2luOiB0aGlzLm9yaWdpbixcbiAgICAgICAgICAgIHByb3RvY29sOiB0aGlzLnByb3RvY29sLFxuICAgICAgICAgICAgdXNlcm5hbWU6IHRoaXMudXNlcm5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZDogdGhpcy5wYXNzd29yZCxcbiAgICAgICAgICAgIGhvc3Q6IHRoaXMuaG9zdCxcbiAgICAgICAgICAgIGhvc3RuYW1lOiB0aGlzLmhvc3RuYW1lLFxuICAgICAgICAgICAgcG9ydDogdGhpcy5wb3J0LFxuICAgICAgICAgICAgcGF0aG5hbWU6IHRoaXMucGF0aG5hbWUsXG4gICAgICAgICAgICBzZWFyY2g6IHRoaXMuc2VhcmNoLFxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zOiB0aGlzLnNlYXJjaFBhcmFtcyxcbiAgICAgICAgICAgIGhhc2g6IHRoaXMuaGFzaFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXh0VVJMKFN0cmluZyh0aGlzKSwgdGhpc1tJbnRlcm5hbF0ub3B0aW9ucyk7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXh0LXVybC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/web/next-url.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/web/spec-extension/adapters/next-request.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/adapters/next-request.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    NextRequestAdapter: function() {\n        return NextRequestAdapter;\n    },\n    ResponseAborted: function() {\n        return ResponseAborted;\n    },\n    ResponseAbortedName: function() {\n        return ResponseAbortedName;\n    },\n    createAbortController: function() {\n        return createAbortController;\n    },\n    signalFromNodeResponse: function() {\n        return signalFromNodeResponse;\n    }\n});\nconst _requestmeta = __webpack_require__(/*! ../../../request-meta */ \"(rsc)/./node_modules/next/dist/server/request-meta.js\");\nconst _utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/next/dist/server/web/utils.js\");\nconst _request = __webpack_require__(/*! ../request */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/request.js\");\nconst _helpers = __webpack_require__(/*! ../../../base-http/helpers */ \"(rsc)/./node_modules/next/dist/server/base-http/helpers.js\");\nconst ResponseAbortedName = 'ResponseAborted';\nclass ResponseAborted extends Error {\n    constructor(...args){\n        super(...args), this.name = ResponseAbortedName;\n    }\n}\nfunction createAbortController(response) {\n    const controller = new AbortController();\n    // If `finish` fires first, then `res.end()` has been called and the close is\n    // just us finishing the stream on our side. If `close` fires first, then we\n    // know the client disconnected before we finished.\n    response.once('close', ()=>{\n        if (response.writableFinished) return;\n        controller.abort(new ResponseAborted());\n    });\n    return controller;\n}\nfunction signalFromNodeResponse(response) {\n    const { errored, destroyed } = response;\n    if (errored || destroyed) {\n        return AbortSignal.abort(errored ?? new ResponseAborted());\n    }\n    const { signal } = createAbortController(response);\n    return signal;\n}\nclass NextRequestAdapter {\n    static fromBaseNextRequest(request, signal) {\n        if (// The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n        false) {} else if (// The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n         true && (0, _helpers.isNodeNextRequest)(request)) {\n            return NextRequestAdapter.fromNodeNextRequest(request, signal);\n        } else {\n            throw Object.defineProperty(new Error('Invariant: Unsupported NextRequest type'), \"__NEXT_ERROR_CODE\", {\n                value: \"E345\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    static fromNodeNextRequest(request, signal) {\n        // HEAD and GET requests can not have a body.\n        let body = null;\n        if (request.method !== 'GET' && request.method !== 'HEAD' && request.body) {\n            // @ts-expect-error - this is handled by undici, when streams/web land use it instead\n            body = request.body;\n        }\n        let url;\n        if (request.url.startsWith('http')) {\n            url = new URL(request.url);\n        } else {\n            // Grab the full URL from the request metadata.\n            const base = (0, _requestmeta.getRequestMeta)(request, 'initURL');\n            if (!base || !base.startsWith('http')) {\n                // Because the URL construction relies on the fact that the URL provided\n                // is absolute, we need to provide a base URL. We can't use the request\n                // URL because it's relative, so we use a dummy URL instead.\n                url = new URL(request.url, 'http://n');\n            } else {\n                url = new URL(request.url, base);\n            }\n        }\n        return new _request.NextRequest(url, {\n            method: request.method,\n            headers: (0, _utils.fromNodeOutgoingHttpHeaders)(request.headers),\n            duplex: 'half',\n            signal,\n            // geo\n            // ip\n            // nextConfig\n            // body can not be passed if request was aborted\n            // or we get a Request body was disturbed error\n            ...signal.aborted ? {} : {\n                body\n            }\n        });\n    }\n    static fromWebNextRequest(request) {\n        // HEAD and GET requests can not have a body.\n        let body = null;\n        if (request.method !== 'GET' && request.method !== 'HEAD') {\n            body = request.body;\n        }\n        return new _request.NextRequest(request.url, {\n            method: request.method,\n            headers: (0, _utils.fromNodeOutgoingHttpHeaders)(request.headers),\n            duplex: 'half',\n            signal: request.request.signal,\n            // geo\n            // ip\n            // nextConfig\n            // body can not be passed if request was aborted\n            // or we get a Request body was disturbed error\n            ...request.request.signal.aborted ? {} : {\n                body\n            }\n        });\n    }\n}\n\n//# sourceMappingURL=next-request.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvbmV4dC1yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsTUFBTSxDQU1MO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFCQUFxQixtQkFBTyxDQUFDLG9GQUF1QjtBQUNwRCxlQUFlLG1CQUFPLENBQUMsdUVBQWE7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMsdUZBQVk7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsOEZBQTRCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBOEUsRUFBRSxFQUUvRSxDQUFDO0FBQ1Y7QUFDQSxRQUFRLEtBQW1DO0FBQzNDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFx3ZWJcXHNwZWMtZXh0ZW5zaW9uXFxhZGFwdGVyc1xcbmV4dC1yZXF1ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTmV4dFJlcXVlc3RBZGFwdGVyOiBudWxsLFxuICAgIFJlc3BvbnNlQWJvcnRlZDogbnVsbCxcbiAgICBSZXNwb25zZUFib3J0ZWROYW1lOiBudWxsLFxuICAgIGNyZWF0ZUFib3J0Q29udHJvbGxlcjogbnVsbCxcbiAgICBzaWduYWxGcm9tTm9kZVJlc3BvbnNlOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIE5leHRSZXF1ZXN0QWRhcHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBOZXh0UmVxdWVzdEFkYXB0ZXI7XG4gICAgfSxcbiAgICBSZXNwb25zZUFib3J0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVzcG9uc2VBYm9ydGVkO1xuICAgIH0sXG4gICAgUmVzcG9uc2VBYm9ydGVkTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZXNwb25zZUFib3J0ZWROYW1lO1xuICAgIH0sXG4gICAgY3JlYXRlQWJvcnRDb250cm9sbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFib3J0Q29udHJvbGxlcjtcbiAgICB9LFxuICAgIHNpZ25hbEZyb21Ob2RlUmVzcG9uc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2lnbmFsRnJvbU5vZGVSZXNwb25zZTtcbiAgICB9XG59KTtcbmNvbnN0IF9yZXF1ZXN0bWV0YSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9yZXF1ZXN0LW1ldGFcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBfcmVxdWVzdCA9IHJlcXVpcmUoXCIuLi9yZXF1ZXN0XCIpO1xuY29uc3QgX2hlbHBlcnMgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS1odHRwL2hlbHBlcnNcIik7XG5jb25zdCBSZXNwb25zZUFib3J0ZWROYW1lID0gJ1Jlc3BvbnNlQWJvcnRlZCc7XG5jbGFzcyBSZXNwb25zZUFib3J0ZWQgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpLCB0aGlzLm5hbWUgPSBSZXNwb25zZUFib3J0ZWROYW1lO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUFib3J0Q29udHJvbGxlcihyZXNwb25zZSkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgLy8gSWYgYGZpbmlzaGAgZmlyZXMgZmlyc3QsIHRoZW4gYHJlcy5lbmQoKWAgaGFzIGJlZW4gY2FsbGVkIGFuZCB0aGUgY2xvc2UgaXNcbiAgICAvLyBqdXN0IHVzIGZpbmlzaGluZyB0aGUgc3RyZWFtIG9uIG91ciBzaWRlLiBJZiBgY2xvc2VgIGZpcmVzIGZpcnN0LCB0aGVuIHdlXG4gICAgLy8ga25vdyB0aGUgY2xpZW50IGRpc2Nvbm5lY3RlZCBiZWZvcmUgd2UgZmluaXNoZWQuXG4gICAgcmVzcG9uc2Uub25jZSgnY2xvc2UnLCAoKT0+e1xuICAgICAgICBpZiAocmVzcG9uc2Uud3JpdGFibGVGaW5pc2hlZCkgcmV0dXJuO1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KG5ldyBSZXNwb25zZUFib3J0ZWQoKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnRyb2xsZXI7XG59XG5mdW5jdGlvbiBzaWduYWxGcm9tTm9kZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgeyBlcnJvcmVkLCBkZXN0cm95ZWQgfSA9IHJlc3BvbnNlO1xuICAgIGlmIChlcnJvcmVkIHx8IGRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gQWJvcnRTaWduYWwuYWJvcnQoZXJyb3JlZCA/PyBuZXcgUmVzcG9uc2VBYm9ydGVkKCkpO1xuICAgIH1cbiAgICBjb25zdCB7IHNpZ25hbCB9ID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKHJlc3BvbnNlKTtcbiAgICByZXR1cm4gc2lnbmFsO1xufVxuY2xhc3MgTmV4dFJlcXVlc3RBZGFwdGVyIHtcbiAgICBzdGF0aWMgZnJvbUJhc2VOZXh0UmVxdWVzdChyZXF1ZXN0LCBzaWduYWwpIHtcbiAgICAgICAgaWYgKC8vIFRoZSB0eXBlIGNoZWNrIGhlcmUgZW5zdXJlcyB0aGF0IGByZXFgIGlzIGNvcnJlY3RseSB0eXBlZCwgYW5kIHRoZVxuICAgICAgICAvLyBlbnZpcm9ubWVudCB2YXJpYWJsZSBjaGVjayBwcm92aWRlcyBkZWFkIGNvZGUgZWxpbWluYXRpb24uXG4gICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnICYmICgwLCBfaGVscGVycy5pc1dlYk5leHRSZXF1ZXN0KShyZXF1ZXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXF1ZXN0QWRhcHRlci5mcm9tV2ViTmV4dFJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoLy8gVGhlIHR5cGUgY2hlY2sgaGVyZSBlbnN1cmVzIHRoYXQgYHJlcWAgaXMgY29ycmVjdGx5IHR5cGVkLCBhbmQgdGhlXG4gICAgICAgIC8vIGVudmlyb25tZW50IHZhcmlhYmxlIGNoZWNrIHByb3ZpZGVzIGRlYWQgY29kZSBlbGltaW5hdGlvbi5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FICE9PSAnZWRnZScgJiYgKDAsIF9oZWxwZXJzLmlzTm9kZU5leHRSZXF1ZXN0KShyZXF1ZXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXF1ZXN0QWRhcHRlci5mcm9tTm9kZU5leHRSZXF1ZXN0KHJlcXVlc3QsIHNpZ25hbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKCdJbnZhcmlhbnQ6IFVuc3VwcG9ydGVkIE5leHRSZXF1ZXN0IHR5cGUnKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiRTM0NVwiLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21Ob2RlTmV4dFJlcXVlc3QocmVxdWVzdCwgc2lnbmFsKSB7XG4gICAgICAgIC8vIEhFQUQgYW5kIEdFVCByZXF1ZXN0cyBjYW4gbm90IGhhdmUgYSBib2R5LlxuICAgICAgICBsZXQgYm9keSA9IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcgJiYgcmVxdWVzdC5tZXRob2QgIT09ICdIRUFEJyAmJiByZXF1ZXN0LmJvZHkpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSB0aGlzIGlzIGhhbmRsZWQgYnkgdW5kaWNpLCB3aGVuIHN0cmVhbXMvd2ViIGxhbmQgdXNlIGl0IGluc3RlYWRcbiAgICAgICAgICAgIGJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVybDtcbiAgICAgICAgaWYgKHJlcXVlc3QudXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICAgICAgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBHcmFiIHRoZSBmdWxsIFVSTCBmcm9tIHRoZSByZXF1ZXN0IG1ldGFkYXRhLlxuICAgICAgICAgICAgY29uc3QgYmFzZSA9ICgwLCBfcmVxdWVzdG1ldGEuZ2V0UmVxdWVzdE1ldGEpKHJlcXVlc3QsICdpbml0VVJMJyk7XG4gICAgICAgICAgICBpZiAoIWJhc2UgfHwgIWJhc2Uuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdGlvbiByZWxpZXMgb24gdGhlIGZhY3QgdGhhdCB0aGUgVVJMIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgLy8gaXMgYWJzb2x1dGUsIHdlIG5lZWQgdG8gcHJvdmlkZSBhIGJhc2UgVVJMLiBXZSBjYW4ndCB1c2UgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAvLyBVUkwgYmVjYXVzZSBpdCdzIHJlbGF0aXZlLCBzbyB3ZSB1c2UgYSBkdW1teSBVUkwgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsLCAnaHR0cDovL24nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCwgYmFzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBfcmVxdWVzdC5OZXh0UmVxdWVzdCh1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiAoMCwgX3V0aWxzLmZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycykocmVxdWVzdC5oZWFkZXJzKSxcbiAgICAgICAgICAgIGR1cGxleDogJ2hhbGYnLFxuICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgLy8gZ2VvXG4gICAgICAgICAgICAvLyBpcFxuICAgICAgICAgICAgLy8gbmV4dENvbmZpZ1xuICAgICAgICAgICAgLy8gYm9keSBjYW4gbm90IGJlIHBhc3NlZCBpZiByZXF1ZXN0IHdhcyBhYm9ydGVkXG4gICAgICAgICAgICAvLyBvciB3ZSBnZXQgYSBSZXF1ZXN0IGJvZHkgd2FzIGRpc3R1cmJlZCBlcnJvclxuICAgICAgICAgICAgLi4uc2lnbmFsLmFib3J0ZWQgPyB7fSA6IHtcbiAgICAgICAgICAgICAgICBib2R5XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVdlYk5leHRSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgLy8gSEVBRCBhbmQgR0VUIHJlcXVlc3RzIGNhbiBub3QgaGF2ZSBhIGJvZHkuXG4gICAgICAgIGxldCBib2R5ID0gbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnR0VUJyAmJiByZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICAgICAgICBib2R5ID0gcmVxdWVzdC5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgX3JlcXVlc3QuTmV4dFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiAoMCwgX3V0aWxzLmZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycykocmVxdWVzdC5oZWFkZXJzKSxcbiAgICAgICAgICAgIGR1cGxleDogJ2hhbGYnLFxuICAgICAgICAgICAgc2lnbmFsOiByZXF1ZXN0LnJlcXVlc3Quc2lnbmFsLFxuICAgICAgICAgICAgLy8gZ2VvXG4gICAgICAgICAgICAvLyBpcFxuICAgICAgICAgICAgLy8gbmV4dENvbmZpZ1xuICAgICAgICAgICAgLy8gYm9keSBjYW4gbm90IGJlIHBhc3NlZCBpZiByZXF1ZXN0IHdhcyBhYm9ydGVkXG4gICAgICAgICAgICAvLyBvciB3ZSBnZXQgYSBSZXF1ZXN0IGJvZHkgd2FzIGRpc3R1cmJlZCBlcnJvclxuICAgICAgICAgICAgLi4ucmVxdWVzdC5yZXF1ZXN0LnNpZ25hbC5hYm9ydGVkID8ge30gOiB7XG4gICAgICAgICAgICAgICAgYm9keVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5leHQtcmVxdWVzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/web/spec-extension/adapters/next-request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ReflectAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return ReflectAdapter;\n    }\n}));\nclass ReflectAdapter {\n    static get(target, prop, receiver) {\n        const value = Reflect.get(target, prop, receiver);\n        if (typeof value === 'function') {\n            return value.bind(target);\n        }\n        return value;\n    }\n    static set(target, prop, value, receiver) {\n        return Reflect.set(target, prop, value, receiver);\n    }\n    static has(target, prop) {\n        return Reflect.has(target, prop);\n    }\n    static deleteProperty(target, prop) {\n        return Reflect.deleteProperty(target, prop);\n    }\n}\n\n//# sourceMappingURL=reflect.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVmbGVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxcd2ViXFxzcGVjLWV4dGVuc2lvblxcYWRhcHRlcnNcXHJlZmxlY3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZWZsZWN0QWRhcHRlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXI7XG4gICAgfVxufSk7XG5jbGFzcyBSZWZsZWN0QWRhcHRlciB7XG4gICAgc3RhdGljIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5iaW5kKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcik7XG4gICAgfVxuICAgIHN0YXRpYyBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCk7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZsZWN0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/web/spec-extension/cookies.js":
/*!*********************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/cookies.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    RequestCookies: function() {\n        return _cookies.RequestCookies;\n    },\n    ResponseCookies: function() {\n        return _cookies.ResponseCookies;\n    },\n    stringifyCookie: function() {\n        return _cookies.stringifyCookie;\n    }\n});\nconst _cookies = __webpack_require__(/*! next/dist/compiled/@edge-runtime/cookies */ \"(rsc)/./node_modules/next/dist/compiled/@edge-runtime/cookies/index.js\");\n\n//# sourceMappingURL=cookies.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vY29va2llcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLE1BQU0sQ0FJTDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQixtQkFBTyxDQUFDLHdIQUEwQzs7QUFFbkUiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxzZXJ2ZXJcXHdlYlxcc3BlYy1leHRlbnNpb25cXGNvb2tpZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBSZXF1ZXN0Q29va2llczogbnVsbCxcbiAgICBSZXNwb25zZUNvb2tpZXM6IG51bGwsXG4gICAgc3RyaW5naWZ5Q29va2llOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIFJlcXVlc3RDb29raWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9jb29raWVzLlJlcXVlc3RDb29raWVzO1xuICAgIH0sXG4gICAgUmVzcG9uc2VDb29raWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9jb29raWVzLlJlc3BvbnNlQ29va2llcztcbiAgICB9LFxuICAgIHN0cmluZ2lmeUNvb2tpZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfY29va2llcy5zdHJpbmdpZnlDb29raWU7XG4gICAgfVxufSk7XG5jb25zdCBfY29va2llcyA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvQGVkZ2UtcnVudGltZS9jb29raWVzXCIpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb29raWVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/web/spec-extension/cookies.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/web/spec-extension/image-response.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/image-response.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * @deprecated ImageResponse moved from \"next/server\" to \"next/og\" since Next.js 14, please import from \"next/og\" instead.\n * Migration with codemods: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#next-og-import\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageResponse\", ({\n    enumerable: true,\n    get: function() {\n        return ImageResponse;\n    }\n}));\nfunction ImageResponse() {\n    throw Object.defineProperty(new Error('ImageResponse moved from \"next/server\" to \"next/og\" since Next.js 14, please import from \"next/og\" instead'), \"__NEXT_ERROR_CODE\", {\n        value: \"E183\",\n        enumerable: false,\n        configurable: true\n    });\n}\n\n//# sourceMappingURL=image-response.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vaW1hZ2UtcmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsSUFBaUI7QUFDakIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxcd2ViXFxzcGVjLWV4dGVuc2lvblxcaW1hZ2UtcmVzcG9uc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZGVwcmVjYXRlZCBJbWFnZVJlc3BvbnNlIG1vdmVkIGZyb20gXCJuZXh0L3NlcnZlclwiIHRvIFwibmV4dC9vZ1wiIHNpbmNlIE5leHQuanMgMTQsIHBsZWFzZSBpbXBvcnQgZnJvbSBcIm5leHQvb2dcIiBpbnN0ZWFkLlxuICogTWlncmF0aW9uIHdpdGggY29kZW1vZHM6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3VwZ3JhZGluZy9jb2RlbW9kcyNuZXh0LW9nLWltcG9ydFxuICovIFwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1hZ2VSZXNwb25zZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSW1hZ2VSZXNwb25zZTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIEltYWdlUmVzcG9uc2UoKSB7XG4gICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcignSW1hZ2VSZXNwb25zZSBtb3ZlZCBmcm9tIFwibmV4dC9zZXJ2ZXJcIiB0byBcIm5leHQvb2dcIiBzaW5jZSBOZXh0LmpzIDE0LCBwbGVhc2UgaW1wb3J0IGZyb20gXCJuZXh0L29nXCIgaW5zdGVhZCcpLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgdmFsdWU6IFwiRTE4M1wiLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLXJlc3BvbnNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/web/spec-extension/image-response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/web/spec-extension/request.js":
/*!*********************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/request.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    INTERNALS: function() {\n        return INTERNALS;\n    },\n    NextRequest: function() {\n        return NextRequest;\n    }\n});\nconst _nexturl = __webpack_require__(/*! ../next-url */ \"(rsc)/./node_modules/next/dist/server/web/next-url.js\");\nconst _utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/next/dist/server/web/utils.js\");\nconst _error = __webpack_require__(/*! ../error */ \"(rsc)/./node_modules/next/dist/server/web/error.js\");\nconst _cookies = __webpack_require__(/*! ./cookies */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/cookies.js\");\nconst INTERNALS = Symbol('internal request');\nclass NextRequest extends Request {\n    constructor(input, init = {}){\n        const url = typeof input !== 'string' && 'url' in input ? input.url : String(input);\n        (0, _utils.validateURL)(url);\n        // node Request instance requires duplex option when a body\n        // is present or it errors, we don't handle this for\n        // Request being passed in since it would have already\n        // errored if this wasn't configured\n        if (true) {\n            if (init.body && init.duplex !== 'half') {\n                init.duplex = 'half';\n            }\n        }\n        if (input instanceof Request) super(input, init);\n        else super(url, init);\n        const nextUrl = new _nexturl.NextURL(url, {\n            headers: (0, _utils.toNodeOutgoingHttpHeaders)(this.headers),\n            nextConfig: init.nextConfig\n        });\n        this[INTERNALS] = {\n            cookies: new _cookies.RequestCookies(this.headers),\n            nextUrl,\n            url:  false ? 0 : nextUrl.toString()\n        };\n    }\n    [Symbol.for('edge-runtime.inspect.custom')]() {\n        return {\n            cookies: this.cookies,\n            nextUrl: this.nextUrl,\n            url: this.url,\n            // rest of props come from Request\n            bodyUsed: this.bodyUsed,\n            cache: this.cache,\n            credentials: this.credentials,\n            destination: this.destination,\n            headers: Object.fromEntries(this.headers),\n            integrity: this.integrity,\n            keepalive: this.keepalive,\n            method: this.method,\n            mode: this.mode,\n            redirect: this.redirect,\n            referrer: this.referrer,\n            referrerPolicy: this.referrerPolicy,\n            signal: this.signal\n        };\n    }\n    get cookies() {\n        return this[INTERNALS].cookies;\n    }\n    get nextUrl() {\n        return this[INTERNALS].nextUrl;\n    }\n    /**\n   * @deprecated\n   * `page` has been deprecated in favour of `URLPattern`.\n   * Read more: https://nextjs.org/docs/messages/middleware-request-page\n   */ get page() {\n        throw new _error.RemovedPageError();\n    }\n    /**\n   * @deprecated\n   * `ua` has been removed in favour of \\`userAgent\\` function.\n   * Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent\n   */ get ua() {\n        throw new _error.RemovedUAError();\n    }\n    get url() {\n        return this[INTERNALS].url;\n    }\n}\n\n//# sourceMappingURL=request.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vcmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLE1BQU0sQ0FHTDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBYTtBQUN0QyxlQUFlLG1CQUFPLENBQUMsb0VBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLG9FQUFVO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHNGQUFXO0FBQ3BDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQThDLEdBQUcsQ0FBRztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFx3ZWJcXHNwZWMtZXh0ZW5zaW9uXFxyZXF1ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgSU5URVJOQUxTOiBudWxsLFxuICAgIE5leHRSZXF1ZXN0OiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIElOVEVSTkFMUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBJTlRFUk5BTFM7XG4gICAgfSxcbiAgICBOZXh0UmVxdWVzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBOZXh0UmVxdWVzdDtcbiAgICB9XG59KTtcbmNvbnN0IF9uZXh0dXJsID0gcmVxdWlyZShcIi4uL25leHQtdXJsXCIpO1xuY29uc3QgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuY29uc3QgX2Nvb2tpZXMgPSByZXF1aXJlKFwiLi9jb29raWVzXCIpO1xuY29uc3QgSU5URVJOQUxTID0gU3ltYm9sKCdpbnRlcm5hbCByZXF1ZXN0Jyk7XG5jbGFzcyBOZXh0UmVxdWVzdCBleHRlbmRzIFJlcXVlc3Qge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0LCBpbml0ID0ge30pe1xuICAgICAgICBjb25zdCB1cmwgPSB0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnICYmICd1cmwnIGluIGlucHV0ID8gaW5wdXQudXJsIDogU3RyaW5nKGlucHV0KTtcbiAgICAgICAgKDAsIF91dGlscy52YWxpZGF0ZVVSTCkodXJsKTtcbiAgICAgICAgLy8gbm9kZSBSZXF1ZXN0IGluc3RhbmNlIHJlcXVpcmVzIGR1cGxleCBvcHRpb24gd2hlbiBhIGJvZHlcbiAgICAgICAgLy8gaXMgcHJlc2VudCBvciBpdCBlcnJvcnMsIHdlIGRvbid0IGhhbmRsZSB0aGlzIGZvclxuICAgICAgICAvLyBSZXF1ZXN0IGJlaW5nIHBhc3NlZCBpbiBzaW5jZSBpdCB3b3VsZCBoYXZlIGFscmVhZHlcbiAgICAgICAgLy8gZXJyb3JlZCBpZiB0aGlzIHdhc24ndCBjb25maWd1cmVkXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgIT09ICdlZGdlJykge1xuICAgICAgICAgICAgaWYgKGluaXQuYm9keSAmJiBpbml0LmR1cGxleCAhPT0gJ2hhbGYnKSB7XG4gICAgICAgICAgICAgICAgaW5pdC5kdXBsZXggPSAnaGFsZic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkgc3VwZXIoaW5wdXQsIGluaXQpO1xuICAgICAgICBlbHNlIHN1cGVyKHVybCwgaW5pdCk7XG4gICAgICAgIGNvbnN0IG5leHRVcmwgPSBuZXcgX25leHR1cmwuTmV4dFVSTCh1cmwsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6ICgwLCBfdXRpbHMudG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycykodGhpcy5oZWFkZXJzKSxcbiAgICAgICAgICAgIG5leHRDb25maWc6IGluaXQubmV4dENvbmZpZ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpc1tJTlRFUk5BTFNdID0ge1xuICAgICAgICAgICAgY29va2llczogbmV3IF9jb29raWVzLlJlcXVlc3RDb29raWVzKHRoaXMuaGVhZGVycyksXG4gICAgICAgICAgICBuZXh0VXJsLFxuICAgICAgICAgICAgdXJsOiBwcm9jZXNzLmVudi5fX05FWFRfTk9fTUlERExFV0FSRV9VUkxfTk9STUFMSVpFID8gdXJsIDogbmV4dFVybC50b1N0cmluZygpXG4gICAgICAgIH07XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdlZGdlLXJ1bnRpbWUuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb29raWVzOiB0aGlzLmNvb2tpZXMsXG4gICAgICAgICAgICBuZXh0VXJsOiB0aGlzLm5leHRVcmwsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgLy8gcmVzdCBvZiBwcm9wcyBjb21lIGZyb20gUmVxdWVzdFxuICAgICAgICAgICAgYm9keVVzZWQ6IHRoaXMuYm9keVVzZWQsXG4gICAgICAgICAgICBjYWNoZTogdGhpcy5jYWNoZSxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLmNyZWRlbnRpYWxzLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IHRoaXMuZGVzdGluYXRpb24sXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5oZWFkZXJzKSxcbiAgICAgICAgICAgIGludGVncml0eTogdGhpcy5pbnRlZ3JpdHksXG4gICAgICAgICAgICBrZWVwYWxpdmU6IHRoaXMua2VlcGFsaXZlLFxuICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICAgIHJlZGlyZWN0OiB0aGlzLnJlZGlyZWN0LFxuICAgICAgICAgICAgcmVmZXJyZXI6IHRoaXMucmVmZXJyZXIsXG4gICAgICAgICAgICByZWZlcnJlclBvbGljeTogdGhpcy5yZWZlcnJlclBvbGljeSxcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy5zaWduYWxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IGNvb2tpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0lOVEVSTkFMU10uY29va2llcztcbiAgICB9XG4gICAgZ2V0IG5leHRVcmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0lOVEVSTkFMU10ubmV4dFVybDtcbiAgICB9XG4gICAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIGBwYWdlYCBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBgVVJMUGF0dGVybmAuXG4gICAqIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1yZXF1ZXN0LXBhZ2VcbiAgICovIGdldCBwYWdlKCkge1xuICAgICAgICB0aHJvdyBuZXcgX2Vycm9yLlJlbW92ZWRQYWdlRXJyb3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIGB1YWAgaGFzIGJlZW4gcmVtb3ZlZCBpbiBmYXZvdXIgb2YgXFxgdXNlckFnZW50XFxgIGZ1bmN0aW9uLlxuICAgKiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL21pZGRsZXdhcmUtcGFyc2UtdXNlci1hZ2VudFxuICAgKi8gZ2V0IHVhKCkge1xuICAgICAgICB0aHJvdyBuZXcgX2Vycm9yLlJlbW92ZWRVQUVycm9yKCk7XG4gICAgfVxuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0lOVEVSTkFMU10udXJsO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/web/spec-extension/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/web/spec-extension/response.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/response.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"NextResponse\", ({\n    enumerable: true,\n    get: function() {\n        return NextResponse;\n    }\n}));\nconst _cookies = __webpack_require__(/*! ../../web/spec-extension/cookies */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/cookies.js\");\nconst _nexturl = __webpack_require__(/*! ../next-url */ \"(rsc)/./node_modules/next/dist/server/web/next-url.js\");\nconst _utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/next/dist/server/web/utils.js\");\nconst _reflect = __webpack_require__(/*! ./adapters/reflect */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nconst _cookies1 = __webpack_require__(/*! ./cookies */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/cookies.js\");\nconst INTERNALS = Symbol('internal response');\nconst REDIRECTS = new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\nfunction handleMiddlewareField(init, headers) {\n    var _init_request;\n    if (init == null ? void 0 : (_init_request = init.request) == null ? void 0 : _init_request.headers) {\n        if (!(init.request.headers instanceof Headers)) {\n            throw Object.defineProperty(new Error('request.headers must be an instance of Headers'), \"__NEXT_ERROR_CODE\", {\n                value: \"E119\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const keys = [];\n        for (const [key, value] of init.request.headers){\n            headers.set('x-middleware-request-' + key, value);\n            keys.push(key);\n        }\n        headers.set('x-middleware-override-headers', keys.join(','));\n    }\n}\nclass NextResponse extends Response {\n    constructor(body, init = {}){\n        super(body, init);\n        const headers = this.headers;\n        const cookies = new _cookies1.ResponseCookies(headers);\n        const cookiesProxy = new Proxy(cookies, {\n            get (target, prop, receiver) {\n                switch(prop){\n                    case 'delete':\n                    case 'set':\n                        {\n                            return (...args)=>{\n                                const result = Reflect.apply(target[prop], target, args);\n                                const newHeaders = new Headers(headers);\n                                if (result instanceof _cookies1.ResponseCookies) {\n                                    headers.set('x-middleware-set-cookie', result.getAll().map((cookie)=>(0, _cookies.stringifyCookie)(cookie)).join(','));\n                                }\n                                handleMiddlewareField(init, newHeaders);\n                                return result;\n                            };\n                        }\n                    default:\n                        return _reflect.ReflectAdapter.get(target, prop, receiver);\n                }\n            }\n        });\n        this[INTERNALS] = {\n            cookies: cookiesProxy,\n            url: init.url ? new _nexturl.NextURL(init.url, {\n                headers: (0, _utils.toNodeOutgoingHttpHeaders)(headers),\n                nextConfig: init.nextConfig\n            }) : undefined\n        };\n    }\n    [Symbol.for('edge-runtime.inspect.custom')]() {\n        return {\n            cookies: this.cookies,\n            url: this.url,\n            // rest of props come from Response\n            body: this.body,\n            bodyUsed: this.bodyUsed,\n            headers: Object.fromEntries(this.headers),\n            ok: this.ok,\n            redirected: this.redirected,\n            status: this.status,\n            statusText: this.statusText,\n            type: this.type\n        };\n    }\n    get cookies() {\n        return this[INTERNALS].cookies;\n    }\n    static json(body, init) {\n        const response = Response.json(body, init);\n        return new NextResponse(response.body, response);\n    }\n    static redirect(url, init) {\n        const status = typeof init === 'number' ? init : (init == null ? void 0 : init.status) ?? 307;\n        if (!REDIRECTS.has(status)) {\n            throw Object.defineProperty(new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code'), \"__NEXT_ERROR_CODE\", {\n                value: \"E529\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const initObj = typeof init === 'object' ? init : {};\n        const headers = new Headers(initObj == null ? void 0 : initObj.headers);\n        headers.set('Location', (0, _utils.validateURL)(url));\n        return new NextResponse(null, {\n            ...initObj,\n            headers,\n            status\n        });\n    }\n    static rewrite(destination, init) {\n        const headers = new Headers(init == null ? void 0 : init.headers);\n        headers.set('x-middleware-rewrite', (0, _utils.validateURL)(destination));\n        handleMiddlewareField(init, headers);\n        return new NextResponse(null, {\n            ...init,\n            headers\n        });\n    }\n    static next(init) {\n        const headers = new Headers(init == null ? void 0 : init.headers);\n        headers.set('x-middleware-next', '1');\n        handleMiddlewareField(init, headers);\n        return new NextResponse(null, {\n            ...init,\n            headers\n        });\n    }\n}\n\n//# sourceMappingURL=response.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vcmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixpQkFBaUIsbUJBQU8sQ0FBQyw2R0FBa0M7QUFDM0QsaUJBQWlCLG1CQUFPLENBQUMsMEVBQWE7QUFDdEMsZUFBZSxtQkFBTyxDQUFDLG9FQUFVO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHdHQUFvQjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxcd2ViXFxzcGVjLWV4dGVuc2lvblxccmVzcG9uc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOZXh0UmVzcG9uc2VcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZTtcbiAgICB9XG59KTtcbmNvbnN0IF9jb29raWVzID0gcmVxdWlyZShcIi4uLy4uL3dlYi9zcGVjLWV4dGVuc2lvbi9jb29raWVzXCIpO1xuY29uc3QgX25leHR1cmwgPSByZXF1aXJlKFwiLi4vbmV4dC11cmxcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBfcmVmbGVjdCA9IHJlcXVpcmUoXCIuL2FkYXB0ZXJzL3JlZmxlY3RcIik7XG5jb25zdCBfY29va2llczEgPSByZXF1aXJlKFwiLi9jb29raWVzXCIpO1xuY29uc3QgSU5URVJOQUxTID0gU3ltYm9sKCdpbnRlcm5hbCByZXNwb25zZScpO1xuY29uc3QgUkVESVJFQ1RTID0gbmV3IFNldChbXG4gICAgMzAxLFxuICAgIDMwMixcbiAgICAzMDMsXG4gICAgMzA3LFxuICAgIDMwOFxuXSk7XG5mdW5jdGlvbiBoYW5kbGVNaWRkbGV3YXJlRmllbGQoaW5pdCwgaGVhZGVycykge1xuICAgIHZhciBfaW5pdF9yZXF1ZXN0O1xuICAgIGlmIChpbml0ID09IG51bGwgPyB2b2lkIDAgOiAoX2luaXRfcmVxdWVzdCA9IGluaXQucmVxdWVzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbml0X3JlcXVlc3QuaGVhZGVycykge1xuICAgICAgICBpZiAoIShpbml0LnJlcXVlc3QuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKCdyZXF1ZXN0LmhlYWRlcnMgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBIZWFkZXJzJyksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIkUxMTlcIixcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaW5pdC5yZXF1ZXN0LmhlYWRlcnMpe1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ3gtbWlkZGxld2FyZS1yZXF1ZXN0LScgKyBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlcnMuc2V0KCd4LW1pZGRsZXdhcmUtb3ZlcnJpZGUtaGVhZGVycycsIGtleXMuam9pbignLCcpKTtcbiAgICB9XG59XG5jbGFzcyBOZXh0UmVzcG9uc2UgZXh0ZW5kcyBSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IoYm9keSwgaW5pdCA9IHt9KXtcbiAgICAgICAgc3VwZXIoYm9keSwgaW5pdCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmhlYWRlcnM7XG4gICAgICAgIGNvbnN0IGNvb2tpZXMgPSBuZXcgX2Nvb2tpZXMxLlJlc3BvbnNlQ29va2llcyhoZWFkZXJzKTtcbiAgICAgICAgY29uc3QgY29va2llc1Byb3h5ID0gbmV3IFByb3h5KGNvb2tpZXMsIHtcbiAgICAgICAgICAgIGdldCAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHN3aXRjaChwcm9wKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuYXBwbHkodGFyZ2V0W3Byb3BdLCB0YXJnZXQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdIZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBfY29va2llczEuUmVzcG9uc2VDb29raWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLnNldCgneC1taWRkbGV3YXJlLXNldC1jb29raWUnLCByZXN1bHQuZ2V0QWxsKCkubWFwKChjb29raWUpPT4oMCwgX2Nvb2tpZXMuc3RyaW5naWZ5Q29va2llKShjb29raWUpKS5qb2luKCcsJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU1pZGRsZXdhcmVGaWVsZChpbml0LCBuZXdIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzW0lOVEVSTkFMU10gPSB7XG4gICAgICAgICAgICBjb29raWVzOiBjb29raWVzUHJveHksXG4gICAgICAgICAgICB1cmw6IGluaXQudXJsID8gbmV3IF9uZXh0dXJsLk5leHRVUkwoaW5pdC51cmwsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiAoMCwgX3V0aWxzLnRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMpKGhlYWRlcnMpLFxuICAgICAgICAgICAgICAgIG5leHRDb25maWc6IGluaXQubmV4dENvbmZpZ1xuICAgICAgICAgICAgfSkgOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ2VkZ2UtcnVudGltZS5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvb2tpZXM6IHRoaXMuY29va2llcyxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICAvLyByZXN0IG9mIHByb3BzIGNvbWUgZnJvbSBSZXNwb25zZVxuICAgICAgICAgICAgYm9keTogdGhpcy5ib2R5LFxuICAgICAgICAgICAgYm9keVVzZWQ6IHRoaXMuYm9keVVzZWQsXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5oZWFkZXJzKSxcbiAgICAgICAgICAgIG9rOiB0aGlzLm9rLFxuICAgICAgICAgICAgcmVkaXJlY3RlZDogdGhpcy5yZWRpcmVjdGVkLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgY29va2llcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTXS5jb29raWVzO1xuICAgIH1cbiAgICBzdGF0aWMganNvbihib2R5LCBpbml0KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gUmVzcG9uc2UuanNvbihib2R5LCBpbml0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXh0UmVzcG9uc2UocmVzcG9uc2UuYm9keSwgcmVzcG9uc2UpO1xuICAgIH1cbiAgICBzdGF0aWMgcmVkaXJlY3QodXJsLCBpbml0KSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHR5cGVvZiBpbml0ID09PSAnbnVtYmVyJyA/IGluaXQgOiAoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpID8/IDMwNztcbiAgICAgICAgaWYgKCFSRURJUkVDVFMuaGFzKHN0YXR1cykpIHtcbiAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgUmFuZ2VFcnJvcignRmFpbGVkIHRvIGV4ZWN1dGUgXCJyZWRpcmVjdFwiIG9uIFwicmVzcG9uc2VcIjogSW52YWxpZCBzdGF0dXMgY29kZScpLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJFNTI5XCIsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbml0T2JqID0gdHlwZW9mIGluaXQgPT09ICdvYmplY3QnID8gaW5pdCA6IHt9O1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdE9iaiA9PSBudWxsID8gdm9pZCAwIDogaW5pdE9iai5oZWFkZXJzKTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ0xvY2F0aW9uJywgKDAsIF91dGlscy52YWxpZGF0ZVVSTCkodXJsKSk7XG4gICAgICAgIHJldHVybiBuZXcgTmV4dFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgICAgIC4uLmluaXRPYmosXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgcmV3cml0ZShkZXN0aW5hdGlvbiwgaW5pdCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzKTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ3gtbWlkZGxld2FyZS1yZXdyaXRlJywgKDAsIF91dGlscy52YWxpZGF0ZVVSTCkoZGVzdGluYXRpb24pKTtcbiAgICAgICAgaGFuZGxlTWlkZGxld2FyZUZpZWxkKGluaXQsIGhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gbmV3IE5leHRSZXNwb25zZShudWxsLCB7XG4gICAgICAgICAgICAuLi5pbml0LFxuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIG5leHQoaW5pdCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzKTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ3gtbWlkZGxld2FyZS1uZXh0JywgJzEnKTtcbiAgICAgICAgaGFuZGxlTWlkZGxld2FyZUZpZWxkKGluaXQsIGhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gbmV3IE5leHRSZXNwb25zZShudWxsLCB7XG4gICAgICAgICAgICAuLi5pbml0LFxuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc3BvbnNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/web/spec-extension/response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/web/spec-extension/url-pattern.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/url-pattern.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"URLPattern\", ({\n    enumerable: true,\n    get: function() {\n        return GlobalURLPattern;\n    }\n}));\nconst GlobalURLPattern = // @ts-expect-error: URLPattern is not available in Node.js\ntypeof URLPattern === 'undefined' ? undefined : URLPattern;\n\n//# sourceMappingURL=url-pattern.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vdXJsLXBhdHRlcm4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiw4Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRjtBQUNBOztBQUVBIiwic291cmNlcyI6WyJFOlxcQnRlY2ggNHRoIHNlbVxcbWluaSBwcm9qZWN0XFxNaW5pIHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFx3ZWJcXHNwZWMtZXh0ZW5zaW9uXFx1cmwtcGF0dGVybi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVSTFBhdHRlcm5cIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEdsb2JhbFVSTFBhdHRlcm47XG4gICAgfVxufSk7XG5jb25zdCBHbG9iYWxVUkxQYXR0ZXJuID0gLy8gQHRzLWV4cGVjdC1lcnJvcjogVVJMUGF0dGVybiBpcyBub3QgYXZhaWxhYmxlIGluIE5vZGUuanNcbnR5cGVvZiBVUkxQYXR0ZXJuID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVSTFBhdHRlcm47XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybC1wYXR0ZXJuLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/web/spec-extension/url-pattern.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/web/spec-extension/user-agent.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/user-agent.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isBot: function() {\n        return isBot;\n    },\n    userAgent: function() {\n        return userAgent;\n    },\n    userAgentFromString: function() {\n        return userAgentFromString;\n    }\n});\nconst _uaparserjs = /*#__PURE__*/ _interop_require_default(__webpack_require__(/*! next/dist/compiled/ua-parser-js */ \"(rsc)/./node_modules/next/dist/compiled/ua-parser-js/ua-parser.js\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction isBot(input) {\n    return /Googlebot|Mediapartners-Google|AdsBot-Google|googleweblight|Storebot-Google|Google-PageRenderer|Google-InspectionTool|Bingbot|BingPreview|Slurp|DuckDuckBot|baiduspider|yandex|sogou|LinkedInBot|bitlybot|tumblr|vkShare|quora link preview|facebookexternalhit|facebookcatalog|Twitterbot|applebot|redditbot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|ia_archiver/i.test(input);\n}\nfunction userAgentFromString(input) {\n    return {\n        ...(0, _uaparserjs.default)(input),\n        isBot: input === undefined ? false : isBot(input)\n    };\n}\nfunction userAgent({ headers }) {\n    return userAgentFromString(headers.get('user-agent') || undefined);\n}\n\n//# sourceMappingURL=user-agent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vdXNlci1hZ2VudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLE1BQU0sQ0FJTDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDJEQUEyRCxtQkFBTyxDQUFDLDBHQUFpQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxcd2ViXFxzcGVjLWV4dGVuc2lvblxcdXNlci1hZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlzQm90OiBudWxsLFxuICAgIHVzZXJBZ2VudDogbnVsbCxcbiAgICB1c2VyQWdlbnRGcm9tU3RyaW5nOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGlzQm90OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzQm90O1xuICAgIH0sXG4gICAgdXNlckFnZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJBZ2VudDtcbiAgICB9LFxuICAgIHVzZXJBZ2VudEZyb21TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlckFnZW50RnJvbVN0cmluZztcbiAgICB9XG59KTtcbmNvbnN0IF91YXBhcnNlcmpzID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC91YS1wYXJzZXItanNcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBpc0JvdChpbnB1dCkge1xuICAgIHJldHVybiAvR29vZ2xlYm90fE1lZGlhcGFydG5lcnMtR29vZ2xlfEFkc0JvdC1Hb29nbGV8Z29vZ2xld2VibGlnaHR8U3RvcmVib3QtR29vZ2xlfEdvb2dsZS1QYWdlUmVuZGVyZXJ8R29vZ2xlLUluc3BlY3Rpb25Ub29sfEJpbmdib3R8QmluZ1ByZXZpZXd8U2x1cnB8RHVja0R1Y2tCb3R8YmFpZHVzcGlkZXJ8eWFuZGV4fHNvZ291fExpbmtlZEluQm90fGJpdGx5Ym90fHR1bWJscnx2a1NoYXJlfHF1b3JhIGxpbmsgcHJldmlld3xmYWNlYm9va2V4dGVybmFsaGl0fGZhY2Vib29rY2F0YWxvZ3xUd2l0dGVyYm90fGFwcGxlYm90fHJlZGRpdGJvdHxTbGFja2JvdHxEaXNjb3JkYm90fFdoYXRzQXBwfFNreXBlVXJpUHJldmlld3xpYV9hcmNoaXZlci9pLnRlc3QoaW5wdXQpO1xufVxuZnVuY3Rpb24gdXNlckFnZW50RnJvbVN0cmluZyhpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLigwLCBfdWFwYXJzZXJqcy5kZWZhdWx0KShpbnB1dCksXG4gICAgICAgIGlzQm90OiBpbnB1dCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBpc0JvdChpbnB1dClcbiAgICB9O1xufVxuZnVuY3Rpb24gdXNlckFnZW50KHsgaGVhZGVycyB9KSB7XG4gICAgcmV0dXJuIHVzZXJBZ2VudEZyb21TdHJpbmcoaGVhZGVycy5nZXQoJ3VzZXItYWdlbnQnKSB8fCB1bmRlZmluZWQpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VyLWFnZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/web/spec-extension/user-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/server/web/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/server/web/utils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    fromNodeOutgoingHttpHeaders: function() {\n        return fromNodeOutgoingHttpHeaders;\n    },\n    normalizeNextQueryParam: function() {\n        return normalizeNextQueryParam;\n    },\n    splitCookiesString: function() {\n        return splitCookiesString;\n    },\n    toNodeOutgoingHttpHeaders: function() {\n        return toNodeOutgoingHttpHeaders;\n    },\n    validateURL: function() {\n        return validateURL;\n    }\n});\nconst _constants = __webpack_require__(/*! ../../lib/constants */ \"(rsc)/./node_modules/next/dist/lib/constants.js\");\nfunction fromNodeOutgoingHttpHeaders(nodeHeaders) {\n    const headers = new Headers();\n    for (let [key, value] of Object.entries(nodeHeaders)){\n        const values = Array.isArray(value) ? value : [\n            value\n        ];\n        for (let v of values){\n            if (typeof v === 'undefined') continue;\n            if (typeof v === 'number') {\n                v = v.toString();\n            }\n            headers.append(key, v);\n        }\n    }\n    return headers;\n}\nfunction splitCookiesString(cookiesString) {\n    var cookiesStrings = [];\n    var pos = 0;\n    var start;\n    var ch;\n    var lastComma;\n    var nextStart;\n    var cookiesSeparatorFound;\n    function skipWhitespace() {\n        while(pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))){\n            pos += 1;\n        }\n        return pos < cookiesString.length;\n    }\n    function notSpecialChar() {\n        ch = cookiesString.charAt(pos);\n        return ch !== '=' && ch !== ';' && ch !== ',';\n    }\n    while(pos < cookiesString.length){\n        start = pos;\n        cookiesSeparatorFound = false;\n        while(skipWhitespace()){\n            ch = cookiesString.charAt(pos);\n            if (ch === ',') {\n                // ',' is a cookie separator if we have later first '=', not ';' or ','\n                lastComma = pos;\n                pos += 1;\n                skipWhitespace();\n                nextStart = pos;\n                while(pos < cookiesString.length && notSpecialChar()){\n                    pos += 1;\n                }\n                // currently special character\n                if (pos < cookiesString.length && cookiesString.charAt(pos) === '=') {\n                    // we found cookies separator\n                    cookiesSeparatorFound = true;\n                    // pos is inside the next cookie, so back up and return it.\n                    pos = nextStart;\n                    cookiesStrings.push(cookiesString.substring(start, lastComma));\n                    start = pos;\n                } else {\n                    // in param ',' or param separator ';',\n                    // we continue from that comma\n                    pos = lastComma + 1;\n                }\n            } else {\n                pos += 1;\n            }\n        }\n        if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n        }\n    }\n    return cookiesStrings;\n}\nfunction toNodeOutgoingHttpHeaders(headers) {\n    const nodeHeaders = {};\n    const cookies = [];\n    if (headers) {\n        for (const [key, value] of headers.entries()){\n            if (key.toLowerCase() === 'set-cookie') {\n                // We may have gotten a comma joined string of cookies, or multiple\n                // set-cookie headers. We need to merge them into one header array\n                // to represent all the cookies.\n                cookies.push(...splitCookiesString(value));\n                nodeHeaders[key] = cookies.length === 1 ? cookies[0] : cookies;\n            } else {\n                nodeHeaders[key] = value;\n            }\n        }\n    }\n    return nodeHeaders;\n}\nfunction validateURL(url) {\n    try {\n        return String(new URL(String(url)));\n    } catch (error) {\n        throw Object.defineProperty(new Error(`URL is malformed \"${String(url)}\". Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`, {\n            cause: error\n        }), \"__NEXT_ERROR_CODE\", {\n            value: \"E61\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nfunction normalizeNextQueryParam(key) {\n    const prefixes = [\n        _constants.NEXT_QUERY_PARAM_PREFIX,\n        _constants.NEXT_INTERCEPTION_MARKER_PREFIX\n    ];\n    for (const prefix of prefixes){\n        if (key !== prefix && key.startsWith(prefix)) {\n            return key.substring(prefix.length);\n        }\n    }\n    return null;\n}\n\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixNQUFNLENBTUw7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsNEVBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUVBQW1FLFlBQVk7QUFDL0U7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkU6XFxCdGVjaCA0dGggc2VtXFxtaW5pIHByb2plY3RcXE1pbmkgcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxzZXJ2ZXJcXHdlYlxcdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBmcm9tTm9kZU91dGdvaW5nSHR0cEhlYWRlcnM6IG51bGwsXG4gICAgbm9ybWFsaXplTmV4dFF1ZXJ5UGFyYW06IG51bGwsXG4gICAgc3BsaXRDb29raWVzU3RyaW5nOiBudWxsLFxuICAgIHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnM6IG51bGwsXG4gICAgdmFsaWRhdGVVUkw6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZnJvbU5vZGVPdXRnb2luZ0h0dHBIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycztcbiAgICB9LFxuICAgIG5vcm1hbGl6ZU5leHRRdWVyeVBhcmFtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZU5leHRRdWVyeVBhcmFtO1xuICAgIH0sXG4gICAgc3BsaXRDb29raWVzU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNwbGl0Q29va2llc1N0cmluZztcbiAgICB9LFxuICAgIHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycztcbiAgICB9LFxuICAgIHZhbGlkYXRlVVJMOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlVVJMO1xuICAgIH1cbn0pO1xuY29uc3QgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi8uLi9saWIvY29uc3RhbnRzXCIpO1xuZnVuY3Rpb24gZnJvbU5vZGVPdXRnb2luZ0h0dHBIZWFkZXJzKG5vZGVIZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGVIZWFkZXJzKSl7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGxldCB2IG9mIHZhbHVlcyl7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT09ICd1bmRlZmluZWQnKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB2ID0gdi50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIHNwbGl0Q29va2llc1N0cmluZyhjb29raWVzU3RyaW5nKSB7XG4gICAgdmFyIGNvb2tpZXNTdHJpbmdzID0gW107XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBjaDtcbiAgICB2YXIgbGFzdENvbW1hO1xuICAgIHZhciBuZXh0U3RhcnQ7XG4gICAgdmFyIGNvb2tpZXNTZXBhcmF0b3JGb3VuZDtcbiAgICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICAgICAgd2hpbGUocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgL1xccy8udGVzdChjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpKSl7XG4gICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zIDwgY29va2llc1N0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vdFNwZWNpYWxDaGFyKCkge1xuICAgICAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICAgIHJldHVybiBjaCAhPT0gJz0nICYmIGNoICE9PSAnOycgJiYgY2ggIT09ICcsJztcbiAgICB9XG4gICAgd2hpbGUocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGgpe1xuICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gZmFsc2U7XG4gICAgICAgIHdoaWxlKHNraXBXaGl0ZXNwYWNlKCkpe1xuICAgICAgICAgICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICAvLyAnLCcgaXMgYSBjb29raWUgc2VwYXJhdG9yIGlmIHdlIGhhdmUgbGF0ZXIgZmlyc3QgJz0nLCBub3QgJzsnIG9yICcsJ1xuICAgICAgICAgICAgICAgIGxhc3RDb21tYSA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIG5leHRTdGFydCA9IHBvcztcbiAgICAgICAgICAgICAgICB3aGlsZShwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBub3RTcGVjaWFsQ2hhcigpKXtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRseSBzcGVjaWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGlmIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZm91bmQgY29va2llcyBzZXBhcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9zIGlzIGluc2lkZSB0aGUgbmV4dCBjb29raWUsIHNvIGJhY2sgdXAgYW5kIHJldHVybiBpdC5cbiAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBsYXN0Q29tbWEpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gcGFyYW0gJywnIG9yIHBhcmFtIHNlcGFyYXRvciAnOycsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNvbnRpbnVlIGZyb20gdGhhdCBjb21tYVxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBsYXN0Q29tbWEgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb29raWVzU2VwYXJhdG9yRm91bmQgfHwgcG9zID49IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBjb29raWVzU3RyaW5nLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb29raWVzU3RyaW5ncztcbn1cbmZ1bmN0aW9uIHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMoaGVhZGVycykge1xuICAgIGNvbnN0IG5vZGVIZWFkZXJzID0ge307XG4gICAgY29uc3QgY29va2llcyA9IFtdO1xuICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGhlYWRlcnMuZW50cmllcygpKXtcbiAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbWF5IGhhdmUgZ290dGVuIGEgY29tbWEgam9pbmVkIHN0cmluZyBvZiBjb29raWVzLCBvciBtdWx0aXBsZVxuICAgICAgICAgICAgICAgIC8vIHNldC1jb29raWUgaGVhZGVycy4gV2UgbmVlZCB0byBtZXJnZSB0aGVtIGludG8gb25lIGhlYWRlciBhcnJheVxuICAgICAgICAgICAgICAgIC8vIHRvIHJlcHJlc2VudCBhbGwgdGhlIGNvb2tpZXMuXG4gICAgICAgICAgICAgICAgY29va2llcy5wdXNoKC4uLnNwbGl0Q29va2llc1N0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIG5vZGVIZWFkZXJzW2tleV0gPSBjb29raWVzLmxlbmd0aCA9PT0gMSA/IGNvb2tpZXNbMF0gOiBjb29raWVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlSGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVIZWFkZXJzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVVUkwodXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhuZXcgVVJMKFN0cmluZyh1cmwpKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcihgVVJMIGlzIG1hbGZvcm1lZCBcIiR7U3RyaW5nKHVybCl9XCIuIFBsZWFzZSB1c2Ugb25seSBhYnNvbHV0ZSBVUkxzIC0gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1yZWxhdGl2ZS11cmxzYCwge1xuICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgIH0pLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBcIkU2MVwiLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplTmV4dFF1ZXJ5UGFyYW0oa2V5KSB7XG4gICAgY29uc3QgcHJlZml4ZXMgPSBbXG4gICAgICAgIF9jb25zdGFudHMuTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVgsXG4gICAgICAgIF9jb25zdGFudHMuTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWFxuICAgIF07XG4gICAgZm9yIChjb25zdCBwcmVmaXggb2YgcHJlZml4ZXMpe1xuICAgICAgICBpZiAoa2V5ICE9PSBwcmVmaXggJiYga2V5LnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/server/web/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/get-hostname.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/get-hostname.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getHostname\", ({\n    enumerable: true,\n    get: function() {\n        return getHostname;\n    }\n}));\nfunction getHostname(parsed, headers) {\n    // Get the hostname from the headers if it exists, otherwise use the parsed\n    // hostname.\n    let hostname;\n    if ((headers == null ? void 0 : headers.host) && !Array.isArray(headers.host)) {\n        hostname = headers.host.toString().split(':', 1)[0];\n    } else if (parsed.hostname) {\n        hostname = parsed.hostname;\n    } else return;\n    return hostname.toLowerCase();\n} //# sourceMappingURL=get-hostname.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvZ2V0LWhvc3RuYW1lLmpzIiwibWFwcGluZ3MiOiI7Ozs7K0NBUWdCQTs7O2VBQUFBOzs7QUFBVCxTQUFTQSxZQUNkQyxNQUFvQyxFQUNwQ0MsT0FBNkI7SUFFN0IsMkVBQTJFO0lBQzNFLFlBQVk7SUFDWixJQUFJQztJQUNKLElBQUlELENBQUFBLFdBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFFBQVNFLElBQUFBLEtBQVEsQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSixRQUFRRSxJQUFJLEdBQUc7UUFDakRELFdBQVdELFFBQVFFLElBQUksQ0FBQ0csUUFBUSxHQUFHQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRTtJQUNyRCxPQUFPLElBQUlQLE9BQU9FLFFBQVEsRUFBRTtRQUMxQkEsV0FBV0YsT0FBT0UsUUFBUTtJQUM1QixPQUFPO0lBRVAsT0FBT0EsU0FBU00sV0FBVztBQUM3QiIsInNvdXJjZXMiOlsiRTpcXHNyY1xcc2hhcmVkXFxsaWJcXGdldC1ob3N0bmFtZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE91dGdvaW5nSHR0cEhlYWRlcnMgfSBmcm9tICdodHRwJ1xuXG4vKipcbiAqIFRha2VzIGFuIG9iamVjdCB3aXRoIGEgaG9zdG5hbWUgcHJvcGVydHkgKGxpa2UgYSBwYXJzZWQgVVJMKSBhbmQgc29tZVxuICogaGVhZGVycyB0aGF0IG1heSBjb250YWluIEhvc3QgYW5kIHJldHVybnMgdGhlIHByZWZlcnJlZCBob3N0bmFtZS5cbiAqIEBwYXJhbSBwYXJzZWQgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBob3N0bmFtZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSBoZWFkZXJzIEEgZGljdGlvbmFyeSB3aXRoIGhlYWRlcnMgY29udGFpbmluZyBhIGBob3N0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvc3RuYW1lKFxuICBwYXJzZWQ6IHsgaG9zdG5hbWU/OiBzdHJpbmcgfCBudWxsIH0sXG4gIGhlYWRlcnM/OiBPdXRnb2luZ0h0dHBIZWFkZXJzXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAvLyBHZXQgdGhlIGhvc3RuYW1lIGZyb20gdGhlIGhlYWRlcnMgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgdXNlIHRoZSBwYXJzZWRcbiAgLy8gaG9zdG5hbWUuXG4gIGxldCBob3N0bmFtZTogc3RyaW5nXG4gIGlmIChoZWFkZXJzPy5ob3N0ICYmICFBcnJheS5pc0FycmF5KGhlYWRlcnMuaG9zdCkpIHtcbiAgICBob3N0bmFtZSA9IGhlYWRlcnMuaG9zdC50b1N0cmluZygpLnNwbGl0KCc6JywgMSlbMF1cbiAgfSBlbHNlIGlmIChwYXJzZWQuaG9zdG5hbWUpIHtcbiAgICBob3N0bmFtZSA9IHBhcnNlZC5ob3N0bmFtZVxuICB9IGVsc2UgcmV0dXJuXG5cbiAgcmV0dXJuIGhvc3RuYW1lLnRvTG93ZXJDYXNlKClcbn1cbiJdLCJuYW1lcyI6WyJnZXRIb3N0bmFtZSIsInBhcnNlZCIsImhlYWRlcnMiLCJob3N0bmFtZSIsImhvc3QiLCJBcnJheSIsImlzQXJyYXkiLCJ0b1N0cmluZyIsInNwbGl0IiwidG9Mb3dlckNhc2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/get-hostname.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"detectDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return detectDomainLocale;\n    }\n}));\nfunction detectDomainLocale(domainItems, hostname, detectedLocale) {\n    if (!domainItems) return;\n    if (detectedLocale) {\n        detectedLocale = detectedLocale.toLowerCase();\n    }\n    for (const item of domainItems){\n        var _item_domain, _item_locales;\n        // remove port if present\n        const domainHostname = (_item_domain = item.domain) == null ? void 0 : _item_domain.split(':', 1)[0].toLowerCase();\n        if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || ((_item_locales = item.locales) == null ? void 0 : _item_locales.some((locale)=>locale.toLowerCase() === detectedLocale))) {\n            return item;\n        }\n    }\n} //# sourceMappingURL=detect-domain-locale.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQUVnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsbUJBQ2RDLFdBQXFDLEVBQ3JDQyxRQUFpQixFQUNqQkMsY0FBdUI7SUFFdkIsSUFBSSxDQUFDRixhQUFhO0lBRWxCLElBQUlFLGdCQUFnQjtRQUNsQkEsaUJBQWlCQSxlQUFlQyxXQUFXO0lBQzdDO0lBRUEsS0FBSyxNQUFNQyxRQUFRSixZQUFhO1lBRVBJLGNBSXJCQTtRQUxGLHlCQUF5QjtRQUN6QixNQUFNQyxpQkFBQUEsQ0FBaUJELGVBQUFBLEtBQUtFLE1BQUFBLEtBQU0sZ0JBQVhGLGFBQWFHLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUNKLFdBQVc7UUFDaEUsSUFDRUYsYUFBYUksa0JBQ2JILG1CQUFtQkUsS0FBS0ksYUFBYSxDQUFDTCxXQUFXLFFBQ2pEQyxnQkFBQUEsS0FBS0ssT0FBQUEsS0FBTyxnQkFBWkwsY0FBY00sSUFBSSxDQUFDLENBQUNDLFNBQVdBLE9BQU9SLFdBQVcsT0FBT0QsZUFBQUEsR0FDeEQ7WUFDQSxPQUFPRTtRQUNUO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiRTpcXHNyY1xcc2hhcmVkXFxsaWJcXGkxOG5cXGRldGVjdC1kb21haW4tbG9jYWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRG9tYWluTG9jYWxlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2NvbmZpZy1zaGFyZWQnXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3REb21haW5Mb2NhbGUoXG4gIGRvbWFpbkl0ZW1zPzogcmVhZG9ubHkgRG9tYWluTG9jYWxlW10sXG4gIGhvc3RuYW1lPzogc3RyaW5nLFxuICBkZXRlY3RlZExvY2FsZT86IHN0cmluZ1xuKSB7XG4gIGlmICghZG9tYWluSXRlbXMpIHJldHVyblxuXG4gIGlmIChkZXRlY3RlZExvY2FsZSkge1xuICAgIGRldGVjdGVkTG9jYWxlID0gZGV0ZWN0ZWRMb2NhbGUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZm9yIChjb25zdCBpdGVtIG9mIGRvbWFpbkl0ZW1zKSB7XG4gICAgLy8gcmVtb3ZlIHBvcnQgaWYgcHJlc2VudFxuICAgIGNvbnN0IGRvbWFpbkhvc3RuYW1lID0gaXRlbS5kb21haW4/LnNwbGl0KCc6JywgMSlbMF0udG9Mb3dlckNhc2UoKVxuICAgIGlmIChcbiAgICAgIGhvc3RuYW1lID09PSBkb21haW5Ib3N0bmFtZSB8fFxuICAgICAgZGV0ZWN0ZWRMb2NhbGUgPT09IGl0ZW0uZGVmYXVsdExvY2FsZS50b0xvd2VyQ2FzZSgpIHx8XG4gICAgICBpdGVtLmxvY2FsZXM/LnNvbWUoKGxvY2FsZSkgPT4gbG9jYWxlLnRvTG93ZXJDYXNlKCkgPT09IGRldGVjdGVkTG9jYWxlKVxuICAgICkge1xuICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJkZXRlY3REb21haW5Mb2NhbGUiLCJkb21haW5JdGVtcyIsImhvc3RuYW1lIiwiZGV0ZWN0ZWRMb2NhbGUiLCJ0b0xvd2VyQ2FzZSIsIml0ZW0iLCJkb21haW5Ib3N0bmFtZSIsImRvbWFpbiIsInNwbGl0IiwiZGVmYXVsdExvY2FsZSIsImxvY2FsZXMiLCJzb21lIiwibG9jYWxlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"normalizeLocalePath\", ({\n    enumerable: true,\n    get: function() {\n        return normalizeLocalePath;\n    }\n}));\n/**\n * A cache of lowercased locales for each list of locales. This is stored as a\n * WeakMap so if the locales are garbage collected, the cache entry will be\n * removed as well.\n */ const cache = new WeakMap();\nfunction normalizeLocalePath(pathname, locales) {\n    // If locales is undefined, return the pathname as is.\n    if (!locales) return {\n        pathname\n    };\n    // Get the cached lowercased locales or create a new cache entry.\n    let lowercasedLocales = cache.get(locales);\n    if (!lowercasedLocales) {\n        lowercasedLocales = locales.map((locale)=>locale.toLowerCase());\n        cache.set(locales, lowercasedLocales);\n    }\n    let detectedLocale;\n    // The first segment will be empty, because it has a leading `/`. If\n    // there is no further segment, there is no locale (or it's the default).\n    const segments = pathname.split('/', 2);\n    // If there's no second segment (ie, the pathname is just `/`), there's no\n    // locale.\n    if (!segments[1]) return {\n        pathname\n    };\n    // The second segment will contain the locale part if any.\n    const segment = segments[1].toLowerCase();\n    // See if the segment matches one of the locales. If it doesn't, there is\n    // no locale (or it's the default).\n    const index = lowercasedLocales.indexOf(segment);\n    if (index < 0) return {\n        pathname\n    };\n    // Return the case-sensitive locale.\n    detectedLocale = locales[index];\n    // Remove the `/${locale}` part of the pathname.\n    pathname = pathname.slice(detectedLocale.length + 1) || '/';\n    return {\n        pathname,\n        detectedLocale\n    };\n} //# sourceMappingURL=normalize-locale-path.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGguanMiLCJtYXBwaW5ncyI6Ijs7Ozt1REFxQmdCQTs7O2VBQUFBOzs7QUFoQmhCOzs7O0NBSUMsR0FDRCxNQUFNQyxRQUFRLElBQUlDO0FBV1gsU0FBU0Ysb0JBQ2RHLFFBQWdCLEVBQ2hCQyxPQUEyQjtJQUUzQixzREFBc0Q7SUFDdEQsSUFBSSxDQUFDQSxTQUFTLE9BQU87UUFBRUQ7SUFBUztJQUVoQyxpRUFBaUU7SUFDakUsSUFBSUUsb0JBQW9CSixNQUFNSyxHQUFHLENBQUNGO0lBQ2xDLElBQUksQ0FBQ0MsbUJBQW1CO1FBQ3RCQSxvQkFBb0JELFFBQVFHLEdBQUcsQ0FBQyxDQUFDQyxTQUFXQSxPQUFPQyxXQUFXO1FBQzlEUixNQUFNUyxHQUFHLENBQUNOLFNBQVNDO0lBQ3JCO0lBRUEsSUFBSU07SUFFSixvRUFBb0U7SUFDcEUseUVBQXlFO0lBQ3pFLE1BQU1DLFdBQVdULFNBQVNVLEtBQUssQ0FBQyxLQUFLO0lBRXJDLDBFQUEwRTtJQUMxRSxVQUFVO0lBQ1YsSUFBSSxDQUFDRCxRQUFRLENBQUMsRUFBRSxFQUFFLE9BQU87UUFBRVQ7SUFBUztJQUVwQywwREFBMEQ7SUFDMUQsTUFBTVcsVUFBVUYsUUFBUSxDQUFDLEVBQUUsQ0FBQ0gsV0FBVztJQUV2Qyx5RUFBeUU7SUFDekUsbUNBQW1DO0lBQ25DLE1BQU1NLFFBQVFWLGtCQUFrQlcsT0FBTyxDQUFDRjtJQUN4QyxJQUFJQyxRQUFRLEdBQUcsT0FBTztRQUFFWjtJQUFTO0lBRWpDLG9DQUFvQztJQUNwQ1EsaUJBQWlCUCxPQUFPLENBQUNXLE1BQU07SUFFL0IsZ0RBQWdEO0lBQ2hEWixXQUFXQSxTQUFTYyxLQUFLLENBQUNOLGVBQWVPLE1BQU0sR0FBRyxNQUFNO0lBRXhELE9BQU87UUFBRWY7UUFBVVE7SUFBZTtBQUNwQyIsInNvdXJjZXMiOlsiRTpcXHNyY1xcc2hhcmVkXFxsaWJcXGkxOG5cXG5vcm1hbGl6ZS1sb2NhbGUtcGF0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFBhdGhMb2NhbGUge1xuICBkZXRlY3RlZExvY2FsZT86IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG59XG5cbi8qKlxuICogQSBjYWNoZSBvZiBsb3dlcmNhc2VkIGxvY2FsZXMgZm9yIGVhY2ggbGlzdCBvZiBsb2NhbGVzLiBUaGlzIGlzIHN0b3JlZCBhcyBhXG4gKiBXZWFrTWFwIHNvIGlmIHRoZSBsb2NhbGVzIGFyZSBnYXJiYWdlIGNvbGxlY3RlZCwgdGhlIGNhY2hlIGVudHJ5IHdpbGwgYmVcbiAqIHJlbW92ZWQgYXMgd2VsbC5cbiAqL1xuY29uc3QgY2FjaGUgPSBuZXcgV2Vha01hcDxyZWFkb25seSBzdHJpbmdbXSwgcmVhZG9ubHkgc3RyaW5nW10+KClcblxuLyoqXG4gKiBGb3IgYSBwYXRobmFtZSB0aGF0IG1heSBpbmNsdWRlIGEgbG9jYWxlIGZyb20gYSBsaXN0IG9mIGxvY2FsZXMsIGl0XG4gKiByZW1vdmVzIHRoZSBsb2NhbGUgZnJvbSB0aGUgcGF0aG5hbWUgcmV0dXJuaW5nIGl0IGFsb25nc2lkZSB3aXRoIHRoZVxuICogZGV0ZWN0ZWQgbG9jYWxlLlxuICpcbiAqIEBwYXJhbSBwYXRobmFtZSBBIHBhdGhuYW1lIHRoYXQgbWF5IGluY2x1ZGUgYSBsb2NhbGUuXG4gKiBAcGFyYW0gbG9jYWxlcyBBIGxpc3Qgb2YgbG9jYWxlcy5cbiAqIEByZXR1cm5zIFRoZSBkZXRlY3RlZCBsb2NhbGUgYW5kIHBhdGhuYW1lIHdpdGhvdXQgbG9jYWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGVQYXRoKFxuICBwYXRobmFtZTogc3RyaW5nLFxuICBsb2NhbGVzPzogcmVhZG9ubHkgc3RyaW5nW11cbik6IFBhdGhMb2NhbGUge1xuICAvLyBJZiBsb2NhbGVzIGlzIHVuZGVmaW5lZCwgcmV0dXJuIHRoZSBwYXRobmFtZSBhcyBpcy5cbiAgaWYgKCFsb2NhbGVzKSByZXR1cm4geyBwYXRobmFtZSB9XG5cbiAgLy8gR2V0IHRoZSBjYWNoZWQgbG93ZXJjYXNlZCBsb2NhbGVzIG9yIGNyZWF0ZSBhIG5ldyBjYWNoZSBlbnRyeS5cbiAgbGV0IGxvd2VyY2FzZWRMb2NhbGVzID0gY2FjaGUuZ2V0KGxvY2FsZXMpXG4gIGlmICghbG93ZXJjYXNlZExvY2FsZXMpIHtcbiAgICBsb3dlcmNhc2VkTG9jYWxlcyA9IGxvY2FsZXMubWFwKChsb2NhbGUpID0+IGxvY2FsZS50b0xvd2VyQ2FzZSgpKVxuICAgIGNhY2hlLnNldChsb2NhbGVzLCBsb3dlcmNhc2VkTG9jYWxlcylcbiAgfVxuXG4gIGxldCBkZXRlY3RlZExvY2FsZTogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgLy8gVGhlIGZpcnN0IHNlZ21lbnQgd2lsbCBiZSBlbXB0eSwgYmVjYXVzZSBpdCBoYXMgYSBsZWFkaW5nIGAvYC4gSWZcbiAgLy8gdGhlcmUgaXMgbm8gZnVydGhlciBzZWdtZW50LCB0aGVyZSBpcyBubyBsb2NhbGUgKG9yIGl0J3MgdGhlIGRlZmF1bHQpLlxuICBjb25zdCBzZWdtZW50cyA9IHBhdGhuYW1lLnNwbGl0KCcvJywgMilcblxuICAvLyBJZiB0aGVyZSdzIG5vIHNlY29uZCBzZWdtZW50IChpZSwgdGhlIHBhdGhuYW1lIGlzIGp1c3QgYC9gKSwgdGhlcmUncyBub1xuICAvLyBsb2NhbGUuXG4gIGlmICghc2VnbWVudHNbMV0pIHJldHVybiB7IHBhdGhuYW1lIH1cblxuICAvLyBUaGUgc2Vjb25kIHNlZ21lbnQgd2lsbCBjb250YWluIHRoZSBsb2NhbGUgcGFydCBpZiBhbnkuXG4gIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1sxXS50b0xvd2VyQ2FzZSgpXG5cbiAgLy8gU2VlIGlmIHRoZSBzZWdtZW50IG1hdGNoZXMgb25lIG9mIHRoZSBsb2NhbGVzLiBJZiBpdCBkb2Vzbid0LCB0aGVyZSBpc1xuICAvLyBubyBsb2NhbGUgKG9yIGl0J3MgdGhlIGRlZmF1bHQpLlxuICBjb25zdCBpbmRleCA9IGxvd2VyY2FzZWRMb2NhbGVzLmluZGV4T2Yoc2VnbWVudClcbiAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIHsgcGF0aG5hbWUgfVxuXG4gIC8vIFJldHVybiB0aGUgY2FzZS1zZW5zaXRpdmUgbG9jYWxlLlxuICBkZXRlY3RlZExvY2FsZSA9IGxvY2FsZXNbaW5kZXhdXG5cbiAgLy8gUmVtb3ZlIHRoZSBgLyR7bG9jYWxlfWAgcGFydCBvZiB0aGUgcGF0aG5hbWUuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUuc2xpY2UoZGV0ZWN0ZWRMb2NhbGUubGVuZ3RoICsgMSkgfHwgJy8nXG5cbiAgcmV0dXJuIHsgcGF0aG5hbWUsIGRldGVjdGVkTG9jYWxlIH1cbn1cbiJdLCJuYW1lcyI6WyJub3JtYWxpemVMb2NhbGVQYXRoIiwiY2FjaGUiLCJXZWFrTWFwIiwicGF0aG5hbWUiLCJsb2NhbGVzIiwibG93ZXJjYXNlZExvY2FsZXMiLCJnZXQiLCJtYXAiLCJsb2NhbGUiLCJ0b0xvd2VyQ2FzZSIsInNldCIsImRldGVjdGVkTG9jYWxlIiwic2VnbWVudHMiLCJzcGxpdCIsInNlZ21lbnQiLCJpbmRleCIsImluZGV4T2YiLCJzbGljZSIsImxlbmd0aCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/invariant-error.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/invariant-error.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"InvariantError\", ({\n    enumerable: true,\n    get: function() {\n        return InvariantError;\n    }\n}));\nclass InvariantError extends Error {\n    constructor(message, options){\n        super(\"Invariant: \" + (message.endsWith('.') ? message : message + '.') + \" This is a bug in Next.js.\", options);\n        this.name = 'InvariantError';\n    }\n} //# sourceMappingURL=invariant-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7a0RBQWFBOzs7ZUFBQUE7OztBQUFOLE1BQU1BLHVCQUF1QkM7SUFDbENDLFlBQVlDLE9BQWUsRUFBRUMsT0FBc0IsQ0FBRTtRQUNuRCxLQUFLLENBQ0YsZ0JBQWFELENBQUFBLFFBQVFFLFFBQVEsQ0FBQyxPQUFPRixVQUFVQSxVQUFVLElBQUUsR0FBRSw4QkFDOURDO1FBRUYsSUFBSSxDQUFDRSxJQUFJLEdBQUc7SUFDZDtBQUNGIiwic291cmNlcyI6WyJFOlxcc3JjXFxzaGFyZWRcXGxpYlxcaW52YXJpYW50LWVycm9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBJbnZhcmlhbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBvcHRpb25zPzogRXJyb3JPcHRpb25zKSB7XG4gICAgc3VwZXIoXG4gICAgICBgSW52YXJpYW50OiAke21lc3NhZ2UuZW5kc1dpdGgoJy4nKSA/IG1lc3NhZ2UgOiBtZXNzYWdlICsgJy4nfSBUaGlzIGlzIGEgYnVnIGluIE5leHQuanMuYCxcbiAgICAgIG9wdGlvbnNcbiAgICApXG4gICAgdGhpcy5uYW1lID0gJ0ludmFyaWFudEVycm9yJ1xuICB9XG59XG4iXSwibmFtZXMiOlsiSW52YXJpYW50RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm9wdGlvbnMiLCJlbmRzV2l0aCIsIm5hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/invariant-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/is-thenable.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/is-thenable.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isThenable\", ({\n    enumerable: true,\n    get: function() {\n        return isThenable;\n    }\n}));\nfunction isThenable(promise) {\n    return promise !== null && typeof promise === 'object' && 'then' in promise && typeof promise.then === 'function';\n} //# sourceMappingURL=is-thenable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaXMtdGhlbmFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7Ozs7OENBQ2VBOzs7ZUFBQUE7OztBQUFULFNBQVNBLFdBQ2RDLE9BQXVCO0lBRXZCLE9BQ0VBLFlBQVksUUFDWixPQUFPQSxZQUFZLFlBQ25CLFVBQVVBLFdBQ1YsT0FBT0EsUUFBUUMsSUFBSSxLQUFLO0FBRTVCIiwic291cmNlcyI6WyJFOlxcc3JjXFxzaGFyZWRcXGxpYlxcaXMtdGhlbmFibGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgYSB2YWx1ZSBpcyBUaGVuYWJsZS5cbiAqXG4gKiBAcGFyYW0gcHJvbWlzZSB0aGUgbWF5YmUtdGhlbmFibGUgdmFsdWVcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIHRoZW5hYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1RoZW5hYmxlPFQgPSB1bmtub3duPihcbiAgcHJvbWlzZTogUHJvbWlzZTxUPiB8IFRcbik6IHByb21pc2UgaXMgUHJvbWlzZTxUPiB7XG4gIHJldHVybiAoXG4gICAgcHJvbWlzZSAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiBwcm9taXNlID09PSAnb2JqZWN0JyAmJlxuICAgICd0aGVuJyBpbiBwcm9taXNlICYmXG4gICAgdHlwZW9mIHByb21pc2UudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG4iXSwibmFtZXMiOlsiaXNUaGVuYWJsZSIsInByb21pc2UiLCJ0aGVuIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/is-thenable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/router/utils/add-locale.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/add-locale.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addLocale\", ({\n    enumerable: true,\n    get: function() {\n        return addLocale;\n    }\n}));\nconst _addpathprefix = __webpack_require__(/*! ./add-path-prefix */ \"(rsc)/./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\");\nconst _pathhasprefix = __webpack_require__(/*! ./path-has-prefix */ \"(rsc)/./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\nfunction addLocale(path, locale, defaultLocale, ignorePrefix) {\n    // If no locale was given or the locale is the default locale, we don't need\n    // to prefix the path.\n    if (!locale || locale === defaultLocale) return path;\n    const lower = path.toLowerCase();\n    // If the path is an API path or the path already has the locale prefix, we\n    // don't need to prefix the path.\n    if (!ignorePrefix) {\n        if ((0, _pathhasprefix.pathHasPrefix)(lower, '/api')) return path;\n        if ((0, _pathhasprefix.pathHasPrefix)(lower, \"/\" + locale.toLowerCase())) return path;\n    }\n    // Add the locale prefix to the path.\n    return (0, _addpathprefix.addPathPrefix)(path, \"/\" + locale);\n} //# sourceMappingURL=add-locale.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1sb2NhbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs2Q0FRZ0JBOzs7ZUFBQUE7OzsyQ0FSYzsyQ0FDQTtBQU92QixTQUFTQSxVQUNkQyxJQUFZLEVBQ1pDLE1BQXVCLEVBQ3ZCQyxhQUFzQixFQUN0QkMsWUFBc0I7SUFFdEIsNEVBQTRFO0lBQzVFLHNCQUFzQjtJQUN0QixJQUFJLENBQUNGLFVBQVVBLFdBQVdDLGVBQWUsT0FBT0Y7SUFFaEQsTUFBTUksUUFBUUosS0FBS0ssV0FBVztJQUU5QiwyRUFBMkU7SUFDM0UsaUNBQWlDO0lBQ2pDLElBQUksQ0FBQ0YsY0FBYztRQUNqQixJQUFJRyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQUNGLE9BQU8sU0FBUyxPQUFPSjtRQUN6QyxJQUFJTSxDQUFBQSxHQUFBQSxlQUFBQSxhQUFBQSxFQUFjRixPQUFRLE1BQUdILE9BQU9JLFdBQVcsS0FBTyxPQUFPTDtJQUMvRDtJQUVBLHFDQUFxQztJQUNyQyxPQUFPTyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFBQSxFQUFjUCxNQUFPLE1BQUdDO0FBQ2pDIiwic291cmNlcyI6WyJFOlxcc3JjXFxzaGFyZWRcXGxpYlxccm91dGVyXFx1dGlsc1xcYWRkLWxvY2FsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhZGRQYXRoUHJlZml4IH0gZnJvbSAnLi9hZGQtcGF0aC1wcmVmaXgnXG5pbXBvcnQgeyBwYXRoSGFzUHJlZml4IH0gZnJvbSAnLi9wYXRoLWhhcy1wcmVmaXgnXG5cbi8qKlxuICogRm9yIGEgZ2l2ZW4gcGF0aCBhbmQgYSBsb2NhbGUsIGlmIHRoZSBsb2NhbGUgaXMgZ2l2ZW4sIGl0IHdpbGwgcHJlZml4IHRoZVxuICogbG9jYWxlLiBUaGUgcGF0aCBzaG91bGRuJ3QgYmUgYW4gQVBJIHBhdGguIElmIGEgZGVmYXVsdCBsb2NhbGUgaXMgZ2l2ZW4gdGhlXG4gKiBwcmVmaXggd2lsbCBiZSBvbWl0dGVkIGlmIHRoZSBsb2NhbGUgaXMgYWxyZWFkeSB0aGUgZGVmYXVsdCBsb2NhbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRMb2NhbGUoXG4gIHBhdGg6IHN0cmluZyxcbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2UsXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmcsXG4gIGlnbm9yZVByZWZpeD86IGJvb2xlYW5cbikge1xuICAvLyBJZiBubyBsb2NhbGUgd2FzIGdpdmVuIG9yIHRoZSBsb2NhbGUgaXMgdGhlIGRlZmF1bHQgbG9jYWxlLCB3ZSBkb24ndCBuZWVkXG4gIC8vIHRvIHByZWZpeCB0aGUgcGF0aC5cbiAgaWYgKCFsb2NhbGUgfHwgbG9jYWxlID09PSBkZWZhdWx0TG9jYWxlKSByZXR1cm4gcGF0aFxuXG4gIGNvbnN0IGxvd2VyID0gcGF0aC50b0xvd2VyQ2FzZSgpXG5cbiAgLy8gSWYgdGhlIHBhdGggaXMgYW4gQVBJIHBhdGggb3IgdGhlIHBhdGggYWxyZWFkeSBoYXMgdGhlIGxvY2FsZSBwcmVmaXgsIHdlXG4gIC8vIGRvbid0IG5lZWQgdG8gcHJlZml4IHRoZSBwYXRoLlxuICBpZiAoIWlnbm9yZVByZWZpeCkge1xuICAgIGlmIChwYXRoSGFzUHJlZml4KGxvd2VyLCAnL2FwaScpKSByZXR1cm4gcGF0aFxuICAgIGlmIChwYXRoSGFzUHJlZml4KGxvd2VyLCBgLyR7bG9jYWxlLnRvTG93ZXJDYXNlKCl9YCkpIHJldHVybiBwYXRoXG4gIH1cblxuICAvLyBBZGQgdGhlIGxvY2FsZSBwcmVmaXggdG8gdGhlIHBhdGguXG4gIHJldHVybiBhZGRQYXRoUHJlZml4KHBhdGgsIGAvJHtsb2NhbGV9YClcbn1cbiJdLCJuYW1lcyI6WyJhZGRMb2NhbGUiLCJwYXRoIiwibG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImlnbm9yZVByZWZpeCIsImxvd2VyIiwidG9Mb3dlckNhc2UiLCJwYXRoSGFzUHJlZml4IiwiYWRkUGF0aFByZWZpeCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/router/utils/add-locale.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addPathPrefix\", ({\n    enumerable: true,\n    get: function() {\n        return addPathPrefix;\n    }\n}));\nconst _parsepath = __webpack_require__(/*! ./parse-path */ \"(rsc)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nfunction addPathPrefix(path, prefix) {\n    if (!path.startsWith('/') || !prefix) {\n        return path;\n    }\n    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);\n    return \"\" + prefix + pathname + query + hash;\n} //# sourceMappingURL=add-path-prefix.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1wYXRoLXByZWZpeC5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQU1nQkE7OztlQUFBQTs7O3VDQU5VO0FBTW5CLFNBQVNBLGNBQWNDLElBQVksRUFBRUMsTUFBZTtJQUN6RCxJQUFJLENBQUNELEtBQUtFLFVBQVUsQ0FBQyxRQUFRLENBQUNELFFBQVE7UUFDcEMsT0FBT0Q7SUFDVDtJQUVBLE1BQU0sRUFBRUcsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxXQUFBQSxTQUFBQSxFQUFVTjtJQUM1QyxPQUFRLEtBQUVDLFNBQVNFLFdBQVdDLFFBQVFDO0FBQ3hDIiwic291cmNlcyI6WyJFOlxcc3JjXFxzaGFyZWRcXGxpYlxccm91dGVyXFx1dGlsc1xcYWRkLXBhdGgtcHJlZml4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gJy4vcGFyc2UtcGF0aCdcblxuLyoqXG4gKiBBZGRzIHRoZSBwcm92aWRlZCBwcmVmaXggdG8gdGhlIGdpdmVuIHBhdGguIEl0IGZpcnN0IGVuc3VyZXMgdGhhdCB0aGUgcGF0aFxuICogaXMgaW5kZWVkIHN0YXJ0aW5nIHdpdGggYSBzbGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFBhdGhQcmVmaXgocGF0aDogc3RyaW5nLCBwcmVmaXg/OiBzdHJpbmcpIHtcbiAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSB8fCAhcHJlZml4KSB7XG4gICAgcmV0dXJuIHBhdGhcbiAgfVxuXG4gIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5LCBoYXNoIH0gPSBwYXJzZVBhdGgocGF0aClcbiAgcmV0dXJuIGAke3ByZWZpeH0ke3BhdGhuYW1lfSR7cXVlcnl9JHtoYXNofWBcbn1cbiJdLCJuYW1lcyI6WyJhZGRQYXRoUHJlZml4IiwicGF0aCIsInByZWZpeCIsInN0YXJ0c1dpdGgiLCJwYXRobmFtZSIsInF1ZXJ5IiwiaGFzaCIsInBhcnNlUGF0aCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addPathSuffix\", ({\n    enumerable: true,\n    get: function() {\n        return addPathSuffix;\n    }\n}));\nconst _parsepath = __webpack_require__(/*! ./parse-path */ \"(rsc)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nfunction addPathSuffix(path, suffix) {\n    if (!path.startsWith('/') || !suffix) {\n        return path;\n    }\n    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);\n    return \"\" + pathname + suffix + query + hash;\n} //# sourceMappingURL=add-path-suffix.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1wYXRoLXN1ZmZpeC5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQU9nQkE7OztlQUFBQTs7O3VDQVBVO0FBT25CLFNBQVNBLGNBQWNDLElBQVksRUFBRUMsTUFBZTtJQUN6RCxJQUFJLENBQUNELEtBQUtFLFVBQVUsQ0FBQyxRQUFRLENBQUNELFFBQVE7UUFDcEMsT0FBT0Q7SUFDVDtJQUVBLE1BQU0sRUFBRUcsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxXQUFBQSxTQUFBQSxFQUFVTjtJQUM1QyxPQUFRLEtBQUVHLFdBQVdGLFNBQVNHLFFBQVFDO0FBQ3hDIiwic291cmNlcyI6WyJFOlxcc3JjXFxzaGFyZWRcXGxpYlxccm91dGVyXFx1dGlsc1xcYWRkLXBhdGgtc3VmZml4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gJy4vcGFyc2UtcGF0aCdcblxuLyoqXG4gKiBTaW1pbGFybHkgdG8gYGFkZFBhdGhQcmVmaXhgLCB0aGlzIGZ1bmN0aW9uIGFkZHMgYSBzdWZmaXggYXQgdGhlIGVuZCBvbiB0aGVcbiAqIHByb3ZpZGVkIHBhdGguIEl0IGFsc28gd29ya3Mgb25seSBmb3IgcGF0aHMgZW5zdXJpbmcgdGhlIGFyZ3VtZW50IHN0YXJ0c1xuICogd2l0aCBhIHNsYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUGF0aFN1ZmZpeChwYXRoOiBzdHJpbmcsIHN1ZmZpeD86IHN0cmluZykge1xuICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpIHx8ICFzdWZmaXgpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnksIGhhc2ggfSA9IHBhcnNlUGF0aChwYXRoKVxuICByZXR1cm4gYCR7cGF0aG5hbWV9JHtzdWZmaXh9JHtxdWVyeX0ke2hhc2h9YFxufVxuIl0sIm5hbWVzIjpbImFkZFBhdGhTdWZmaXgiLCJwYXRoIiwic3VmZml4Iiwic3RhcnRzV2l0aCIsInBhdGhuYW1lIiwicXVlcnkiLCJoYXNoIiwicGFyc2VQYXRoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"formatNextPathnameInfo\", ({\n    enumerable: true,\n    get: function() {\n        return formatNextPathnameInfo;\n    }\n}));\nconst _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"(rsc)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst _addpathprefix = __webpack_require__(/*! ./add-path-prefix */ \"(rsc)/./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\");\nconst _addpathsuffix = __webpack_require__(/*! ./add-path-suffix */ \"(rsc)/./node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"(rsc)/./node_modules/next/dist/shared/lib/router/utils/add-locale.js\");\nfunction formatNextPathnameInfo(info) {\n    let pathname = (0, _addlocale.addLocale)(info.pathname, info.locale, info.buildId ? undefined : info.defaultLocale, info.ignorePrefix);\n    if (info.buildId || !info.trailingSlash) {\n        pathname = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    }\n    if (info.buildId) {\n        pathname = (0, _addpathsuffix.addPathSuffix)((0, _addpathprefix.addPathPrefix)(pathname, \"/_next/data/\" + info.buildId), info.pathname === '/' ? 'index.json' : '.json');\n    }\n    pathname = (0, _addpathprefix.addPathPrefix)(pathname, info.basePath);\n    return !info.buildId && info.trailingSlash ? !pathname.endsWith('/') ? (0, _addpathsuffix.addPathSuffix)(pathname, '/') : pathname : (0, _removetrailingslash.removeTrailingSlash)(pathname);\n} //# sourceMappingURL=format-next-pathname-info.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm8uanMiLCJtYXBwaW5ncyI6Ijs7OzswREFXZ0JBOzs7ZUFBQUE7OztpREFWb0I7MkNBQ047MkNBQ0E7dUNBQ0o7QUFPbkIsU0FBU0EsdUJBQXVCQyxJQUFrQjtJQUN2RCxJQUFJQyxXQUFXQyxDQUFBQSxHQUFBQSxXQUFBQSxTQUFBQSxFQUNiRixLQUFLQyxRQUFRLEVBQ2JELEtBQUtHLE1BQU0sRUFDWEgsS0FBS0ksT0FBTyxHQUFHQyxZQUFZTCxLQUFLTSxhQUFhLEVBQzdDTixLQUFLTyxZQUFZO0lBR25CLElBQUlQLEtBQUtJLE9BQU8sSUFBSSxDQUFDSixLQUFLUSxhQUFhLEVBQUU7UUFDdkNQLFdBQVdRLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBQUEsRUFBb0JSO0lBQ2pDO0lBRUEsSUFBSUQsS0FBS0ksT0FBTyxFQUFFO1FBQ2hCSCxXQUFXUyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFBQSxFQUNUQyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFBQSxFQUFjVixVQUFXLGlCQUFjRCxLQUFLSSxPQUFPLEdBQ25ESixLQUFLQyxRQUFRLEtBQUssTUFBTSxlQUFlO0lBRTNDO0lBRUFBLFdBQVdVLENBQUFBLEdBQUFBLGVBQUFBLGFBQUFBLEVBQWNWLFVBQVVELEtBQUtZLFFBQVE7SUFDaEQsT0FBTyxDQUFDWixLQUFLSSxPQUFPLElBQUlKLEtBQUtRLGFBQWEsR0FDdEMsQ0FBQ1AsU0FBU1ksUUFBUSxDQUFDLE9BQ2pCSCxDQUFBQSxHQUFBQSxlQUFBQSxhQUFBQSxFQUFjVCxVQUFVLE9BQ3hCQSxXQUNGUSxDQUFBQSxHQUFBQSxxQkFBQUEsbUJBQUFBLEVBQW9CUjtBQUMxQiIsInNvdXJjZXMiOlsiRTpcXHNyY1xcc2hhcmVkXFxsaWJcXHJvdXRlclxcdXRpbHNcXGZvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm8udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBOZXh0UGF0aG5hbWVJbmZvIH0gZnJvbSAnLi9nZXQtbmV4dC1wYXRobmFtZS1pbmZvJ1xuaW1wb3J0IHsgcmVtb3ZlVHJhaWxpbmdTbGFzaCB9IGZyb20gJy4vcmVtb3ZlLXRyYWlsaW5nLXNsYXNoJ1xuaW1wb3J0IHsgYWRkUGF0aFByZWZpeCB9IGZyb20gJy4vYWRkLXBhdGgtcHJlZml4J1xuaW1wb3J0IHsgYWRkUGF0aFN1ZmZpeCB9IGZyb20gJy4vYWRkLXBhdGgtc3VmZml4J1xuaW1wb3J0IHsgYWRkTG9jYWxlIH0gZnJvbSAnLi9hZGQtbG9jYWxlJ1xuXG5pbnRlcmZhY2UgRXh0ZW5kZWRJbmZvIGV4dGVuZHMgTmV4dFBhdGhuYW1lSW5mbyB7XG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgaWdub3JlUHJlZml4PzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyhpbmZvOiBFeHRlbmRlZEluZm8pIHtcbiAgbGV0IHBhdGhuYW1lID0gYWRkTG9jYWxlKFxuICAgIGluZm8ucGF0aG5hbWUsXG4gICAgaW5mby5sb2NhbGUsXG4gICAgaW5mby5idWlsZElkID8gdW5kZWZpbmVkIDogaW5mby5kZWZhdWx0TG9jYWxlLFxuICAgIGluZm8uaWdub3JlUHJlZml4XG4gIClcblxuICBpZiAoaW5mby5idWlsZElkIHx8ICFpbmZvLnRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRobmFtZSA9IHJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG4gIH1cblxuICBpZiAoaW5mby5idWlsZElkKSB7XG4gICAgcGF0aG5hbWUgPSBhZGRQYXRoU3VmZml4KFxuICAgICAgYWRkUGF0aFByZWZpeChwYXRobmFtZSwgYC9fbmV4dC9kYXRhLyR7aW5mby5idWlsZElkfWApLFxuICAgICAgaW5mby5wYXRobmFtZSA9PT0gJy8nID8gJ2luZGV4Lmpzb24nIDogJy5qc29uJ1xuICAgIClcbiAgfVxuXG4gIHBhdGhuYW1lID0gYWRkUGF0aFByZWZpeChwYXRobmFtZSwgaW5mby5iYXNlUGF0aClcbiAgcmV0dXJuICFpbmZvLmJ1aWxkSWQgJiYgaW5mby50cmFpbGluZ1NsYXNoXG4gICAgPyAhcGF0aG5hbWUuZW5kc1dpdGgoJy8nKVxuICAgICAgPyBhZGRQYXRoU3VmZml4KHBhdGhuYW1lLCAnLycpXG4gICAgICA6IHBhdGhuYW1lXG4gICAgOiByZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxufVxuIl0sIm5hbWVzIjpbImZvcm1hdE5leHRQYXRobmFtZUluZm8iLCJpbmZvIiwicGF0aG5hbWUiLCJhZGRMb2NhbGUiLCJsb2NhbGUiLCJidWlsZElkIiwidW5kZWZpbmVkIiwiZGVmYXVsdExvY2FsZSIsImlnbm9yZVByZWZpeCIsInRyYWlsaW5nU2xhc2giLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiYWRkUGF0aFN1ZmZpeCIsImFkZFBhdGhQcmVmaXgiLCJiYXNlUGF0aCIsImVuZHNXaXRoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getNextPathnameInfo\", ({\n    enumerable: true,\n    get: function() {\n        return getNextPathnameInfo;\n    }\n}));\nconst _normalizelocalepath = __webpack_require__(/*! ../../i18n/normalize-locale-path */ \"(rsc)/./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nconst _removepathprefix = __webpack_require__(/*! ./remove-path-prefix */ \"(rsc)/./node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js\");\nconst _pathhasprefix = __webpack_require__(/*! ./path-has-prefix */ \"(rsc)/./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\nfunction getNextPathnameInfo(pathname, options) {\n    var _options_nextConfig;\n    const { basePath, i18n, trailingSlash } = (_options_nextConfig = options.nextConfig) != null ? _options_nextConfig : {};\n    const info = {\n        pathname,\n        trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash\n    };\n    if (basePath && (0, _pathhasprefix.pathHasPrefix)(info.pathname, basePath)) {\n        info.pathname = (0, _removepathprefix.removePathPrefix)(info.pathname, basePath);\n        info.basePath = basePath;\n    }\n    let pathnameNoDataPrefix = info.pathname;\n    if (info.pathname.startsWith('/_next/data/') && info.pathname.endsWith('.json')) {\n        const paths = info.pathname.replace(/^\\/_next\\/data\\//, '').replace(/\\.json$/, '').split('/');\n        const buildId = paths[0];\n        info.buildId = buildId;\n        pathnameNoDataPrefix = paths[1] !== 'index' ? \"/\" + paths.slice(1).join('/') : '/';\n        // update pathname with normalized if enabled although\n        // we use normalized to populate locale info still\n        if (options.parseData === true) {\n            info.pathname = pathnameNoDataPrefix;\n        }\n    }\n    // If provided, use the locale route normalizer to detect the locale instead\n    // of the function below.\n    if (i18n) {\n        let result = options.i18nProvider ? options.i18nProvider.analyze(info.pathname) : (0, _normalizelocalepath.normalizeLocalePath)(info.pathname, i18n.locales);\n        info.locale = result.detectedLocale;\n        var _result_pathname;\n        info.pathname = (_result_pathname = result.pathname) != null ? _result_pathname : info.pathname;\n        if (!result.detectedLocale && info.buildId) {\n            result = options.i18nProvider ? options.i18nProvider.analyze(pathnameNoDataPrefix) : (0, _normalizelocalepath.normalizeLocalePath)(pathnameNoDataPrefix, i18n.locales);\n            if (result.detectedLocale) {\n                info.locale = result.detectedLocale;\n            }\n        }\n    }\n    return info;\n} //# sourceMappingURL=get-next-pathname-info.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm8uanMiLCJtYXBwaW5ncyI6Ijs7Ozt1REFvRGdCQTs7O2VBQUFBOzs7aURBcERvQjs4Q0FDSDsyQ0FDSDtBQWtEdkIsU0FBU0Esb0JBQ2RDLFFBQWdCLEVBQ2hCQyxPQUFnQjtRQUUwQkE7SUFBMUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLElBQUksRUFBRUMsYUFBYSxFQUFFLEdBQUdILENBQUFBLHNCQUFBQSxRQUFRSSxVQUFBQSxLQUFVLE9BQWxCSixzQkFBc0IsQ0FBQztJQUNqRSxNQUFNSyxPQUF5QjtRQUM3Qk47UUFDQUksZUFBZUosYUFBYSxNQUFNQSxTQUFTTyxRQUFRLENBQUMsT0FBT0g7SUFDN0Q7SUFFQSxJQUFJRixZQUFZTSxDQUFBQSxHQUFBQSxlQUFBQSxhQUFBQSxFQUFjRixLQUFLTixRQUFRLEVBQUVFLFdBQVc7UUFDdERJLEtBQUtOLFFBQVEsR0FBR1MsQ0FBQUEsR0FBQUEsa0JBQUFBLGdCQUFBQSxFQUFpQkgsS0FBS04sUUFBUSxFQUFFRTtRQUNoREksS0FBS0osUUFBUSxHQUFHQTtJQUNsQjtJQUNBLElBQUlRLHVCQUF1QkosS0FBS04sUUFBUTtJQUV4QyxJQUNFTSxLQUFLTixRQUFRLENBQUNXLFVBQVUsQ0FBQyxtQkFDekJMLEtBQUtOLFFBQVEsQ0FBQ08sUUFBUSxDQUFDLFVBQ3ZCO1FBQ0EsTUFBTUssUUFBUU4sS0FBS04sUUFBUSxDQUN4QmEsT0FBTyxDQUFDLG9CQUFvQixJQUM1QkEsT0FBTyxDQUFDLFdBQVcsSUFDbkJDLEtBQUssQ0FBQztRQUVULE1BQU1DLFVBQVVILEtBQUssQ0FBQyxFQUFFO1FBQ3hCTixLQUFLUyxPQUFPLEdBQUdBO1FBQ2ZMLHVCQUNFRSxLQUFLLENBQUMsRUFBRSxLQUFLLFVBQVcsTUFBR0EsTUFBTUksS0FBSyxDQUFDLEdBQUdDLElBQUksQ0FBQyxPQUFTO1FBRTFELHNEQUFzRDtRQUN0RCxrREFBa0Q7UUFDbEQsSUFBSWhCLFFBQVFpQixTQUFTLEtBQUssTUFBTTtZQUM5QlosS0FBS04sUUFBUSxHQUFHVTtRQUNsQjtJQUNGO0lBRUEsNEVBQTRFO0lBQzVFLHlCQUF5QjtJQUN6QixJQUFJUCxNQUFNO1FBQ1IsSUFBSWdCLFNBQVNsQixRQUFRbUIsWUFBWSxHQUM3Qm5CLFFBQVFtQixZQUFZLENBQUNDLE9BQU8sQ0FBQ2YsS0FBS04sUUFBUSxJQUMxQ3NCLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBQUEsRUFBb0JoQixLQUFLTixRQUFRLEVBQUVHLEtBQUtvQixPQUFPO1FBRW5EakIsS0FBS2tCLE1BQU0sR0FBR0wsT0FBT00sY0FBYztZQUNuQk47UUFBaEJiLEtBQUtOLFFBQVEsR0FBR21CLENBQUFBLG1CQUFBQSxPQUFPbkIsUUFBQUEsS0FBUSxPQUFmbUIsbUJBQW1CYixLQUFLTixRQUFRO1FBRWhELElBQUksQ0FBQ21CLE9BQU9NLGNBQWMsSUFBSW5CLEtBQUtTLE9BQU8sRUFBRTtZQUMxQ0ksU0FBU2xCLFFBQVFtQixZQUFZLEdBQ3pCbkIsUUFBUW1CLFlBQVksQ0FBQ0MsT0FBTyxDQUFDWCx3QkFDN0JZLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBQUEsRUFBb0JaLHNCQUFzQlAsS0FBS29CLE9BQU87WUFFMUQsSUFBSUosT0FBT00sY0FBYyxFQUFFO2dCQUN6Qm5CLEtBQUtrQixNQUFNLEdBQUdMLE9BQU9NLGNBQWM7WUFDckM7UUFDRjtJQUNGO0lBQ0EsT0FBT25CO0FBQ1QiLCJzb3VyY2VzIjpbIkU6XFxzcmNcXHNoYXJlZFxcbGliXFxyb3V0ZXJcXHV0aWxzXFxnZXQtbmV4dC1wYXRobmFtZS1pbmZvLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG5vcm1hbGl6ZUxvY2FsZVBhdGggfSBmcm9tICcuLi8uLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCdcbmltcG9ydCB7IHJlbW92ZVBhdGhQcmVmaXggfSBmcm9tICcuL3JlbW92ZS1wYXRoLXByZWZpeCdcbmltcG9ydCB7IHBhdGhIYXNQcmVmaXggfSBmcm9tICcuL3BhdGgtaGFzLXByZWZpeCdcbmltcG9ydCB0eXBlIHsgSTE4TlByb3ZpZGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2VydmVyL2xpYi9pMThuLXByb3ZpZGVyJ1xuXG5leHBvcnQgaW50ZXJmYWNlIE5leHRQYXRobmFtZUluZm8ge1xuICAvKipcbiAgICogVGhlIGJhc2UgcGF0aCBpbiBjYXNlIHRoZSBwYXRobmFtZSBpbmNsdWRlZCBpdC5cbiAgICovXG4gIGJhc2VQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgYnVpbGRJZCBmb3Igd2hlbiB0aGUgcGFyc2VkIFVSTCBpcyBhIGRhdGEgVVJMLiBQYXJzaW5nIGl0IGNhbiBiZVxuICAgKiBkaXNhYmxlZCB3aXRoIHRoZSBgcGFyc2VEYXRhYCBvcHRpb24uXG4gICAqL1xuICBidWlsZElkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBJZiB0aGVyZSB3YXMgYSBsb2NhbGUgaW4gdGhlIHBhdGhuYW1lLCB0aGlzIHdpbGwgaG9sZCBpdHMgdmFsdWUuXG4gICAqL1xuICBsb2NhbGU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBwcm9jZXNzZWQgcGF0aG5hbWUgd2l0aG91dCBhIGJhc2UgcGF0aCwgbG9jYWxlLCBvciBkYXRhIFVSTCBlbGVtZW50c1xuICAgKiB3aGVuIHBhcnNpbmcgaXQgaXMgZW5hYmxlZC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgLyoqXG4gICAqIEEgYm9vbGVhbiB0ZWxsaW5nIGlmIHRoZSBwYXRobmFtZSBoYWQgYSB0cmFpbGluZ1NsYXNoLiBUaGlzIGNhbiBiZSBvbmx5XG4gICAqIHRydWUgaWYgdHJhaWxpbmdTbGFzaCBpcyBlbmFibGVkLlxuICAgKi9cbiAgdHJhaWxpbmdTbGFzaD86IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIE9wdGlvbnMge1xuICAvKipcbiAgICogV2hlbiBwYXNzZWQgdG8gdHJ1ZSwgdGhpcyBmdW5jdGlvbiB3aWxsIGFsc28gcGFyc2UgTmV4dGpzIGRhdGEgVVJMcy5cbiAgICovXG4gIHBhcnNlRGF0YT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIEEgcGFydGlhbCBvZiB0aGUgTmV4dC5qcyBjb25maWd1cmF0aW9uIHRvIHBhcnNlIHRoZSBVUkwuXG4gICAqL1xuICBuZXh0Q29uZmlnPzoge1xuICAgIGJhc2VQYXRoPzogc3RyaW5nXG4gICAgaTE4bj86IHsgbG9jYWxlcz86IHJlYWRvbmx5IHN0cmluZ1tdIH0gfCBudWxsXG4gICAgdHJhaWxpbmdTbGFzaD86IGJvb2xlYW5cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBwcm92aWRlZCwgdGhpcyBub3JtYWxpemVyIHdpbGwgYmUgdXNlZCB0byBkZXRlY3QgdGhlIGxvY2FsZSBpbnN0ZWFkIG9mXG4gICAqIHRoZSBkZWZhdWx0IGxvY2FsZSBkZXRlY3Rpb24uXG4gICAqL1xuICBpMThuUHJvdmlkZXI/OiBJMThOUHJvdmlkZXJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5leHRQYXRobmFtZUluZm8oXG4gIHBhdGhuYW1lOiBzdHJpbmcsXG4gIG9wdGlvbnM6IE9wdGlvbnNcbik6IE5leHRQYXRobmFtZUluZm8ge1xuICBjb25zdCB7IGJhc2VQYXRoLCBpMThuLCB0cmFpbGluZ1NsYXNoIH0gPSBvcHRpb25zLm5leHRDb25maWcgPz8ge31cbiAgY29uc3QgaW5mbzogTmV4dFBhdGhuYW1lSW5mbyA9IHtcbiAgICBwYXRobmFtZSxcbiAgICB0cmFpbGluZ1NsYXNoOiBwYXRobmFtZSAhPT0gJy8nID8gcGF0aG5hbWUuZW5kc1dpdGgoJy8nKSA6IHRyYWlsaW5nU2xhc2gsXG4gIH1cblxuICBpZiAoYmFzZVBhdGggJiYgcGF0aEhhc1ByZWZpeChpbmZvLnBhdGhuYW1lLCBiYXNlUGF0aCkpIHtcbiAgICBpbmZvLnBhdGhuYW1lID0gcmVtb3ZlUGF0aFByZWZpeChpbmZvLnBhdGhuYW1lLCBiYXNlUGF0aClcbiAgICBpbmZvLmJhc2VQYXRoID0gYmFzZVBhdGhcbiAgfVxuICBsZXQgcGF0aG5hbWVOb0RhdGFQcmVmaXggPSBpbmZvLnBhdGhuYW1lXG5cbiAgaWYgKFxuICAgIGluZm8ucGF0aG5hbWUuc3RhcnRzV2l0aCgnL19uZXh0L2RhdGEvJykgJiZcbiAgICBpbmZvLnBhdGhuYW1lLmVuZHNXaXRoKCcuanNvbicpXG4gICkge1xuICAgIGNvbnN0IHBhdGhzID0gaW5mby5wYXRobmFtZVxuICAgICAgLnJlcGxhY2UoL15cXC9fbmV4dFxcL2RhdGFcXC8vLCAnJylcbiAgICAgIC5yZXBsYWNlKC9cXC5qc29uJC8sICcnKVxuICAgICAgLnNwbGl0KCcvJylcblxuICAgIGNvbnN0IGJ1aWxkSWQgPSBwYXRoc1swXVxuICAgIGluZm8uYnVpbGRJZCA9IGJ1aWxkSWRcbiAgICBwYXRobmFtZU5vRGF0YVByZWZpeCA9XG4gICAgICBwYXRoc1sxXSAhPT0gJ2luZGV4JyA/IGAvJHtwYXRocy5zbGljZSgxKS5qb2luKCcvJyl9YCA6ICcvJ1xuXG4gICAgLy8gdXBkYXRlIHBhdGhuYW1lIHdpdGggbm9ybWFsaXplZCBpZiBlbmFibGVkIGFsdGhvdWdoXG4gICAgLy8gd2UgdXNlIG5vcm1hbGl6ZWQgdG8gcG9wdWxhdGUgbG9jYWxlIGluZm8gc3RpbGxcbiAgICBpZiAob3B0aW9ucy5wYXJzZURhdGEgPT09IHRydWUpIHtcbiAgICAgIGluZm8ucGF0aG5hbWUgPSBwYXRobmFtZU5vRGF0YVByZWZpeFxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHByb3ZpZGVkLCB1c2UgdGhlIGxvY2FsZSByb3V0ZSBub3JtYWxpemVyIHRvIGRldGVjdCB0aGUgbG9jYWxlIGluc3RlYWRcbiAgLy8gb2YgdGhlIGZ1bmN0aW9uIGJlbG93LlxuICBpZiAoaTE4bikge1xuICAgIGxldCByZXN1bHQgPSBvcHRpb25zLmkxOG5Qcm92aWRlclxuICAgICAgPyBvcHRpb25zLmkxOG5Qcm92aWRlci5hbmFseXplKGluZm8ucGF0aG5hbWUpXG4gICAgICA6IG5vcm1hbGl6ZUxvY2FsZVBhdGgoaW5mby5wYXRobmFtZSwgaTE4bi5sb2NhbGVzKVxuXG4gICAgaW5mby5sb2NhbGUgPSByZXN1bHQuZGV0ZWN0ZWRMb2NhbGVcbiAgICBpbmZvLnBhdGhuYW1lID0gcmVzdWx0LnBhdGhuYW1lID8/IGluZm8ucGF0aG5hbWVcblxuICAgIGlmICghcmVzdWx0LmRldGVjdGVkTG9jYWxlICYmIGluZm8uYnVpbGRJZCkge1xuICAgICAgcmVzdWx0ID0gb3B0aW9ucy5pMThuUHJvdmlkZXJcbiAgICAgICAgPyBvcHRpb25zLmkxOG5Qcm92aWRlci5hbmFseXplKHBhdGhuYW1lTm9EYXRhUHJlZml4KVxuICAgICAgICA6IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aG5hbWVOb0RhdGFQcmVmaXgsIGkxOG4ubG9jYWxlcylcblxuICAgICAgaWYgKHJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICBpbmZvLmxvY2FsZSA9IHJlc3VsdC5kZXRlY3RlZExvY2FsZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mb1xufVxuIl0sIm5hbWVzIjpbImdldE5leHRQYXRobmFtZUluZm8iLCJwYXRobmFtZSIsIm9wdGlvbnMiLCJiYXNlUGF0aCIsImkxOG4iLCJ0cmFpbGluZ1NsYXNoIiwibmV4dENvbmZpZyIsImluZm8iLCJlbmRzV2l0aCIsInBhdGhIYXNQcmVmaXgiLCJyZW1vdmVQYXRoUHJlZml4IiwicGF0aG5hbWVOb0RhdGFQcmVmaXgiLCJzdGFydHNXaXRoIiwicGF0aHMiLCJyZXBsYWNlIiwic3BsaXQiLCJidWlsZElkIiwic2xpY2UiLCJqb2luIiwicGFyc2VEYXRhIiwicmVzdWx0IiwiaTE4blByb3ZpZGVyIiwiYW5hbHl6ZSIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJsb2NhbGVzIiwibG9jYWxlIiwiZGV0ZWN0ZWRMb2NhbGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/parse-path.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"parsePath\", ({\n    enumerable: true,\n    get: function() {\n        return parsePath;\n    }\n}));\nfunction parsePath(path) {\n    const hashIndex = path.indexOf('#');\n    const queryIndex = path.indexOf('?');\n    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);\n    if (hasQuery || hashIndex > -1) {\n        return {\n            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : '',\n            hash: hashIndex > -1 ? path.slice(hashIndex) : ''\n        };\n    }\n    return {\n        pathname: path,\n        query: '',\n        hash: ''\n    };\n} //# sourceMappingURL=parse-path.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXBhdGguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQzs7Ozs2Q0FDZUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsVUFBVUMsSUFBWTtJQUNwQyxNQUFNQyxZQUFZRCxLQUFLRSxPQUFPLENBQUM7SUFDL0IsTUFBTUMsYUFBYUgsS0FBS0UsT0FBTyxDQUFDO0lBQ2hDLE1BQU1FLFdBQVdELGFBQWEsQ0FBQyxLQUFNRixDQUFBQSxZQUFZLEtBQUtFLGFBQWFGLFNBQUFBLENBQVE7SUFFM0UsSUFBSUcsWUFBWUgsWUFBWSxDQUFDLEdBQUc7UUFDOUIsT0FBTztZQUNMSSxVQUFVTCxLQUFLTSxTQUFTLENBQUMsR0FBR0YsV0FBV0QsYUFBYUY7WUFDcERNLE9BQU9ILFdBQ0hKLEtBQUtNLFNBQVMsQ0FBQ0gsWUFBWUYsWUFBWSxDQUFDLElBQUlBLFlBQVlPLGFBQ3hEO1lBQ0pDLE1BQU1SLFlBQVksQ0FBQyxJQUFJRCxLQUFLVSxLQUFLLENBQUNULGFBQWE7UUFDakQ7SUFDRjtJQUVBLE9BQU87UUFBRUksVUFBVUw7UUFBTU8sT0FBTztRQUFJRSxNQUFNO0lBQUc7QUFDL0MiLCJzb3VyY2VzIjpbIkU6XFxzcmNcXHNoYXJlZFxcbGliXFxyb3V0ZXJcXHV0aWxzXFxwYXJzZS1wYXRoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2l2ZW4gYSBwYXRoIHRoaXMgZnVuY3Rpb24gd2lsbCBmaW5kIHRoZSBwYXRobmFtZSwgcXVlcnkgYW5kIGhhc2ggYW5kIHJldHVyblxuICogdGhlbS4gVGhpcyBpcyB1c2VmdWwgdG8gcGFyc2UgZnVsbCBwYXRocyBvbiB0aGUgY2xpZW50IHNpZGUuXG4gKiBAcGFyYW0gcGF0aCBBIHBhdGggdG8gcGFyc2UgZS5nLiAvZm9vL2Jhcj9pZD0xI2hhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgY29uc3QgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJylcbiAgY29uc3QgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpXG4gIGNvbnN0IGhhc1F1ZXJ5ID0gcXVlcnlJbmRleCA+IC0xICYmIChoYXNoSW5kZXggPCAwIHx8IHF1ZXJ5SW5kZXggPCBoYXNoSW5kZXgpXG5cbiAgaWYgKGhhc1F1ZXJ5IHx8IGhhc2hJbmRleCA+IC0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGhuYW1lOiBwYXRoLnN1YnN0cmluZygwLCBoYXNRdWVyeSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXgpLFxuICAgICAgcXVlcnk6IGhhc1F1ZXJ5XG4gICAgICAgID8gcGF0aC5zdWJzdHJpbmcocXVlcnlJbmRleCwgaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiB1bmRlZmluZWQpXG4gICAgICAgIDogJycsXG4gICAgICBoYXNoOiBoYXNoSW5kZXggPiAtMSA/IHBhdGguc2xpY2UoaGFzaEluZGV4KSA6ICcnLFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHBhdGhuYW1lOiBwYXRoLCBxdWVyeTogJycsIGhhc2g6ICcnIH1cbn1cbiJdLCJuYW1lcyI6WyJwYXJzZVBhdGgiLCJwYXRoIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInF1ZXJ5SW5kZXgiLCJoYXNRdWVyeSIsInBhdGhuYW1lIiwic3Vic3RyaW5nIiwicXVlcnkiLCJ1bmRlZmluZWQiLCJoYXNoIiwic2xpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"pathHasPrefix\", ({\n    enumerable: true,\n    get: function() {\n        return pathHasPrefix;\n    }\n}));\nconst _parsepath = __webpack_require__(/*! ./parse-path */ \"(rsc)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nfunction pathHasPrefix(path, prefix) {\n    if (typeof path !== 'string') {\n        return false;\n    }\n    const { pathname } = (0, _parsepath.parsePath)(path);\n    return pathname === prefix || pathname.startsWith(prefix + '/');\n} //# sourceMappingURL=path-has-prefix.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhdGgtaGFzLXByZWZpeC5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQVNnQkE7OztlQUFBQTs7O3VDQVRVO0FBU25CLFNBQVNBLGNBQWNDLElBQVksRUFBRUMsTUFBYztJQUN4RCxJQUFJLE9BQU9ELFNBQVMsVUFBVTtRQUM1QixPQUFPO0lBQ1Q7SUFFQSxNQUFNLEVBQUVFLFFBQVEsRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxXQUFBQSxTQUFBQSxFQUFVSDtJQUMvQixPQUFPRSxhQUFhRCxVQUFVQyxTQUFTRSxVQUFVLENBQUNILFNBQVM7QUFDN0QiLCJzb3VyY2VzIjpbIkU6XFxzcmNcXHNoYXJlZFxcbGliXFxyb3V0ZXJcXHV0aWxzXFxwYXRoLWhhcy1wcmVmaXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnLi9wYXJzZS1wYXRoJ1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIHBhdGggc3RhcnRzIHdpdGggYSBnaXZlbiBwcmVmaXguIEl0IGVuc3VyZXMgaXQgbWF0Y2hlc1xuICogZXhhY3RseSB3aXRob3V0IGNvbnRhaW5pbmcgZXh0cmEgY2hhcnMuIGUuZy4gcHJlZml4IC9kb2NzIHNob3VsZCByZXBsYWNlXG4gKiBmb3IgL2RvY3MsIC9kb2NzLywgL2RvY3MvYSBidXQgbm90IC9kb2Nzc3NcbiAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHByZWZpeCBUaGUgcHJlZml4IHRvIGNoZWNrIGFnYWluc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXRoSGFzUHJlZml4KHBhdGg6IHN0cmluZywgcHJlZml4OiBzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgeyBwYXRobmFtZSB9ID0gcGFyc2VQYXRoKHBhdGgpXG4gIHJldHVybiBwYXRobmFtZSA9PT0gcHJlZml4IHx8IHBhdGhuYW1lLnN0YXJ0c1dpdGgocHJlZml4ICsgJy8nKVxufVxuIl0sIm5hbWVzIjpbInBhdGhIYXNQcmVmaXgiLCJwYXRoIiwicHJlZml4IiwicGF0aG5hbWUiLCJwYXJzZVBhdGgiLCJzdGFydHNXaXRoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"removePathPrefix\", ({\n    enumerable: true,\n    get: function() {\n        return removePathPrefix;\n    }\n}));\nconst _pathhasprefix = __webpack_require__(/*! ./path-has-prefix */ \"(rsc)/./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\nfunction removePathPrefix(path, prefix) {\n    // If the path doesn't start with the prefix we can return it as is. This\n    // protects us from situations where the prefix is a substring of the path\n    // prefix such as:\n    //\n    // For prefix: /blog\n    //\n    //   /blog -> true\n    //   /blog/ -> true\n    //   /blog/1 -> true\n    //   /blogging -> false\n    //   /blogging/ -> false\n    //   /blogging/1 -> false\n    if (!(0, _pathhasprefix.pathHasPrefix)(path, prefix)) {\n        return path;\n    }\n    // Remove the prefix from the path via slicing.\n    const withoutPrefix = path.slice(prefix.length);\n    // If the path without the prefix starts with a `/` we can return it as is.\n    if (withoutPrefix.startsWith('/')) {\n        return withoutPrefix;\n    }\n    // If the path without the prefix doesn't start with a `/` we need to add it\n    // back to the path to make sure it's a valid path.\n    return \"/\" + withoutPrefix;\n} //# sourceMappingURL=remove-path-prefix.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JlbW92ZS1wYXRoLXByZWZpeC5qcyIsIm1hcHBpbmdzIjoiOzs7O29EQVVnQkE7OztlQUFBQTs7OzJDQVZjO0FBVXZCLFNBQVNBLGlCQUFpQkMsSUFBWSxFQUFFQyxNQUFjO0lBQzNELHlFQUF5RTtJQUN6RSwwRUFBMEU7SUFDMUUsa0JBQWtCO0lBQ2xCLEVBQUU7SUFDRixvQkFBb0I7SUFDcEIsRUFBRTtJQUNGLGtCQUFrQjtJQUNsQixtQkFBbUI7SUFDbkIsb0JBQW9CO0lBQ3BCLHVCQUF1QjtJQUN2Qix3QkFBd0I7SUFDeEIseUJBQXlCO0lBQ3pCLElBQUksQ0FBQ0MsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBQUEsRUFBY0YsTUFBTUMsU0FBUztRQUNoQyxPQUFPRDtJQUNUO0lBRUEsK0NBQStDO0lBQy9DLE1BQU1HLGdCQUFnQkgsS0FBS0ksS0FBSyxDQUFDSCxPQUFPSSxNQUFNO0lBRTlDLDJFQUEyRTtJQUMzRSxJQUFJRixjQUFjRyxVQUFVLENBQUMsTUFBTTtRQUNqQyxPQUFPSDtJQUNUO0lBRUEsNEVBQTRFO0lBQzVFLG1EQUFtRDtJQUNuRCxPQUFRLE1BQUdBO0FBQ2IiLCJzb3VyY2VzIjpbIkU6XFxzcmNcXHNoYXJlZFxcbGliXFxyb3V0ZXJcXHV0aWxzXFxyZW1vdmUtcGF0aC1wcmVmaXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGF0aEhhc1ByZWZpeCB9IGZyb20gJy4vcGF0aC1oYXMtcHJlZml4J1xuXG4vKipcbiAqIEdpdmVuIGEgcGF0aCBhbmQgYSBwcmVmaXggaXQgd2lsbCByZW1vdmUgdGhlIHByZWZpeCB3aGVuIGl0IGV4aXN0cyBpbiB0aGVcbiAqIGdpdmVuIHBhdGguIEl0IGVuc3VyZXMgaXQgbWF0Y2hlcyBleGFjdGx5IHdpdGhvdXQgY29udGFpbmluZyBleHRyYSBjaGFyc1xuICogYW5kIGlmIHRoZSBwcmVmaXggaXMgbm90IHRoZXJlIGl0IHdpbGwgYmUgbm9vcC5cbiAqXG4gKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byByZW1vdmUgdGhlIHByZWZpeCBmcm9tLlxuICogQHBhcmFtIHByZWZpeCBUaGUgcHJlZml4IHRvIGJlIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQYXRoUHJlZml4KHBhdGg6IHN0cmluZywgcHJlZml4OiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBJZiB0aGUgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggdGhlIHByZWZpeCB3ZSBjYW4gcmV0dXJuIGl0IGFzIGlzLiBUaGlzXG4gIC8vIHByb3RlY3RzIHVzIGZyb20gc2l0dWF0aW9ucyB3aGVyZSB0aGUgcHJlZml4IGlzIGEgc3Vic3RyaW5nIG9mIHRoZSBwYXRoXG4gIC8vIHByZWZpeCBzdWNoIGFzOlxuICAvL1xuICAvLyBGb3IgcHJlZml4OiAvYmxvZ1xuICAvL1xuICAvLyAgIC9ibG9nIC0+IHRydWVcbiAgLy8gICAvYmxvZy8gLT4gdHJ1ZVxuICAvLyAgIC9ibG9nLzEgLT4gdHJ1ZVxuICAvLyAgIC9ibG9nZ2luZyAtPiBmYWxzZVxuICAvLyAgIC9ibG9nZ2luZy8gLT4gZmFsc2VcbiAgLy8gICAvYmxvZ2dpbmcvMSAtPiBmYWxzZVxuICBpZiAoIXBhdGhIYXNQcmVmaXgocGF0aCwgcHJlZml4KSkge1xuICAgIHJldHVybiBwYXRoXG4gIH1cblxuICAvLyBSZW1vdmUgdGhlIHByZWZpeCBmcm9tIHRoZSBwYXRoIHZpYSBzbGljaW5nLlxuICBjb25zdCB3aXRob3V0UHJlZml4ID0gcGF0aC5zbGljZShwcmVmaXgubGVuZ3RoKVxuXG4gIC8vIElmIHRoZSBwYXRoIHdpdGhvdXQgdGhlIHByZWZpeCBzdGFydHMgd2l0aCBhIGAvYCB3ZSBjYW4gcmV0dXJuIGl0IGFzIGlzLlxuICBpZiAod2l0aG91dFByZWZpeC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICByZXR1cm4gd2l0aG91dFByZWZpeFxuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggd2l0aG91dCB0aGUgcHJlZml4IGRvZXNuJ3Qgc3RhcnQgd2l0aCBhIGAvYCB3ZSBuZWVkIHRvIGFkZCBpdFxuICAvLyBiYWNrIHRvIHRoZSBwYXRoIHRvIG1ha2Ugc3VyZSBpdCdzIGEgdmFsaWQgcGF0aC5cbiAgcmV0dXJuIGAvJHt3aXRob3V0UHJlZml4fWBcbn1cbiJdLCJuYW1lcyI6WyJyZW1vdmVQYXRoUHJlZml4IiwicGF0aCIsInByZWZpeCIsInBhdGhIYXNQcmVmaXgiLCJ3aXRob3V0UHJlZml4Iiwic2xpY2UiLCJsZW5ndGgiLCJzdGFydHNXaXRoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * Removes the trailing slash for a given route or page path. Preserves the\n * root page. Examples:\n *   - `/foo/bar/` -> `/foo/bar`\n *   - `/foo/bar` -> `/foo/bar`\n *   - `/` -> `/`\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"removeTrailingSlash\", ({\n    enumerable: true,\n    get: function() {\n        return removeTrailingSlash;\n    }\n}));\nfunction removeTrailingSlash(route) {\n    return route.replace(/\\/$/, '') || '/';\n} //# sourceMappingURL=remove-trailing-slash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0NBTUM7Ozs7dURBQ2VBOzs7ZUFBQUE7OztBQUFULFNBQVNBLG9CQUFvQkMsS0FBYTtJQUMvQyxPQUFPQSxNQUFNQyxPQUFPLENBQUMsT0FBTyxPQUFPO0FBQ3JDIiwic291cmNlcyI6WyJFOlxcc3JjXFxzaGFyZWRcXGxpYlxccm91dGVyXFx1dGlsc1xccmVtb3ZlLXRyYWlsaW5nLXNsYXNoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVtb3ZlcyB0aGUgdHJhaWxpbmcgc2xhc2ggZm9yIGEgZ2l2ZW4gcm91dGUgb3IgcGFnZSBwYXRoLiBQcmVzZXJ2ZXMgdGhlXG4gKiByb290IHBhZ2UuIEV4YW1wbGVzOlxuICogICAtIGAvZm9vL2Jhci9gIC0+IGAvZm9vL2JhcmBcbiAqICAgLSBgL2Zvby9iYXJgIC0+IGAvZm9vL2JhcmBcbiAqICAgLSBgL2AgLT4gYC9gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUcmFpbGluZ1NsYXNoKHJvdXRlOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nXG59XG4iXSwibmFtZXMiOlsicmVtb3ZlVHJhaWxpbmdTbGFzaCIsInJvdXRlIiwicmVwbGFjZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/shared/lib/utils/reflect-utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils/reflect-utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("// This regex will have fast negatives meaning valid identifiers may not pass\n// this test. However this is only used during static generation to provide hints\n// about why a page bailed out of some or all prerendering and we can use bracket notation\n// for example while `_` is a valid identifier it's ok to print `searchParams['_']`\n// even if this would have been fine too `searchParams._`\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    describeHasCheckingStringProperty: function() {\n        return describeHasCheckingStringProperty;\n    },\n    describeStringPropertyAccess: function() {\n        return describeStringPropertyAccess;\n    },\n    wellKnownProperties: function() {\n        return wellKnownProperties;\n    }\n});\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;\nfunction describeStringPropertyAccess(target, prop) {\n    if (isDefinitelyAValidIdentifier.test(prop)) {\n        return \"`\" + target + \".\" + prop + \"`\";\n    }\n    return \"`\" + target + \"[\" + JSON.stringify(prop) + \"]`\";\n}\nfunction describeHasCheckingStringProperty(target, prop) {\n    const stringifiedProp = JSON.stringify(prop);\n    return \"`Reflect.has(\" + target + \", \" + stringifiedProp + \")`, `\" + stringifiedProp + \" in \" + target + \"`, or similar\";\n}\nconst wellKnownProperties = new Set([\n    'hasOwnProperty',\n    'isPrototypeOf',\n    'propertyIsEnumerable',\n    'toString',\n    'valueOf',\n    'toLocaleString',\n    // Promise prototype\n    // fallthrough\n    'then',\n    'catch',\n    'finally',\n    // React Promise extension\n    // fallthrough\n    'status',\n    // React introspection\n    'displayName',\n    // Common tested properties\n    // fallthrough\n    'toJSON',\n    '$$typeof',\n    '__esModule'\n]); //# sourceMappingURL=reflect-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMvcmVmbGVjdC11dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQSw2RUFBNkU7QUFDN0UsaUZBQWlGO0FBQ2pGLDBGQUEwRjtBQUMxRix1RkFBdUY7QUFDdkYsMkRBQTJEOzs7Ozs7Ozs7Ozs7O0lBVTNDQSxpQ0FBaUM7ZUFBakNBOztJQVBBQyw0QkFBNEI7ZUFBNUJBOztJQWVIQyxtQkFBbUI7ZUFBbkJBOzs7QUFqQmIsTUFBTUMsK0JBQStCO0FBRTlCLFNBQVNGLDZCQUE2QkcsTUFBYyxFQUFFQyxJQUFZO0lBQ3ZFLElBQUlGLDZCQUE2QkcsSUFBSSxDQUFDRCxPQUFPO1FBQzNDLE9BQVEsTUFBSUQsU0FBTyxNQUFHQyxPQUFLO0lBQzdCO0lBQ0EsT0FBUSxNQUFJRCxTQUFPLE1BQUdHLEtBQUtDLFNBQVMsQ0FBQ0gsUUFBTTtBQUM3QztBQUVPLFNBQVNMLGtDQUNkSSxNQUFjLEVBQ2RDLElBQVk7SUFFWixNQUFNSSxrQkFBa0JGLEtBQUtDLFNBQVMsQ0FBQ0g7SUFDdkMsT0FBUSxrQkFBZ0JELFNBQU8sT0FBSUssa0JBQWdCLFVBQVNBLGtCQUFnQixTQUFNTCxTQUFPO0FBQzNGO0FBRU8sTUFBTUYsc0JBQXNCLElBQUlRLElBQUk7SUFDekM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBRUEsb0JBQW9CO0lBQ3BCLGNBQWM7SUFDZDtJQUNBO0lBQ0E7SUFFQSwwQkFBMEI7SUFDMUIsY0FBYztJQUNkO0lBRUEsc0JBQXNCO0lBQ3RCO0lBRUEsMkJBQTJCO0lBQzNCLGNBQWM7SUFDZDtJQUNBO0lBQ0E7Q0FDRCIsInNvdXJjZXMiOlsiRTpcXHNyY1xcc2hhcmVkXFxsaWJcXHV0aWxzXFxyZWZsZWN0LXV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgcmVnZXggd2lsbCBoYXZlIGZhc3QgbmVnYXRpdmVzIG1lYW5pbmcgdmFsaWQgaWRlbnRpZmllcnMgbWF5IG5vdCBwYXNzXG4vLyB0aGlzIHRlc3QuIEhvd2V2ZXIgdGhpcyBpcyBvbmx5IHVzZWQgZHVyaW5nIHN0YXRpYyBnZW5lcmF0aW9uIHRvIHByb3ZpZGUgaGludHNcbi8vIGFib3V0IHdoeSBhIHBhZ2UgYmFpbGVkIG91dCBvZiBzb21lIG9yIGFsbCBwcmVyZW5kZXJpbmcgYW5kIHdlIGNhbiB1c2UgYnJhY2tldCBub3RhdGlvblxuLy8gZm9yIGV4YW1wbGUgd2hpbGUgYOCyoF/gsqBgIGlzIGEgdmFsaWQgaWRlbnRpZmllciBpdCdzIG9rIHRvIHByaW50IGBzZWFyY2hQYXJhbXNbJ+CyoF/gsqAnXWBcbi8vIGV2ZW4gaWYgdGhpcyB3b3VsZCBoYXZlIGJlZW4gZmluZSB0b28gYHNlYXJjaFBhcmFtcy7gsqBf4LKgYFxuY29uc3QgaXNEZWZpbml0ZWx5QVZhbGlkSWRlbnRpZmllciA9IC9eW0EtWmEtel8kXVtBLVphLXowLTlfJF0qJC9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3ModGFyZ2V0OiBzdHJpbmcsIHByb3A6IHN0cmluZykge1xuICBpZiAoaXNEZWZpbml0ZWx5QVZhbGlkSWRlbnRpZmllci50ZXN0KHByb3ApKSB7XG4gICAgcmV0dXJuIGBcXGAke3RhcmdldH0uJHtwcm9wfVxcYGBcbiAgfVxuICByZXR1cm4gYFxcYCR7dGFyZ2V0fVske0pTT04uc3RyaW5naWZ5KHByb3ApfV1cXGBgXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkoXG4gIHRhcmdldDogc3RyaW5nLFxuICBwcm9wOiBzdHJpbmdcbikge1xuICBjb25zdCBzdHJpbmdpZmllZFByb3AgPSBKU09OLnN0cmluZ2lmeShwcm9wKVxuICByZXR1cm4gYFxcYFJlZmxlY3QuaGFzKCR7dGFyZ2V0fSwgJHtzdHJpbmdpZmllZFByb3B9KVxcYCwgXFxgJHtzdHJpbmdpZmllZFByb3B9IGluICR7dGFyZ2V0fVxcYCwgb3Igc2ltaWxhcmBcbn1cblxuZXhwb3J0IGNvbnN0IHdlbGxLbm93blByb3BlcnRpZXMgPSBuZXcgU2V0KFtcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZicsXG4gICd0b0xvY2FsZVN0cmluZycsXG5cbiAgLy8gUHJvbWlzZSBwcm90b3R5cGVcbiAgLy8gZmFsbHRocm91Z2hcbiAgJ3RoZW4nLFxuICAnY2F0Y2gnLFxuICAnZmluYWxseScsXG5cbiAgLy8gUmVhY3QgUHJvbWlzZSBleHRlbnNpb25cbiAgLy8gZmFsbHRocm91Z2hcbiAgJ3N0YXR1cycsXG5cbiAgLy8gUmVhY3QgaW50cm9zcGVjdGlvblxuICAnZGlzcGxheU5hbWUnLFxuXG4gIC8vIENvbW1vbiB0ZXN0ZWQgcHJvcGVydGllc1xuICAvLyBmYWxsdGhyb3VnaFxuICAndG9KU09OJyxcbiAgJyQkdHlwZW9mJyxcbiAgJ19fZXNNb2R1bGUnLFxuXSlcbiJdLCJuYW1lcyI6WyJkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkiLCJkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzIiwid2VsbEtub3duUHJvcGVydGllcyIsImlzRGVmaW5pdGVseUFWYWxpZElkZW50aWZpZXIiLCJ0YXJnZXQiLCJwcm9wIiwidGVzdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdHJpbmdpZmllZFByb3AiLCJTZXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/shared/lib/utils/reflect-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/server/route-modules/app-page/module.compiled.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/server/route-modules/app-page/module.compiled.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nif (false) {} else {\n    if (false) {} else {\n        if (true) {\n            module.exports = __webpack_require__(/*! next/dist/compiled/next-server/app-page.runtime.dev.js */ \"next/dist/compiled/next-server/app-page.runtime.dev.js\");\n        } else {}\n    }\n}\n\n//# sourceMappingURL=module.compiled.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1wYWdlL21vZHVsZS5jb21waWxlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUksS0FBbUMsRUFBRSxFQUV4QyxDQUFDO0FBQ0YsUUFBUSxLQUFxQyxFQUFFLEVBUTFDLENBQUM7QUFDTixZQUFZLElBQXNDO0FBQ2xELFlBQVksNEpBQWtGO0FBQzlGLFVBQVUsS0FBSyxFQUlOO0FBQ1Q7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRTpcXEJ0ZWNoIDR0aCBzZW1cXG1pbmkgcHJvamVjdFxcTWluaSBwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxccm91dGUtbW9kdWxlc1xcYXBwLXBhZ2VcXG1vZHVsZS5jb21waWxlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmlmIChwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdlZGdlJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1wYWdlL21vZHVsZS5qcycpO1xufSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0VYUEVSSU1FTlRBTF9SRUFDVCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL25leHQtc2VydmVyL2FwcC1wYWdlLWV4cGVyaW1lbnRhbC5ydW50aW1lLmRldi5qcycpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvbmV4dC1zZXJ2ZXIvYXBwLXBhZ2UtdHVyYm8tZXhwZXJpbWVudGFsLnJ1bnRpbWUucHJvZC5qcycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvbmV4dC1zZXJ2ZXIvYXBwLXBhZ2UtZXhwZXJpbWVudGFsLnJ1bnRpbWUucHJvZC5qcycpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LXNlcnZlci9hcHAtcGFnZS5ydW50aW1lLmRldi5qcycpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvbmV4dC1zZXJ2ZXIvYXBwLXBhZ2UtdHVyYm8ucnVudGltZS5wcm9kLmpzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LXNlcnZlci9hcHAtcGFnZS5ydW50aW1lLnByb2QuanMnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmNvbXBpbGVkLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/server/route-modules/app-page/module.compiled.js\n");

/***/ })

};
;